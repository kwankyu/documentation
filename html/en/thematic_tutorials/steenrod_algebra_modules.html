
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Steenrod Algebra Modules &#8212; Thematic Tutorials</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sage.css" />
    <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="_static/thebelab.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Tutorial: Programming in Python and Sage" href="tutorial-programming-python.html" />
    <link rel="prev" title="Draw polytopes in LaTeX using TikZ" href="geometry/polytope_tikz.html" />
  <link rel="icon" href="_static/sageicon.png" type="image/x-icon" />
  <!-- <script src="_static/thebe.js" type="text/javascript"></script> -->
  <!-- <script src="_static/thebe-sage.js" type="text/javascript"></script> -->

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorial-programming-python.html" title="Tutorial: Programming in Python and Sage"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="geometry/polytope_tikz.html" title="Draw polytopes in LaTeX using TikZ"
             accesskey="P">previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="index.html">Thematic Tutorials</a> &#187;
    
  </li>

          <li class="nav-item nav-item-1"><a href="toctree.html" accesskey="U">Thematic tutorial document tree</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Steenrod Algebra Modules</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="steenrod-algebra-modules">
<span id="id1"></span><h1>Steenrod Algebra Modules<a class="headerlink" href="#steenrod-algebra-modules" title="Permalink to this headline">¶</a></h1>
<p><em>Author: Robert R. Bruner, Michael J. Catanzaro, Sverre Lunoee–Nielsen, and Koen van Woerden</em></p>
<div class="toctree-wrapper compound">
</div>
<p>Let <span class="math notranslate nohighlight">\(p\)</span> be a prime number.  The mod <span class="math notranslate nohighlight">\(p\)</span> Steenrod algebra <span class="math notranslate nohighlight">\(A\)</span>
is a connected algebra over <span class="math notranslate nohighlight">\(\GF{p}\)</span>, the finite field of <span class="math notranslate nohighlight">\(p\)</span> elements.
All modules presented here will be defined over <span class="math notranslate nohighlight">\(A\)</span> or one of its sub-Hopf
algebras.  E.g.:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">SteenrodAlgebra</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The constructor of the module class takes as arguments an ordered tuple of
degrees and the algebra over which the module is defined, together with an
optional set of relations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.modules.fp_graded.steenrod.module</span> <span class="kn">import</span> <span class="n">SteenrodFPModule</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">SteenrodFPModule</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">]);</span> <span class="n">F</span>
<span class="go">Free graded left module on 3 generators over mod 2 Steenrod algebra, milnor basis</span>
</pre></div>
</div>
<p>Denote the module generators of an <span class="math notranslate nohighlight">\(A\)</span>-module <span class="math notranslate nohighlight">\(M\)</span> by <span class="math notranslate nohighlight">\(g_{d_1}, \ldots, g_{d_N}\)</span>,
where subscripts denote their degrees. A homogeneous relation of degree <span class="math notranslate nohighlight">\(n\)</span>
has the form</p>
<div class="math notranslate nohighlight">
\[\sum_{i=1}^N a_i\cdot g_{d_i} = 0,\]</div>
<p>where the homogeneous coefficients <span class="math notranslate nohighlight">\(a_1, \ldots, a_N\)</span> lie in <span class="math notranslate nohighlight">\(A\)</span>, such that
<span class="math notranslate nohighlight">\(\deg(a_i) + \deg(g_{d_i}) = n\)</span> for <span class="math notranslate nohighlight">\(i = 1, \ldots, N\)</span>.  To create a module
with relations, the coefficients for each relation is given:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">r1</span> <span class="o">=</span> <span class="p">[</span><span class="n">Sq</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">Sq</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span>   <span class="c1"># First relation</span>
<span class="gp">sage: </span><span class="n">r2</span> <span class="o">=</span> <span class="p">[</span><span class="n">Sq</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>       <span class="c1"># Second relation</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">SteenrodFPModule</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">relations</span><span class="o">=</span><span class="p">[</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">]);</span> <span class="n">M</span>
<span class="go">Finitely presented left module on 3 generators and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
</pre></div>
</div>
<p>The resulting module will have three generators in the degrees we gave them:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">generator_degrees</span><span class="p">()</span>
<span class="go">(0, 1, 7)</span>
</pre></div>
</div>
<p>The connectivity of a module over a connected graded algebra is the minimum
degree of all its module generators.  Thus, if the module is non-trivial, the
connectivity is an integer:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">connectivity</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Each module is defined over a Steenrod algebra or some sub-Hopf algebra of it,
given by its base ring:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
<span class="go">mod 2 Steenrod algebra, milnor basis</span>
<span class="gp">sage: </span><span class="n">SteenrodFPModule</span><span class="p">(</span><span class="n">SteenrodAlgebra</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">profile</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span>
<span class="go">sub-Hopf algebra of mod 2 Steenrod algebra, milnor basis, profile function</span>
<span class="go">[3, 2, 1]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling <code class="docutils literal notranslate"><span class="pre">algebra()</span></code> will not return the desired algebra. Users should
use the <code class="docutils literal notranslate"><span class="pre">base_ring()</span></code> method.</p>
</div>
<section id="module-elements">
<h2>Module elements<a class="headerlink" href="#module-elements" title="Permalink to this headline">¶</a></h2>
<p>Module elements are displayed in terms of generators, which by default
are called <code class="docutils literal notranslate"><span class="pre">g[degree]</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">an_element</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">Sq(2,1)*g[0] + Sq(4)*g[1]</span>

<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">an_element</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">15</span><span class="p">);</span> <span class="n">e</span>
<span class="go">Sq(0,0,0,1)*g[0] + Sq(1,2,1)*g[1] + Sq(8)*g[7]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">dense_coefficient_list</span><span class="p">()</span>
<span class="go">[Sq(0,0,0,1), Sq(1,2,1), Sq(8)]</span>
</pre></div>
</div>
<p>The generators are themselves elements of the module:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">gens</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">generators</span><span class="p">();</span> <span class="n">gens</span>
<span class="go">(g[0], g[1], g[7])</span>
<span class="gp">sage: </span><span class="n">gens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">M</span>
<span class="go">True</span>
</pre></div>
</div>
<p>One can produce an element from a given set of algebra coefficients:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">coeffs</span><span class="o">=</span><span class="p">[</span><span class="n">Sq</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="n">Sq</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">*</span><span class="n">Sq</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Sq</span><span class="p">(</span><span class="mi">8</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">coeffs</span><span class="p">);</span> <span class="n">x</span>
<span class="go">Sq(15)*g[0] + (Sq(4,1,1)+Sq(7,0,1)+Sq(11,1))*g[1] + Sq(8)*g[7]</span>
</pre></div>
</div>
<p>The module action produces new elements:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sq</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span>
<span class="go">Sq(14,1)*g[0] + (Sq(7,1)+Sq(10))*g[7]</span>
</pre></div>
</div>
<p>Each non-zero homogeneous element has a well-defined degree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">15</span>
</pre></div>
</div>
<p>but the zero element does not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">zero</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">zero</span><span class="p">();</span> <span class="n">zero</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">zero</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the zero element does not have a well-defined degree</span>
</pre></div>
</div>
<p>At this point it may be useful to point out that elements are not reduced to
a minimal representation when they are created.  A normalization can be
enforced, however:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g7</span> <span class="o">=</span> <span class="n">M</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span> <span class="n">g7</span>
<span class="go">g[7]</span>
<span class="gp">sage: </span><span class="n">g7</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
<span class="go">Sq(7)*g[0]</span>
<span class="gp">sage: </span><span class="n">g7</span> <span class="o">==</span> <span class="n">g7</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">M</span><span class="p">([</span><span class="n">Sq</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">g7</span><span class="p">;</span> <span class="n">s</span>         <span class="c1"># m and g7 are related by m = Sq(7)*g[0] = g[7],</span>
<span class="go">Sq(7)*g[0] + g[7]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span>                <span class="c1"># so their sum should zero.</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>         <span class="c1"># Its normalized form is more revealing.</span>
<span class="go">0</span>
</pre></div>
</div>
<p>For every integer <span class="math notranslate nohighlight">\(n\)</span>, the set of module elements of degree <span class="math notranslate nohighlight">\(n\)</span> form a
vector space over the ground field <span class="math notranslate nohighlight">\(\GF{p}\)</span>.  A basis for this vector space
can be computed:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">basis_elements</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">(Sq(0,0,1)*g[0],</span>
<span class="go"> Sq(1,2)*g[0],</span>
<span class="go"> Sq(4,1)*g[0],</span>
<span class="go"> Sq(7)*g[0],</span>
<span class="go"> Sq(0,2)*g[1],</span>
<span class="go"> Sq(3,1)*g[1],</span>
<span class="go"> Sq(6)*g[1])</span>
</pre></div>
</div>
<p>Note that the third generator <span class="math notranslate nohighlight">\(g_7\)</span> of degree 7 is apparently missing from the
basis above.  This is because of the relation <span class="math notranslate nohighlight">\(\operatorname{Sq}^7(g_0) = g_7\)</span>.</p>
<p>A vector space presentation can be produced:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">vector_presentation</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">Vector space quotient V/W of dimension 4 over Finite Field of size 2 where</span>
<span class="go">V: Vector space of dimension 4 over Finite Field of size 2</span>
<span class="go">W: Vector space of degree 4 and dimension 0 over Finite Field of size 2</span>
<span class="go">Basis matrix:</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Given any element, its coordinates with respect to this basis can be computed:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">an_element</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span> <span class="n">x</span>
<span class="go">Sq(0,0,1)*g[0] + Sq(3,1)*g[1] + g[7]</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">vector_presentation</span><span class="p">();</span> <span class="n">v</span>
<span class="go">(1, 0, 0, 1, 0, 1, 0)</span>
</pre></div>
</div>
<p>Going the other way, any element can be constructed by specifying its
coordinates:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x_</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">element_from_coordinates</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x_</span>
<span class="go">(Sq(0,0,1)+Sq(7))*g[0] + Sq(3,1)*g[1]</span>
<span class="gp">sage: </span><span class="n">x_</span> <span class="o">==</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
</section>
<section id="module-homomorphisms">
<h2>Module homomorphisms<a class="headerlink" href="#module-homomorphisms" title="Permalink to this headline">¶</a></h2>
<p>Homomorphisms of <span class="math notranslate nohighlight">\(A\)</span>-modules <span class="math notranslate nohighlight">\(M\to N\)</span> are linear maps of their
underlying <span class="math notranslate nohighlight">\(\GF{p}\)</span>-vector spaces which commute with the <span class="math notranslate nohighlight">\(A\)</span>-module
structure. Homomorphisms are required to be homogeneneous but need not
be degree zero.</p>
<p>To create a homomorphism, first create the object modeling the set of all
such homomorphisms using the function <code class="docutils literal notranslate"><span class="pre">Hom</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Hko</span> <span class="o">=</span> <span class="n">SteenrodFPModule</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[[</span><span class="n">Sq</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span> <span class="p">[</span><span class="n">Sq</span><span class="p">(</span><span class="mi">1</span><span class="p">)]])</span>
<span class="gp">sage: </span><span class="n">homspace</span> <span class="o">=</span> <span class="n">Hom</span><span class="p">(</span><span class="n">Hko</span><span class="p">,</span> <span class="n">Hko</span><span class="p">);</span> <span class="n">homspace</span>
<span class="go">Set of Morphisms from Finitely presented left module on 1 generator and 2 relations</span>
<span class="go">  over mod 2 Steenrod algebra, milnor basis</span>
<span class="go"> to Finitely presented left module on 1 generator and 2 relations</span>
<span class="go">  over mod 2 Steenrod algebra, milnor basis</span>
<span class="go"> in Category of finitely presented graded modules over mod 2 Steenrod algebra, milnor basis</span>
</pre></div>
</div>
<p>Just as with module elements, homomorphisms are created using the homspace.
The only argument is a list of elements in the codomain, giving the
images of the module generators of the domain:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">gen</span> <span class="o">=</span> <span class="n">Hko</span><span class="o">.</span><span class="n">generator</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># the generator of the codomain module</span>
<span class="gp">sage: </span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">Sq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">gen</span><span class="p">];</span> <span class="n">values</span>
<span class="go">[Sq(0,0,1)*g[0]]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">homspace</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting homomorphism is the one sending the <span class="math notranslate nohighlight">\(i\)</span>-th generator of the
domain to the <span class="math notranslate nohighlight">\(i\)</span>-th codomain value given:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span>
<span class="go">Module endomorphism of Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  Defn: g[0] |--&gt; Sq(0,0,1)*g[0]</span>
</pre></div>
</div>
<p>Homomorphisms can be evaluated on elements of the domain module:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">Sq</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">gen</span><span class="p">);</span> <span class="n">v1</span>
<span class="go">Sq(4,0,1)*g[0]</span>

<span class="gp">sage: </span><span class="n">v2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">Sq</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Sq</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">gen</span><span class="p">);</span> <span class="n">v2</span>
<span class="go">(Sq(3,1,1)+Sq(6,0,1))*g[0]</span>
</pre></div>
</div>
<p>and they respect the module action:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">Sq</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">gen</span><span class="p">)</span> <span class="o">==</span> <span class="n">Sq</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">Sq</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Sq</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">gen</span><span class="p">)</span> <span class="o">==</span> <span class="n">Sq</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Sq</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Convenience methods exist for creating the trivial morphism:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">Sq</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">Sq</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">*</span><span class="n">gen</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">zero_map</span> <span class="o">=</span> <span class="n">homspace</span><span class="o">.</span><span class="n">zero</span><span class="p">();</span> <span class="n">zero_map</span>
<span class="go">Module endomorphism of Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  Defn: g[0] |--&gt; 0</span>
<span class="gp">sage: </span><span class="n">zero_map</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">zero_map</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>as well as the identity endomorphism:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">one</span> <span class="o">=</span> <span class="n">Hom</span><span class="p">(</span><span class="n">Hko</span><span class="p">,</span> <span class="n">Hko</span><span class="p">)</span><span class="o">.</span><span class="n">identity</span><span class="p">();</span> <span class="n">one</span>
<span class="go">Module endomorphism of Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  Defn: g[0] |--&gt; g[0]</span>
<span class="gp">sage: </span><span class="n">one</span><span class="o">.</span><span class="n">is_endomorphism</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">one</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">one</span><span class="o">.</span><span class="n">is_identity</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Any non-trivial homomorphism has a well defined degree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">7</span>
</pre></div>
</div>
<p>but just as for module elements, the trivial homomorphism does not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">zero_map</span> <span class="o">=</span> <span class="n">homspace</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">zero_map</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the zero morphism does not have a well-defined degree</span>
</pre></div>
</div>
<p>Any two homomorphisms can be added as long as they are of the same degree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f1</span> <span class="o">=</span> <span class="n">homspace</span><span class="p">([</span><span class="n">Hko</span><span class="p">([</span><span class="n">Sq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">Sq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])])</span>
<span class="gp">sage: </span><span class="n">f2</span> <span class="o">=</span> <span class="n">homspace</span><span class="p">([</span><span class="n">Hko</span><span class="p">([</span><span class="n">Sq</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)])])</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">f1</span> <span class="o">+</span> <span class="n">f2</span><span class="p">)</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">f1</span> <span class="o">+</span> <span class="n">f2</span>
<span class="go">Module endomorphism of Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  Defn: g[0] |--&gt; (Sq(0,0,3)+Sq(0,2,0,1)+Sq(8,2,1))*g[0]</span>
</pre></div>
</div>
<p>or when at least one of them is zero:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">+</span> <span class="n">zero_map</span> <span class="o">==</span> <span class="n">f</span>
<span class="go">True</span>
</pre></div>
</div>
<p>but not if they have different degrees:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">SteenrodFPModule</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b4</span> <span class="o">=</span> <span class="n">Hom</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">F</span><span class="p">)([</span><span class="n">Sq</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">F</span><span class="o">.</span><span class="n">generator</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">b8</span> <span class="o">=</span> <span class="n">Hom</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">F</span><span class="p">)([</span><span class="n">Sq</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="n">F</span><span class="o">.</span><span class="n">generator</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">b4</span> <span class="o">+</span> <span class="n">b8</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: morphisms do not have the same degree</span>
</pre></div>
</div>
<p>Finally, additive inverses exist:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The restriction of a homomorphism to the vector space of <span class="math notranslate nohighlight">\(n\)</span>-dimensional module
elements is a linear transformation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f_21</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">vector_presentation</span><span class="p">(</span><span class="mi">21</span><span class="p">);</span> <span class="n">f_21</span>
<span class="go">Vector space morphism represented by the matrix:</span>
<span class="go">[1 0 0 0 0 0]</span>
<span class="go">[0 0 0 0 0 0]</span>
<span class="go">[1 0 0 0 0 0]</span>
<span class="go">Domain: Vector space quotient V/W of dimension 3 over Finite Field of size 2 where</span>
<span class="go">V: Vector space of dimension 20 over Finite Field of size 2</span>
<span class="go">W: Vector space of degree 20 and dimension 17 over Finite Field of size 2</span>
<span class="go">Basis matrix:</span>
<span class="go">[1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0]</span>
<span class="go">[0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span>
<span class="go">[0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0]</span>
<span class="go">[0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0]</span>
<span class="go">[0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0]</span>
<span class="go">[0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1]</span>
<span class="go">[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0]</span>
<span class="go">[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1]</span>
<span class="go">Codomain: Vector space quotient V/W of dimension 6 over Finite Field of size 2 where</span>
<span class="go">V: Vector space of dimension 35 over Finite Field of size 2</span>
<span class="go">W: Vector space of degree 35 and dimension 29 over Finite Field of size 2</span>
<span class="go">Basis matrix:</span>
<span class="go">29 x 35 dense matrix over Finite Field of size 2</span>
</pre></div>
</div>
<p>This is compatible with the vector presentations of its domain and codomain
modules:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Hko</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Hko</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f_21</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Hko</span><span class="o">.</span><span class="n">vector_presentation</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f_21</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="ow">is</span> <span class="n">Hko</span><span class="o">.</span><span class="n">vector_presentation</span><span class="p">(</span><span class="mi">21</span> <span class="o">+</span> <span class="n">f</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Elements in the preimage of a homomorphism can be found:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Sq</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Sq</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">Sq</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">*</span><span class="n">gen</span><span class="p">)</span>
<span class="go">Sq(0,2)*g[0]</span>

<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Sq</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="n">gen</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Homomorphisms can be composed as expected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">homspace</span><span class="p">([</span><span class="n">Sq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">gen</span><span class="p">]);</span> <span class="n">g</span>
<span class="go">Module endomorphism of Finitely presented left module on 1 generator and 2 relations</span>
<span class="go"> over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  Defn: g[0] |--&gt; Sq(0,0,0,1)*g[0]</span>

<span class="gp">sage: </span><span class="n">g</span><span class="o">*</span><span class="n">f</span>
<span class="go">Module endomorphism of Finitely presented left module on 1 generator and 2 relations</span>
<span class="go"> over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  Defn: g[0] |--&gt; Sq(0,0,1,1)*g[0]</span>

<span class="gp">sage: </span><span class="n">one</span> <span class="o">=</span> <span class="n">homspace</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">*</span><span class="n">one</span> <span class="o">==</span> <span class="n">f</span>
<span class="go">True</span>
</pre></div>
</div>
<section id="homological-algebra">
<h3>Homological algebra<a class="headerlink" href="#homological-algebra" title="Permalink to this headline">¶</a></h3>
<p>The category of modules over <span class="math notranslate nohighlight">\(A\)</span> is Abelian, so kernels, images and
cokernels all exist and can be computed using <a class="reference external" href="../reference/modules/sage/modules/fp_graded/steenrod/morphism.html#sage.modules.fp_graded.steenrod.morphism.SteenrodFPModuleMorphism" title="(in Modules v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">the</span> <span class="pre">morphisms</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Methods for morphisms like</p>
<ul class="simple">
<li><p><a class="reference external" href="../reference/modules/sage/modules/fp_graded/steenrod/morphism.html#sage.modules.fp_graded.steenrod.morphism.SteenrodFPModuleMorphism.kernel_inclusion" title="(in Modules v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kernel_inclusion()</span></code></a>,</p></li>
<li><p><a class="reference external" href="../reference/modules/sage/modules/fp_graded/steenrod/morphism.html#sage.modules.fp_graded.steenrod.morphism.SteenrodFPModuleMorphism.cokernel_projection" title="(in Modules v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cokernel_projection()</span></code></a>,</p></li>
<li><p><a class="reference external" href="../reference/modules/sage/modules/fp_graded/steenrod/morphism.html#sage.modules.fp_graded.steenrod.morphism.SteenrodFPModuleMorphism.image" title="(in Modules v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">image()</span></code></a>,</p></li>
<li><p><a class="reference external" href="../reference/modules/sage/modules/fp_graded/morphism.html#sage.modules.fp_graded.morphism.FPModuleMorphism.homology" title="(in Modules v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology()</span></code></a></p></li>
</ul>
<p>compute sub- and quotient modules related to homomorphisms, but
they do not return instances of the module class.  Rather, they
return the natural homomorphisms which connect these modules to
the modules that gave rise to them.</p>
<p>For example the function
<a class="reference external" href="../reference/modules/sage/modules/fp_graded/steenrod/morphism.html#sage.modules.fp_graded.steenrod.morphism.SteenrodFPModuleMorphism.kernel_inclusion" title="(in Modules v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kernel_inclusion()</span></code></a>
returns an injective homomorphism which is onto the kernel
submodule we asked it to compute, while the function
<a class="reference external" href="../reference/modules/sage/modules/fp_graded/steenrod/morphism.html#sage.modules.fp_graded.steenrod.morphism.SteenrodFPModuleMorphism.cokernel_projection" title="(in Modules v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cokernel_projection()</span></code></a>
provides a surjective homomorphism onto the cokernel module.</p>
<p>In each case, getting a reference to the module instance requires calling
<code class="xref py py-meth docutils literal notranslate"><span class="pre">domain()</span></code>
or
<code class="xref py py-meth docutils literal notranslate"><span class="pre">codomain()</span></code>
on the returned homomorphism, depending on the case.</p>
<p>Refer to each function’s documentation for specific details.</p>
</div>
</section>
<section id="cokernels">
<h3>Cokernels<a class="headerlink" href="#cokernels" title="Permalink to this headline">¶</a></h3>
<p>In the following example, we define a cyclic module <span class="math notranslate nohighlight">\(H\ZZ\)</span> with one
relation in two ways: first explicitly, and then as the cokernel of a
homomorphism of free modules.  We then construct a candidate for an isomorphism
and check that it is both injective and surjective:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">HZ</span> <span class="o">=</span> <span class="n">SteenrodFPModule</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[[</span><span class="n">Sq</span><span class="p">(</span><span class="mi">1</span><span class="p">)]]);</span> <span class="n">HZ</span>
<span class="go">Finitely presented left module on 1 generator and 1 relation over mod 2 Steenrod algebra, milnor basis</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">SteenrodFPModule</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">Hom</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">F</span><span class="p">)([</span><span class="n">Sq</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">generator</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">coker</span> <span class="o">=</span> <span class="n">j</span><span class="o">.</span><span class="n">cokernel_projection</span><span class="p">()</span> <span class="c1"># the natural quotient homomorphism onto the cokernel.</span>
<span class="gp">sage: </span><span class="n">hz</span> <span class="o">=</span> <span class="n">coker</span><span class="o">.</span><span class="n">codomain</span><span class="p">();</span> <span class="n">hz</span>
<span class="go">Finitely presented left module on 1 generator and 1 relation over mod 2 Steenrod algebra, milnor basis</span>

<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">Hom</span><span class="p">(</span><span class="n">HZ</span><span class="p">,</span> <span class="n">hz</span><span class="p">)([</span><span class="n">hz</span><span class="o">.</span><span class="n">generator</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">is_injective</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">is_surjective</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</section>
<section id="kernels">
<h3>Kernels<a class="headerlink" href="#kernels" title="Permalink to this headline">¶</a></h3>
<p>When computing the kernel of a homomorphism <span class="math notranslate nohighlight">\(f\)</span>, the result is an
injective homomorphism into the domain of <span class="math notranslate nohighlight">\(f\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">k</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">kernel_inclusion</span><span class="p">();</span> <span class="n">k</span>
<span class="go">Module morphism:</span>
<span class="go">  From: Finitely presented left module on 1 generator and 3 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  To:   Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  Defn: g[7] |--&gt; Sq(0,0,1)*g[0]</span>
<span class="gp">sage: </span><span class="n">k</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">k</span><span class="o">.</span><span class="n">is_injective</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">ker</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ker</span>
<span class="go">Finitely presented left module on 1 generator and 3 relations over mod 2 Steenrod algebra, milnor basis</span>
</pre></div>
</div>
<p>We can check that the injective image of <span class="math notranslate nohighlight">\(k\)</span> is the kernel of <span class="math notranslate nohighlight">\(f\)</span> by
showing that <span class="math notranslate nohighlight">\(f\)</span> factors as <span class="math notranslate nohighlight">\(h\circ c\)</span>, where <span class="math notranslate nohighlight">\(c\)</span> is the quotient map
to the cokernel of <span class="math notranslate nohighlight">\(k\)</span>, and <span class="math notranslate nohighlight">\(h\)</span> is injective:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span>        <span class="c1"># We want to check that this really is the kernel of f.</span>
<span class="gp">sage: </span><span class="n">coker</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">cokernel_projection</span><span class="p">()</span>    <span class="c1"># coker is the natural map: Hko -&gt; coker(f) with kernel K.</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Hom</span><span class="p">(</span><span class="n">coker</span><span class="o">.</span><span class="n">codomain</span><span class="p">(),</span> <span class="n">Hko</span><span class="p">)(</span><span class="n">f</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">*</span><span class="n">coker</span> <span class="o">==</span> <span class="n">f</span>            <span class="c1"># Is K contained in ker(f) ?</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">is_injective</span><span class="p">()</span>        <span class="c1"># Is ker(f) contained in K ?</span>
<span class="go">True</span>
</pre></div>
</div>
</section>
<section id="images">
<h3>Images<a class="headerlink" href="#images" title="Permalink to this headline">¶</a></h3>
<p>The method
<a class="reference external" href="../reference/modules/sage/modules/fp_graded/steenrod/morphism.html#sage.modules.fp_graded.steenrod.morphism.SteenrodFPModuleMorphism.image" title="(in Modules v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">image()</span></code></a>
behaves similarly, returning an injective homomorphism with image
equal to the submodule <span class="math notranslate nohighlight">\(\operatorname{im}(f)\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">i</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">image</span><span class="p">();</span> <span class="n">i</span>
<span class="go">Module morphism:</span>
<span class="go">  From: Finitely presented left module on 1 generator and 3 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  To:   Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  Defn: g[7] |--&gt; Sq(0,0,1)*g[0]</span>
<span class="gp">sage: </span><span class="n">i</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">i</span><span class="o">.</span><span class="n">is_injective</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can check that the injective image of <span class="math notranslate nohighlight">\(i\)</span> is the image of <span class="math notranslate nohighlight">\(f\)</span> by
lifting <span class="math notranslate nohighlight">\(f\)</span> over <span class="math notranslate nohighlight">\(i\)</span>, and showing that the lift is surjective:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f_</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">lift</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="n">f_</span>
<span class="go">Module morphism:</span>
<span class="go">  From: Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  To:   Finitely presented left module on 1 generator and 3 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  Defn: g[0] |--&gt; g[7]</span>
<span class="gp">sage: </span><span class="n">i</span><span class="o">*</span><span class="n">f_</span> <span class="o">==</span> <span class="n">f</span>             <span class="c1"># Is im(i) contained in im(f) ?</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f_</span><span class="o">.</span><span class="n">is_surjective</span><span class="p">()</span>    <span class="c1"># Is im(f) contained in im(i) ?</span>
<span class="go">True</span>
</pre></div>
</div>
<p>When a pair of composable homomorphisms <span class="math notranslate nohighlight">\(g\circ f: M\to N\to L\)</span> satisfy the
condition <span class="math notranslate nohighlight">\(g\circ f = 0\)</span>, the sub-quotient <span class="math notranslate nohighlight">\(\ker(g) / \operatorname{im}(f)\)</span>
can be computed and is given by the natural quotient homomorphism with
domain <span class="math notranslate nohighlight">\(\ker(g)\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">*</span> <span class="n">f</span> <span class="o">==</span> <span class="mi">0</span>        <span class="c1"># Does the kernel of f contain the image of f ?</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">kernel_inclusion</span><span class="p">()</span>    <span class="c1"># k: ker(f) -&gt; Hko</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="c1"># h: ker(f) -&gt; ker(f) / im(f)</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span>      <span class="c1"># This is the homology module.</span>
<span class="go">Finitely presented left module on 1 generator and 4 relations over mod 2 Steenrod algebra, milnor basis</span>
</pre></div>
</div>
</section>
<section id="free-resolutions">
<h3>Free resolutions<a class="headerlink" href="#free-resolutions" title="Permalink to this headline">¶</a></h3>
<p>Finally, free resolutions can be computed.  These calculations usually take
some time to complete, so it is usually a good idea to raise the verbose flag
to output progress information.</p>
<p>The following examples are taken from
<a class="reference external" href="https://digitalcommons.wayne.edu/oa_theses/602/">Michael Catanzaro’s thesis</a>
where the first version of this software appeared:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">res</span> <span class="o">=</span> <span class="n">Hko</span><span class="o">.</span><span class="n">resolution</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Computing f_1 (1/6)</span>
<span class="go">Computing f_2 (2/6)</span>
<span class="go">Computing using the profile:</span>
<span class="go">(2, 1)</span>
<span class="go">Resolving the kernel in the range of dimensions [1, 8]: 1 2 3 4 5 6 7 8.</span>
<span class="go">Computing f_3 (3/6)</span>
<span class="go">Computing using the profile:</span>
<span class="go">(2, 1)</span>
<span class="go">Resolving the kernel in the range of dimensions [2, 10]: 2 3 4 5 6 7 8 9 10.</span>
<span class="go">Computing f_4 (4/6)</span>
<span class="go">Computing using the profile:</span>
<span class="go">(2, 1)</span>
<span class="go">Resolving the kernel in the range of dimensions [3, 13]: 3 4 5 6 7 8 9 10 11 12 13.</span>
<span class="go">Computing f_5 (5/6)</span>
<span class="go">Computing using the profile:</span>
<span class="go">(2, 1)</span>
<span class="go">Resolving the kernel in the range of dimensions [4, 18]: 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18.</span>
<span class="go">Computing f_6 (6/6)</span>
<span class="go">Computing using the profile:</span>
<span class="go">(2, 1)</span>
<span class="go">Resolving the kernel in the range of dimensions [5, 20]: 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20.</span>
</pre></div>
</div>
<p>The result of the calculation is a list of all the maps in the resolution:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>
<span class="go">[Free graded left module on 1 generator over mod 2 Steenrod algebra, milnor basis,</span>
<span class="go"> Free graded left module on 2 generators over mod 2 Steenrod algebra, milnor basis,</span>
<span class="go"> Free graded left module on 2 generators over mod 2 Steenrod algebra, milnor basis,</span>
<span class="go"> Free graded left module on 2 generators over mod 2 Steenrod algebra, milnor basis,</span>
<span class="go"> Free graded left module on 3 generators over mod 2 Steenrod algebra, milnor basis,</span>
<span class="go"> Free graded left module on 4 generators over mod 2 Steenrod algebra, milnor basis,</span>
<span class="go"> Free graded left module on 4 generators over mod 2 Steenrod algebra, milnor basis]</span>

<span class="gp">sage: </span><span class="k">def</span> <span class="nf">is_complex</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">is_zero</span><span class="p">():</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="kc">False</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="kc">True</span>
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="n">is_complex</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="k">def</span> <span class="nf">is_exact</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">h</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">h</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span><span class="o">.</span><span class="n">is_trivial</span><span class="p">():</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="kc">False</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="kc">True</span>

<span class="gp">sage: </span><span class="n">is_exact</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span><span class="o">.</span><span class="n">generator_degrees</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>
<span class="go">[(0,), (0,), (2, 1), (2, 4), (3, 7), (4, 8, 12), (5, 9, 13, 14)]</span>

<span class="gp">sage: </span><span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>
<span class="go">[(g[0],),</span>
<span class="go"> (Sq(2)*g[0], Sq(1)*g[0]),</span>
<span class="go"> (Sq(1)*g[1], Sq(3)*g[1] + Sq(2)*g[2]),</span>
<span class="go"> (Sq(1)*g[2], Sq(2,1)*g[2] + Sq(3)*g[4]),</span>
<span class="go"> (Sq(1)*g[3], Sq(2,1)*g[3] + Sq(1)*g[7], Sq(2,1)*g[7]),</span>
<span class="go"> (Sq(1)*g[4],</span>
<span class="go">  Sq(2,1)*g[4] + Sq(1)*g[8],</span>
<span class="go">  Sq(2,1)*g[8] + Sq(1)*g[12],</span>
<span class="go">  Sq(2)*g[12]),</span>
<span class="go"> (Sq(1)*g[5],</span>
<span class="go">  Sq(2,1)*g[5] + Sq(1)*g[9],</span>
<span class="go">  Sq(2,1)*g[9] + Sq(1)*g[13],</span>
<span class="go">  Sq(0,1)*g[13] + Sq(2)*g[14])]</span>
</pre></div>
</div>
</section>
</section>
<section id="example-counting-lifts">
<h2>Example: Counting lifts<a class="headerlink" href="#example-counting-lifts" title="Permalink to this headline">¶</a></h2>
<p>In this more elaborate example we show how to find all possible lifts of a
particular homomorphism.  We will do this in two ways, and as a check of
validity, we will compare the results in the end.</p>
<p>We will work with the following modules over the mod 2
Steenrod algebra <span class="math notranslate nohighlight">\(A\)</span>:</p>
<div class="math notranslate nohighlight">
 \begin{align}
     H\ZZ &amp;= A/A\cdot \operatorname{Sq}(1)\\
     Hko &amp;= A/A\cdot \{\operatorname{Sq}(2), \operatorname{Sq}(1)\} \,.
 \end{align}</div><p>There is a natural projection <span class="math notranslate nohighlight">\(q: H\ZZ\to Hko\)</span>, and a non-trivial
endomorphism of degree 28, represented as a degree zero map
<span class="math notranslate nohighlight">\(f: \Sigma^{28}Hko\to Hko\)</span> that we define below.</p>
<p>The problem we will solve is to find all possible homomorphisms
<span class="math notranslate nohighlight">\(f': \Sigma^{28}Hko\to H\ZZ\)</span>, making the following diagram into a
commuting triangle:</p>
<div class="math notranslate nohighlight">
\[H\ZZ\xrightarrow{q} Hko \xleftarrow{f} \Sigma^{28} Hko.\]</div>
<p>We begin by defining the modules and the homomorphisms <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(q\)</span>.
In the following, we let <span class="math notranslate nohighlight">\(L = \Sigma^{28}Hko\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.modules.fp_graded.steenrod.module</span> <span class="kn">import</span> <span class="n">SteenrodFPModule</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">SteenrodAlgebra</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Hko</span> <span class="o">=</span> <span class="n">SteenrodFPModule</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[[</span><span class="n">Sq</span><span class="p">(</span><span class="mi">2</span><span class="p">)],[</span><span class="n">Sq</span><span class="p">(</span><span class="mi">1</span><span class="p">)]])</span>
<span class="gp">sage: </span><span class="n">HZ</span> <span class="o">=</span> <span class="n">SteenrodFPModule</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[[</span><span class="n">Sq</span><span class="p">(</span><span class="mi">1</span><span class="p">)]])</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">Hko</span><span class="o">.</span><span class="n">suspension</span><span class="p">(</span><span class="mi">28</span><span class="p">)</span>
</pre></div>
</div>
<p>The projection:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">Hom</span><span class="p">(</span><span class="n">HZ</span><span class="p">,</span> <span class="n">Hko</span><span class="p">)([</span><span class="n">Hko</span><span class="o">.</span><span class="n">generator</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">q</span>
<span class="go">Module morphism:</span>
<span class="go">  From: Finitely presented left module on 1 generator and 1 relation over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  To:   Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  Defn: g[0] |--&gt; g[0]</span>
</pre></div>
</div>
<p>The map to lift over <span class="math notranslate nohighlight">\(q\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Hom</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">Hko</span><span class="p">)([</span><span class="n">Sq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Hko</span><span class="o">.</span><span class="n">generator</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">Module morphism:</span>
<span class="go">  From: Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  To:   Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  Defn: g[28] |--&gt; Sq(0,2,1,1)*g[0]</span>

<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>   <span class="c1"># f is non-trivial.</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We will count the number of different lifts in two ways.  First, we will simply
compute the vector space of all possible maps <span class="math notranslate nohighlight">\(L \to H\ZZ\)</span>, and then check which
of those become <span class="math notranslate nohighlight">\(f\)</span> when composed with <span class="math notranslate nohighlight">\(q\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">basis</span> <span class="o">=</span> <span class="n">Hom</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">HZ</span><span class="p">)</span><span class="o">.</span><span class="n">basis_elements</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># The basis for the vector space of degree 0 maps L -&gt; HZ</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">from_coords</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="sd">&#39;&#39;&#39;</span>
<span class="gp">....: </span><span class="sd">    Create a linear combination of the three basis homomorphisms.</span>
<span class="gp">....: </span><span class="sd">    &#39;&#39;&#39;</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">basis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">basis</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<span class="gp">sage: </span><span class="k">for</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">q</span><span class="o">*</span><span class="n">from_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">))</span>
<span class="go">(0, 0, 0): False</span>
<span class="go">(0, 0, 1): False</span>
<span class="go">(0, 1, 0): True</span>
<span class="go">(0, 1, 1): True</span>
<span class="go">(1, 0, 0): True</span>
<span class="go">(1, 0, 1): True</span>
<span class="go">(1, 1, 0): False</span>
<span class="go">(1, 1, 1): False</span>
</pre></div>
</div>
<p>From this we conclude that four out of eight different homomorphisms
<span class="math notranslate nohighlight">\(L \to H\ZZ\)</span> are lifts of <span class="math notranslate nohighlight">\(f\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">lifts</span> <span class="o">=</span> <span class="p">[</span><span class="n">from_coords</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span>
<span class="gp">....: </span>         <span class="n">from_coords</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span>
<span class="gp">....: </span>         <span class="n">from_coords</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span>
<span class="gp">....: </span>         <span class="n">from_coords</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))]</span>
<span class="gp">sage: </span><span class="n">lifts</span>
<span class="go">[Module morphism:</span>
<span class="go">   From: Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">   To:   Finitely presented left module on 1 generator and 1 relation over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">   Defn: g[28] |--&gt; Sq(6,5,1)*g[0],</span>
<span class="go"> Module morphism:</span>
<span class="go">   From: Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">   To:   Finitely presented left module on 1 generator and 1 relation over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">   Defn: g[28] |--&gt; (Sq(6,5,1)+Sq(18,1,1))*g[0],</span>
<span class="go"> Module morphism:</span>
<span class="go">   From: Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">   To:   Finitely presented left module on 1 generator and 1 relation over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">   Defn: g[28] |--&gt; Sq(10,1,0,1)*g[0],</span>
<span class="go"> Module morphism:</span>
<span class="go">   From: Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">   To:   Finitely presented left module on 1 generator and 1 relation over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">   Defn: g[28] |--&gt; (Sq(10,1,0,1)+Sq(18,1,1))*g[0]]</span>
</pre></div>
</div>
<p>Alternatively we can use left-exactness of the functor
<span class="math notranslate nohighlight">\(\operatorname{Hom}_A(L, -)\)</span> to enumerate all possible lifts of <span class="math notranslate nohighlight">\(f\)</span>.
Start by finding a single lift of <span class="math notranslate nohighlight">\(f\)</span> over the projection <span class="math notranslate nohighlight">\(q\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fl</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">lift</span><span class="p">(</span><span class="n">q</span><span class="p">);</span> <span class="n">fl</span>
<span class="go">Module morphism:</span>
<span class="go">  From: Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  To:   Finitely presented left module on 1 generator and 1 relation over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">  Defn: g[28] |--&gt; (Sq(4,3,0,1)+Sq(6,0,1,1)+Sq(7,2,0,1)+Sq(10,1,0,1))*g[0]</span>
</pre></div>
</div>
<p>We verify that <code class="docutils literal notranslate"><span class="pre">fl</span></code> is indeed a lift:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">q</span> <span class="o">*</span> <span class="n">fl</span> <span class="o">==</span> <span class="n">f</span>
<span class="go">True</span>
</pre></div>
</div>
<p>There is an exact sequence</p>
<div class="math notranslate nohighlight">
\[0 \to \operatorname{Hom}_A(L, \ker(q)) \xrightarrow{iK_*}
\operatorname{Hom}_A(L, H\ZZ) \xrightarrow{q_*} \operatorname{Hom}_A(L, Hko),\]</div>
<p>which means that the indeterminacy of choosing a lift for
<span class="math notranslate nohighlight">\(f \in \operatorname{Hom}_A(L, Hko)\)</span> is represented by an element in
<span class="math notranslate nohighlight">\(\operatorname{Hom}_A(L,\ker(f))\)</span>.  Therefore, we can proceed to count the
number of lifts by computing this vector space of homomorphisms:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">iK</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">kernel_inclusion</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">iK</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">generator_degrees</span><span class="p">()</span>
<span class="go">(2,)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">relations</span><span class="p">()</span>
<span class="go">(Sq(2)*g[2],)</span>
<span class="gp">sage: </span><span class="n">ind</span> <span class="o">=</span> <span class="n">Hom</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">basis_elements</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>So now we know that the vector space of indeterminacies is 2-dimensional over the
field of two elements.  This means that there are four distinct lifts of <span class="math notranslate nohighlight">\(f\)</span> over
<span class="math notranslate nohighlight">\(q\)</span>, and we can construct these by taking the one lift we already found, and add
to it all the different elements in the image of <span class="math notranslate nohighlight">\(iK_*\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">flift</span> <span class="o">=</span> <span class="p">[</span><span class="n">fl</span><span class="p">,</span>
<span class="gp">....: </span>         <span class="n">fl</span> <span class="o">+</span> <span class="n">iK</span> <span class="o">*</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">....: </span>         <span class="n">fl</span> <span class="o">+</span> <span class="n">iK</span> <span class="o">*</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>         <span class="n">fl</span> <span class="o">+</span> <span class="n">iK</span> <span class="o">*</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
<span class="gp">sage: </span><span class="n">flift</span>
<span class="go">[Module morphism:</span>
<span class="go">   From: Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">   To:   Finitely presented left module on 1 generator and 1 relation over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">   Defn: g[28] |--&gt; (Sq(4,3,0,1)+Sq(6,0,1,1)+Sq(7,2,0,1)+Sq(10,1,0,1))*g[0],</span>
<span class="go"> Module morphism:</span>
<span class="go">   From: Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">   To:   Finitely presented left module on 1 generator and 1 relation over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">   Defn: g[28] |--&gt; (Sq(0,7,1)+Sq(3,6,1)+Sq(4,1,3)+Sq(6,0,1,1)+Sq(6,5,1)+Sq(7,0,3))*g[0],</span>
<span class="go"> Module morphism:</span>
<span class="go">   From: Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">   To:   Finitely presented left module on 1 generator and 1 relation over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">   Defn: g[28] |--&gt; (Sq(4,3,0,1)+Sq(6,0,1,1)+Sq(7,2,0,1)+Sq(10,1,0,1)+Sq(12,3,1)+Sq(15,2,1)+Sq(18,1,1))*g[0],</span>
<span class="go"> Module morphism:</span>
<span class="go">   From: Finitely presented left module on 1 generator and 2 relations over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">   To:   Finitely presented left module on 1 generator and 1 relation over mod 2 Steenrod algebra, milnor basis</span>
<span class="go">   Defn: g[28] |--&gt; (Sq(0,7,1)+Sq(3,6,1)+Sq(4,1,3)+Sq(6,0,1,1)+Sq(6,5,1)+Sq(7,0,3)+Sq(12,3,1)+Sq(15,2,1)+Sq(18,1,1))*g[0]]</span>
</pre></div>
</div>
<p>As a test of correctness, we now compare the two sets of lifts.  As they stand,
it is not obvious that the lists <code class="docutils literal notranslate"><span class="pre">flift</span></code> and <code class="docutils literal notranslate"><span class="pre">lifts</span></code> are the same (up to a
re-ordering of list elements), so the following comparison is reassuring:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">flift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">lifts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">flift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">lifts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">flift</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">lifts</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">flift</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">lifts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Steenrod Algebra Modules</a><ul>
<li><a class="reference internal" href="#module-elements">Module elements</a></li>
<li><a class="reference internal" href="#module-homomorphisms">Module homomorphisms</a><ul>
<li><a class="reference internal" href="#homological-algebra">Homological algebra</a></li>
<li><a class="reference internal" href="#cokernels">Cokernels</a></li>
<li><a class="reference internal" href="#kernels">Kernels</a></li>
<li><a class="reference internal" href="#images">Images</a></li>
<li><a class="reference internal" href="#free-resolutions">Free resolutions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-counting-lifts">Example: Counting lifts</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="geometry/polytope_tikz.html"
                          title="previous chapter">Draw polytopes in LaTeX using TikZ</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="tutorial-programming-python.html"
                          title="next chapter">Tutorial: Programming in Python and Sage</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/steenrod_algebra_modules.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorial-programming-python.html" title="Tutorial: Programming in Python and Sage"
             >next</a> |</li>
        <li class="right" >
          <a href="geometry/polytope_tikz.html" title="Draw polytopes in LaTeX using TikZ"
             >previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="index.html">Thematic Tutorials</a> &#187;
    
  </li>

          <li class="nav-item nav-item-1"><a href="toctree.html" >Thematic tutorial document tree</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Steenrod Algebra Modules</a></li> 
      </ul>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2022, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
  </script>
  <script type="text/javascript">
/* detex the document title by removing "\(", "\)", "\", "$" */
document.title = document.title.replace(/\\\(/g, '').replace(/\\\)/g, '').replace(/\\/g, '').replace(/\$/g, '');
  </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>