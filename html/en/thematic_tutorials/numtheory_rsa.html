
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Number Theory and the RSA Public Key Cryptosystem &#8212; Thematic Tutorials v8.3</title>
    <link rel="stylesheet" href="_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Coding Theory in Sage" href="coding_theory.html" />
    <link rel="prev" title="Linear Programming (Mixed Integer)" href="linear_programming.html" />
    <link rel="icon" href="_static/sageicon.png" type="image/x-icon" />
    <script src="_static/thebe.js" type="text/javascript"></script>
    <script src="_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="coding_theory.html" title="Coding Theory in Sage"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="linear_programming.html" title="Linear Programming (Mixed Integer)"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../index.html"><img src="_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="index.html">Thematic Tutorials v8.3</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="toctree.html" accesskey="U">Thematic tutorial document tree</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="number-theory-and-the-rsa-public-key-cryptosystem">
<span id="numtheory-rsa"></span><h1>Number Theory and the RSA Public Key Cryptosystem<a class="headerlink" href="#number-theory-and-the-rsa-public-key-cryptosystem" title="Permalink to this headline">¶</a></h1>
<p><em>Author: Minh Van Nguyen &lt;<a class="reference external" href="mailto:nguyenminh2&#37;&#52;&#48;gmail&#46;com">nguyenminh2<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</em></p>
<p>This tutorial uses Sage to study elementary number theory and the RSA
public key cryptosystem.  A number of Sage commands will be presented
that help us to perform basic number theoretic operations such as
greatest common divisor and Euler’s phi function.  We then present the
RSA cryptosystem and use Sage’s built-in commands to encrypt and
decrypt data via the RSA algorithm.  Note that this tutorial on RSA is
for pedagogy purposes only.  For further details on cryptography or
the security of various cryptosystems, consult specialized texts such
as
<a class="reference internal" href="#menezesetal1996" id="id1">[MenezesEtAl1996]</a>,
<a class="reference internal" href="#stinson2006" id="id2">[Stinson2006]</a>, and
<a class="reference internal" href="#trappewashington2006" id="id3">[TrappeWashington2006]</a>.</p>
<div class="section" id="elementary-number-theory">
<h2>Elementary number theory<a class="headerlink" href="#elementary-number-theory" title="Permalink to this headline">¶</a></h2>
<p>We first review basic concepts from elementary number theory,
including the notion of primes, greatest common divisors, congruences
and Euler’s phi function.  The number theoretic concepts and Sage
commands introduced will be referred to in later sections when we
present the RSA algorithm.</p>
<div class="section" id="prime-numbers">
<h3>Prime numbers<a class="headerlink" href="#prime-numbers" title="Permalink to this headline">¶</a></h3>
<p>Public key cryptography uses many fundamental concepts from number
theory, such as prime numbers and greatest common divisors.  A
positive integer <span class="math notranslate nohighlight">\(n &gt; 1\)</span> is said to be <em>prime</em> if its factors are
exclusively 1 and itself.  In Sage, we can obtain the first 20 prime
numbers using the command <code class="docutils literal notranslate"><span class="pre">primes_first_n</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">primes_first_n</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]</span>
</pre></div>
</div>
</div>
<div class="section" id="greatest-common-divisors">
<h3>Greatest common divisors<a class="headerlink" href="#greatest-common-divisors" title="Permalink to this headline">¶</a></h3>
<p>Let <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> be integers, not both zero. Then the greatest common
divisor (GCD) of <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> is the largest positive integer which is
a factor of both <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>. We use <span class="math notranslate nohighlight">\(\gcd(a,b)\)</span> to denote this
largest positive factor. One can extend this definition by setting
<span class="math notranslate nohighlight">\(\gcd(0,0) = 0\)</span>. Sage uses <code class="docutils literal notranslate"><span class="pre">gcd(a,</span> <span class="pre">b)</span></code> to denote the GCD of <span class="math notranslate nohighlight">\(a\)</span>
and <span class="math notranslate nohighlight">\(b\)</span>. The GCD of any two distinct primes is 1, and the GCD of 18
and 27 is 9.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">gcd</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">59</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">gcd</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">27</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
<p>If <span class="math notranslate nohighlight">\(\gcd(a,b) = 1\)</span>, we say that <span class="math notranslate nohighlight">\(a\)</span> is <em>coprime</em> (or relatively
prime) to <span class="math notranslate nohighlight">\(b\)</span>.  In particular, <span class="math notranslate nohighlight">\(\gcd(3, 59) = 1\)</span> so 3 is coprime to 59
and vice versa.</p>
</div>
<div class="section" id="congruences">
<h3>Congruences<a class="headerlink" href="#congruences" title="Permalink to this headline">¶</a></h3>
<p>When one integer is divided by a non-zero integer, we usually get a
remainder.  For example, upon dividing 23 by 5, we get a remainder of
3; when 8 is divided by 5, the remainder is again 3.  The notion of
congruence helps us to describe the situation in which two integers
have the same remainder upon division by a non-zero integer.  Let
<span class="math notranslate nohighlight">\(a,b,n \in \ZZ\)</span> such that <span class="math notranslate nohighlight">\(n \neq 0\)</span>.  If <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> have the
same remainder upon division by <span class="math notranslate nohighlight">\(n\)</span>, then we say that <span class="math notranslate nohighlight">\(a\)</span> is
<em>congruent</em> to <span class="math notranslate nohighlight">\(b\)</span> modulo <span class="math notranslate nohighlight">\(n\)</span> and denote this relationship by</p>
<div class="math notranslate nohighlight">
\[a \equiv b \pmod{n}\]</div>
<p>This definition is equivalent to saying that <span class="math notranslate nohighlight">\(n\)</span> divides the
difference of <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>, i.e. <span class="math notranslate nohighlight">\(n \;|\; (a - b)\)</span>.  Thus
<span class="math notranslate nohighlight">\(23 \equiv 8 \pmod{5}\)</span> because when both 23 and 8 are divided by 5, we
end up with a remainder of 3.  The command <code class="docutils literal notranslate"><span class="pre">mod</span></code> allows us to
compute such a remainder:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">mod</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">mod</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</div>
<div class="section" id="euler-s-phi-function">
<h3>Euler’s phi function<a class="headerlink" href="#euler-s-phi-function" title="Permalink to this headline">¶</a></h3>
<p>Consider all the integers from 1 to 20, inclusive.  List all those
integers that are coprime to 20.  In other words, we want to find
those integers <span class="math notranslate nohighlight">\(n\)</span>, where <span class="math notranslate nohighlight">\(1 \leq n \leq 20\)</span>, such that
<span class="math notranslate nohighlight">\(\gcd(n,20) = 1\)</span>.  The latter task can be easily accomplished with a
little bit of Sage programming:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">):</span>
<span class="go">....:     if gcd(n, 20) == 1:</span>
<span class="go">....:         L.append(n)</span>
<span class="gp">sage: </span><span class="n">L</span>
<span class="go">[1, 3, 7, 9, 11, 13, 17, 19]</span>
</pre></div>
</div>
<p>The above programming statements can be saved to a text file called,
say, <code class="docutils literal notranslate"><span class="pre">/home/mvngu/totient.sage</span></code>, organizing it as follows to enhance
readability.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">gcd</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">L</span>
</pre></div>
</div>
<p>We refer to <code class="docutils literal notranslate"><span class="pre">totient.sage</span></code> as a Sage script, just as one would refer
to a file containing Python code as a Python script.  We use 4 space
indentations, which is a coding convention in Sage as well as Python
programming, instead of tabs.</p>
<p>The command <code class="docutils literal notranslate"><span class="pre">load</span></code> can be used to read the file containing our
programming statements into Sage and, upon loading the content of the
file, have Sage execute those statements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;/home/mvngu/totient.sage&quot;</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">]</span>
</pre></div>
</div>
<p>From the latter list, there are 8 integers in the closed interval
<span class="math notranslate nohighlight">\([1, 20]\)</span> that are coprime to 20.  Without explicitly generating the
list</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>  <span class="mi">3</span>  <span class="mi">7</span>  <span class="mi">9</span>  <span class="mi">11</span>  <span class="mi">13</span>  <span class="mi">17</span>  <span class="mi">19</span>
</pre></div>
</div>
<p>how can we compute the number of integers in <span class="math notranslate nohighlight">\([1, 20]\)</span> that are
coprime to 20?  This is where Euler’s phi function comes in handy.
Let <span class="math notranslate nohighlight">\(n \in \ZZ\)</span> be positive.  Then <em>Euler’s phi function</em> counts the
number of integers <span class="math notranslate nohighlight">\(a\)</span>, with <span class="math notranslate nohighlight">\(1 \leq a \leq n\)</span>, such that
<span class="math notranslate nohighlight">\(\gcd(a,n) = 1\)</span>.  This number is denoted by <span class="math notranslate nohighlight">\(\varphi(n)\)</span>.  Euler’s phi
function is sometimes referred to as Euler’s totient function, hence
the name <code class="docutils literal notranslate"><span class="pre">totient.sage</span></code> for the above Sage script.  The command
<code class="docutils literal notranslate"><span class="pre">euler_phi</span></code> implements Euler’s phi function.  To compute
<span class="math notranslate nohighlight">\(\varphi(20)\)</span> without explicitly generating the above list, we proceed
as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">euler_phi</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">8</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="how-to-keep-a-secret">
<h2>How to keep a secret?<a class="headerlink" href="#how-to-keep-a-secret" title="Permalink to this headline">¶</a></h2>
<p><em>Cryptography</em> is the science (some might say art) of concealing
data.  Imagine that we are composing a confidential email to
someone.  Having written the email, we can send it in one of two ways.
The first, and usually convenient, way is to simply press the send
button and not care about how our email will be delivered.  Sending an
email in this manner is similar to writing our confidential message on
a postcard and post it without enclosing our postcard inside an
envelope.  Anyone who can access our postcard can see our message.
On the other hand, before sending our email, we can scramble the
confidential message and then press the send button.  Scrambling our
message is similar to enclosing our postcard inside an envelope.
While not 100% secure, at least we know that anyone wanting to read
our postcard has to open the envelope.</p>
<p>In cryptography parlance, our message is called <em>plaintext</em>.  The
process of scrambling our message is referred to as <em>encryption</em>.
After encrypting our message, the scrambled version is called
<em>ciphertext</em>.  From the ciphertext, we can recover our original
unscrambled message via <em>decryption</em>. The following figure
illustrates the processes of encryption and decryption.  A
<em>cryptosystem</em> is comprised of a pair of related encryption and
decryption processes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+</span> <span class="o">---------+</span>   <span class="n">encrypt</span>    <span class="o">+------------+</span>   <span class="n">decrypt</span>    <span class="o">+-----------+</span>
<span class="o">|</span> <span class="n">plaintext</span><span class="o">|</span> <span class="o">-----------&gt;</span> <span class="o">|</span> <span class="n">ciphertext</span> <span class="o">|</span> <span class="o">-----------&gt;</span> <span class="o">|</span> <span class="n">plaintext</span> <span class="o">|</span>
<span class="o">+----------+</span>              <span class="o">+------------+</span>              <span class="o">+-----------+</span>
</pre></div>
</div>
<p>The following table provides a very simple method of scrambling a
message written in English and using only upper case letters,
excluding punctuation characters.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+----------------------------------------------------+</span>
<span class="o">|</span> <span class="n">A</span>   <span class="n">B</span>   <span class="n">C</span>   <span class="n">D</span>   <span class="n">E</span>   <span class="n">F</span>   <span class="n">G</span>   <span class="n">H</span>   <span class="n">I</span>   <span class="n">J</span>   <span class="n">K</span>   <span class="n">L</span>   <span class="n">M</span>  <span class="o">|</span>
<span class="o">|</span> <span class="mi">65</span>  <span class="mi">66</span>  <span class="mi">67</span>  <span class="mi">68</span>  <span class="mi">69</span>  <span class="mi">70</span>  <span class="mi">71</span>  <span class="mi">72</span>  <span class="mi">73</span>  <span class="mi">74</span>  <span class="mi">75</span>  <span class="mi">76</span>  <span class="mi">77</span> <span class="o">|</span>
<span class="o">+----------------------------------------------------+</span>
<span class="o">|</span> <span class="n">N</span>   <span class="n">O</span>   <span class="n">P</span>   <span class="n">Q</span>   <span class="n">R</span>   <span class="n">S</span>   <span class="n">T</span>   <span class="n">U</span>   <span class="n">V</span>   <span class="n">W</span>   <span class="n">X</span>   <span class="n">Y</span>   <span class="n">Z</span>  <span class="o">|</span>
<span class="o">|</span> <span class="mi">78</span>  <span class="mi">79</span>  <span class="mi">80</span>  <span class="mi">81</span>  <span class="mi">82</span>  <span class="mi">83</span>  <span class="mi">84</span>  <span class="mi">85</span>  <span class="mi">86</span>  <span class="mi">87</span>  <span class="mi">88</span>  <span class="mi">89</span>  <span class="mi">90</span> <span class="o">|</span>
<span class="o">+----------------------------------------------------+</span>
</pre></div>
</div>
<p>Formally, let</p>
<div class="math notranslate nohighlight">
\[\Sigma
=
\{ \mathtt{A}, \mathtt{B}, \mathtt{C}, \dots, \mathtt{Z} \}\]</div>
<p>be the set of capital letters of the English alphabet. Furthermore,
let</p>
<div class="math notranslate nohighlight">
\[\Phi
=
\{ 65, 66, 67, \dots, 90 \}\]</div>
<p>be the American Standard Code for Information Interchange (ASCII)
encodings of the upper case English letters.  Then the above table
explicitly describes the mapping <span class="math notranslate nohighlight">\(f: \Sigma \longrightarrow \Phi\)</span>.
(For those familiar with ASCII, <span class="math notranslate nohighlight">\(f\)</span> is actually a common process for
<em>encoding</em> elements of <span class="math notranslate nohighlight">\(\Sigma\)</span>, rather than a cryptographic
“scrambling” process <em>per se</em>.)  To scramble a message written using
the alphabet <span class="math notranslate nohighlight">\(\Sigma\)</span>, we simply replace each capital letter of the
message with its corresponding ASCII encoding.  However, the
scrambling process described in the above table provides,
cryptographically speaking, very little to no security at all and we
strongly discourage its use in practice.</p>
</div>
<div class="section" id="keeping-a-secret-with-two-keys">
<h2>Keeping a secret with two keys<a class="headerlink" href="#keeping-a-secret-with-two-keys" title="Permalink to this headline">¶</a></h2>
<p>The Rivest, Shamir, Adleman (RSA) cryptosystem is an example of a
<em>public key cryptosystem</em>.  RSA uses a <em>public key</em> to
encrypt messages and decryption is performed using a corresponding
<em>private key</em>.  We can distribute our public keys, but for
security reasons we should keep our private keys to ourselves.  The
encryption and decryption processes draw upon techniques from
elementary number theory.  The algorithm below is adapted from page
165 of <a class="reference internal" href="#trappewashington2006" id="id4">[TrappeWashington2006]</a>. It outlines the RSA procedure for
encryption and decryption.</p>
<ol class="arabic simple">
<li>Choose two primes <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span> and let <span class="math notranslate nohighlight">\(n = pq\)</span>.</li>
<li>Let <span class="math notranslate nohighlight">\(e \in \ZZ\)</span> be positive such that
<span class="math notranslate nohighlight">\(\gcd \big( e, \varphi(n) \big) = 1\)</span>.</li>
<li>Compute a value for <span class="math notranslate nohighlight">\(d \in \ZZ\)</span> such that
<span class="math notranslate nohighlight">\(de \equiv 1 \pmod{\varphi(n)}\)</span>.</li>
<li>Our public key is the pair <span class="math notranslate nohighlight">\((n, e)\)</span> and our private key is the
triple <span class="math notranslate nohighlight">\((p,q,d)\)</span>.</li>
<li>For any non-zero integer <span class="math notranslate nohighlight">\(m &lt; n\)</span>, encrypt <span class="math notranslate nohighlight">\(m\)</span> using
<span class="math notranslate nohighlight">\(c \equiv m^e \pmod{n}\)</span>.</li>
<li>Decrypt <span class="math notranslate nohighlight">\(c\)</span> using <span class="math notranslate nohighlight">\(m \equiv c^d \pmod{n}\)</span>.</li>
</ol>
<p>The next two sections will step through the RSA algorithm, using
Sage to generate public and private keys, and perform encryption
and decryption based on those keys.</p>
</div>
<div class="section" id="generating-public-and-private-keys">
<h2>Generating public and private keys<a class="headerlink" href="#generating-public-and-private-keys" title="Permalink to this headline">¶</a></h2>
<p>Positive integers of the form <span class="math notranslate nohighlight">\(M_m = 2^m - 1\)</span> are called
<em>Mersenne numbers</em>.  If <span class="math notranslate nohighlight">\(p\)</span> is prime and <span class="math notranslate nohighlight">\(M_p = 2^p - 1\)</span> is also
prime, then <span class="math notranslate nohighlight">\(M_p\)</span> is called a <em>Mersenne prime</em>.  For example, 31
is prime and <span class="math notranslate nohighlight">\(M_{31} = 2^{31} - 1\)</span> is a Mersenne prime, as can be
verified using the command <code class="docutils literal notranslate"><span class="pre">is_prime(p)</span></code>.  This command returns
<code class="docutils literal notranslate"><span class="pre">True</span></code> if its argument <code class="docutils literal notranslate"><span class="pre">p</span></code> is precisely a prime number;
otherwise it returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.  By definition, a prime must be a
positive integer, hence <code class="docutils literal notranslate"><span class="pre">is_prime(-2)</span></code> returns <code class="docutils literal notranslate"><span class="pre">False</span></code>
although we know that 2 is prime.  Indeed, the number
<span class="math notranslate nohighlight">\(M_{61} = 2^{61} - 1\)</span> is also a Mersenne prime.  We can use
<span class="math notranslate nohighlight">\(M_{31}\)</span> and <span class="math notranslate nohighlight">\(M_{61}\)</span> to work through step 1 in the RSA algorithm:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">31</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">is_prime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">61</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">is_prime</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">q</span> <span class="p">;</span> <span class="n">n</span>
<span class="go">4951760154835678088235319297</span>
</pre></div>
</div>
<p>A word of warning is in order here.  In the above code example, the
choice of <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span> as Mersenne primes, and with so many digits far
apart from each other, is a very bad choice in terms of cryptographic
security.  However, we shall use the above chosen numeric values for
<span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span> for the remainder of this tutorial, always bearing in mind
that they have been chosen for pedagogy purposes only.  Refer to
<a class="reference internal" href="#menezesetal1996" id="id5">[MenezesEtAl1996]</a>,
<a class="reference internal" href="#stinson2006" id="id6">[Stinson2006]</a>, and
<a class="reference internal" href="#trappewashington2006" id="id7">[TrappeWashington2006]</a>
for in-depth discussions on the security of RSA, or consult other
specialized texts.</p>
<p>For step 2, we need to find a positive integer that is coprime to
<span class="math notranslate nohighlight">\(\varphi(n)\)</span>.  The set of integers is implemented within the Sage
module <code class="docutils literal notranslate"><span class="pre">sage.rings.integer_ring</span></code>.  Various operations on
integers can be accessed via the <code class="docutils literal notranslate"><span class="pre">ZZ.*</span></code> family of functions.
For instance, the command <code class="docutils literal notranslate"><span class="pre">ZZ.random_element(n)</span></code> returns a
pseudo-random integer uniformly distributed within the closed interval
<span class="math notranslate nohighlight">\([0, n-1]\)</span>.</p>
<p>We can compute the value <span class="math notranslate nohighlight">\(\varphi(n)\)</span> by calling the sage function
<code class="docutils literal notranslate"><span class="pre">euler_phi(n)</span></code>, but for arbitrarily large prime numbers <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span>,
this can take an enormous amount of time. Indeed, the private key
can be quickly deduced from the public key once you know <span class="math notranslate nohighlight">\(\varphi(n)\)</span>,
so it is an important part of the security of the RSA cryptosystem that
<span class="math notranslate nohighlight">\(\varphi(n)\)</span> cannot be computed in a short time, if only <span class="math notranslate nohighlight">\(n\)</span> is known.
On the other hand, if the private key is available, we can compute
<span class="math notranslate nohighlight">\(\varphi(n)=(p-1)(q-1)\)</span> in a very short time.</p>
<p>Using a simple programming loop, we can compute the
required value of <span class="math notranslate nohighlight">\(e\)</span> as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">31</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="mi">61</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">q</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">phi</span>
<span class="go">4951760152529835076874141700</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">random_element</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">while</span> <span class="n">gcd</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
<span class="go">....:     e = ZZ.random_element(phi)</span>
<span class="gp">...</span>
<span class="gp">sage: </span><span class="n">e</span>  <span class="c1"># random</span>
<span class="go">1850567623300615966303954877</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">&lt;</span> <span class="n">n</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As <code class="docutils literal notranslate"><span class="pre">e</span></code> is a pseudo-random integer, its numeric value changes
after each execution of <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">=</span> <span class="pre">ZZ.random_element(phi)</span></code>.</p>
<p>To calculate a value for <code class="docutils literal notranslate"><span class="pre">d</span></code> in step 3 of the RSA algorithm, we use
the extended Euclidean algorithm.  By definition of congruence,
<span class="math notranslate nohighlight">\(de \equiv 1 \pmod{\varphi(n)}\)</span> is equivalent to</p>
<div class="math notranslate nohighlight">
\[de - k \cdot \varphi(n) = 1\]</div>
<p>where <span class="math notranslate nohighlight">\(k \in \ZZ\)</span>.  From steps 1 and 2, we already know the numeric
values of <span class="math notranslate nohighlight">\(e\)</span> and <span class="math notranslate nohighlight">\(\varphi(n)\)</span>.  The extended Euclidean algorithm
allows us to compute <span class="math notranslate nohighlight">\(d\)</span> and <span class="math notranslate nohighlight">\(-k\)</span>.  In Sage, this can be accomplished
via the command <code class="docutils literal notranslate"><span class="pre">xgcd</span></code>.  Given two integers <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>,
<code class="docutils literal notranslate"><span class="pre">xgcd(x,</span> <span class="pre">y)</span></code> returns a 3-tuple <code class="docutils literal notranslate"><span class="pre">(g,</span> <span class="pre">s,</span> <span class="pre">t)</span></code> that satisfies
the Bézout identity <span class="math notranslate nohighlight">\(g = \gcd(x,y) = sx + ty\)</span>.  Having computed a
value for <code class="docutils literal notranslate"><span class="pre">d</span></code>, we then use the command
<code class="docutils literal notranslate"><span class="pre">mod(d*e,</span> <span class="pre">phi)</span></code> to check that <code class="docutils literal notranslate"><span class="pre">d*e</span></code> is indeed congruent
to 1 modulo <code class="docutils literal notranslate"><span class="pre">phi</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="mi">4951760154835678088235319297</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="mi">1850567623300615966303954877</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="mi">4951760152529835076874141700</span>
<span class="gp">sage: </span><span class="n">bezout</span> <span class="o">=</span> <span class="n">xgcd</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">);</span> <span class="n">bezout</span>  <span class="c1"># random</span>
<span class="go">(1, 4460824882019967172592779313, -1667095708515377925087033035)</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">mod</span><span class="p">(</span><span class="n">bezout</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">phi</span><span class="p">))</span> <span class="p">;</span> <span class="n">d</span>  <span class="c1"># random</span>
<span class="go">4460824882019967172592779313</span>
<span class="gp">sage: </span><span class="n">mod</span><span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">e</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Thus, our RSA public key is</p>
<div class="math notranslate nohighlight">
\[(n, e)
=
(4951760154835678088235319297,\, 1850567623300615966303954877)\]</div>
<p>and our corresponding private key is</p>
<div class="math notranslate nohighlight">
\[(p, q, d)
=
(2147483647,\, 2305843009213693951,\, 4460824882019967172592779313)\]</div>
</div>
<div class="section" id="encryption-and-decryption">
<h2>Encryption and decryption<a class="headerlink" href="#encryption-and-decryption" title="Permalink to this headline">¶</a></h2>
<p>Suppose we want to scramble the message <code class="docutils literal notranslate"><span class="pre">HELLOWORLD</span></code> using RSA
encryption.  From the above ASCII table, our message maps to integers
of the ASCII encodings as given below.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+----------------------------------------+</span>
<span class="o">|</span> <span class="n">H</span>   <span class="n">E</span>   <span class="n">L</span>   <span class="n">L</span>   <span class="n">O</span>   <span class="n">W</span>   <span class="n">O</span>   <span class="n">R</span>   <span class="n">L</span>   <span class="n">D</span>  <span class="o">|</span>
<span class="o">|</span> <span class="mi">72</span>  <span class="mi">69</span>  <span class="mi">76</span>  <span class="mi">76</span>  <span class="mi">79</span>  <span class="mi">87</span>  <span class="mi">79</span>  <span class="mi">82</span>  <span class="mi">76</span>  <span class="mi">68</span> <span class="o">|</span>
<span class="o">+----------------------------------------+</span>
</pre></div>
</div>
<p>Concatenating all the integers in the last table, our message can be
represented by the integer</p>
<div class="math notranslate nohighlight">
\[m = 72697676798779827668\]</div>
<p>There are other more cryptographically secure means for representing
our message as an integer.  The above process is used for
demonstration purposes only and we strongly discourage its use in
practice. In Sage, we can obtain an integer representation of our
message as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="s2">&quot;HELLOWORLD&quot;</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="nb">ord</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">m</span><span class="p">];</span> <span class="n">m</span>
<span class="go">[72, 69, 76, 76, 79, 87, 79, 82, 76, 68]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">m</span><span class="p">)),</span> <span class="mi">100</span><span class="p">)</span> <span class="p">;</span> <span class="n">m</span>
<span class="go">72697676798779827668</span>
</pre></div>
</div>
<p>To encrypt our message, we raise <span class="math notranslate nohighlight">\(m\)</span> to the power of <span class="math notranslate nohighlight">\(e\)</span> and reduce
the result modulo <span class="math notranslate nohighlight">\(n\)</span>.  The command <code class="docutils literal notranslate"><span class="pre">mod(a^b,</span> <span class="pre">n)</span></code> first computes
<code class="docutils literal notranslate"><span class="pre">a^b</span></code> and then reduces the result modulo <code class="docutils literal notranslate"><span class="pre">n</span></code>.  If the exponent
<code class="docutils literal notranslate"><span class="pre">b</span></code> is a “large” integer, say with more than 20 digits, then
performing modular exponentiation in this naive manner takes quite
some time.  Brute force (or naive) modular exponentiation is
inefficient and, when performed using a computer, can quickly
consume a huge quantity of the computer’s memory or result in overflow
messages.  For instance, if we perform naive modular exponentiation
using the command <code class="docutils literal notranslate"><span class="pre">mod(m^e,</span> <span class="pre">n)</span></code>, where <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">e</span></code> are as
given above, we would get an error message similar to the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mod</span><span class="p">(</span><span class="n">m</span><span class="o">^</span><span class="n">e</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">)</span>
<span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">mvngu</span><span class="o">/&lt;</span><span class="n">ipython</span> <span class="n">console</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span><span class="p">()</span>
<span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">mvngu</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">sage</span><span class="o">-</span><span class="mf">3.1</span><span class="o">.</span><span class="mi">4</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">python2</span><span class="o">.</span><span class="mi">5</span><span class="o">/</span><span class="n">site</span><span class="o">-</span><span class="n">packages</span><span class="o">/</span><span class="n">sage</span><span class="o">/</span><span class="n">rings</span><span class="o">/</span><span class="n">integer</span><span class="o">.</span><span class="n">so</span>
<span class="ow">in</span> <span class="n">sage</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">integer</span><span class="o">.</span><span class="n">Integer</span><span class="o">.</span><span class="fm">__pow__</span> <span class="p">(</span><span class="n">sage</span><span class="o">/</span><span class="n">rings</span><span class="o">/</span><span class="n">integer</span><span class="o">.</span><span class="n">c</span><span class="p">:</span><span class="mi">9650</span><span class="p">)()</span>
<span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">exponent</span> <span class="n">must</span> <span class="n">be</span> <span class="n">at</span> <span class="n">most</span> <span class="mi">2147483647</span>
</pre></div>
</div>
<p>There is a trick to efficiently perform modular exponentiation, called
the method of repeated squaring, cf. page 879 of <a class="reference internal" href="#cormenetal2001" id="id8">[CormenEtAl2001]</a>.
Suppose we want to compute <span class="math notranslate nohighlight">\(a^b \mod n\)</span>.  First, let
<span class="math notranslate nohighlight">\(d \mathrel{\mathop:}= 1\)</span> and obtain the binary representation of <span class="math notranslate nohighlight">\(b\)</span>,
say <span class="math notranslate nohighlight">\((b_1, b_2, \dots, b_k)\)</span> where each <span class="math notranslate nohighlight">\(b_i \in \ZZ/2\ZZ\)</span>.  For
<span class="math notranslate nohighlight">\(i \mathrel{\mathop:}= 1, \dots, k\)</span>, let
<span class="math notranslate nohighlight">\(d \mathrel{\mathop:}= d^2 \mod n\)</span> and if <span class="math notranslate nohighlight">\(b_i = 1\)</span> then let
<span class="math notranslate nohighlight">\(d \mathrel{\mathop:}= da \mod n\)</span>.  This algorithm is implemented in
the function <code class="docutils literal notranslate"><span class="pre">power_mod</span></code>. We now use the function <code class="docutils literal notranslate"><span class="pre">power_mod</span></code> to
encrypt our message:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="mi">72697676798779827668</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="mi">1850567623300615966303954877</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="mi">4951760154835678088235319297</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">power_mod</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="n">c</span>
<span class="go">630913632577520058415521090</span>
</pre></div>
</div>
<p>Thus <span class="math notranslate nohighlight">\(c = 630913632577520058415521090\)</span> is the ciphertext.  To recover
our plaintext, we raise <code class="docutils literal notranslate"><span class="pre">c</span></code> to the power of <code class="docutils literal notranslate"><span class="pre">d</span></code> and reduce the
result modulo <code class="docutils literal notranslate"><span class="pre">n</span></code>.  Again, we use modular exponentiation via
repeated squaring in the decryption process:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="mi">72697676798779827668</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="mi">630913632577520058415521090</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="mi">4460824882019967172592779313</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="mi">4951760154835678088235319297</span>
<span class="gp">sage: </span><span class="n">power_mod</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="go">72697676798779827668</span>
<span class="gp">sage: </span><span class="n">power_mod</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Notice in the last output that the value 72697676798779827668 is the
same as the integer that represents our original message.  Hence we
have recovered our plaintext.</p>
</div>
<div class="section" id="acknowledgements">
<h2>Acknowledgements<a class="headerlink" href="#acknowledgements" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>2009-07-25: Ron Evans (Department of Mathematics, UCSD) reported
a typo in the definition of greatest common divisors. The revised
definition incorporates his suggestions.</li>
<li>2008-11-04: Martin Albrecht (Information Security Group, Royal
Holloway, University of London), John Cremona (Mathematics
Institute, University of Warwick) and William Stein (Department of
Mathematics, University of Washington) reviewed this tutorial. Many
of their invaluable suggestions have been incorporated into this
document.</li>
</ol>
</div>
<div class="section" id="bibliography">
<h2>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">¶</a></h2>
<table class="docutils citation" frame="void" id="cormenetal2001" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[CormenEtAl2001]</a></td><td>T. H. Cormen, C. E. Leiserson, R. L. Rivest, and
C. Stein. <em>Introduction to Algorithms</em>. The MIT Press, USA, 2nd
edition, 2001.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="menezesetal1996" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[MenezesEtAl1996]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> A. J. Menezes, P. C. van Oorschot, and
S. A. Vanstone. <em>Handbook of Applied Cryptography</em>. CRC Press, Boca
Raton, FL, USA, 1996.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="stinson2006" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Stinson2006]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> D. R. Stinson. <em>Cryptography: Theory and Practice</em>.
Chapman &amp; Hall/CRC, Boca Raton, USA, 3rd edition, 2006.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="trappewashington2006" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[TrappeWashington2006]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id4">2</a>, <a class="fn-backref" href="#id7">3</a>)</em> W. Trappe and L. C. Washington. <em>Introduction
to Cryptography with Coding Theory</em>. Pearson Prentice Hall, Upper
Saddle River, New Jersey, USA, 2nd edition, 2006.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Number Theory and the RSA Public Key Cryptosystem</a><ul>
<li><a class="reference internal" href="#elementary-number-theory">Elementary number theory</a><ul>
<li><a class="reference internal" href="#prime-numbers">Prime numbers</a></li>
<li><a class="reference internal" href="#greatest-common-divisors">Greatest common divisors</a></li>
<li><a class="reference internal" href="#congruences">Congruences</a></li>
<li><a class="reference internal" href="#euler-s-phi-function">Euler’s phi function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#how-to-keep-a-secret">How to keep a secret?</a></li>
<li><a class="reference internal" href="#keeping-a-secret-with-two-keys">Keeping a secret with two keys</a></li>
<li><a class="reference internal" href="#generating-public-and-private-keys">Generating public and private keys</a></li>
<li><a class="reference internal" href="#encryption-and-decryption">Encryption and decryption</a></li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#bibliography">Bibliography</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="linear_programming.html"
                        title="previous chapter">Linear Programming (Mixed Integer)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="coding_theory.html"
                        title="next chapter">Coding Theory in Sage</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/numtheory_rsa.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="coding_theory.html" title="Coding Theory in Sage"
             >next</a> |</li>
        <li class="right" >
          <a href="linear_programming.html" title="Linear Programming (Mixed Integer)"
             >previous</a> |</li>
  
    
      <a href="../index.html"><img src="_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="index.html">Thematic Tutorials v8.3</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="toctree.html" >Thematic tutorial document tree</a> &#187;</li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2018, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>