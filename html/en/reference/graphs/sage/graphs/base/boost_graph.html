
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Interface to run Boost algorithms &#8212; Graph Theory</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sage.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/thebelab.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Hypergraph generators" href="../hypergraph_generators.html" />
    <link rel="prev" title="Backends for Sage (di)graphs." href="graph_backends.html" />
  <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />
  <!-- <script src="../../../../_static/thebe.js" type="text/javascript"></script> -->
  <!-- <script src="../../../../_static/thebe-sage.js" type="text/javascript"></script> -->

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../hypergraph_generators.html" title="Hypergraph generators"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="graph_backends.html" title="Backends for Sage (di)graphs."
             accesskey="P">previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="../../../../_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../../../../../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="../../../../index.html">Reference Manual</a> &#187;
      
      <a href="../../../index.html">Graph Theory</a> &#187;
    
  </li>

        <li class="nav-item nav-item-this"><a href="">Interface to run Boost algorithms</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="interface-to-run-boost-algorithms">
<span id="sage-graphs-base-boost-graph"></span><h1>Interface to run Boost algorithms<a class="headerlink" href="#interface-to-run-boost-algorithms" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.graphs.base.boost_graph"></span><p>Wrapper for a Boost graph. The Boost graphs are Cython C++ variables, and they
cannot be converted to Python objects: as a consequence, only functions defined
with cdef are able to create, read, modify, and delete these graphs.</p>
<p>A very important feature of Boost graph library is that all object are generic:
for instance, adjacency lists can be stored using different data structures,
and (most of) the functions work with all implementations provided. This feature
is implemented in our interface using fused types: however, Cython’s support for
fused types is still experimental, and some features are missing. For instance,
there cannot be nested generic function calls, and no variable can have a
generic type, apart from the arguments of a generic function.</p>
<p>All the input functions use pointers, because otherwise we might have problems
with <code class="docutils literal notranslate"><span class="pre">delete()</span></code>.</p>
<p><strong>Basic Boost Graph operations:</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.base.boost_graph.clustering_coeff" title="sage.graphs.base.boost_graph.clustering_coeff"><code class="xref py py-func docutils literal notranslate"><span class="pre">clustering_coeff()</span></code></a></p></td>
<td><p>Return the clustering coefficient of all vertices in the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.base.boost_graph.edge_connectivity" title="sage.graphs.base.boost_graph.edge_connectivity"><code class="xref py py-func docutils literal notranslate"><span class="pre">edge_connectivity()</span></code></a></p></td>
<td><p>Return the edge connectivity of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.base.boost_graph.dominator_tree" title="sage.graphs.base.boost_graph.dominator_tree"><code class="xref py py-func docutils literal notranslate"><span class="pre">dominator_tree()</span></code></a></p></td>
<td><p>Return a dominator tree of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.base.boost_graph.bandwidth_heuristics" title="sage.graphs.base.boost_graph.bandwidth_heuristics"><code class="xref py py-func docutils literal notranslate"><span class="pre">bandwidth_heuristics()</span></code></a></p></td>
<td><p>Use heuristics to approximate the bandwidth of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.base.boost_graph.min_spanning_tree" title="sage.graphs.base.boost_graph.min_spanning_tree"><code class="xref py py-func docutils literal notranslate"><span class="pre">min_spanning_tree()</span></code></a></p></td>
<td><p>Compute a minimum spanning tree of a (weighted) graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.base.boost_graph.shortest_paths" title="sage.graphs.base.boost_graph.shortest_paths"><code class="xref py py-func docutils literal notranslate"><span class="pre">shortest_paths()</span></code></a></p></td>
<td><p>Use Dijkstra or Bellman-Ford algorithm to compute the single-source shortest paths.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.base.boost_graph.johnson_shortest_paths" title="sage.graphs.base.boost_graph.johnson_shortest_paths"><code class="xref py py-func docutils literal notranslate"><span class="pre">johnson_shortest_paths()</span></code></a></p></td>
<td><p>Use Johnson algorithm to compute the all-pairs shortest paths.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.base.boost_graph.floyd_warshall_shortest_paths" title="sage.graphs.base.boost_graph.floyd_warshall_shortest_paths"><code class="xref py py-func docutils literal notranslate"><span class="pre">floyd_warshall_shortest_paths()</span></code></a></p></td>
<td><p>Use Floyd-Warshall algorithm to compute the all-pairs shortest paths.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.base.boost_graph.johnson_closeness_centrality" title="sage.graphs.base.boost_graph.johnson_closeness_centrality"><code class="xref py py-func docutils literal notranslate"><span class="pre">johnson_closeness_centrality()</span></code></a></p></td>
<td><p>Use Johnson algorithm to compute the closeness centrality of all vertices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.base.boost_graph.blocks_and_cut_vertices" title="sage.graphs.base.boost_graph.blocks_and_cut_vertices"><code class="xref py py-func docutils literal notranslate"><span class="pre">blocks_and_cut_vertices()</span></code></a></p></td>
<td><p>Use Tarjan’s algorithm to compute the blocks and cut vertices of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.base.boost_graph.min_cycle_basis" title="sage.graphs.base.boost_graph.min_cycle_basis"><code class="xref py py-func docutils literal notranslate"><span class="pre">min_cycle_basis()</span></code></a></p></td>
<td><p>Return a minimum weight cycle basis of the input graph.</p></td>
</tr>
</tbody>
</table>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.bandwidth_heuristics">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">bandwidth_heuristics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cuthill_mckee'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.bandwidth_heuristics" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Boost heuristics to approximate the bandwidth of the input graph.</p>
<p>The bandwidth <span class="math notranslate nohighlight">\(bw(M)\)</span> of a matrix <span class="math notranslate nohighlight">\(M\)</span> is the smallest integer <span class="math notranslate nohighlight">\(k\)</span> such that
all non-zero entries of <span class="math notranslate nohighlight">\(M\)</span> are at distance <span class="math notranslate nohighlight">\(k\)</span> from the diagonal. The
bandwidth <span class="math notranslate nohighlight">\(bw(g)\)</span> of an undirected graph <span class="math notranslate nohighlight">\(g\)</span> is the minimum bandwidth of
the adjacency matrix of <span class="math notranslate nohighlight">\(g\)</span>, over all possible relabellings of its vertices
(for more information, see the
<a class="reference internal" href="../graph_decompositions/bandwidth.html#module-sage.graphs.graph_decompositions.bandwidth" title="sage.graphs.graph_decompositions.bandwidth"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bandwidth</span></code></a>
module).</p>
<p>Unfortunately, exactly computing the bandwidth is NP-hard (and an
exponential algorithm is implemented in Sagemath in routine
<a class="reference internal" href="../graph_decompositions/bandwidth.html#sage.graphs.graph_decompositions.bandwidth.bandwidth" title="sage.graphs.graph_decompositions.bandwidth.bandwidth"><code class="xref py py-func docutils literal notranslate"><span class="pre">bandwidth()</span></code></a>). Here, we
implement two heuristics to find good orderings: Cuthill-McKee, and King.</p>
<p>This function works only in undirected graphs, and its running time is
<span class="math notranslate nohighlight">\(O(md_{max}\log d_{max})\)</span> for the Cuthill-McKee ordering, and
<span class="math notranslate nohighlight">\(O(md_{max}^2\log d_{max})\)</span> for the King ordering, where <span class="math notranslate nohighlight">\(m\)</span> is the number
of edges, and <span class="math notranslate nohighlight">\(d_{max}\)</span> is the maximum degree in the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – the input Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'cuthill_mckee'</span></code>); the heuristic used
to compute the ordering among <code class="docutils literal notranslate"><span class="pre">'cuthill_mckee'</span></code> and <code class="docutils literal notranslate"><span class="pre">'king'</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<p>A pair <code class="docutils literal notranslate"><span class="pre">[bandwidth,</span> <span class="pre">ordering]</span></code>, where <code class="docutils literal notranslate"><span class="pre">ordering</span></code> is the ordering of
vertices, <code class="docutils literal notranslate"><span class="pre">bandwidth</span></code> is the bandwidth of that specific ordering (which
is not necessarily the bandwidth of the graph, because this is a heuristic).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">bandwidth_heuristics</span>
<span class="gp">sage: </span><span class="n">bandwidth_heuristics</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">(1, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">sage: </span><span class="n">bandwidth_heuristics</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">(3, [(0, 0), (1, 0), (0, 1), (2, 0), (1, 1), (0, 2), (2, 1), (1, 2), (2, 2)])</span>
<span class="gp">sage: </span><span class="n">bandwidth_heuristics</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;king&#39;</span><span class="p">)</span>
<span class="go">(3, [(0, 0), (1, 0), (0, 1), (2, 0), (1, 1), (0, 2), (2, 1), (1, 2), (2, 2)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.blocks_and_cut_vertices">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">blocks_and_cut_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.blocks_and_cut_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the blocks and cut vertices of the graph.</p>
<p>This method uses the implementation of Tarjan’s algorithm available in the
Boost library .</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – the input Sage graph</p></li>
</ul>
<p>OUTPUT:</p>
<p>A 2-dimensional vector with m+1 rows (m is the number of biconnected
components), where each of the first m rows correspond to vertices in a
block, and the last row is the list of cut vertices.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="../generic_graph.html#sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices" title="sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.graphs.generic_graph.GenericGraph.blocks_and_cut_vertices()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">blocks_and_cut_vertices</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">KrackhardtKiteGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">blocks_and_cut_vertices</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">([[8, 9], [7, 8], [0, 1, 2, 3, 5, 4, 6, 7]], [8, 7])</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">})])</span>
<span class="gp">sage: </span><span class="n">blocks_and_cut_vertices</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">([[0, 1, 2]], [])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.clustering_coeff">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">clustering_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.clustering_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the clustering coefficient of the input graph, using Boost.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../generic_graph.html#sage.graphs.generic_graph.GenericGraph.clustering_coeff" title="sage.graphs.generic_graph.GenericGraph.clustering_coeff"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.graphs.generic_graph.GenericGraph.clustering_coeff()</span></code></a></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – the input Sage Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertices</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the list of vertices to analyze
(if <code class="docutils literal notranslate"><span class="pre">None</span></code>, compute the clustering coefficient of all vertices)</p></li>
</ul>
<p>OUTPUT: a pair <code class="docutils literal notranslate"><span class="pre">(average_clustering_coefficient,</span> <span class="pre">clust_of_v)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">average_clustering_coefficient</span></code> is the average clustering of the vertices
in variable <code class="docutils literal notranslate"><span class="pre">vertices</span></code>, <code class="docutils literal notranslate"><span class="pre">clust_of_v</span></code> is a dictionary that associates to
each vertex its clustering coefficient. If <code class="docutils literal notranslate"><span class="pre">vertices</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, all
vertices are considered.</p>
<p>EXAMPLES:</p>
<p>Computing the clustering coefficient of a clique:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">clustering_coeff</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">clustering_coeff</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">(1.0, {0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0})</span>
<span class="gp">sage: </span><span class="n">clustering_coeff</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(1.0, {0: 1.0, 1: 1.0, 2: 1.0})</span>
</pre></div>
</div>
<p>Of a non-clique graph with triangles:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">IcosahedralGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">clustering_coeff</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">(0.5, {1: 0.5, 2: 0.5, 3: 0.5})</span>
</pre></div>
</div>
<p>With labels:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">relabel</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s2">&quot;abcdefghiklm&quot;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">clustering_coeff</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="s2">&quot;abde&quot;</span><span class="p">)</span>
<span class="go">(0.5, {&#39;a&#39;: 0.5, &#39;b&#39;: 0.5, &#39;d&#39;: 0.5, &#39;e&#39;: 0.5})</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.diameter">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">diameter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.diameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the diameter of <span class="math notranslate nohighlight">\(G\)</span>.</p>
<p>This method returns Infinity if the digraph is not strongly connected. It
can also quickly return a lower bound on the diameter using the <code class="docutils literal notranslate"><span class="pre">2Dsweep</span></code>
scheme.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – the input sage digraph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); specifies the algorithm to
use among:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'2Dsweep'</span></code> – Computes lower bound on the diameter of an weighted
directed graph using the weighted version of the algorithm proposed in
<a class="reference internal" href="../../../../references/index.html#broder2000" id="id1"><span>[Broder2000]</span></a>. See the code’s documentation for more details.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'DiFUB'</span></code> – Computes the diameter of an weighted directed graph
using the weighted version of the algorithm proposed in <a class="reference internal" href="../../../../references/index.html#cglm2012" id="id2"><span>[CGLM2012]</span></a>.
See the code’s documentation for more details.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) vertex from which to start the
computation. If <code class="docutils literal notranslate"><span class="pre">source==None</span></code>, an arbitrary vertex of the graph is
chosen. Raise an error if the initial vertex is not in <span class="math notranslate nohighlight">\(G\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
associates a weight to each edge. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the weights of
<code class="docutils literal notranslate"><span class="pre">G</span></code> are used, if <code class="docutils literal notranslate"><span class="pre">G.weighted()==True</span></code>, otherwise all edges have
weight 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> outputs a number for each edge.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">diameter</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">diameter</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;DiFUB&#39;</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">sage: </span><span class="n">diameter</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;DiFUB&#39;</span><span class="p">,</span> <span class="n">weight_function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">2.0</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">diameter</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;DiFUB&#39;</span><span class="p">,</span> <span class="n">weight_function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span><span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">2.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.diameter_DHV">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">diameter_DHV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.diameter_DHV" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the diameter of weighted graph <span class="math notranslate nohighlight">\(g\)</span>.</p>
<p>This method computes the diameter of undirected graph using the
algorithm proposed in <a class="reference internal" href="../../../../references/index.html#dragan2018" id="id3"><span>[Dragan2018]</span></a>.</p>
<p>This method returns Infinity if graph is not connected.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – the input Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
associates a weight to each edge. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the weights of
<code class="docutils literal notranslate"><span class="pre">g</span></code> are used, if <code class="docutils literal notranslate"><span class="pre">g.weighted()==True</span></code>, otherwise all edges have
weight 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> outputs a number for each edge</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">diameter_DHV</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ButterflyGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">diameter_DHV</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">2.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.dominator_tree">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">dominator_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.dominator_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Boost to compute the dominator tree of <code class="docutils literal notranslate"><span class="pre">g</span></code>, rooted at <code class="docutils literal notranslate"><span class="pre">root</span></code>.</p>
<p>A node <span class="math notranslate nohighlight">\(d\)</span> dominates a node <span class="math notranslate nohighlight">\(n\)</span> if every path from the entry node
<code class="docutils literal notranslate"><span class="pre">root</span></code> to <span class="math notranslate nohighlight">\(n\)</span> must go through <span class="math notranslate nohighlight">\(d\)</span>. The immediate dominator of a node
<span class="math notranslate nohighlight">\(n\)</span> is the unique node that strictly dominates <span class="math notranslate nohighlight">\(n\)</span> but does not dominate
any other node that dominates <span class="math notranslate nohighlight">\(n\)</span>. A dominator tree is a tree where each
node’s children are those nodes it immediately dominates. For more
information, see the <a class="reference external" href="https://en.wikipedia.org/wiki/Dominator_(graph_theory)">Wikipedia article Dominator_(graph_theory)</a>.</p>
<p>If the graph is connected and undirected, the parent of a vertex <span class="math notranslate nohighlight">\(v\)</span> is:</p>
<blockquote>
<div><ul class="simple">
<li><p>the root if <span class="math notranslate nohighlight">\(v\)</span> is in the same biconnected component as the root;</p></li>
<li><p>the first cut vertex in a path from <span class="math notranslate nohighlight">\(v\)</span> to the root, otherwise.</p></li>
</ul>
</div></blockquote>
<p>If the graph is not connected, the dominator tree of the whole graph is
equal to the dominator tree of the connected component of the root.</p>
<p>If the graph is directed, computing a dominator tree is more complicated,
and it needs time <span class="math notranslate nohighlight">\(O(m\log m)\)</span>, where <span class="math notranslate nohighlight">\(m\)</span> is the number of edges. The
implementation provided by Boost is the most general one, so it needs time
<span class="math notranslate nohighlight">\(O(m\log m)\)</span> even for undirected graphs.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – the input Sage (Di)Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">root</span></code> – the root of the dominator tree</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">return_dict</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the function
returns a dictionary associating to each vertex its parent in the
dominator tree. If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), it returns the whole tree, as a
<code class="docutils literal notranslate"><span class="pre">Graph</span></code> or a <code class="docutils literal notranslate"><span class="pre">DiGraph</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); when set to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
computes the dominator tree in the reverse graph</p></li>
</ul>
<p>OUTPUT:</p>
<p>The dominator tree, as a graph or as a dictionary, depending on the
value of <code class="docutils literal notranslate"><span class="pre">return_dict</span></code>. If the output is a dictionary, it will contain
<code class="docutils literal notranslate"><span class="pre">None</span></code> in correspondence of <code class="docutils literal notranslate"><span class="pre">root</span></code> and of vertices that are not
reachable from <code class="docutils literal notranslate"><span class="pre">root</span></code>. If the output is a graph, it will not contain
vertices that are not reachable from <code class="docutils literal notranslate"><span class="pre">root</span></code>.</p>
<p>EXAMPLES:</p>
<p>An undirected grid is biconnected, and its dominator tree is a star
(everyone’s parent is the root):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">to_dictionary</span><span class="p">()</span>
<span class="go">{(0, 0): [(0, 1), (1, 0), (1, 1)], (0, 1): [(0, 0)], (1, 0): [(0, 0)], (1, 1): [(0, 0)]}</span>
</pre></div>
</div>
<p>If the graph is made by two 3-cycles <span class="math notranslate nohighlight">\(C_1,C_2\)</span> connected by an edge <span class="math notranslate nohighlight">\((v,w)\)</span>,
with <span class="math notranslate nohighlight">\(v \in C_1\)</span>, <span class="math notranslate nohighlight">\(w \in C_2\)</span>, the cut vertices are <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(w\)</span>, the
biconnected components are <span class="math notranslate nohighlight">\(C_1\)</span>, <span class="math notranslate nohighlight">\(C_2\)</span>, and the edge <span class="math notranslate nohighlight">\((v,w)\)</span>. If the root
is in <span class="math notranslate nohighlight">\(C_1\)</span>, the parent of each vertex in <span class="math notranslate nohighlight">\(C_1\)</span> is the root, the parent of
<span class="math notranslate nohighlight">\(w\)</span> is <span class="math notranslate nohighlight">\(v\)</span>, and the parent of each vertex in <span class="math notranslate nohighlight">\(C_2\)</span> is <span class="math notranslate nohighlight">\(w\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">return_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{0: 1, 1: None, 2: 1, 3: 0, 4: 3, 5: 3}</span>
</pre></div>
</div>
<p>An example with a directed graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">to_dictionary</span><span class="p">()</span>
<span class="go">{0: [1], 1: [2], 2: [3], 3: [4], 4: [], 5: [6], 6: [7], 7: [8], 8: [9], 9: [0]}</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">to_dictionary</span><span class="p">()</span>
<span class="go">{0: [9], 1: [0], 2: [1], 3: [2], 4: [3], 5: [4], 6: [], 7: [6], 8: [7], 9: [8]}</span>
</pre></div>
</div>
<p>If the output is a dictionary:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">dominator_tree</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">return_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{(0, 0): None, (0, 1): (0, 0), (1, 0): (0, 0), (1, 1): (0, 0)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.eccentricity_DHV">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">eccentricity_DHV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.eccentricity_DHV" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the vector of eccentricities using the algorithm of <a class="reference internal" href="../../../../references/index.html#dragan2018" id="id4"><span>[Dragan2018]</span></a>.</p>
<p>The array returned is of length <span class="math notranslate nohighlight">\(n\)</span>, and by default its <span class="math notranslate nohighlight">\(i\)</span>-th component is
the eccentricity of the <span class="math notranslate nohighlight">\(i\)</span>-th vertex in <code class="docutils literal notranslate"><span class="pre">g.vertices()</span></code>,
if <code class="docutils literal notranslate"><span class="pre">vertex_list</span> <span class="pre">is</span> <span class="pre">None</span></code>, otherwise <code class="docutils literal notranslate"><span class="pre">ecc[i]</span></code> is the eccentricity of
vertex <code class="docutils literal notranslate"><span class="pre">vertex_list[i]</span></code>.</p>
<p>The algorithm proposed in <a class="reference internal" href="../../../../references/index.html#dragan2018" id="id5"><span>[Dragan2018]</span></a> is based on the observation that for
all nodes <span class="math notranslate nohighlight">\(v,w\in V\)</span>, we have <span class="math notranslate nohighlight">\(\max(ecc[v]-d(v,w), d(v,w))\leq ecc[w] \leq
ecc[v] + d(v,w)\)</span>. Also the algorithm iteratively improves upper and lower
bounds on the eccentricity of each vertex until no further improvements can
be done.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – the input Sage graph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_list</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a list of <span class="math notranslate nohighlight">\(n\)</span> vertices
specifying a mapping from <span class="math notranslate nohighlight">\((0, \ldots, n-1)\)</span> to vertex labels in <span class="math notranslate nohighlight">\(g\)</span>. When
set, <code class="docutils literal notranslate"><span class="pre">ecc[i]</span></code> is the eccentricity of vertex <code class="docutils literal notranslate"><span class="pre">vertex_list[i]</span></code>. When
<code class="docutils literal notranslate"><span class="pre">vertex_list</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">ecc[i]</span></code> is the eccentricity of vertex
<code class="docutils literal notranslate"><span class="pre">g.vertices()[i]</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
associates a weight to each edge. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the weights of
<code class="docutils literal notranslate"><span class="pre">g</span></code> are used, if <code class="docutils literal notranslate"><span class="pre">g.weighted()==True</span></code>, otherwise all edges have
weight 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> outputs a number for each edge</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">eccentricity_DHV</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">BullGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">eccentricity_DHV</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">[2.0, 2.0, 2.0, 3.0, 3.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.edge_connectivity">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">edge_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.edge_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the edge connectivity of the input graph, using Boost.</p>
<p>OUTPUT: a pair <code class="docutils literal notranslate"><span class="pre">(ec,</span> <span class="pre">edges)</span></code>, where <code class="docutils literal notranslate"><span class="pre">ec</span></code> is the edge
connectivity, <code class="docutils literal notranslate"><span class="pre">edges</span></code> is the list of edges in a minimum cut.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../generic_graph.html#sage.graphs.generic_graph.GenericGraph.edge_connectivity" title="sage.graphs.generic_graph.GenericGraph.edge_connectivity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.graphs.generic_graph.GenericGraph.edge_connectivity()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<p>Computing the edge connectivity of a clique:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">edge_connectivity</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">(4, [(0, 1), (0, 2), (0, 3), (0, 4)])</span>
</pre></div>
</div>
<p>Vertex-labeled graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">edge_connectivity</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">edge_connectivity</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">(2, [((0, 0), (0, 1)), ((0, 0), (1, 0))])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.floyd_warshall_shortest_paths">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">floyd_warshall_shortest_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distances</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predecessors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.floyd_warshall_shortest_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Floyd-Warshall algorithm to solve the all-pairs-shortest-paths.</p>
<p>This routine outputs the distance between each pair of vertices and the 
predecessors matrix (depending on the values of boolean <code class="docutils literal notranslate"><span class="pre">distances</span></code> and
<code class="docutils literal notranslate"><span class="pre">predecessors</span></code>) using a dictionary of dictionaries. This method should be
preferred only if the graph is dense. If the graph is sparse the much
faster johnson_shortest_paths should be used.</p>
<p>The time-complexity is <span class="math notranslate nohighlight">\(O(n^3 + nm)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes and
<span class="math notranslate nohighlight">\(m\)</span> the number of edges. The factor <span class="math notranslate nohighlight">\(nm\)</span> in the complexity is added only
when <code class="docutils literal notranslate"><span class="pre">predecessors</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – the input Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
associates a weight to each edge. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the weights of
<code class="docutils literal notranslate"><span class="pre">g</span></code> are used, if <code class="docutils literal notranslate"><span class="pre">g.weighted()==True</span></code>, otherwise all edges have
weight 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">distances</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to return
the dictionary of shortest distances</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">predecessors</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
predecessors matrix</p></li>
</ul>
<p>OUTPUT:</p>
<p>Depending on the input, this function return the dictionary of
predecessors, the dictionary of distances, or a pair of dictionaries
<code class="docutils literal notranslate"><span class="pre">(distances,</span> <span class="pre">predecessors)</span></code> where <code class="docutils literal notranslate"><span class="pre">distance[u][v]</span></code> denotes the distance
of a shortest path from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span> and <code class="docutils literal notranslate"><span class="pre">predecessors[u][v]</span></code> indicates the
predecessor of <span class="math notranslate nohighlight">\(w\)</span> on a shortest path from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span>.</p>
<p>EXAMPLES:</p>
<p>Undirected graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">floyd_warshall_shortest_paths</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">floyd_warshall_shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">{0: {0: 0, 1: 1, 2: 3, 3: 4},</span>
<span class="go"> 1: {0: 1, 1: 0, 2: 2, 3: 3},</span>
<span class="go"> 2: {0: 3, 1: 2, 2: 0, 3: 1},</span>
<span class="go"> 3: {0: 4, 1: 3, 2: 1, 3: 0}}</span>
<span class="gp">sage: </span><span class="n">expected</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
<span class="gp">....: </span>            <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
<span class="gp">....: </span>            <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
<span class="gp">....: </span>            <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="kc">None</span><span class="p">}}</span>
<span class="gp">sage: </span><span class="n">floyd_warshall_shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">distances</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">predecessors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="n">expected</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">floyd_warshall_shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">{0: {0: 0, 1: 1, 2: -1, 3: 0},</span>
<span class="go"> 1: {1: 0, 2: -2, 3: -1},</span>
<span class="go"> 2: {2: 0, 3: 1},</span>
<span class="go"> 3: {3: 0}}</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">floyd_warshall_shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">distances</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">predecessors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{1: {1: None, 2: 4, 3: 2, 4: 1},</span>
<span class="go"> 2: {2: None, 3: 2},</span>
<span class="go"> 3: {3: None},</span>
<span class="go"> 4: {2: 4, 3: 2, 4: None}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.johnson_closeness_centrality">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">johnson_closeness_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.johnson_closeness_centrality" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Johnson algorithm to compute the closeness centrality of all vertices.</p>
<p>This routine is preferable to <a class="reference internal" href="#sage.graphs.base.boost_graph.johnson_shortest_paths" title="sage.graphs.base.boost_graph.johnson_shortest_paths"><code class="xref py py-func docutils literal notranslate"><span class="pre">johnson_shortest_paths()</span></code></a> because it
does not create a doubly indexed dictionary of distances, saving memory.</p>
<p>The time-complexity is <span class="math notranslate nohighlight">\(O(mn\log n)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes and
<span class="math notranslate nohighlight">\(m\)</span> is the number of edges.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – the input Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
associates a weight to each edge. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the weights of
<code class="docutils literal notranslate"><span class="pre">g</span></code> are used, if <code class="docutils literal notranslate"><span class="pre">g.weighted()==True</span></code>, otherwise all edges have
weight 1.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A dictionary associating each vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> to its closeness centrality.</p>
<p>EXAMPLES:</p>
<p>Undirected graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">johnson_closeness_centrality</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">johnson_closeness_centrality</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">{0: 0.375, 1: 0.5, 2: 0.5, 3: 0.375}</span>
</pre></div>
</div>
<p>Directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">johnson_closeness_centrality</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">johnson_closeness_centrality</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">{0: inf, 1: -0.4444444444444444, 2: 0.3333333333333333}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.johnson_shortest_paths">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">johnson_shortest_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distances</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predecessors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.johnson_shortest_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Johnson algorithm to solve the all-pairs-shortest-paths.</p>
<p>This routine outputs the distance between each pair of vertices and the 
predecessors matrix (depending on the values of boolean <code class="docutils literal notranslate"><span class="pre">distances</span></code> and
<code class="docutils literal notranslate"><span class="pre">predecessors</span></code>) using a dictionary of dictionaries. It works on all kinds
of graphs, but it is designed specifically for graphs with negative weights
(otherwise there are more efficient algorithms, like Dijkstra).</p>
<p>The time-complexity is <span class="math notranslate nohighlight">\(O(mn\log n)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes and
<span class="math notranslate nohighlight">\(m\)</span> is the number of edges.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – the input Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
associates a weight to each edge. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the weights of
<code class="docutils literal notranslate"><span class="pre">g</span></code> are used, if <code class="docutils literal notranslate"><span class="pre">g.weighted()==True</span></code>, otherwise all edges have
weight 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">distances</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); whether to return the
dictionary of shortest distances</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">predecessors</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
predecessors matrix</p></li>
</ul>
<p>OUTPUT:</p>
<p>Depending on the input, this function return the dictionary of
predecessors, the dictionary of distances, or a pair of dictionaries
<code class="docutils literal notranslate"><span class="pre">(distances,</span> <span class="pre">predecessors)</span></code> where <code class="docutils literal notranslate"><span class="pre">distance[u][v]</span></code> denotes the distance
of a shortest path from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span> and <code class="docutils literal notranslate"><span class="pre">predecessors[u][v]</span></code> indicates the
predecessor of <span class="math notranslate nohighlight">\(w\)</span> on a shortest path from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span>.</p>
<p>EXAMPLES:</p>
<p>Undirected graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">johnson_shortest_paths</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">johnson_shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">{0: {0: 0, 1: 1, 2: 3, 3: 4},</span>
<span class="go"> 1: {0: 1, 1: 0, 2: 2, 3: 3},</span>
<span class="go"> 2: {0: 3, 1: 2, 2: 0, 3: 1},</span>
<span class="go"> 3: {0: 4, 1: 3, 2: 1, 3: 0}}</span>
<span class="gp">sage: </span><span class="n">expected</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
<span class="gp">....: </span>            <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
<span class="gp">....: </span>            <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
<span class="gp">....: </span>            <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="kc">None</span><span class="p">}}</span>
<span class="gp">sage: </span><span class="n">johnson_shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">distances</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">predecessors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="n">expected</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">johnson_shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">{0: {0: 0, 1: 1, 2: -1, 3: 0},</span>
<span class="go"> 1: {1: 0, 2: -2, 3: -1},</span>
<span class="go"> 2: {2: 0, 3: 1},</span>
<span class="go"> 3: {3: 0}}</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">johnson_shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">distances</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">predecessors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{1: {1: None, 2: 4, 3: 2, 4: 1},</span>
<span class="go"> 2: {2: None, 3: 2},</span>
<span class="go"> 3: {3: None},</span>
<span class="go"> 4: {2: 4, 3: 2, 4: None}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.min_cycle_basis">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">min_cycle_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g_sage</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.min_cycle_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a minimum weight cycle basis of the input graph <code class="docutils literal notranslate"><span class="pre">g_sage</span></code>.</p>
<p>A cycle basis is a list of cycles (list of vertices forming a cycle) of
<code class="docutils literal notranslate"><span class="pre">g_sage</span></code>. Note that the vertices are not necessarily returned in the order
in which they appear in the cycle.</p>
<p>A minimum weight cycle basis is a cycle basis that minimizes the sum of the
weights (length for unweighted graphs) of its cycles.</p>
<p>Not implemented for directed graphs and multigraphs.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g_sage</span></code> – a Sage Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that takes
as input an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span> <span class="pre">l)</span></code> and outputs its weight. If not <code class="docutils literal notranslate"><span class="pre">None</span></code>,
<code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is automatically set to <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code> and
<code class="docutils literal notranslate"><span class="pre">by_weight</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the weights of <code class="docutils literal notranslate"><span class="pre">g_sage</span></code> are used, if
<code class="docutils literal notranslate"><span class="pre">g_sage.weighted()==True</span></code>, otherwise all edges have weight 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">by_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the edges in
the graph are weighted, otherwise all edges have weight 1</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">250</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">17</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">minimum_cycle_basis</span><span class="p">(</span><span class="n">by_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[[1, 2, 3], [1, 2, 3, 4], [5, 6, 7]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">minimum_cycle_basis</span><span class="p">())</span>
<span class="go">[[1, 2, 3], [1, 3, 4], [5, 6, 7]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Cycle_basis">Wikipedia article Cycle_basis</a></p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.min_spanning_tree">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">min_spanning_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Kruskal'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.min_spanning_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Boost to compute the minimum spanning tree of the input graph.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – the input Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
inputs an edge <code class="docutils literal notranslate"><span class="pre">e</span></code> and outputs its weight. An edge has the form
<code class="docutils literal notranslate"><span class="pre">(u,v,l)</span></code>, where <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> are vertices, <code class="docutils literal notranslate"><span class="pre">l</span></code> is a label (that
can be of any kind). The <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> can be used to transform the
label into a weight (see the example below). In particular:</p>
<ul class="simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>, the weight of an edge <code class="docutils literal notranslate"><span class="pre">e</span></code> is
<code class="docutils literal notranslate"><span class="pre">weight_function(e)</span></code>;</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default) and <code class="docutils literal notranslate"><span class="pre">g</span></code> is weighted (that
is, <code class="docutils literal notranslate"><span class="pre">g.weighted()==True</span></code>), for each edge <code class="docutils literal notranslate"><span class="pre">e=(u,v,l)</span></code>, we set weight
<code class="docutils literal notranslate"><span class="pre">l</span></code>;</p></li>
<li><p>if <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> is not weighted, we set all
weights to 1 (hence, the output can be any spanning tree).</p></li>
</ul>
<p>Note that, if the weight is not convertible to a number with function
<code class="docutils literal notranslate"><span class="pre">float()</span></code>, an error is raised (see tests below).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'Kruskal'</span></code>); the algorithm to use
among <code class="docutils literal notranslate"><span class="pre">'Kruskal'</span></code> and <code class="docutils literal notranslate"><span class="pre">'Prim'</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<p>The edges of a minimum spanning tree of <code class="docutils literal notranslate"><span class="pre">g</span></code>, if one exists, otherwise
the empty list.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="../generic_graph.html#sage.graphs.generic_graph.GenericGraph.min_spanning_tree" title="sage.graphs.generic_graph.GenericGraph.min_spanning_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.graphs.generic_graph.GenericGraph.min_spanning_tree()</span></code></a></p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">min_spanning_tree</span>
<span class="gp">sage: </span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">[(0, 1, None), (1, 2, None), (2, 3, None)]</span>

<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">})])</span>
<span class="gp">sage: </span><span class="n">min_spanning_tree</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">weight_function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">])</span>
<span class="go">[(0, 1, {&#39;name&#39;: &#39;a&#39;, &#39;weight&#39;: 1}), (1, 2, {&#39;name&#39;: &#39;b&#39;, &#39;weight&#39;: 1})]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.radius_DHV">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">radius_DHV</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.radius_DHV" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the radius of weighted graph <span class="math notranslate nohighlight">\(g\)</span>.</p>
<p>This method computes the radius of undirected graph using the algorithm
given in <a class="reference internal" href="../../../../references/index.html#dragan2018" id="id6"><span>[Dragan2018]</span></a>.</p>
<p>This method returns Infinity if graph is not connected.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – the input Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
associates a weight to each edge. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the weights of
<code class="docutils literal notranslate"><span class="pre">g</span></code> are used, if <code class="docutils literal notranslate"><span class="pre">g.weighted()==True</span></code>, otherwise all edges have
weight 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> outputs a number for each edge.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">radius_DHV</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">radius_DHV</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">radius_DHV</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">radius</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Dijkstra_Boost&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.shortest_paths">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">shortest_paths</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.shortest_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the shortest paths from <code class="docutils literal notranslate"><span class="pre">start</span></code> to all other vertices.</p>
<p>This routine outputs all shortest paths from node <code class="docutils literal notranslate"><span class="pre">start</span></code> to any other
node in the graph. The input graph can be weighted: if the algorithm is
Dijkstra, no negative weights are allowed, while if the algorithm is
Bellman-Ford, negative weights are allowed, but there must be no negative
cycle (otherwise, the shortest paths might not exist).</p>
<p>However, Dijkstra algorithm is more efficient: for this reason, we suggest
to use Bellman-Ford only if necessary (which is also the default option).
Note that, if the graph is undirected, a negative edge automatically creates
a negative cycle: for this reason, in this case, Dijkstra algorithm is
always better.</p>
<p>The running-time is <span class="math notranslate nohighlight">\(O(n \log n+m)\)</span> for Dijkstra algorithm and <span class="math notranslate nohighlight">\(O(mn)\)</span> for
Bellman-Ford algorithm, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes and <span class="math notranslate nohighlight">\(m\)</span> is the
number of edges.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – the input Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">start</span></code> – the starting vertex to compute shortest paths</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
associates a weight to each edge. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the weights of
<code class="docutils literal notranslate"><span class="pre">g</span></code> are used, if <code class="docutils literal notranslate"><span class="pre">g.weighted()==True</span></code>, otherwise all edges have
weight 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code>: the Dijkstra algorithm implemented
in Boost (works only with positive weights)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Bellman-Ford'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Bellman-Ford_Boost'</span></code>: the Bellman-Ford algorithm
implemented in Boost (works also with negative weights, if there is no
negative cycle)</p></li>
</ul>
</li>
</ul>
<p>OUTPUT:</p>
<p>A pair of dictionaries <code class="docutils literal notranslate"><span class="pre">(distances,</span> <span class="pre">predecessors)</span></code> such that, for each
vertex <code class="docutils literal notranslate"><span class="pre">v</span></code>, <code class="docutils literal notranslate"><span class="pre">distances[v]</span></code> is the distance from <code class="docutils literal notranslate"><span class="pre">start</span></code> to <code class="docutils literal notranslate"><span class="pre">v</span></code>,
<code class="docutils literal notranslate"><span class="pre">predecessors[v]</span></code> is the last vertex in a shortest path from <code class="docutils literal notranslate"><span class="pre">start</span></code> to
<code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p>EXAMPLES:</p>
<p>Undirected graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">shortest_paths</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">({0: 1, 1: 0, 2: 2, 3: 3}, {0: 1, 1: None, 2: 1, 3: 2})</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">GridGraph</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">weight_function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span><span class="mi">2</span><span class="p">)</span>
<span class="go">({(0, 0): 0, (0, 1): 2, (1, 0): 2, (1, 1): 4},</span>
<span class="go"> {(0, 0): None, (0, 1): (0, 0), (1, 0): (0, 0), (1, 1): (0, 1)})</span>
</pre></div>
</div>
<p>Directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">({1: 0, 2: 2, 3: 3}, {1: None, 2: 1, 3: 2})</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.shortest_paths_from_vertices">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">shortest_paths_from_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.shortest_paths_from_vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the shortest paths to all vertices from each vertex in
<code class="docutils literal notranslate"><span class="pre">vertex_list</span></code>.</p>
<p>The input graph can be weighted: if the algorithm is Dijkstra, no negative
weights are allowed, while if the algorithm is Bellman-Ford, negative
weights are allowed, but there must be no negative cycle (otherwise, the
shortest paths might not exist).</p>
<p>However, Dijkstra algorithm is more efficient: for this reason, we suggest
to use Bellman-Ford only if necessary (which is also the default option).</p>
<p>The running-time for each vertex is <span class="math notranslate nohighlight">\(O(n \log n+m)\)</span> for Dijkstra algorithm
and <span class="math notranslate nohighlight">\(O(mn)\)</span> for Bellman-Ford algorithm, where <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes and
<span class="math notranslate nohighlight">\(m\)</span> is the number of edges.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – the input Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vertex_list</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); list of vertices to compute
shortest paths from. By default (<code class="docutils literal notranslate"><span class="pre">None</span></code>), compute shortest paths from
all vertices.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">order</span></code> – list (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); order of vertices of <span class="math notranslate nohighlight">\(g\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
associates a weight to each edge. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the weights of
<code class="docutils literal notranslate"><span class="pre">g</span></code> are used, if <code class="docutils literal notranslate"><span class="pre">g.weighted()==True</span></code>, otherwise all edges have
weight 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code> - the Dijkstra algorithm
implemented in Boost (works only with positive weights)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Bellman-Ford'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Bellman-Ford_Boost'</span></code> - the Bellman-Ford
algorithm implemented in Boost (works also with negative weights,
if there is no negative cycle)</p></li>
</ul>
</li>
</ul>
<p>OUTPUT:</p>
<p>The type of output depends on the input. More precisely -</p>
<ul class="simple">
<li><p>A pair of dictionaries of list <code class="docutils literal notranslate"><span class="pre">(distances,</span> <span class="pre">predecessors)</span></code>, when
<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code>, such that for each vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> in <code class="docutils literal notranslate"><span class="pre">vertex_list</span></code>,
<code class="docutils literal notranslate"><span class="pre">distances[v][i]</span></code> store the shortest distance between <code class="docutils literal notranslate"><span class="pre">v</span></code> and
<code class="docutils literal notranslate"><span class="pre">order[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">predecessors[v][i]</span></code> store the last vertex in the
shortest path from <code class="docutils literal notranslate"><span class="pre">v</span></code> to <code class="docutils literal notranslate"><span class="pre">order[i]</span></code>.</p></li>
<li><p>A pair of dictionaries of dictionaries <code class="docutils literal notranslate"><span class="pre">(distances,</span> <span class="pre">predecessors)</span></code> such
that for each vertex <code class="docutils literal notranslate"><span class="pre">v</span></code> in <code class="docutils literal notranslate"><span class="pre">vertex_list</span></code>, <code class="docutils literal notranslate"><span class="pre">distances[v]</span></code> store the
shortest distances of all the other vertices from <code class="docutils literal notranslate"><span class="pre">v</span></code>,
<code class="docutils literal notranslate"><span class="pre">predecessors[v]</span></code> store the last vertices in the shortest path from
<code class="docutils literal notranslate"><span class="pre">v</span></code> to all the other vertices.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Undirected graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.base.boost_graph</span> <span class="kn">import</span> <span class="n">shortest_paths_from_vertices</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">shortest_paths_from_vertices</span><span class="p">(</span><span class="n">g</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">({1: {0: 1.0, 1: 0.0, 2: 2.0, 3: 3.0}, 2: {0: 3.0, 1: 2.0, 2: 0.0, 3: 1.0}},</span>
<span class="go"> {1: {0: 1, 1: None, 2: 1, 3: 2}, 2: {0: 1, 1: 2, 2: None, 3: 2}})</span>
</pre></div>
</div>
<p>Directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">shortest_paths_from_vertices</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">({1: {0: 1.0, 1: 0.0, 2: -1.0, 3: 0.0}}, {1: {0: 2, 1: None, 2: 1, 3: 2}})</span>
<span class="gp">sage: </span><span class="n">shortest_paths_from_vertices</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">({1: [1.0, 0.0, -1.0, 0.0]}, {1: [2, None, 1, 2]})</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.graphs.base.boost_graph.wiener_index">
<span class="sig-prename descclassname"><span class="pre">sage.graphs.base.boost_graph.</span></span><span class="sig-name descname"><span class="pre">wiener_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">g</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.base.boost_graph.wiener_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Wiener index of the graph.</p>
<p>The Wiener index of an undirected graph <span class="math notranslate nohighlight">\(G\)</span> is defined as
<span class="math notranslate nohighlight">\(W(G) = \frac{1}{2} \sum_{u,v\in G} d(u,v)\)</span> where <span class="math notranslate nohighlight">\(d(u,v)\)</span> denotes the
distance between vertices <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> (see <a class="reference internal" href="../../../../references/index.html#krg1996" id="id7"><span>[KRG1996]</span></a>).</p>
<p>The Wiener index of a directed graph <span class="math notranslate nohighlight">\(G\)</span> is defined as the sum of the
distances between each pairs of vertices, <span class="math notranslate nohighlight">\(W(G) = \sum_{u,v\in G} d(u,v)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">g</span></code> – the input Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'Dijkstra'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Dijkstra_Boost'</span></code>: the Dijkstra algorithm implemented
in Boost (works only with positive weights)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Bellman-Ford'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Bellman-Ford_Boost'</span></code>: the Bellman-Ford algorithm
implemented in Boost (works also with negative weights, if there is no
negative cycle)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">weight_function</span></code> – function (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); a function that
associates a weight to each edge. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), the weights of
<code class="docutils literal notranslate"><span class="pre">g</span></code> are used, if <code class="docutils literal notranslate"><span class="pre">g.weighted()==True</span></code>, otherwise all edges have
weight 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_weight</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>); if <code class="docutils literal notranslate"><span class="pre">True</span></code>, we check
that the <code class="docutils literal notranslate"><span class="pre">weight_function</span></code> outputs a number for each edge.</p></li>
</ul>
<p>EXAMPLES:</p>
<blockquote>
<div><p>sage: from sage.graphs.base.boost_graph import wiener_index
sage: g = Graph([(0,1,9), (1,2,7), (2,3,4), (3,0,3)])
sage: wiener_index(g)
8.0
sage: g.weighted(True)
sage: wiener_index(g)
41.0</p>
</div></blockquote>
<p>Wiener index of circuit digraphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">wiener_index</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="n">w</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Wiener index of a graph of order 1:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">wiener_index</span><span class="p">(</span><span class="n">Graph</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The Wiener index is not defined on the empty graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">wiener_index</span><span class="p">(</span><span class="n">Graph</span><span class="p">())</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: Wiener index is not defined for the empty graph</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Interface to run Boost algorithms</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="graph_backends.html"
                          title="previous chapter">Backends for Sage (di)graphs.</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="../hypergraph_generators.html"
                          title="next chapter">Hypergraph generators</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/sage/graphs/base/boost_graph.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../hypergraph_generators.html" title="Hypergraph generators"
             >next</a> |</li>
        <li class="right" >
          <a href="graph_backends.html" title="Backends for Sage (di)graphs."
             >previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="../../../../_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../../../../../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="../../../../index.html">Reference Manual</a> &#187;
      
      <a href="../../../index.html">Graph Theory</a> &#187;
    
  </li>

        <li class="nav-item nav-item-this"><a href="">Interface to run Boost algorithms</a></li> 
      </ul>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2022, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
  </script>
  <script type="text/javascript">
/* detex the document title by removing "\(", "\)", "\", "$" */
document.title = document.title.replace(/\\\(/g, '').replace(/\\\)/g, '').replace(/\\/g, '').replace(/\$/g, '');
  </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>