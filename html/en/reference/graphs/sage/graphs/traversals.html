
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="viewport" content="width=600, initial-scale=1">
    <title>Graph traversals. &#8212; Sage 9.3 Reference Manual: Graph Theory</title>
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script async="async" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Graph Plotting" href="graph_plot.html" />
    <link rel="prev" title="Wrapper for Boyer’s (C) planarity algorithm" href="planarity.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="graph_plot.html" title="Graph Plotting"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="planarity.html" title="Wrapper for Boyer’s (C) planarity algorithm"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.3 Reference Manual: Graph Theory</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Graph traversals.</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="graph-traversals">
<span id="sage-graphs-traversals"></span><h1>Graph traversals.<a class="headerlink" href="#graph-traversals" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.graphs.traversals"></span><p><strong>This module implements the following graph traversals</strong></p>
<table class="colwidths-given contentstable docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.traversals.lex_BFS" title="sage.graphs.traversals.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a></p></td>
<td><p>Perform a lexicographic breadth first search (LexBFS) on the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.traversals.lex_DFS" title="sage.graphs.traversals.lex_DFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a></p></td>
<td><p>Perform a lexicographic depth first search (LexDFS) on the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.traversals.lex_UP" title="sage.graphs.traversals.lex_UP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_UP()</span></code></a></p></td>
<td><p>Perform a lexicographic UP search (LexUP) on the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.traversals.lex_DOWN" title="sage.graphs.traversals.lex_DOWN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a></p></td>
<td><p>Perform a lexicographic DOWN search (LexDOWN) on the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.traversals.lex_M" title="sage.graphs.traversals.lex_M"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_M()</span></code></a></p></td>
<td><p>Return an ordering of the vertices according the LexM graph traversal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.traversals.lex_M_slow" title="sage.graphs.traversals.lex_M_slow"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_M_slow()</span></code></a></p></td>
<td><p>Return an ordering of the vertices according the LexM graph traversal.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.traversals.lex_M_fast" title="sage.graphs.traversals.lex_M_fast"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_M_fast()</span></code></a></p></td>
<td><p>Return an ordering of the vertices according the LexM graph traversal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sage.graphs.traversals.maximum_cardinality_search" title="sage.graphs.traversals.maximum_cardinality_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximum_cardinality_search()</span></code></a></p></td>
<td><p>Return an ordering of the vertices according a maximum cardinality search.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sage.graphs.traversals.maximum_cardinality_search_M" title="sage.graphs.traversals.maximum_cardinality_search_M"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximum_cardinality_search_M()</span></code></a></p></td>
<td><p>Return the ordering and the edges of the triangulation produced by MCS-M.</p></td>
</tr>
</tbody>
</table>
<div class="section" id="methods">
<h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="sage.graphs.traversals.is_valid_lex_M_order">
<code class="sig-prename descclassname">sage.graphs.traversals.</code><code class="sig-name descname">is_valid_lex_M_order</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">alpha</span></em>, <em class="sig-param"><span class="n">F</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.is_valid_lex_M_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the ordering alpha and the triangulation F are valid for G.</p>
<p>Given the graph <span class="math notranslate nohighlight">\(G = (V, E)\)</span> with vertex set <span class="math notranslate nohighlight">\(V\)</span> and edge set <span class="math notranslate nohighlight">\(E\)</span>, and the
set <span class="math notranslate nohighlight">\(F\)</span> of edges of a triangulation of <span class="math notranslate nohighlight">\(G\)</span>, let <span class="math notranslate nohighlight">\(H = (V, E\cup F)\)</span>.
By induction one can see that for every <span class="math notranslate nohighlight">\(i \in \{1, ..., n - 1\}\)</span> the
neighbors of <span class="math notranslate nohighlight">\(\alpha(i)\)</span> in <span class="math notranslate nohighlight">\(H[\{\alpha(i), ..., \alpha(n)\}]\)</span> induce a
clique. The ordering <span class="math notranslate nohighlight">\(\alpha\)</span> is a perfect elimination ordering of <span class="math notranslate nohighlight">\(H\)</span>, so
<span class="math notranslate nohighlight">\(H\)</span> is chordal. See <a class="reference internal" href="../../../references/index.html#rtl76" id="id1"><span>[RTL76]</span></a> for more details.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> – list; an ordering of the vertices of <span class="math notranslate nohighlight">\(G\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">F</span></code> – an iterable of edges given either as <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v)</span></code> or <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span>
<span class="pre">label)</span></code>, the edges of the triangulation of <span class="math notranslate nohighlight">\(G\)</span></p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt id="sage.graphs.traversals.lex_BFS">
<code class="sig-prename descclassname">sage.graphs.traversals.</code><code class="sig-name descname">lex_BFS</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">reverse</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">tree</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">initial_vertex</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">algorithm</span><span class="o">=</span><span class="default_value">'fast'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_BFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a lexicographic breadth first search (LexBFS) on the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">&quot;fast&quot;</span></code>); algorithm to use among:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;slow&quot;</span></code> – This algorithm maintains for each vertex left in the graph
a code corresponding to the vertices already removed. The vertex of
maximal code (according to the lexicographic order) is then removed, and
the codes are updated. See for instance <a class="reference internal" href="../../../references/index.html#ck2008" id="id2"><span>[CK2008]</span></a> for more details.  The
time complexity of this algorithm as described in <a class="reference internal" href="../../../references/index.html#ck2008" id="id3"><span>[CK2008]</span></a> is in
<span class="math notranslate nohighlight">\(O(n + m)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is the number of
edges, but our implementation is in <span class="math notranslate nohighlight">\(O(n^2)\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;fast&quot;</span></code> – This algorithm uses the notion of <em>slices</em> to refine the
position of the vertices in the ordering. The time complexity of this
algorithm is in <span class="math notranslate nohighlight">\(O(n + m)\)</span>, and our implementation follows that
complexity. See <a class="reference internal" href="../../../references/index.html#hmpv2000" id="id4"><span>[HMPV2000]</span></a> and next section for more details.</p></li>
</ul>
</li>
</ul>
<p>ALGORITHM:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&quot;fast&quot;</span></code> algorithm is the <span class="math notranslate nohighlight">\(O(n + m)\)</span> time algorithm proposed in
<a class="reference internal" href="../../../references/index.html#hmpv2000" id="id5"><span>[HMPV2000]</span></a>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is the number of
edges. It uses the notion of <em>slices</em>, i.e., subsets of consecutive vertices
in the ordering, and iteratively refines the slices by subdividing them into
sub-slices to determine the exact position of the vertices in the ordering.</p>
<p>Consider an ordering <span class="math notranslate nohighlight">\(\sigma\)</span> of the vertices. For a vertex <span class="math notranslate nohighlight">\(v\)</span>, we define
<span class="math notranslate nohighlight">\(N_i(v) = \{u | u \in N(v) \text{ and } \sigma(u) &lt; i\}\)</span>, that is the subset
of neighbors of <span class="math notranslate nohighlight">\(v\)</span> appearing before the <span class="math notranslate nohighlight">\(i\)</span>-th vertex in the ordering
<span class="math notranslate nohighlight">\(\sigma\)</span>. Now, a slice of an ordering <span class="math notranslate nohighlight">\(\sigma\)</span> is a set of consecutive
vertices, <span class="math notranslate nohighlight">\(S = \{u | i \leq \sigma(u) \leq j\}\)</span>, such that for any <span class="math notranslate nohighlight">\(u \in
S\)</span>, we have <span class="math notranslate nohighlight">\(N_i(u) = N_i(\sigma^{-1}(i))\)</span> and for any <span class="math notranslate nohighlight">\(v\)</span> such that <span class="math notranslate nohighlight">\(j &lt;
\sigma(v)\)</span>, <span class="math notranslate nohighlight">\(N_i(v) \neq N_i(\sigma^{-1}(i))\)</span>. The <em>head</em> of a slice is the
first position of its vertices.</p>
<p>The algorithm starts with a single slice containing all vertices. Then, when
the position of the <span class="math notranslate nohighlight">\(i\)</span>-th vertex <span class="math notranslate nohighlight">\(v\)</span> is fixed, it explores the neighbors of
<span class="math notranslate nohighlight">\(v\)</span> that have not yet been ordered. Consider a slice <span class="math notranslate nohighlight">\(S\)</span> such that <span class="math notranslate nohighlight">\(N(x)\cap
S \neq \emptyset\)</span>. The algorithm will rearrange the ordering of the vertices
in <span class="math notranslate nohighlight">\(S\)</span> so that the first vertices are the neighbors of <span class="math notranslate nohighlight">\(v\)</span>. The sub-slice
containing the neighbors of <span class="math notranslate nohighlight">\(v\)</span> is assigned a new slice name, and the head
of slice <span class="math notranslate nohighlight">\(S\)</span> is set to the position of the first vertex of <span class="math notranslate nohighlight">\(S \setminus
N(v)\)</span> in the ordering <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
<p>Observe that each arc of the graph can induce the subdivision of a
slice. Hence, the algorithm can use up to <span class="math notranslate nohighlight">\(m + 1\)</span> different slices.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Lexicographic_breadth-first_search">Wikipedia article Lexicographic_breadth-first_search</a></p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DFS" title="sage.graphs.generic_graph.GenericGraph.lex_DFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a> – perform a
lexicographic depth first search (LexDFS) on the graph</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_UP" title="sage.graphs.generic_graph.GenericGraph.lex_UP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_UP()</span></code></a> – perform a
lexicographic UP search (LexUP) on the graph</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DOWN" title="sage.graphs.generic_graph.GenericGraph.lex_DOWN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a> – perform a
lexicographic DOWN search (LexDOWN) on the graph</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A Lex BFS is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">())</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lex BFS ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 4, 6]</span>
</pre></div>
</div>
<p>The method also works for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;slow&quot;</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;fast&quot;</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
</pre></div>
</div>
<p>For a Chordal Graph, a reversed Lex BFS is a Perfect Elimination Order:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">lexicographic_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[(2, 1), (2, 0), (1, 1), (1, 0), (0, 1), (0, 0)]</span>
</pre></div>
</div>
<p>And the vertices at the end of the tree of discovery are, for chordal
graphs, simplicial vertices (their neighborhood is a complete graph):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">()</span><span class="o">.</span><span class="n">lexicographic_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">peo</span><span class="p">,</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span> <span class="o">=</span> <span class="n">v</span><span class="p">,</span>  <span class="n">tree</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">leaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tree</span> <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">in_degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">.</span><span class="n">is_clique</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Different orderings for different traversals:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;fast&quot;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;slow&quot;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;011&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;, &#39;011&#39;, &#39;100&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;011&#39;, &#39;010&#39;, &#39;110&#39;, &#39;111&#39;, &#39;101&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sage.graphs.traversals.lex_DFS">
<code class="sig-prename descclassname">sage.graphs.traversals.</code><code class="sig-name descname">lex_DFS</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">reverse</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">tree</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">initial_vertex</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_DFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a lexicographic depth first search (LexDFS) on the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</p></li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm maintains for each vertex left in the graph a code
corresponding to the vertices already removed. The vertex of maximal
code (according to the lexicographic order) is then removed, and the
codes are updated. Lex DFS differs from Lex BFS only in the way codes are
updated after each iteration.</p>
<p>Time complexity is <span class="math notranslate nohighlight">\(O(n+m)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is
the number of edges.</p>
<p>See <a class="reference internal" href="../../../references/index.html#ck2008" id="id6"><span>[CK2008]</span></a> for more details on the algorithm.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_BFS" title="sage.graphs.generic_graph.GenericGraph.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a> – perform a
lexicographic breadth first search (LexBFS) on the graph</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_UP" title="sage.graphs.generic_graph.GenericGraph.lex_UP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_UP()</span></code></a> – perform a
lexicographic UP search (LexUP) on the graph</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DOWN" title="sage.graphs.generic_graph.GenericGraph.lex_DOWN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a> – perform a
lexicographic DOWN search (LexDOWN) on the graph</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A Lex DFS is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">())</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lex DFS ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 6, 4]</span>
</pre></div>
</div>
<p>The method also works for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
</pre></div>
</div>
<p>Different orderings for different traversals:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;011&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;, &#39;011&#39;, &#39;100&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;011&#39;, &#39;010&#39;, &#39;110&#39;, &#39;111&#39;, &#39;101&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sage.graphs.traversals.lex_DOWN">
<code class="sig-prename descclassname">sage.graphs.traversals.</code><code class="sig-name descname">lex_DOWN</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">reverse</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">tree</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">initial_vertex</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_DOWN" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a lexicographic DOWN search (LexDOWN) on the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</p></li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm maintains for each vertex left in the graph a code
corresponding to the vertices already removed. The vertex of maximal
code (according to the lexicographic order) is then removed, and the
codes are updated. During the <span class="math notranslate nohighlight">\(i\)</span>-th iteration of the algorithm <span class="math notranslate nohighlight">\(n-i\)</span> is
prepended to the codes of all neighbors of the selected vertex that are left
in the graph.</p>
<p>Time complexity is <span class="math notranslate nohighlight">\(O(n+m)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is
the number of edges.</p>
<p>See <a class="reference internal" href="../../../references/index.html#mil2017" id="id7"><span>[Mil2017]</span></a> for more details on the algorithm.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_BFS" title="sage.graphs.generic_graph.GenericGraph.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a> – perform a
lexicographic breadth first search (LexBFS) on the graph</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DFS" title="sage.graphs.generic_graph.GenericGraph.lex_DFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a> – perform a
lexicographic depth first search (LexDFS) on the graph</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_UP" title="sage.graphs.generic_graph.GenericGraph.lex_UP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_UP()</span></code></a> – perform a
lexicographic UP search (LexUP) on the graph</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A Lex DOWN is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">())</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lex DOWN ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 5]</span>
</pre></div>
</div>
<p>The method also works for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
</pre></div>
</div>
<p>Different orderings for different traversals:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;011&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;, &#39;011&#39;, &#39;100&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;011&#39;, &#39;010&#39;, &#39;110&#39;, &#39;111&#39;, &#39;101&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sage.graphs.traversals.lex_M">
<code class="sig-prename descclassname">sage.graphs.traversals.</code><code class="sig-name descname">lex_M</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">triangulation</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">labels</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">initial_vertex</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">algorithm</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_M" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ordering of the vertices according the LexM graph traversal.</p>
<p>LexM is a lexicographic ordering scheme that is a special type of
breadth-first-search. LexM can also produce a triangulation of the
given graph. This functionality is implemented in this method. For
more details on the algorithms used see Sections 4 (<code class="docutils literal notranslate"><span class="pre">'lex_M_slow'</span></code>)
and 5.3 (<code class="docutils literal notranslate"><span class="pre">'lex_M_fast'</span></code>) of <a class="reference internal" href="../../../references/index.html#rtl76" id="id8"><span>[RTL76]</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method works only for undirected graphs.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">triangulation</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
list of edges that need to be added in order to triangulate the graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the labels
assigned to each vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'lex_M_slow'</span></code>: slower implementation of LexM traversal</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'lex_M_fast'</span></code>: faster implementation of LexM traversal (works only
when <code class="docutils literal notranslate"><span class="pre">labels</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: Sage chooses the best algorithm: <code class="docutils literal notranslate"><span class="pre">'lex_M_slow'</span></code> if
<code class="docutils literal notranslate"><span class="pre">labels</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">'lex_M_fast'</span></code> otherwise.</p></li>
</ul>
</li>
</ul>
<p>OUTPUT:</p>
<p>Depending on the values of the parameters <code class="docutils literal notranslate"><span class="pre">triangulation</span></code> and <code class="docutils literal notranslate"><span class="pre">labels</span></code>
the method will return one or more of the following (in that order):</p>
<ul class="simple">
<li><p>an ordering of vertices of the graph according to LexM ordering scheme</p></li>
<li><p>the labels assigned to each vertex</p></li>
<li><p>a list of edges that when added to the graph will triangulate it</p></li>
</ul>
<p>EXAMPLES:</p>
<p>LexM produces an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">ord</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lex_M_fast&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">ord</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lex_M_slow&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Both algorithms produce a valid LexM ordering <span class="math notranslate nohighlight">\(\alpha\)</span> (i.e the neighbors of
<span class="math notranslate nohighlight">\(\alpha(i)\)</span> in <span class="math notranslate nohighlight">\(G[\{\alpha(i), ..., \alpha(n)\}]\)</span> induce a clique):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">is_valid_lex_M_order</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">ord</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">triangulation</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lex_M_slow&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_valid_lex_M_order</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="nb">ord</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">ord</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">triangulation</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lex_M_fast&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_valid_lex_M_order</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="nb">ord</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>LexM produces a triangulation of given graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">triangulation</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s1">&#39;list_of_edges&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_chordal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>LexM ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_M</span><span class="p">()</span>
<span class="go">[6, 4, 5, 3, 2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sage.graphs.traversals.lex_M_fast">
<code class="sig-prename descclassname">sage.graphs.traversals.</code><code class="sig-name descname">lex_M_fast</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">triangulation</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">initial_vertex</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_M_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ordering of the vertices according the LexM graph traversal.</p>
<p>LexM is a lexicographic ordering scheme that is a special type of
breadth-first-search. This function implements the algorithm described in
Section 5.3 of <a class="reference internal" href="../../../references/index.html#rtl76" id="id9"><span>[RTL76]</span></a>.</p>
<p>Note that instead of using labels <span class="math notranslate nohighlight">\(1, 2, \ldots, k\)</span> and adding <span class="math notranslate nohighlight">\(1/2\)</span>, we
use labels <span class="math notranslate nohighlight">\(2, 4, \ldots, k\)</span> and add <span class="math notranslate nohighlight">\(1\)</span>, thus avoiding to use floats or
rationals.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method works only for undirected graphs.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">triangulation</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
triangulation of given graph produced by the method</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to consider</p></li>
</ul>
<p>OUTPUT:</p>
<p>This method will return an ordering of the vertices of <code class="docutils literal notranslate"><span class="pre">G</span></code> according to
the LexM ordering scheme. Furthermore, if <code class="docutils literal notranslate"><span class="pre">triangulation</span></code> is set to
<code class="docutils literal notranslate"><span class="pre">True</span></code> the method also returns a list of edges <code class="docutils literal notranslate"><span class="pre">F</span></code> such that when added
to <code class="docutils literal notranslate"><span class="pre">G</span></code> the resulting graph is a triangulation of <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p>
<p>EXAMPLES:</p>
<p>A LexM ordering is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_fast</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">lex_M_fast</span><span class="p">(</span><span class="n">g</span><span class="p">))</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>LexM ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_fast</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">lex_M_fast</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">[6, 4, 5, 3, 2, 1]</span>
</pre></div>
</div>
<p>LexM produces a triangulation of given graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_fast</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">lex_M_fast</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">triangulation</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_chordal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sage.graphs.traversals.lex_M_slow">
<code class="sig-prename descclassname">sage.graphs.traversals.</code><code class="sig-name descname">lex_M_slow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">triangulation</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">labels</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">initial_vertex</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_M_slow" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ordering of the vertices according the LexM graph traversal.</p>
<p>LexM is a lexicographic ordering scheme that is a special type of
breadth-first-search. This function implements the algorithm described in
Section 4 of <a class="reference internal" href="../../../references/index.html#rtl76" id="id10"><span>[RTL76]</span></a>.</p>
<p>During the search, the vertices are numbered from <span class="math notranslate nohighlight">\(n\)</span> to <span class="math notranslate nohighlight">\(1\)</span>. Let
<span class="math notranslate nohighlight">\(\alpha(i)\)</span> denote the vertex numbered <span class="math notranslate nohighlight">\(i\)</span> and let <span class="math notranslate nohighlight">\(\alpha^{-1}(u)\)</span> denote
the number assigned to <span class="math notranslate nohighlight">\(u\)</span>. Each vertex <span class="math notranslate nohighlight">\(u\)</span> has also a label, denoted by
<span class="math notranslate nohighlight">\(label(u)\)</span>, consisting of a list of numbers selected from <span class="math notranslate nohighlight">\([1,n]\)</span> and
ordered in decreasing order. Given two labels <span class="math notranslate nohighlight">\(L_1=[p_1, p_2,\ldots, p_k]\)</span>
and <span class="math notranslate nohighlight">\(L_1=[q_1, q_2,\ldots, q_l]\)</span>, we define <span class="math notranslate nohighlight">\(L_1&lt;L_2\)</span> if, for some <span class="math notranslate nohighlight">\(j\)</span>,
<span class="math notranslate nohighlight">\(p_i==q_i\)</span> for <span class="math notranslate nohighlight">\(i=1,\ldots,j-1\)</span> and <span class="math notranslate nohighlight">\(p_j&lt;q_j\)</span>, or if <span class="math notranslate nohighlight">\(p_i==q_i\)</span> for
<span class="math notranslate nohighlight">\(i=1,\ldots,k\)</span> and <span class="math notranslate nohighlight">\(k&lt;l\)</span>. Observe that this is exactly how Python compares
two lists.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method works only for undirected graphs.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">triangulation</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
triangulation of the graph produced by the method</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the labels
assigned to each vertex</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider. If not specified, an arbitrary vertex is chosen.</p></li>
</ul>
<p>OUTPUT:</p>
<p>Depending on the values of the parameters <code class="docutils literal notranslate"><span class="pre">triangulation</span></code> and <code class="docutils literal notranslate"><span class="pre">labels</span></code>
the method will return one or more of the following (in that order):</p>
<ul class="simple">
<li><p>the ordering of vertices of <span class="math notranslate nohighlight">\(G\)</span></p></li>
<li><p>the labels assigned to each vertex</p></li>
<li><p>a list of edges that when added to <span class="math notranslate nohighlight">\(G\)</span> will produce a triangulation of <span class="math notranslate nohighlight">\(G\)</span></p></li>
</ul>
<p>EXAMPLES:</p>
<p>A LexM ordering is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_slow</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">lex_M_slow</span><span class="p">(</span><span class="n">g</span><span class="p">))</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>LexM ordering and label assignments on the vertices of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_slow</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">lex_M_slow</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">([6, 4, 5, 3, 2, 1],</span>
<span class="go"> {1: [], 2: [5], 3: [5, 4], 4: [4, 2], 5: [4, 3], 6: [3, 2]})</span>
</pre></div>
</div>
<p>LexM produces a triangulation of given graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_slow</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">lex_M_slow</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">triangulation</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_chordal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sage.graphs.traversals.lex_UP">
<code class="sig-prename descclassname">sage.graphs.traversals.</code><code class="sig-name descname">lex_UP</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">reverse</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">tree</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">initial_vertex</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_UP" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a lexicographic UP search (LexUP) on the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</p></li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm maintains for each vertex left in the graph a code
corresponding to the vertices already removed. The vertex of maximal
code (according to the lexicographic order) is then removed, and the
codes are updated. During the <span class="math notranslate nohighlight">\(i\)</span>-th iteration of the algorithm <span class="math notranslate nohighlight">\(i\)</span> is
appended to the codes of all neighbors of the selected vertex that are left
in the graph.</p>
<p>Time complexity is <span class="math notranslate nohighlight">\(O(n+m)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is
the number of edges.</p>
<p>See <a class="reference internal" href="../../../references/index.html#mil2017" id="id11"><span>[Mil2017]</span></a> for more details on the algorithm.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<ul class="simple">
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_BFS" title="sage.graphs.generic_graph.GenericGraph.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a> – perform a
lexicographic breadth first search (LexBFS) on the graph</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DFS" title="sage.graphs.generic_graph.GenericGraph.lex_DFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a> – perform a
lexicographic depth first search (LexDFS) on the graph</p></li>
<li><p><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DOWN" title="sage.graphs.generic_graph.GenericGraph.lex_DOWN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a> – perform a
lexicographic DOWN search (LexDOWN) on the graph</p></li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A Lex UP is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">())</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lex UP ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">()</span>
<span class="go">[1, 2, 4, 5, 6, 3]</span>
</pre></div>
</div>
<p>The method also works for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
</pre></div>
</div>
<p>Different orderings for different traversals:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;011&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;, &#39;011&#39;, &#39;100&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;011&#39;, &#39;010&#39;, &#39;110&#39;, &#39;111&#39;, &#39;101&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sage.graphs.traversals.maximum_cardinality_search">
<code class="sig-prename descclassname">sage.graphs.traversals.</code><code class="sig-name descname">maximum_cardinality_search</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">reverse</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">tree</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">initial_vertex</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.maximum_cardinality_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ordering of the vertices according a maximum cardinality search.</p>
<p>Maximum cardinality search (MCS) is a graph traversal introduced in
<a class="reference internal" href="../../../references/index.html#ty1984" id="id12"><span>[TY1984]</span></a>. It starts by assigning an arbitrary vertex (or the specified
<code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code>) of <span class="math notranslate nohighlight">\(G\)</span> the last position in the ordering <span class="math notranslate nohighlight">\(\alpha\)</span>. Every
vertex keeps a weight equal to the number of its already processed neighbors
(i.e., already added to <span class="math notranslate nohighlight">\(\alpha\)</span>), and a vertex of largest such number is
chosen at each step <span class="math notranslate nohighlight">\(i\)</span> to be placed in position <span class="math notranslate nohighlight">\(n - i\)</span> in <span class="math notranslate nohighlight">\(\alpha\)</span>. This
ordering can be computed in time <span class="math notranslate nohighlight">\(O(n + m)\)</span>.</p>
<p>When the graph is chordal, the ordering returned by MCS is a <em>perfect
elimination ordering</em>, like <a class="reference internal" href="#sage.graphs.traversals.lex_BFS" title="sage.graphs.traversals.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a>. So
this ordering can be used to recognize chordal graphs. See <a class="reference internal" href="../../../references/index.html#he2006" id="id13"><span>[He2006]</span></a> for
more details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The current implementation is for connected graphs only.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Sage Graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to also return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to consider</p></li>
</ul>
<p>OUTPUT:</p>
<p>By default, return the ordering <span class="math notranslate nohighlight">\(\alpha\)</span> as a list. When <code class="docutils literal notranslate"><span class="pre">tree</span></code> is
<code class="docutils literal notranslate"><span class="pre">True</span></code>, the method returns a tuple <span class="math notranslate nohighlight">\((\alpha, T)\)</span>, where <span class="math notranslate nohighlight">\(T\)</span> is a directed
tree with the same set of vertices as <span class="math notranslate nohighlight">\(G\)</span> to <span class="math notranslate nohighlight">\(v\)</span>
if <span class="math notranslate nohighlight">\(u\)</span> was the first vertex to saw <span class="math notranslate nohighlight">\(v\)</span>.</p>
<p>EXAMPLES:</p>
<p>When specified, the <code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> is placed at the end of the ordering,
unless parameter <code class="docutils literal notranslate"><span class="pre">reverse</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, in which case it is placed at the
beginning:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[3, 2, 1, 0]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[0, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[0, 1, 3, 2]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[3, 2, 1, 0]</span>
</pre></div>
</div>
<p>Returning the discovery tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">tree</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">initial_vertex</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">order</span><span class="p">(),</span> <span class="n">T</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">(4, 3)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[(1, 0), (2, 1), (3, 2)]</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search</span><span class="p">(</span><span class="n">tree</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">initial_vertex</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[(0, 1), (1, 2), (2, 3)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sage.graphs.traversals.maximum_cardinality_search_M">
<code class="sig-prename descclassname">sage.graphs.traversals.</code><code class="sig-name descname">maximum_cardinality_search_M</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em>, <em class="sig-param"><span class="n">initial_vertex</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.maximum_cardinality_search_M" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ordering and the edges of the triangulation produced by MCS-M.</p>
<p>Maximum cardinality search M (MCS-M) is an extension of MCS
(<a class="reference internal" href="#sage.graphs.traversals.maximum_cardinality_search" title="sage.graphs.traversals.maximum_cardinality_search"><code class="xref py py-meth docutils literal notranslate"><span class="pre">maximum_cardinality_search()</span></code></a>) in the same way
that Lex-M (<a class="reference internal" href="#sage.graphs.traversals.lex_M" title="sage.graphs.traversals.lex_M"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_M()</span></code></a>) is an extension of
Lex-BFS (<a class="reference internal" href="#sage.graphs.traversals.lex_BFS" title="sage.graphs.traversals.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a>). That is, in MCS-M when
<span class="math notranslate nohighlight">\(u\)</span> receives number <span class="math notranslate nohighlight">\(i\)</span> at step <span class="math notranslate nohighlight">\(n - i + 1\)</span>, it increments the weight of all
unnumbered vertices <span class="math notranslate nohighlight">\(v\)</span> for which there exists a path between <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span>
consisting only of unnumbered vertices with weight strictly less than
<span class="math notranslate nohighlight">\(w^-(u)\)</span> and <span class="math notranslate nohighlight">\(w^-(v)\)</span>, where <span class="math notranslate nohighlight">\(w^-\)</span> is the number of times a vertex has been
reached during previous iterations. See <a class="reference internal" href="../../../references/index.html#bbhp2004" id="id14"><span>[BBHP2004]</span></a> for the details of this
<span class="math notranslate nohighlight">\(O(nm)\)</span> time algorithm.</p>
<p>If <span class="math notranslate nohighlight">\(G\)</span> is not connected, the orderings of each of its connected components
are added consecutively. Furthermore, if <span class="math notranslate nohighlight">\(G\)</span> has <span class="math notranslate nohighlight">\(k\)</span> connected components
<span class="math notranslate nohighlight">\(C_i\)</span> for <span class="math notranslate nohighlight">\(0 \leq i &lt; k\)</span>, <span class="math notranslate nohighlight">\(X\)</span> contains at least one vertex of <span class="math notranslate nohighlight">\(C_i\)</span> for each
<span class="math notranslate nohighlight">\(i \geq 1\)</span>. Hence, <span class="math notranslate nohighlight">\(|X| \geq k - 1\)</span>. In particular, some isolated vertices
(i.e., of degree 0) can appear in <span class="math notranslate nohighlight">\(X\)</span> as for such a vertex <span class="math notranslate nohighlight">\(x\)</span>, we have that
<span class="math notranslate nohighlight">\(G \setminus N(x) = G\)</span> is not connected.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Sage graph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to consider</p></li>
</ul>
<p>OUTPUT: a tuple <span class="math notranslate nohighlight">\((\alpha, F, X)\)</span>, where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\alpha\)</span> is the resulting ordering of the vertices. If an initial vertex
is specified, it gets the last position in the ordering <span class="math notranslate nohighlight">\(\alpha\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(F\)</span> is the list of edges of a minimal triangulation of <span class="math notranslate nohighlight">\(G\)</span> according
<span class="math notranslate nohighlight">\(\alpha\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(X\)</span> is a list of vertices such that for each <span class="math notranslate nohighlight">\(x \in X\)</span>, the
neighborhood of <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(G\)</span> is a separator (i.e., <span class="math notranslate nohighlight">\(G \setminus N(x)\)</span> is not
connected). Note that we may have <span class="math notranslate nohighlight">\(N(x) = \emptyset\)</span> if <span class="math notranslate nohighlight">\(G\)</span> is not
connected and <span class="math notranslate nohighlight">\(x\)</span> has degree 0.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Chordal graphs have a perfect elimination ordering, and so the set <span class="math notranslate nohighlight">\(F\)</span> of
edges of the triangulation is empty:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomChordalGraph</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">alpha</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">();</span> <span class="n">F</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>The cycle of order 4 is not chordal and so the triangulation has one edge:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">alpha</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">();</span> <span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The number of edges needed to triangulate of a cycle graph or order <span class="math notranslate nohighlight">\(n\)</span> is
<span class="math notranslate nohighlight">\(n - 3\)</span>, independently of the initial vertex:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">3</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">random_vertex</span><span class="p">())</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">3</span>
<span class="go">True</span>
</pre></div>
</div>
<p>When an initial vertex is specified, it gets the last position in the
ordering:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">([3, 2, 1, 0], [], [2, 3])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">([3, 2, 0, 1], [], [2, 3])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">([0, 1, 3, 2], [], [0, 1])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">([0, 1, 2, 3], [], [0, 1])</span>
</pre></div>
</div>
<p>When <span class="math notranslate nohighlight">\(G\)</span> is not connected, the orderings of each of its connected components
are added consecutively, the vertices of the component containing the
initial vertex occupying the last positions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CycleGraph</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[5, 4, 6, 7, 2, 3, 1, 0]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">7</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[2, 1, 3, 0, 5, 6, 4, 7]</span>
</pre></div>
</div>
<p>Furthermore, if <span class="math notranslate nohighlight">\(G\)</span> has <span class="math notranslate nohighlight">\(k\)</span> connected components, <span class="math notranslate nohighlight">\(X\)</span> contains at least one
vertex per connected component, except for the first one, and so at least <span class="math notranslate nohighlight">\(k
- 1\)</span> vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;something goes wrong&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">RandomGNP</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cc</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">connected_components</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">X</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In the example of <a class="reference internal" href="../../../references/index.html#bps2010" id="id15"><span>[BPS2010]</span></a>, the triangulation has 3 edges:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">maximum_cardinality_search_M</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Graph traversals.</a><ul>
<li><a class="reference internal" href="#methods">Methods</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="planarity.html"
                        title="previous chapter">Wrapper for Boyer’s (C) planarity algorithm</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="graph_plot.html"
                        title="next chapter">Graph Plotting</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/graphs/traversals.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="graph_plot.html" title="Graph Plotting"
             >next</a> |</li>
        <li class="right" >
          <a href="planarity.html" title="Wrapper for Boyer’s (C) planarity algorithm"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.3 Reference Manual: Graph Theory</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Graph traversals.</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2021, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>