
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Graph traversals. &#8212; Sage Reference Manual v8.9: Graph Theory</title>
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script async="async" type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Graph Plotting" href="graph_plot.html" />
    <link rel="prev" title="Wrapper for Boyer’s (C) planarity algorithm." href="planarity.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="graph_plot.html" title="Graph Plotting"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="planarity.html" title="Wrapper for Boyer’s (C) planarity algorithm."
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Graph Theory</a> &#187;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="graph-traversals">
<span id="sage-graphs-traversals"></span><h1>Graph traversals.<a class="headerlink" href="#graph-traversals" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.graphs.traversals"></span><p><strong>This module implements the following graph traversals</strong></p>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.traversals.lex_BFS" title="sage.graphs.traversals.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a></td>
<td>Perform a lexicographic breadth first search (LexBFS) on the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.traversals.lex_DFS" title="sage.graphs.traversals.lex_DFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a></td>
<td>Perform a lexicographic depth first search (LexDFS) on the graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.traversals.lex_UP" title="sage.graphs.traversals.lex_UP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_UP()</span></code></a></td>
<td>Perform a lexicographic UP search (LexUP) on the graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.traversals.lex_DOWN" title="sage.graphs.traversals.lex_DOWN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a></td>
<td>Perform a lexicographic DOWN search (LexDOWN) on the graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.traversals.lex_M" title="sage.graphs.traversals.lex_M"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_M()</span></code></a></td>
<td>Return an ordering of the vertices according the LexM graph traversal.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.graphs.traversals.lex_M_slow" title="sage.graphs.traversals.lex_M_slow"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_M_slow()</span></code></a></td>
<td>Return an ordering of the vertices according the LexM graph traversal.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.graphs.traversals.lex_M_fast" title="sage.graphs.traversals.lex_M_fast"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_M_fast()</span></code></a></td>
<td>Return an ordering of the vertices according the LexM graph traversal.</td>
</tr>
</tbody>
</table>
<div class="section" id="methods">
<h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="sage.graphs.traversals.is_valid_lex_M_order">
<code class="descclassname">sage.graphs.traversals.</code><code class="descname">is_valid_lex_M_order</code><span class="sig-paren">(</span><em>G</em>, <em>alpha</em>, <em>F</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.is_valid_lex_M_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the ordering alpha and the triangulation F are valid for G.</p>
<p>Given the graph <span class="math notranslate nohighlight">\(G = (V, E)\)</span> with vertex set <span class="math notranslate nohighlight">\(V\)</span> and edge set <span class="math notranslate nohighlight">\(E\)</span>, and the
set <span class="math notranslate nohighlight">\(F\)</span> of edges of a triangulation of <span class="math notranslate nohighlight">\(G\)</span>, let <span class="math notranslate nohighlight">\(H = (V, E\cup F)\)</span>.
By induction one can see that for every <span class="math notranslate nohighlight">\(i \in \{1, ..., n - 1\}\)</span> the
neighbors of <span class="math notranslate nohighlight">\(\alpha(i)\)</span> in <span class="math notranslate nohighlight">\(H[\{\alpha(i), ..., \alpha(n)\}]\)</span> induce a
clique. The ordering <span class="math notranslate nohighlight">\(\alpha\)</span> is a perfect elimination ordering of <span class="math notranslate nohighlight">\(H\)</span>, so
<span class="math notranslate nohighlight">\(H\)</span> is chordal. See <a class="reference internal" href="../../../references/index.html#rtl76" id="id1">[RTL76]</a> for more details.</p>
<p>INPUTS:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">G</span></code> – a Graph</li>
<li><code class="docutils literal notranslate"><span class="pre">alpha</span></code> – list; an ordering of the vertices of <span class="math notranslate nohighlight">\(G\)</span></li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code> – an iterable of edges given either as <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v)</span></code> or <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v,</span>
<span class="pre">label)</span></code>, the edges of the triangulation of <span class="math notranslate nohighlight">\(G\)</span></li>
</ul>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.traversals.lex_BFS">
<code class="descclassname">sage.graphs.traversals.</code><code class="descname">lex_BFS</code><span class="sig-paren">(</span><em>G</em>, <em>reverse=False</em>, <em>tree=False</em>, <em>initial_vertex=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_BFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a lexicographic breadth first search (LexBFS) on the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage graph</li>
<li><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</li>
<li><code class="docutils literal notranslate"><span class="pre">tree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</li>
<li><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm maintains for each vertex left in the graph a code
corresponding to the vertices already removed. The vertex of maximal
code (according to the lexicographic order) is then removed, and the
codes are updated.</p>
<p>Time complexity is <span class="math notranslate nohighlight">\(O(n+m)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is
the number of edges.</p>
<p>See <a class="reference internal" href="../../../references/index.html#ck2008" id="id2">[CK2008]</a> for more details on the algorithm.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Lexicographic_breadth-first_search">Wikipedia article Lexicographic_breadth-first_search</a></li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DFS" title="sage.graphs.generic_graph.GenericGraph.lex_DFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a> – perform a
lexicographic depth first search (LexDFS) on the graph</li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_UP" title="sage.graphs.generic_graph.GenericGraph.lex_UP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_UP()</span></code></a> – perform a
lexicographic UP search (LexUP) on the graph</li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DOWN" title="sage.graphs.generic_graph.GenericGraph.lex_DOWN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a> – perform a
lexicographic DOWN search (LexDOWN) on the graph</li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A Lex BFS is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">())</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lex BFS ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 4, 6]</span>
</pre></div>
</div>
<p>The method also works for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
</pre></div>
</div>
<p>For a Chordal Graph, a reversed Lex BFS is a Perfect Elimination Order:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PathGraph</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">lexicographic_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># py2</span>
<span class="go">[(2, 0), (2, 1), (1, 1), (1, 0), (0, 0), (0, 1)]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># py3</span>
<span class="go">[(2, 1), (2, 0), (1, 1), (1, 0), (0, 1), (0, 0)]</span>
</pre></div>
</div>
<p>And the vertices at the end of the tree of discovery are, for chordal
graphs, simplicial vertices (their neighborhood is a complete graph):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">ClawGraph</span><span class="p">()</span><span class="o">.</span><span class="n">lexicographic_product</span><span class="p">(</span><span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">peo</span><span class="p">,</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span> <span class="o">=</span> <span class="n">v</span><span class="p">,</span>  <span class="n">tree</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">leaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tree</span> <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">in_degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">.</span><span class="n">is_clique</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Different orderings for different traversals:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;011&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;, &#39;011&#39;, &#39;100&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;011&#39;, &#39;010&#39;, &#39;110&#39;, &#39;111&#39;, &#39;101&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.traversals.lex_DFS">
<code class="descclassname">sage.graphs.traversals.</code><code class="descname">lex_DFS</code><span class="sig-paren">(</span><em>G</em>, <em>reverse=False</em>, <em>tree=False</em>, <em>initial_vertex=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_DFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a lexicographic depth first search (LexDFS) on the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage graph</li>
<li><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</li>
<li><code class="docutils literal notranslate"><span class="pre">tree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</li>
<li><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm maintains for each vertex left in the graph a code
corresponding to the vertices already removed. The vertex of maximal
code (according to the lexicographic order) is then removed, and the
codes are updated. Lex DFS differs from Lex BFS only in the way codes are
updated after each iteration.</p>
<p>Time complexity is <span class="math notranslate nohighlight">\(O(n+m)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is
the number of edges.</p>
<p>See <a class="reference internal" href="../../../references/index.html#ck2008" id="id3">[CK2008]</a> for more details on the algorithm.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_BFS" title="sage.graphs.generic_graph.GenericGraph.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a> – perform a
lexicographic breadth first search (LexBFS) on the graph</li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_UP" title="sage.graphs.generic_graph.GenericGraph.lex_UP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_UP()</span></code></a> – perform a
lexicographic UP search (LexUP) on the graph</li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DOWN" title="sage.graphs.generic_graph.GenericGraph.lex_DOWN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a> – perform a
lexicographic DOWN search (LexDOWN) on the graph</li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A Lex DFS is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">())</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lex DFS ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">()</span>
<span class="go">[1, 2, 3, 5, 6, 4]</span>
</pre></div>
</div>
<p>The method also works for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
</pre></div>
</div>
<p>Different orderings for different traversals:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;011&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;, &#39;011&#39;, &#39;100&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;011&#39;, &#39;010&#39;, &#39;110&#39;, &#39;111&#39;, &#39;101&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.traversals.lex_DOWN">
<code class="descclassname">sage.graphs.traversals.</code><code class="descname">lex_DOWN</code><span class="sig-paren">(</span><em>G</em>, <em>reverse=False</em>, <em>tree=False</em>, <em>initial_vertex=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_DOWN" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a lexicographic DOWN search (LexDOWN) on the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage graph</li>
<li><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</li>
<li><code class="docutils literal notranslate"><span class="pre">tree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</li>
<li><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm maintains for each vertex left in the graph a code
corresponding to the vertices already removed. The vertex of maximal
code (according to the lexicographic order) is then removed, and the
codes are updated. During the <span class="math notranslate nohighlight">\(i\)</span>-th iteration of the algorithm <span class="math notranslate nohighlight">\(n-i\)</span> is
prepended to the codes of all neighbors of the selected vertex that are left
in the graph.</p>
<p>Time complexity is <span class="math notranslate nohighlight">\(O(n+m)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is
the number of edges.</p>
<p>See <a class="reference internal" href="../../../references/index.html#mil2017" id="id4">[Mil2017]</a> for more details on the algorithm.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_BFS" title="sage.graphs.generic_graph.GenericGraph.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a> – perform a
lexicographic breadth first search (LexBFS) on the graph</li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DFS" title="sage.graphs.generic_graph.GenericGraph.lex_DFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a> – perform a
lexicographic depth first search (LexDFS) on the graph</li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_UP" title="sage.graphs.generic_graph.GenericGraph.lex_UP"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_UP()</span></code></a> – perform a
lexicographic UP search (LexUP) on the graph</li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A Lex DOWN is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">())</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lex DOWN ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 6, 5]</span>
</pre></div>
</div>
<p>The method also works for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
</pre></div>
</div>
<p>Different orderings for different traversals:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;011&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;, &#39;011&#39;, &#39;100&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;011&#39;, &#39;010&#39;, &#39;110&#39;, &#39;111&#39;, &#39;101&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.traversals.lex_M">
<code class="descclassname">sage.graphs.traversals.</code><code class="descname">lex_M</code><span class="sig-paren">(</span><em>self</em>, <em>triangulation=False</em>, <em>labels=False</em>, <em>initial_vertex=None</em>, <em>algorithm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_M" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ordering of the vertices according the LexM graph traversal.</p>
<p>LexM is a lexicographic ordering scheme that is a special type of
breadth-first-search. LexM can also produce a triangulation of the
given graph. This functionality is implemented in this method. For
more details on the algorithms used see Sections 4 (<code class="docutils literal notranslate"><span class="pre">'lex_M_slow'</span></code>)
and 5.3 (<code class="docutils literal notranslate"><span class="pre">'lex_M_fast'</span></code>) of <a class="reference internal" href="../../../references/index.html#rtl76" id="id5">[RTL76]</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method works only for undirected graphs.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">triangulation</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return a
list of edges that need to be added in order to triangulate the graph</li>
<li><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the labels
assigned to each vertex</li>
<li><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</li>
<li><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); one of the following
algorithms:<ul>
<li><code class="docutils literal notranslate"><span class="pre">'lex_M_slow'</span></code>: slower implementation of LexM traversal</li>
<li><code class="docutils literal notranslate"><span class="pre">'lex_M_fast'</span></code>: faster implementation of LexM traversal (works only
when <code class="docutils literal notranslate"><span class="pre">labels</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">None</span></code>: Sage chooses the best algorithm: <code class="docutils literal notranslate"><span class="pre">'lex_M_slow'</span></code> if
<code class="docutils literal notranslate"><span class="pre">labels</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">'lex_M_fast'</span></code> otherwise.</li>
</ul>
</li>
</ul>
<p>OUTPUT:</p>
<p>Depending on the values of the parameters <code class="docutils literal notranslate"><span class="pre">triangulation</span></code> and <code class="docutils literal notranslate"><span class="pre">labels</span></code>
the method will return one or more of the following (in that order):</p>
<ul class="simple">
<li>an ordering of vertices of the graph according to LexM ordering scheme</li>
<li>the labels assigned to each vertex</li>
<li>a list of edges that when added to the graph will triangulate it</li>
</ul>
<p>EXAMPLES:</p>
<p>LexM produces an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">ord</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lex_M_fast&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">ord</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lex_M_slow&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="nb">ord</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Both algorithms produce a valid LexM ordering <span class="math notranslate nohighlight">\(\alpha\)</span> (i.e the neighbors of
<span class="math notranslate nohighlight">\(\alpha(i)\)</span> in <span class="math notranslate nohighlight">\(G[\{\alpha(i), ..., \alpha(n)\}]\)</span> induce a clique):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">is_valid_lex_M_order</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">ord</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">triangulation</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lex_M_slow&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_valid_lex_M_order</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="nb">ord</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">ord</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">triangulation</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lex_M_fast&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">is_valid_lex_M_order</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="nb">ord</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>LexM produces a triangulation of given graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">lex_M</span><span class="p">(</span><span class="n">triangulation</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s1">&#39;list_of_edges&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_chordal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>LexM ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_M</span><span class="p">()</span>
<span class="go">[6, 4, 5, 3, 2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.traversals.lex_M_fast">
<code class="descclassname">sage.graphs.traversals.</code><code class="descname">lex_M_fast</code><span class="sig-paren">(</span><em>G</em>, <em>triangulation=False</em>, <em>initial_vertex=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_M_fast" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ordering of the vertices according the LexM graph traversal.</p>
<p>LexM is a lexicographic ordering scheme that is a special type of
breadth-first-search. This function implements the algorithm described in
Section 5.3 of <a class="reference internal" href="../../../references/index.html#rtl76" id="id6">[RTL76]</a>.</p>
<p>Note that instead of using labels <span class="math notranslate nohighlight">\(1, 2, \ldots, k\)</span> and adding <span class="math notranslate nohighlight">\(1/2\)</span>, we
use labels <span class="math notranslate nohighlight">\(2, 4, \ldots, k\)</span> and add <span class="math notranslate nohighlight">\(1\)</span>, thus avoiding to use floats or
rationals.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method works only for undirected graphs.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage graph</li>
<li><code class="docutils literal notranslate"><span class="pre">triangulation</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
triangulation of given graph produced by the method</li>
<li><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to consider</li>
</ul>
<p>OUTPUT:</p>
<p>This method will return an ordering of the vertices of <code class="docutils literal notranslate"><span class="pre">G</span></code> according to
the LexM ordering scheme. Furthermore, if <code class="docutils literal notranslate"><span class="pre">triangulation</span></code> is set to
<code class="docutils literal notranslate"><span class="pre">True</span></code> the method also returns a list of edges <code class="docutils literal notranslate"><span class="pre">F</span></code> such that when added
to <code class="docutils literal notranslate"><span class="pre">G</span></code> the resulting graph is a triangulation of <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p>
<p>EXAMPLES:</p>
<p>A LexM ordering is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_fast</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">lex_M_fast</span><span class="p">(</span><span class="n">g</span><span class="p">))</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>LexM ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_fast</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">lex_M_fast</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">[6, 4, 5, 3, 2, 1]</span>
</pre></div>
</div>
<p>LexM produces a triangulation of given graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_fast</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">lex_M_fast</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">triangulation</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_chordal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.traversals.lex_M_slow">
<code class="descclassname">sage.graphs.traversals.</code><code class="descname">lex_M_slow</code><span class="sig-paren">(</span><em>G</em>, <em>triangulation=False</em>, <em>labels=False</em>, <em>initial_vertex=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_M_slow" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ordering of the vertices according the LexM graph traversal.</p>
<p>LexM is a lexicographic ordering scheme that is a special type of
breadth-first-search. This function implements the algorithm described in
Section 4 of <a class="reference internal" href="../../../references/index.html#rtl76" id="id7">[RTL76]</a>.</p>
<p>During the search, the vertices are numbered from <span class="math notranslate nohighlight">\(n\)</span> to <span class="math notranslate nohighlight">\(1\)</span>. Let
<span class="math notranslate nohighlight">\(\alpha(i)\)</span> denote the vertex numbered <span class="math notranslate nohighlight">\(i\)</span> and let <span class="math notranslate nohighlight">\(\alpha^{-1}(u)\)</span> denote
the number assigned to <span class="math notranslate nohighlight">\(u\)</span>. Each vertex <span class="math notranslate nohighlight">\(u\)</span> has also a label, denoted by
<span class="math notranslate nohighlight">\(label(u)\)</span>, consisting of a list of numbers selected from <span class="math notranslate nohighlight">\([1,n]\)</span> and
ordered in decreasing order. Given two labels <span class="math notranslate nohighlight">\(L_1=[p_1, p_2,\ldots, p_k]\)</span>
and <span class="math notranslate nohighlight">\(L_1=[q_1, q_2,\ldots, q_l]\)</span>, we define <span class="math notranslate nohighlight">\(L_1&lt;L_2\)</span> if, for some <span class="math notranslate nohighlight">\(j\)</span>,
<span class="math notranslate nohighlight">\(p_i==q_i\)</span> for <span class="math notranslate nohighlight">\(i=1,\ldots,j-1\)</span> and <span class="math notranslate nohighlight">\(p_j&lt;q_j\)</span>, or if <span class="math notranslate nohighlight">\(p_i==q_i\)</span> for
<span class="math notranslate nohighlight">\(i=1,\ldots,k\)</span> and <span class="math notranslate nohighlight">\(k&lt;l\)</span>. Observe that this is exactly how Python compares
two lists.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method works only for undirected graphs.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage graph</li>
<li><code class="docutils literal notranslate"><span class="pre">triangulation</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
triangulation of the graph produced by the method</li>
<li><code class="docutils literal notranslate"><span class="pre">labels</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the labels
assigned to each vertex</li>
<li><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider. If not specified, an arbitrary vertex is chosen.</li>
</ul>
<p>OUTPUT:</p>
<p>Depending on the values of the parameters <code class="docutils literal notranslate"><span class="pre">triangulation</span></code> and <code class="docutils literal notranslate"><span class="pre">labels</span></code>
the method will return one or more of the following (in that order):</p>
<ul class="simple">
<li>the ordering of vertices of <span class="math notranslate nohighlight">\(G\)</span></li>
<li>the labels assigned to each vertex</li>
<li>a list of edges that when added to <span class="math notranslate nohighlight">\(G\)</span> will produce a triangulation of <span class="math notranslate nohighlight">\(G\)</span></li>
</ul>
<p>EXAMPLES:</p>
<p>A LexM ordering is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_slow</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">lex_M_slow</span><span class="p">(</span><span class="n">g</span><span class="p">))</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>LexM ordering and label assignments on the vertices of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_slow</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">lex_M_slow</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">([6, 4, 5, 3, 2, 1],</span>
<span class="go"> {1: [], 2: [5], 3: [5, 4], 4: [4, 2], 5: [4, 3], 6: [3, 2]})</span>
</pre></div>
</div>
<p>LexM produces a triangulation of given graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.graphs.traversals</span> <span class="kn">import</span> <span class="n">lex_M_slow</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">PetersenGraph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">_</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">lex_M_slow</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">triangulation</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">is_chordal</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.graphs.traversals.lex_UP">
<code class="descclassname">sage.graphs.traversals.</code><code class="descname">lex_UP</code><span class="sig-paren">(</span><em>G</em>, <em>reverse=False</em>, <em>tree=False</em>, <em>initial_vertex=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.graphs.traversals.lex_UP" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a lexicographic UP search (LexUP) on the graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">G</span></code> – a sage graph</li>
<li><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
vertices in discovery order, or the reverse</li>
<li><code class="docutils literal notranslate"><span class="pre">tree</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>); whether to return the
discovery directed tree (each vertex being linked to the one that saw
it for the first time)</li>
<li><code class="docutils literal notranslate"><span class="pre">initial_vertex</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>); the first vertex to
consider</li>
</ul>
<p>ALGORITHM:</p>
<p>This algorithm maintains for each vertex left in the graph a code
corresponding to the vertices already removed. The vertex of maximal
code (according to the lexicographic order) is then removed, and the
codes are updated. During the <span class="math notranslate nohighlight">\(i\)</span>-th iteration of the algorithm <span class="math notranslate nohighlight">\(i\)</span> is
appended to the codes of all neighbors of the selected vertex that are left
in the graph.</p>
<p>Time complexity is <span class="math notranslate nohighlight">\(O(n+m)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices and <span class="math notranslate nohighlight">\(m\)</span> is
the number of edges.</p>
<p>See <a class="reference internal" href="../../../references/index.html#mil2017" id="id8">[Mil2017]</a> for more details on the algorithm.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_BFS" title="sage.graphs.generic_graph.GenericGraph.lex_BFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_BFS()</span></code></a> – perform a
lexicographic breadth first search (LexBFS) on the graph</li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DFS" title="sage.graphs.generic_graph.GenericGraph.lex_DFS"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DFS()</span></code></a> – perform a
lexicographic depth first search (LexDFS) on the graph</li>
<li><a class="reference internal" href="generic_graph.html#sage.graphs.generic_graph.GenericGraph.lex_DOWN" title="sage.graphs.generic_graph.GenericGraph.lex_DOWN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lex_DOWN()</span></code></a> – perform a
lexicographic DOWN search (LexDOWN) on the graph</li>
</ul>
</div>
<p>EXAMPLES:</p>
<p>A Lex UP is obviously an ordering of the vertices:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">graphs</span><span class="o">.</span><span class="n">CompleteGraph</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">())</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Lex UP ordering of the 3-sun graph:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">()</span>
<span class="go">[1, 2, 4, 5, 6, 3]</span>
</pre></div>
</div>
<p>The method also works for directed graphs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2, 3, 1]</span>
</pre></div>
</div>
<p>Different orderings for different traversals:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">digraphs</span><span class="o">.</span><span class="n">DeBruijn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_BFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;011&#39;, &#39;110&#39;, &#39;101&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DFS</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;011&#39;, &#39;111&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_UP</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;, &#39;011&#39;, &#39;100&#39;]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">lex_DOWN</span><span class="p">(</span><span class="n">initial_vertex</span><span class="o">=</span><span class="s1">&#39;000&#39;</span><span class="p">)</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;100&#39;, &#39;011&#39;, &#39;010&#39;, &#39;110&#39;, &#39;111&#39;, &#39;101&#39;]</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Graph traversals.</a><ul>
<li><a class="reference internal" href="#methods">Methods</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="planarity.html"
                        title="previous chapter">Wrapper for Boyer’s (C) planarity algorithm.</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="graph_plot.html"
                        title="next chapter">Graph Plotting</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/graphs/traversals.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="graph_plot.html" title="Graph Plotting"
             >next</a> |</li>
        <li class="right" >
          <a href="planarity.html" title="Wrapper for Boyer’s (C) planarity algorithm."
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Graph Theory</a> &#187;</li>
 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2019, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>