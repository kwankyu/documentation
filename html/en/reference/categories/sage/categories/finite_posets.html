
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Finite posets &#8212; Sage Reference Manual v8.5: Category Framework</title>
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Finite semigroups" href="finite_semigroups.html" />
    <link rel="prev" title="Finite Permutation Groups" href="finite_permutation_groups.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="finite_semigroups.html" title="Finite semigroups"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="finite_permutation_groups.html" title="Finite Permutation Groups"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Category Framework</a> &#187;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="finite-posets">
<span id="sage-categories-finite-posets"></span><h1>Finite posets<a class="headerlink" href="#finite-posets" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.categories.finite_posets"></span><p>Here is some terminology used in this file:</p>
<ul class="simple">
<li>An <em>order filter</em> (or <em>upper set</em>) of a poset <span class="math notranslate nohighlight">\(P\)</span> is a subset <span class="math notranslate nohighlight">\(S\)</span> of <span class="math notranslate nohighlight">\(P\)</span>
such that if <span class="math notranslate nohighlight">\(x \leq y\)</span> and <span class="math notranslate nohighlight">\(x\in S\)</span> then <span class="math notranslate nohighlight">\(y\in S\)</span>.</li>
<li>An <em>order ideal</em> (or <em>lower set</em>) of a poset <span class="math notranslate nohighlight">\(P\)</span> is a subset <span class="math notranslate nohighlight">\(S\)</span> of <span class="math notranslate nohighlight">\(P\)</span>
such that if <span class="math notranslate nohighlight">\(x \leq y\)</span> and <span class="math notranslate nohighlight">\(y\in S\)</span> then <span class="math notranslate nohighlight">\(x\in S\)</span>.</li>
</ul>
<dl class="class">
<dt id="sage.categories.finite_posets.FinitePosets">
<em class="property">class </em><code class="descclassname">sage.categories.finite_posets.</code><code class="descname">FinitePosets</code><span class="sig-paren">(</span><em>base_category</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="category_with_axiom.html#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
<p>The category of finite posets i.e. finite sets with a partial
order structure.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FinitePosets</span><span class="p">()</span>
<span class="go">Category of finite posets</span>
<span class="gp">sage: </span><span class="n">FinitePosets</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of posets, Category of finite sets]</span>
<span class="gp">sage: </span><span class="n">FinitePosets</span><span class="p">()</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">NotImplemented</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="posets.html#sage.categories.posets.Posets" title="sage.categories.posets.Posets"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posets</span></code></a>, <a class="reference external" href="../../../combinat/sage/combinat/posets/posets.html#sage.combinat.posets.posets.Poset" title="(in Sage Reference Manual: Combinatorics v8.5)"><code class="xref py py-func docutils literal notranslate"><span class="pre">Poset()</span></code></a></p>
</div>
<dl class="class">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods">
<em class="property">class </em><code class="descname">ParentMethods</code><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.antichains">
<code class="descname">antichains</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.antichains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all antichains of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">antichains</span><span class="p">();</span> <span class="n">A</span>
<span class="go">Set of antichains of Finite lattice containing 5 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[[], [0], [1], [1, 2], [1, 3], [2], [3], [4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling">
<code class="descname">birational_free_labelling</code><span class="sig-paren">(</span><em>linear_extension=None</em>, <em>prefix='x'</em>, <em>base_field=None</em>, <em>reduced=False</em>, <em>addvars=None</em>, <em>labels=None</em>, <em>min_label=None</em>, <em>max_label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the birational free labelling of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Let us hold back defining this, and introduce birational
toggles and birational rowmotion first. These notions have
been introduced in <a class="reference internal" href="../../../references/index.html#ep2013" id="id1">[EP2013]</a> as generalizations of the notions
of toggles (<a class="reference internal" href="posets.html#sage.categories.posets.Posets.ParentMethods.order_ideal_toggle" title="sage.categories.posets.Posets.ParentMethods.order_ideal_toggle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_ideal_toggle()</span></code></a>) 
and <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rowmotion</span></code></a> on order ideals of a finite poset. They
have been studied further in <a class="reference internal" href="../../../references/index.html#gr2013" id="id2">[GR2013]</a>.</p>
<p>Let <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> be a field, and <span class="math notranslate nohighlight">\(P\)</span> be a finite poset. Let
<span class="math notranslate nohighlight">\(\widehat{P}\)</span> denote the poset obtained from <span class="math notranslate nohighlight">\(P\)</span> by adding a
new element <span class="math notranslate nohighlight">\(1\)</span> which is greater than all existing elements
of <span class="math notranslate nohighlight">\(P\)</span>, and a new element <span class="math notranslate nohighlight">\(0\)</span> which is smaller than all
existing elements of <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(1\)</span>. Now, a <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-<em>labelling
of</em> <span class="math notranslate nohighlight">\(P\)</span> will mean any function from <span class="math notranslate nohighlight">\(\widehat{P}\)</span> to <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>.
The image of an element <span class="math notranslate nohighlight">\(v\)</span> of <span class="math notranslate nohighlight">\(\widehat{P}\)</span> under this labelling
will be called the <em>label</em> of this labelling at <span class="math notranslate nohighlight">\(v\)</span>. The set
of all <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labellings of <span class="math notranslate nohighlight">\(P\)</span> is clearly
<span class="math notranslate nohighlight">\(\mathbf{K}^{\widehat{P}}\)</span>.</p>
<p>For any <span class="math notranslate nohighlight">\(v \in P\)</span>, we now define a rational map
<span class="math notranslate nohighlight">\(T_v : \mathbf{K}^{\widehat{P}} \dashrightarrow
\mathbf{K}^{\widehat{P}}\)</span> as follows: For every <span class="math notranslate nohighlight">\(f \in
\mathbf{K}^{\widehat{P}}\)</span>, the image <span class="math notranslate nohighlight">\(T_v f\)</span> should send every
element <span class="math notranslate nohighlight">\(u \in \widehat{P}\)</span> distinct from <span class="math notranslate nohighlight">\(v\)</span> to <span class="math notranslate nohighlight">\(f(u)\)</span> (so the
labels at all <span class="math notranslate nohighlight">\(u \neq v\)</span> don’t change), while <span class="math notranslate nohighlight">\(v\)</span> is sent to</p>
<div class="math notranslate nohighlight">
\[\frac{1}{f(v)} \cdot
\frac{\sum_{u \lessdot v} f(u)}
{\sum_{u \gtrdot v} \frac{1}{f(u)}}\]</div>
<p>(both sums are over all <span class="math notranslate nohighlight">\(u \in \widehat{P}\)</span> satisfying the
respectively given conditions). Here, <span class="math notranslate nohighlight">\(\lessdot\)</span> and <span class="math notranslate nohighlight">\(\gtrdot\)</span>
mean (respectively) “covered by” and “covers”, interpreted with
respect to the poset <span class="math notranslate nohighlight">\(\widehat{P}\)</span>. This rational map <span class="math notranslate nohighlight">\(T_v\)</span>
is an involution and is called the <em>(birational)</em> <span class="math notranslate nohighlight">\(v\)</span>-<em>toggle</em>; see
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_toggle()</span></code></a> for its implementation.</p>
<p>Now, <em>birational rowmotion</em> is defined as the composition
<span class="math notranslate nohighlight">\(T_{v_1} \circ T_{v_2} \circ \cdots \circ T_{v_n}\)</span>, where
<span class="math notranslate nohighlight">\((v_1, v_2, \ldots, v_n)\)</span> is a linear extension of <span class="math notranslate nohighlight">\(P\)</span>
(written as a linear ordering of the elements of <span class="math notranslate nohighlight">\(P\)</span>). This
is a rational map
<span class="math notranslate nohighlight">\(\mathbf{K}^{\widehat{P}} \dashrightarrow \mathbf{K}^{\widehat{P}}\)</span>
which does not depend on the choice of the linear extension;
it is denoted by <span class="math notranslate nohighlight">\(R\)</span>. See <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_rowmotion()</span></code></a> for
its implementation.</p>
<p>The definitions of birational toggles and birational
rowmotion extend to the case of <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> being any semifield
rather than necessarily a field (although it becomes less
clear what constitutes a rational map in this generality).
The most useful case is that of the <a class="reference external" href="../../../semirings/sage/rings/semirings/tropical_semiring.html#sage.rings.semirings.tropical_semiring.TropicalSemiring" title="(in Sage Reference Manual: Standard Semirings v8.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tropical</span> <span class="pre">semiring</span></code></a>,
in which case birational rowmotion relates to classical
constructions such as promotion of rectangular semistandard
Young tableaux (page 5 of <a class="reference internal" href="../../../references/index.html#ep2013b" id="id3">[EP2013b]</a> and future work, via the
related notion of birational <em>promotion</em>) and rowmotion on
order ideals of the poset (<a class="reference internal" href="../../../references/index.html#ep2013" id="id4">[EP2013]</a>).</p>
<p>The <em>birational free labelling</em> is a special labelling
defined for every finite poset <span class="math notranslate nohighlight">\(P\)</span> and every linear extension
<span class="math notranslate nohighlight">\((v_1, v_2, \ldots, v_n)\)</span> of <span class="math notranslate nohighlight">\(P\)</span>. It is given by sending
every element <span class="math notranslate nohighlight">\(v_i\)</span> in <span class="math notranslate nohighlight">\(P\)</span> to <span class="math notranslate nohighlight">\(x_i\)</span>, sending the element <span class="math notranslate nohighlight">\(0\)</span>
of <span class="math notranslate nohighlight">\(\widehat{P}\)</span> to <span class="math notranslate nohighlight">\(a\)</span>, and sending the element <span class="math notranslate nohighlight">\(1\)</span> of
<span class="math notranslate nohighlight">\(\widehat{P}\)</span> to <span class="math notranslate nohighlight">\(b\)</span>, where the ground field <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> is the
field of rational functions in <span class="math notranslate nohighlight">\(n+2\)</span> indeterminates
<span class="math notranslate nohighlight">\(a, x_1, x_2, \ldots, x_n, b\)</span> over <span class="math notranslate nohighlight">\(\mathbb Q\)</span>.</p>
<p>In Sage, a labelling <span class="math notranslate nohighlight">\(f\)</span> of a poset <span class="math notranslate nohighlight">\(P\)</span> is encoded as a
<span class="math notranslate nohighlight">\(4\)</span>-tuple <span class="math notranslate nohighlight">\((\mathbf{K}, d, u, v)\)</span>, where <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> is the
ground field of the labelling (i. e., its target), <span class="math notranslate nohighlight">\(d\)</span> is the
dictionary containing the values of <span class="math notranslate nohighlight">\(f\)</span> at the elements of
<span class="math notranslate nohighlight">\(P\)</span> (the keys being the respective elements of <span class="math notranslate nohighlight">\(P\)</span>), <span class="math notranslate nohighlight">\(u\)</span>
is the label of <span class="math notranslate nohighlight">\(f\)</span> at <span class="math notranslate nohighlight">\(0\)</span>, and <span class="math notranslate nohighlight">\(v\)</span> is the label of <span class="math notranslate nohighlight">\(f\)</span> at
<span class="math notranslate nohighlight">\(1\)</span>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The dictionary <span class="math notranslate nohighlight">\(d\)</span> is labelled by the elements of <span class="math notranslate nohighlight">\(P\)</span>.
If <span class="math notranslate nohighlight">\(P\)</span> is a poset with <code class="docutils literal notranslate"><span class="pre">facade</span></code> option set to
<code class="docutils literal notranslate"><span class="pre">False</span></code>, these might not be what they seem to be!
(For instance, if
<code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">==</span> <span class="pre">Poset({1:</span> <span class="pre">[2,</span> <span class="pre">3]},</span> <span class="pre">facade=False)</span></code>, then the
value of <span class="math notranslate nohighlight">\(d\)</span> at <span class="math notranslate nohighlight">\(1\)</span> has to be accessed by <code class="docutils literal notranslate"><span class="pre">d[P(1)]</span></code>, not
by <code class="docutils literal notranslate"><span class="pre">d[1]</span></code>.)</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Dictionaries are mutable. They do compare correctly,
but are not hashable and need to be cloned to avoid
spooky action at a distance. Be careful!</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">linear_extension</span></code> – (default: the default linear
extension of <code class="docutils literal notranslate"><span class="pre">self</span></code>) a linear extension of <code class="docutils literal notranslate"><span class="pre">self</span></code>
(as a linear extension or as a list), or more generally
a list of all elements of all elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> each
occurring exactly once</li>
<li><code class="docutils literal notranslate"><span class="pre">prefix</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'x'</span></code>) the prefix to name
the indeterminates corresponding to the elements of
<code class="docutils literal notranslate"><span class="pre">self</span></code> in the labelling (so, setting it to
<code class="docutils literal notranslate"><span class="pre">'frog'</span></code> will result in these indeterminates being
called <code class="docutils literal notranslate"><span class="pre">frog1,</span> <span class="pre">frog2,</span> <span class="pre">...,</span> <span class="pre">frogn</span></code> rather than
<code class="docutils literal notranslate"><span class="pre">x1,</span> <span class="pre">x2,</span> <span class="pre">...,</span> <span class="pre">xn</span></code>).</li>
<li><code class="docutils literal notranslate"><span class="pre">base_field</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">QQ</span></code>) the base field to
be used instead of <span class="math notranslate nohighlight">\(\QQ\)</span> to define the rational
function field over; this is not going to be the base
field of the labelling, because the latter will have
indeterminates adjoined!</li>
<li><code class="docutils literal notranslate"><span class="pre">reduced</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) if set to
<code class="docutils literal notranslate"><span class="pre">True</span></code>, the result will be the <em>reduced</em> birational
free labelling, which differs from the regular one by
having <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(1\)</span> both sent to <span class="math notranslate nohighlight">\(1\)</span> instead of <span class="math notranslate nohighlight">\(a\)</span> and
<span class="math notranslate nohighlight">\(b\)</span> (the indeterminates <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> then also won’t
appear in the ground field)</li>
<li><code class="docutils literal notranslate"><span class="pre">addvars</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">''</span></code>) a string containing
names of extra variables to be adjoined to the ground
field (these don’t have an effect on the labels)</li>
<li><code class="docutils literal notranslate"><span class="pre">labels</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'x'</span></code>) Either a function
that takes an element of the poset and returns a name
for the indeterminate corresponding to that element,
or a string containing a comma-separated list of
indeterminates that will be assigned to elements in
the order of <code class="docutils literal notranslate"><span class="pre">linear_extension</span></code>. If the
list contains more indeterminates than needed, the
excess will be ignored. If it contains too few, then
the needed indeterminates will be constructed from
<code class="docutils literal notranslate"><span class="pre">prefix</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">min_label</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'a'</span></code>) a string to be
used as the label for the element <span class="math notranslate nohighlight">\(0\)</span> of <span class="math notranslate nohighlight">\(\widehat{P}\)</span></li>
<li><code class="docutils literal notranslate"><span class="pre">max_label</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'b'</span></code>) a string to be
used as the label for the element <span class="math notranslate nohighlight">\(1\)</span> of <span class="math notranslate nohighlight">\(\widehat{P}\)</span></li>
</ul>
<p>OUTPUT:</p>
<p>The birational free labelling of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code> and the
linear extension <code class="docutils literal notranslate"><span class="pre">linear_extension</span></code>. Or, if <code class="docutils literal notranslate"><span class="pre">reduced</span></code>
is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the reduced birational free labelling.</p>
<p>EXAMPLES:</p>
<p>We construct the birational free labelling on a simple
poset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">();</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x2), (3, x3)]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x3), (3, x2)]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">reduced</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in x1, x2, x3, spam, eggs over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x3), (3, x2)]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;wut&quot;</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in wut1, wut2, wut3, spam, eggs over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, wut1), (2, wut3), (3, wut2)]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">reduced</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b, spam, eggs over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x3), (3, x2)]</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="go">x3</span>
</pre></div>
</div>
<p>Illustrating labelling with a function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span> <span class="p">:</span> <span class="s1">&#39;x_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[((0, 0), x_00), ((0, 1), x_01), ((1, 0), x_10), ((1, 1), x_11)]</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">a</span>
</pre></div>
</div>
<p>The same, but with <code class="docutils literal notranslate"><span class="pre">min_label</span></code> and <code class="docutils literal notranslate"><span class="pre">max_label</span></code> provided:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">posets</span><span class="o">.</span><span class="n">ChainPoset</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span> <span class="p">:</span> <span class="s1">&#39;x_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">min_label</span><span class="o">=</span><span class="s2">&quot;lambda&quot;</span><span class="p">,</span> <span class="n">max_label</span><span class="o">=</span><span class="s2">&quot;mu&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[((0, 0), x_00), ((0, 1), x_01), ((1, 0), x_10), ((1, 1), x_11)]</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">lambda</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">mu</span>
</pre></div>
</div>
<p>Illustrating labelling with a comma separated list of labels:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s1">&#39;w,x,y,z&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[((0, 0), w), ((0, 1), x), ((1, 0), y), ((1, 1), z)]</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s1">&#39;w,x,y,z,m&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[((0, 0), w), ((0, 1), x), ((1, 0), y), ((1, 1), z)]</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[((0, 0), w), ((0, 1), x1), ((1, 0), x2), ((1, 1), x3)]</span>
</pre></div>
</div>
<p>Illustrating the warning about facade:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">reduced</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b, spam, eggs over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">KeyError</span>: <span class="n">2</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">x3</span>
</pre></div>
</div>
<p>Another poset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SSTPoset</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">lext</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">lext</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;ohai&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, x5, x6, x7, x8, b, ohai over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[([[1, 1], [2]], x1), ([[1, 1], [3]], x2), ([[1, 2], [2]], x3), ([[1, 2], [3]], x4),</span>
<span class="go"> ([[1, 3], [2]], x5), ([[1, 3], [3]], x6), ([[2, 2], [3]], x7), ([[2, 3], [3]], x8)]</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_rowmotion()</span></code></a>, <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_toggle()</span></code></a> and
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_toggles()</span></code></a> for more substantial examples of what
one can do with the birational free labelling.</p>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion">
<code class="descname">birational_rowmotion</code><span class="sig-paren">(</span><em>labelling</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of applying birational rowmotion to the
<span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling <code class="docutils literal notranslate"><span class="pre">labelling</span></code> of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>See the documentation of <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_free_labelling()</span></code></a>
for a definition of birational rowmotion and
<span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labellings and for an explanation of how
<span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labellings are to be encoded to be understood
by Sage. This implementation allows <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> to be a
semifield, not just a field. Birational rowmotion is only a
rational map, so an exception (most likely, <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>)
will be thrown if the denominator is zero.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">labelling</span></code> – a <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the
sense as defined in the documentation of
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_free_labelling()</span></code></a></li>
</ul>
<p>OUTPUT:</p>
<p>The image of the <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling <span class="math notranslate nohighlight">\(f\)</span> under birational
rowmotion.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">lex</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">lex</span><span class="p">);</span> <span class="n">t</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x2), (3, x3), (4, x4)]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_rowmotion</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="n">t</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, a*b/x4), (2, (x1*x2*b + x1*x3*b)/(x2*x4)),</span>
<span class="go"> (3, (x1*x2*b + x1*x3*b)/(x3*x4)), (4, (x2*b + x3*b)/x4)]</span>
</pre></div>
</div>
<p>A result of <a class="reference internal" href="../../../references/index.html#gr2013" id="id5">[GR2013]</a> states that applying birational rowmotion
<span class="math notranslate nohighlight">\(n+m\)</span> times to a <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling <span class="math notranslate nohighlight">\(f\)</span> of the poset
<span class="math notranslate nohighlight">\([n] \times [m]\)</span> gives back <span class="math notranslate nohighlight">\(f\)</span>. Let us check this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_rectangle_periodicity</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="go">....:     P = posets.ChainPoset(n).product(posets.ChainPoset(m))</span>
<span class="go">....:     t0 = P.birational_free_labelling(P)</span>
<span class="go">....:     t = t0</span>
<span class="go">....:     for i in range(k):</span>
<span class="go">....:         t = P.birational_rowmotion(t)</span>
<span class="go">....:     return t == t0</span>
<span class="gp">sage: </span><span class="n">test_rectangle_periodicity</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_rectangle_periodicity</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">test_rectangle_periodicity</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>While computations with the birational free labelling quickly
run out of memory due to the complexity of the rational
functions involved, it is computationally cheap to check
properties of birational rowmotion on examples in the tropical
semiring:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_rectangle_periodicity_tropical</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="go">....:     P = posets.ChainPoset(n).product(posets.ChainPoset(m))</span>
<span class="go">....:     TT = TropicalSemiring(ZZ)</span>
<span class="go">....:     t0 = (TT, {v: TT(floor(random()*100)) for v in P}, TT(0), TT(124))</span>
<span class="go">....:     t = t0</span>
<span class="go">....:     for i in range(k):</span>
<span class="go">....:         t = P.birational_rowmotion(t)</span>
<span class="go">....:     return t == t0</span>
<span class="gp">sage: </span><span class="n">test_rectangle_periodicity_tropical</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Tropicalization is also what relates birational rowmotion to
classical rowmotion on order ideals. In fact, if <span class="math notranslate nohighlight">\(T\)</span> denotes
the <a class="reference external" href="../../../semirings/sage/rings/semirings/tropical_semiring.html#sage.rings.semirings.tropical_semiring.TropicalSemiring" title="(in Sage Reference Manual: Standard Semirings v8.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tropical</span> <span class="pre">semiring</span></code></a> of
<span class="math notranslate nohighlight">\(\ZZ\)</span> and <span class="math notranslate nohighlight">\(P\)</span> is a finite poset, then we can define an embedding
<span class="math notranslate nohighlight">\(\phi\)</span> from the set <span class="math notranslate nohighlight">\(J(P)\)</span> of all order ideals of <span class="math notranslate nohighlight">\(P\)</span> into the
set <span class="math notranslate nohighlight">\(T^{\widehat{P}}\)</span> of all <span class="math notranslate nohighlight">\(T\)</span>-labellings of <span class="math notranslate nohighlight">\(P\)</span> by sending
every <span class="math notranslate nohighlight">\(I \in J(P)\)</span> to the indicator function of <span class="math notranslate nohighlight">\(I\)</span> extended by
the value <span class="math notranslate nohighlight">\(1\)</span> at the element <span class="math notranslate nohighlight">\(0\)</span> and the value <span class="math notranslate nohighlight">\(0\)</span> at the
element <span class="math notranslate nohighlight">\(1\)</span>. This map <span class="math notranslate nohighlight">\(\phi\)</span> has the property that
<span class="math notranslate nohighlight">\(R \circ \phi = \phi \circ r\)</span>, where <span class="math notranslate nohighlight">\(R\)</span> denotes birational
rowmotion, and <span class="math notranslate nohighlight">\(r\)</span> denotes <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classical</span> <span class="pre">rowmotion</span></code></a>
on <span class="math notranslate nohighlight">\(J(P)\)</span>. An example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">IntegerPartitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">TT</span> <span class="o">=</span> <span class="n">TropicalSemiring</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">indicator_labelling</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
<span class="go">....:     # send order ideal `I` to a `T`-labelling of `P`.</span>
<span class="go">....:     dct = {v: TT(v in I) for v in P}</span>
<span class="go">....:     return (TT, dct, TT(1), TT(0))</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">indicator_labelling</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion</span><span class="p">(</span><span class="n">I</span><span class="p">))</span>
<span class="go">....:     == P.birational_rowmotion(indicator_labelling(I))</span>
<span class="go">....:     for I in P.order_ideals_lattice(facade=True))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle">
<code class="descname">birational_toggle</code><span class="sig-paren">(</span><em>v</em>, <em>labelling</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of applying the birational <span class="math notranslate nohighlight">\(v\)</span>-toggle <span class="math notranslate nohighlight">\(T_v\)</span>
to the <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling <code class="docutils literal notranslate"><span class="pre">labelling</span></code> of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>See the documentation of <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_free_labelling()</span></code></a>
for a definition of this toggle and of <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labellings as
well as an explanation of how <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labellings are to be
encoded to be understood by Sage. This implementation allows
<span class="math notranslate nohighlight">\(\mathbf{K}\)</span> to be a semifield, not just a field. The birational
<span class="math notranslate nohighlight">\(v\)</span>-toggle is only a rational map, so an exception (most
likely, <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>) will be thrown if the
denominator is zero.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">v</span></code> – an element of <code class="docutils literal notranslate"><span class="pre">self</span></code> (must have <code class="docutils literal notranslate"><span class="pre">self</span></code> as
parent if <code class="docutils literal notranslate"><span class="pre">self</span></code> is a <code class="docutils literal notranslate"><span class="pre">facade=False</span></code> poset)</li>
<li><code class="docutils literal notranslate"><span class="pre">labelling</span></code> – a <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the
sense as defined in the documentation of
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_free_labelling()</span></code></a></li>
</ul>
<p>OUTPUT:</p>
<p>The <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling <span class="math notranslate nohighlight">\(T_v f\)</span> of <code class="docutils literal notranslate"><span class="pre">self</span></code>, where <span class="math notranslate nohighlight">\(f\)</span> is
<code class="docutils literal notranslate"><span class="pre">labelling</span></code>.</p>
<p>EXAMPLES:</p>
<p>Let us start with the birational free labelling of the
“V”-poset (the three-element poset with Hasse diagram looking
like a “V”):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">();</span> <span class="n">s</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x2), (3, x3)]</span>
</pre></div>
</div>
<p>The image of <span class="math notranslate nohighlight">\(s\)</span> under the <span class="math notranslate nohighlight">\(1\)</span>-toggle <span class="math notranslate nohighlight">\(T_1\)</span> is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="n">s1</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, a*x2*x3/(x1*x2 + x1*x3)), (2, x2), (3, x3)]</span>
</pre></div>
</div>
<p>Now let us apply the <span class="math notranslate nohighlight">\(2\)</span>-toggle <span class="math notranslate nohighlight">\(T_2\)</span> (to the old <code class="docutils literal notranslate"><span class="pre">s</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s2</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="n">s2</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x1*b/x2), (3, x3)]</span>
</pre></div>
</div>
<p>On the other hand, we can also apply <span class="math notranslate nohighlight">\(T_2\)</span> to the image of <span class="math notranslate nohighlight">\(s\)</span>
under <span class="math notranslate nohighlight">\(T_1\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s12</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">s1</span><span class="p">);</span> <span class="n">s12</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s12</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, a*x2*x3/(x1*x2 + x1*x3)), (2, a*x3*b/(x1*x2 + x1*x3)), (3, x3)]</span>
</pre></div>
</div>
<p>Each toggle is an involution:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="o">==</span> <span class="n">s</span>
<span class="go">....:      for i in V )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can also start with a less generic labelling:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">(Rational Field, {...}, 2, 10)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 28/13), (2, 6), (3, 7)]</span>
<span class="gp">sage: </span><span class="n">t13</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span> <span class="n">t13</span>
<span class="go">(Rational Field, {...}, 2, 10)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t13</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 28/13), (2, 6), (3, 40/13)]</span>
</pre></div>
</div>
<p>However, labellings have to be sufficiently generic, lest
denominators vanish:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">rational division by zero</span>
</pre></div>
</div>
<p>We don’t get into zero-division issues in the tropical
semiring (unless the zero of the tropical semiring appears
in the labelling):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">TT</span> <span class="o">=</span> <span class="n">TropicalSemiring</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">)},</span> <span class="n">TT</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">TT</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 6, 0)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 8), (2, 4), (3, 1)]</span>
<span class="gp">sage: </span><span class="n">t12</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span> <span class="n">t12</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 6, 0)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t12</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 8), (2, 4), (3, 1)]</span>
<span class="gp">sage: </span><span class="n">t123</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">t12</span><span class="p">);</span> <span class="n">t123</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 6, 0)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t123</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 8), (2, 4), (3, 7)]</span>
</pre></div>
</div>
<p>We turn to more interesting posets. Here is the <span class="math notranslate nohighlight">\(6\)</span>-element
poset arising from the weak order on <span class="math notranslate nohighlight">\(S_3\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SymmetricGroupWeakOrderPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">))</span>
<span class="go">[&#39;123&#39;, &#39;132&#39;, &#39;213&#39;, &#39;231&#39;, &#39;312&#39;, &#39;321&#39;]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;123&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="s1">&#39;132&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;213&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;231&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;321&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;312&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">)},</span> <span class="n">TT</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 7, 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;123&#39;, 6), (&#39;132&#39;, 2), (&#39;213&#39;, 3), (&#39;231&#39;, 1), (&#39;312&#39;, 2), (&#39;321&#39;, 1)]</span>
<span class="gp">sage: </span><span class="n">t13</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="s1">&#39;213&#39;</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span> <span class="n">t13</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 7, 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t13</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;123&#39;, 6), (&#39;132&#39;, 2), (&#39;213&#39;, 4), (&#39;231&#39;, 1), (&#39;312&#39;, 2), (&#39;321&#39;, 1)]</span>
</pre></div>
</div>
<p>Let us verify on this example some basic properties of
toggles. First of all, again let us check that <span class="math notranslate nohighlight">\(T_v\)</span> is an
involution for every <span class="math notranslate nohighlight">\(v\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span> <span class="o">==</span> <span class="n">t</span>
<span class="go">....:      for v in P )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Furthermore, two toggles <span class="math notranslate nohighlight">\(T_v\)</span> and <span class="math notranslate nohighlight">\(T_w\)</span> commute unless
one of <span class="math notranslate nohighlight">\(v\)</span> or <span class="math notranslate nohighlight">\(w\)</span> covers the other:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">or</span> <span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="go">....:      or P.birational_toggle(v, P.birational_toggle(w, t))</span>
<span class="go">....:         == P.birational_toggle(w, P.birational_toggle(v, t))</span>
<span class="go">....:      for v in P for w in P )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles">
<code class="descname">birational_toggles</code><span class="sig-paren">(</span><em>vs</em>, <em>labelling</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of applying a sequence of birational
toggles (specified by <code class="docutils literal notranslate"><span class="pre">vs</span></code>) to the <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling
<code class="docutils literal notranslate"><span class="pre">labelling</span></code> of the poset <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>See the documentation of <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_free_labelling()</span></code></a>
for a definition of birational toggles and <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labellings
and for an explanation of how <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labellings are to be
encoded to be understood by Sage. This implementation allows
<span class="math notranslate nohighlight">\(\mathbf{K}\)</span> to be a semifield, not just a field. The birational
<span class="math notranslate nohighlight">\(v\)</span>-toggle is only a rational map, so an exception (most
likely, <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>) will be thrown if the
denominator is zero.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">vs</span></code> – an iterable comprising elements of <code class="docutils literal notranslate"><span class="pre">self</span></code>
(which must have <code class="docutils literal notranslate"><span class="pre">self</span></code> as parent if <code class="docutils literal notranslate"><span class="pre">self</span></code> is a
<code class="docutils literal notranslate"><span class="pre">facade=False</span></code> poset)</li>
<li><code class="docutils literal notranslate"><span class="pre">labelling</span></code> – a <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the
sense as defined in the documentation of
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">birational_free_labelling()</span></code></a></li>
</ul>
<p>OUTPUT:</p>
<p>The <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>-labelling <span class="math notranslate nohighlight">\(T_{v_n} T_{v_{n-1}} \cdots T_{v_1} f\)</span>
of <code class="docutils literal notranslate"><span class="pre">self</span></code>, where <span class="math notranslate nohighlight">\(f\)</span> is <code class="docutils literal notranslate"><span class="pre">labelling</span></code> and
<span class="math notranslate nohighlight">\((v_1, v_2, \ldots, v_n)\)</span> is <code class="docutils literal notranslate"><span class="pre">vs</span></code> (written as list).</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">SymmetricGroupBruhatOrderPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">))</span>
<span class="go">[&#39;123&#39;, &#39;132&#39;, &#39;213&#39;, &#39;231&#39;, &#39;312&#39;, &#39;321&#39;]</span>
<span class="gp">sage: </span><span class="n">TT</span> <span class="o">=</span> <span class="n">TropicalSemiring</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;123&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="s1">&#39;132&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;213&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;231&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;321&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;312&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">)},</span> <span class="n">TT</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">tA</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">([</span><span class="s1">&#39;123&#39;</span><span class="p">,</span> <span class="s1">&#39;231&#39;</span><span class="p">,</span> <span class="s1">&#39;312&#39;</span><span class="p">],</span> <span class="n">t</span><span class="p">);</span> <span class="n">tA</span>
<span class="go">(Tropical semiring over Integer Ring, {...}, 7, 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">tA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;123&#39;, 6), (&#39;132&#39;, 2), (&#39;213&#39;, 3), (&#39;231&#39;, 2), (&#39;312&#39;, 1), (&#39;321&#39;, 1)]</span>
<span class="gp">sage: </span><span class="n">tAB</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">([</span><span class="s1">&#39;132&#39;</span><span class="p">,</span> <span class="s1">&#39;213&#39;</span><span class="p">,</span> <span class="s1">&#39;321&#39;</span><span class="p">],</span> <span class="n">tA</span><span class="p">);</span> <span class="n">tAB</span>
<span class="go">(Tropical semiring over Integer Ring, {...}, 7, 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">tAB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;123&#39;, 6), (&#39;132&#39;, 6), (&#39;213&#39;, 5), (&#39;231&#39;, 2), (&#39;312&#39;, 1), (&#39;321&#39;, 1)]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Qx</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">Qx</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">Qx</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)),</span> <span class="n">t</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">(Fraction Field of Univariate Polynomial Ring in x over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, (x^2 + x)/(x^2 + x + 1)), (2, (x^3 + x^2)/(x^2 + x + 1)), (3, x^4/(x^2 + x + 1)), (4, 1)]</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)),</span> <span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 1/x^2), (2, (x^2 + x + 1)/x^4), (3, (x^2 + x + 1)/(x^3 + x^2)), (4, (x^2 + x + 1)/x^3)]</span>
</pre></div>
</div>
<p>Facade set to <code class="docutils literal notranslate"><span class="pre">False</span></code> works:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">],</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lex</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">lex</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">([</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">P</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)],</span> <span class="n">t</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(x, a*x2*x3/(x1*x2 + x1*x3)), (y, a*x3*x4/(x1*x2 + x1*x3)), (w, x3), (z, x4)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.deprecated_function_alias">
<code class="descname">deprecated_function_alias</code><span class="sig-paren">(</span><em>trac_number</em>, <em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.deprecated_function_alias" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an aliased version of a function or a method which raise a
deprecation warning message.</p>
<p>If f is a function or a method, write
<code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">=</span> <span class="pre">deprecated_function_alias(trac_number,</span> <span class="pre">f)</span></code>
to make a deprecated aliased version of f.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">trac_number</span></code> – integer. The trac ticket number where the
deprecation is introduced.</li>
<li><code class="docutils literal notranslate"><span class="pre">func</span></code> – the function or method to be aliased</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.misc.superseded</span> <span class="kn">import</span> <span class="n">deprecated_function_alias</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">deprecated_function_alias</span><span class="p">(</span><span class="mi">13109</span><span class="p">,</span> <span class="n">number_of_partitions</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">doctest:...: DeprecationWarning: g is deprecated. Please use sage.combinat.partition.number_of_partitions instead.</span>
<span class="go">See http://trac.sagemath.org/13109 for details.</span>
<span class="go">7</span>
</pre></div>
</div>
<p>This also works for methods:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">cls</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="go">....:    def new_meth(self): return 42</span>
<span class="go">....:    old_meth = deprecated_function_alias(13109, new_meth)</span>
<span class="gp">sage: </span><span class="bp">cls</span><span class="p">()</span><span class="o">.</span><span class="n">old_meth</span><span class="p">()</span>
<span class="go">doctest:...: DeprecationWarning: old_meth is deprecated. Please use new_meth instead.</span>
<span class="go">See http://trac.sagemath.org/13109 for details.</span>
<span class="go">42</span>
</pre></div>
</div>
<p><a class="reference external" href="https://trac.sagemath.org/11585">trac ticket #11585</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">a</span><span class="p">():</span> <span class="k">pass</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">deprecated_function_alias</span><span class="p">(</span><span class="mi">13109</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span><span class="p">()</span>
<span class="go">doctest:...: DeprecationWarning: b is deprecated. Please use a instead.</span>
<span class="go">See http://trac.sagemath.org/13109 for details.</span>
</pre></div>
</div>
<p>AUTHORS:</p>
<blockquote>
<div><ul class="simple">
<li>Florent Hivert (2009-11-23), with the help of Mike Hansen.</li>
<li>Luca De Feo (2011-07-11), printing the full module path when different from old path</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.directed_subsets">
<code class="descname">directed_subsets</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.directed_subsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order filters (resp. order ideals) of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as lists.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">direction</span></code> is ‘up’, returns the order filters (upper sets).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">direction</span></code> is ‘down’, returns the order ideals (lower sets).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">direction</span></code> – ‘up’ or ‘down’</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">directed_subsets</span><span class="p">(</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="go">[[], [1, 2, 4, 3, 6, 12], [2, 4, 3, 6, 12], [2, 4, 6, 12], [3, 6, 12], [4, 3, 6, 12], [4, 6, 12], [4, 12], [6, 12], [12]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_lattice">
<code class="descname">is_lattice</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the poset is a lattice.</p>
<p>A poset is a lattice if all pairs of elements have
both a least upper bound (“join”) and a greatest lower bound
(“meet”) in the poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lattice</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
<span class="go">....:            6: [8, 10], 7: [9, 10], 8: [11], 9: [11], 10: [11]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lattice</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>Weaker properties: <a class="reference external" href="../../../combinat/sage/combinat/posets/posets.html#sage.combinat.posets.posets.FinitePoset.is_join_semilattice" title="(in Sage Reference Manual: Combinatorics v8.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_join_semilattice()</span></code></a>,
<a class="reference external" href="../../../combinat/sage/combinat/posets/posets.html#sage.combinat.posets.posets.FinitePoset.is_meet_semilattice" title="(in Sage Reference Manual: Combinatorics v8.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_meet_semilattice()</span></code></a></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism">
<code class="descname">is_poset_isomorphism</code><span class="sig-paren">(</span><em>f</em>, <em>codomain</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <span class="math notranslate nohighlight">\(f\)</span> is an isomorphism of posets from
<code class="docutils literal notranslate"><span class="pre">self</span></code> to <code class="docutils literal notranslate"><span class="pre">codomain</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code> – a function from <code class="docutils literal notranslate"><span class="pre">self</span></code> to <code class="docutils literal notranslate"><span class="pre">codomain</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">codomain</span></code> – a poset</li>
</ul>
<p>EXAMPLES:</p>
<p>We build the poset <span class="math notranslate nohighlight">\(D\)</span> of divisors of 30, and check that
it is isomorphic to the boolean lattice <span class="math notranslate nohighlight">\(B\)</span> of the subsets
of <span class="math notranslate nohighlight">\(\{2,3,5\}\)</span> ordered by inclusion, via the reverse
function <span class="math notranslate nohighlight">\(f: B \to D, b \mapsto \prod_{x\in b} x\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])],</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">D</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_isomorphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>On the other hand, <span class="math notranslate nohighlight">\(f\)</span> is not an isomorphism to the chain
of divisors of 30, ordered by usual comparison:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">P</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_isomorphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A non surjective case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])],</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">D</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_isomorphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A non injective case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])],</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">D</span><span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_isomorphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">since <code class="docutils literal notranslate"><span class="pre">D</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are not facade posets, <code class="docutils literal notranslate"><span class="pre">f</span></code> is
responsible for the conversions between integers and subsets to
elements of <code class="docutils literal notranslate"><span class="pre">D</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> and back.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="finite_lattice_posets.html#sage.categories.finite_lattice_posets.FiniteLatticePosets.ParentMethods.is_lattice_morphism" title="sage.categories.finite_lattice_posets.FiniteLatticePosets.ParentMethods.is_lattice_morphism"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FiniteLatticePosets.ParentMethods.is_lattice_morphism()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_morphism">
<code class="descname">is_poset_morphism</code><span class="sig-paren">(</span><em>f</em>, <em>codomain</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_morphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <span class="math notranslate nohighlight">\(f\)</span> is a morphism of posets from <code class="docutils literal notranslate"><span class="pre">self</span></code>
to <code class="docutils literal notranslate"><span class="pre">codomain</span></code>, that is</p>
<div class="math notranslate nohighlight">
\[x\leq y \Longrightarrow f(x) \leq f(y)\]</div>
<p>for all <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code> – a function from <code class="docutils literal notranslate"><span class="pre">self</span></code> to <code class="docutils literal notranslate"><span class="pre">codomain</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">codomain</span></code> – a poset</li>
</ul>
<p>EXAMPLES:</p>
<p>We build the boolean lattice of the subsets of
<span class="math notranslate nohighlight">\(\{2,3,5,6\}\)</span> and the lattice of divisors of <span class="math notranslate nohighlight">\(30\)</span>, and
check that the map <span class="math notranslate nohighlight">\(b \mapsto \gcd(\prod_{x\in b} x, 30)\)</span>
is a morphism of posets:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])],</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">D</span><span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">since <code class="docutils literal notranslate"><span class="pre">D</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are not facade posets, <code class="docutils literal notranslate"><span class="pre">f</span></code> is responsible
for the conversions between integers and subsets to elements of
<code class="docutils literal notranslate"><span class="pre">D</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> and back.</p>
</div>
<p><span class="math notranslate nohighlight">\(f\)</span> is also a morphism of posets to the chain of divisors
of 30, ordered by usual comparison:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">P</span><span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>FIXME: should this be <code class="docutils literal notranslate"><span class="pre">is_order_preserving_morphism</span></code>?</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism" title="sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_poset_isomorphism()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_self_dual">
<code class="descname">is_self_dual</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_self_dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the poset is <em>self-dual</em>.</p>
<p>A poset is self-dual if it is isomorphic to its dual poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_self_dual</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_self_dual</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>Stronger properties: <a class="reference external" href="../../../combinat/sage/combinat/posets/lattices.html#sage.combinat.posets.lattices.FiniteLatticePoset.is_orthocomplemented" title="(in Sage Reference Manual: Combinatorics v8.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_orthocomplemented()</span></code></a> (for lattices)</li>
<li>Other: <a class="reference external" href="../../../combinat/sage/combinat/posets/posets.html#sage.combinat.posets.posets.FinitePoset.dual" title="(in Sage Reference Manual: Combinatorics v8.5)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dual()</span></code></a></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_selfdual">
<code class="descname">is_selfdual</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_selfdual" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: Use <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_self_dual" title="sage.categories.finite_posets.FinitePosets.ParentMethods.is_self_dual"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_self_dual()</span></code></a> instead.
See <a class="reference external" href="https://trac.sagemath.org/24048">trac ticket #24048</a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.order_filter_generators">
<code class="descname">order_filter_generators</code><span class="sig-paren">(</span><em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_filter_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Generators for an order filter</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">filter</span></code> – an order filter of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as a list (or iterable)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">Subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_filter</span><span class="p">([</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">])]);</span> <span class="n">I</span>
<span class="go">[{2, 3}, {1}, {1, 2}, {1, 3}, {1, 2, 3}]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_filter_generators</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">{{2, 3}, {1}}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators" title="sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_ideal_generators()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_complement_generators">
<code class="descname">order_ideal_complement_generators</code><span class="sig-paren">(</span><em>antichain</em>, <em>direction='up'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_complement_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Panyushev complement of the antichain
<code class="docutils literal notranslate"><span class="pre">antichain</span></code>.</p>
<p>Given an antichain <span class="math notranslate nohighlight">\(A\)</span> of a poset <span class="math notranslate nohighlight">\(P\)</span>, the Panyushev
complement of <span class="math notranslate nohighlight">\(A\)</span> is defined to be the antichain consisting
of the minimal elements of the order filter <span class="math notranslate nohighlight">\(B\)</span>, where <span class="math notranslate nohighlight">\(B\)</span>
is the (set-theoretic) complement of the order ideal of
<span class="math notranslate nohighlight">\(P\)</span> generated by <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>Setting the optional keyword variable <code class="docutils literal notranslate"><span class="pre">direction</span></code> to
<code class="docutils literal notranslate"><span class="pre">'down'</span></code> leads to the inverse Panyushev complement being
computed instead of the Panyushev complement. The inverse
Panyushev complement of an antichain <span class="math notranslate nohighlight">\(A\)</span> is the antichain
whose Panyushev complement is <span class="math notranslate nohighlight">\(A\)</span>. It can be found as the
antichain consisting of the maximal elements of the order
ideal <span class="math notranslate nohighlight">\(C\)</span>, where <span class="math notranslate nohighlight">\(C\)</span> is the (set-theoretic) complement of
the order filter of <span class="math notranslate nohighlight">\(P\)</span> generated by <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">panyushev_complement()</span></code></a> is an alias for this method.</p>
<p>Panyushev complementation is related (actually, isomorphic)
to rowmotion (<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rowmotion()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">antichain</span></code> – an antichain of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as a list (or
iterable), or, more generally, generators of an order ideal
(resp. order filter)</li>
<li><code class="docutils literal notranslate"><span class="pre">direction</span></code> – ‘up’ or ‘down’ (default: ‘up’)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the generating antichain of the complement order filter
(resp. order ideal) of the order ideal (resp. order filter)
generated by the antichain <code class="docutils literal notranslate"><span class="pre">antichain</span></code></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">{3}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">set()</span>

<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">{1, 2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">set()</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is a brute force implementation, building the
order ideal generated by the antichain, and searching
for order filter generators of its complement</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators">
<code class="descname">order_ideal_generators</code><span class="sig-paren">(</span><em>ideal</em>, <em>direction='down'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the antichain of (minimal) generators of the order
ideal (resp. order filter) <code class="docutils literal notranslate"><span class="pre">ideal</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ideal</span></code> – an order ideal <span class="math notranslate nohighlight">\(I\)</span> (resp. order filter)
of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as a list (or iterable); this should be
an order ideal if <code class="docutils literal notranslate"><span class="pre">direction</span></code> is set to <code class="docutils literal notranslate"><span class="pre">'down'</span></code>,
and an order filter if <code class="docutils literal notranslate"><span class="pre">direction</span></code> is set to
<code class="docutils literal notranslate"><span class="pre">'up'</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">direction</span></code> – <code class="docutils literal notranslate"><span class="pre">'up'</span></code> or <code class="docutils literal notranslate"><span class="pre">'down'</span></code> (default:
<code class="docutils literal notranslate"><span class="pre">'down'</span></code>).</li>
</ul>
<p>The antichain of (minimal) generators of an order ideal
<span class="math notranslate nohighlight">\(I\)</span> in a poset <span class="math notranslate nohighlight">\(P\)</span> is the set of all minimal elements of
<span class="math notranslate nohighlight">\(P\)</span>. In the case of an order filter, the definition is
similar, but with “maximal” used instead of “minimal”.</p>
<p>EXAMPLES:</p>
<p>We build the boolean lattice of all subsets of <span class="math notranslate nohighlight">\(\{1,2,3\}\)</span>
ordered by inclusion, and compute an order ideal there:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">Subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideal</span><span class="p">([</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">])]);</span> <span class="n">I</span>
<span class="go">[{}, {3}, {2}, {2, 3}, {1}, {1, 2}]</span>
</pre></div>
</div>
<p>Then, we retrieve the generators of this ideal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_generators</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">{{1, 2}, {2, 3}}</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">direction</span></code> is ‘up’, then this instead computes
the minimal generators for an order filter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_filter</span><span class="p">([</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">])]);</span> <span class="n">I</span>
<span class="go">[{2, 3}, {1}, {1, 2}, {1, 3}, {1, 2, 3}]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_generators</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>
<span class="go">{{2, 3}, {1}}</span>
</pre></div>
</div>
<p>Complexity: <span class="math notranslate nohighlight">\(O(n+m)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the cardinality of <span class="math notranslate nohighlight">\(I\)</span>,
and <span class="math notranslate nohighlight">\(m\)</span> the number of upper covers of elements of <span class="math notranslate nohighlight">\(I\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideals_lattice">
<code class="descname">order_ideals_lattice</code><span class="sig-paren">(</span><em>as_ideals=True</em>, <em>facade=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideals_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the lattice of order ideals of a poset <code class="docutils literal notranslate"><span class="pre">self</span></code>,
ordered by inclusion.</p>
<p>The lattice of order ideals of a poset <span class="math notranslate nohighlight">\(P\)</span> is usually
denoted by <span class="math notranslate nohighlight">\(J(P)\)</span>. Its underlying set is the set of order
ideals of <span class="math notranslate nohighlight">\(P\)</span>, and its partial order is given by
inclusion.</p>
<p>The order ideals of <span class="math notranslate nohighlight">\(P\)</span> are in a canonical bijection
with the antichains of <span class="math notranslate nohighlight">\(P\)</span>. The bijection maps every
order ideal to the antichain formed by its maximal
elements. By setting the <code class="docutils literal notranslate"><span class="pre">as_ideals</span></code> keyword variable to
<code class="docutils literal notranslate"><span class="pre">False</span></code>, one can make this method apply this bijection
before returning the lattice.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">as_ideals</span></code> – Boolean, if <code class="docutils literal notranslate"><span class="pre">True</span></code> (default) returns
a poset on the set of order ideals, otherwise on the set
of antichains</li>
<li><code class="docutils literal notranslate"><span class="pre">facade</span></code> – Boolean or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default). Whether to
return a facade lattice or not. By default return facade
lattice if the poset is a facade poset.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 2], [1, 4], [2, 3], [3, 4]]</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideals_lattice</span><span class="p">();</span> <span class="n">J</span>
<span class="go">Finite lattice containing 8 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
<span class="go">[{}, {0}, {0, 2}, {0, 2, 3}, {0, 1}, {0, 1, 2}, {0, 1, 2, 3}, {0, 1, 2, 3, 4}]</span>
</pre></div>
</div>
<p>As a lattice on antichains:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">J2</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideals_lattice</span><span class="p">(</span><span class="bp">False</span><span class="p">);</span> <span class="n">J2</span>
<span class="go">Finite lattice containing 8 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">J2</span><span class="p">)</span>
<span class="go">[(0,), (1, 2), (1, 3), (1,), (2,), (3,), (4,), ()]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement">
<code class="descname">panyushev_complement</code><span class="sig-paren">(</span><em>antichain</em>, <em>direction='up'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Panyushev complement of the antichain
<code class="docutils literal notranslate"><span class="pre">antichain</span></code>.</p>
<p>Given an antichain <span class="math notranslate nohighlight">\(A\)</span> of a poset <span class="math notranslate nohighlight">\(P\)</span>, the Panyushev
complement of <span class="math notranslate nohighlight">\(A\)</span> is defined to be the antichain consisting
of the minimal elements of the order filter <span class="math notranslate nohighlight">\(B\)</span>, where <span class="math notranslate nohighlight">\(B\)</span>
is the (set-theoretic) complement of the order ideal of
<span class="math notranslate nohighlight">\(P\)</span> generated by <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>Setting the optional keyword variable <code class="docutils literal notranslate"><span class="pre">direction</span></code> to
<code class="docutils literal notranslate"><span class="pre">'down'</span></code> leads to the inverse Panyushev complement being
computed instead of the Panyushev complement. The inverse
Panyushev complement of an antichain <span class="math notranslate nohighlight">\(A\)</span> is the antichain
whose Panyushev complement is <span class="math notranslate nohighlight">\(A\)</span>. It can be found as the
antichain consisting of the maximal elements of the order
ideal <span class="math notranslate nohighlight">\(C\)</span>, where <span class="math notranslate nohighlight">\(C\)</span> is the (set-theoretic) complement of
the order filter of <span class="math notranslate nohighlight">\(P\)</span> generated by <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">panyushev_complement()</span></code></a> is an alias for this method.</p>
<p>Panyushev complementation is related (actually, isomorphic)
to rowmotion (<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rowmotion()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">antichain</span></code> – an antichain of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as a list (or
iterable), or, more generally, generators of an order ideal
(resp. order filter)</li>
<li><code class="docutils literal notranslate"><span class="pre">direction</span></code> – ‘up’ or ‘down’ (default: ‘up’)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the generating antichain of the complement order filter
(resp. order ideal) of the order ideal (resp. order filter)
generated by the antichain <code class="docutils literal notranslate"><span class="pre">antichain</span></code></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">{3}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">set()</span>

<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">{1, 2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">set()</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is a brute force implementation, building the
order ideal generated by the antichain, and searching
for order filter generators of its complement</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbit_iter">
<code class="descname">panyushev_orbit_iter</code><span class="sig-paren">(</span><em>antichain</em>, <em>element_constructor=&lt;type 'set'&gt;</em>, <em>stop=True</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbit_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the Panyushev orbit of an antichain
<code class="docutils literal notranslate"><span class="pre">antichain</span></code> of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The Panyushev orbit of an antichain is its orbit under
Panyushev complementation (see
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">panyushev_complement()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">antichain</span></code> – an antichain of <code class="docutils literal notranslate"><span class="pre">self</span></code>, given as an
iterable.</li>
<li><code class="docutils literal notranslate"><span class="pre">element_constructor</span></code> (defaults to <code class="docutils literal notranslate"><span class="pre">set</span></code>) – a type
constructor (<code class="docutils literal notranslate"><span class="pre">set</span></code>, <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">frozenset</span></code>,
<code class="docutils literal notranslate"><span class="pre">iter</span></code>, etc.) which is to be applied to the antichains
before they are yielded.</li>
<li><code class="docutils literal notranslate"><span class="pre">stop</span></code> – a Boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) determining
whether the iterator should stop once it completes its
cycle (this happens when it is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>) or go on
forever (this happens when it is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>).</li>
<li><code class="docutils literal notranslate"><span class="pre">check</span></code> – a Boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) determining
whether <code class="docutils literal notranslate"><span class="pre">antichain</span></code> should be checked for being an
antichain.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an iterator over the orbit of the antichain <code class="docutils literal notranslate"><span class="pre">antichain</span></code>
under Panyushev complementation. This iterator <span class="math notranslate nohighlight">\(I\)</span> has the
property that <code class="docutils literal notranslate"><span class="pre">I[0]</span> <span class="pre">==</span> <span class="pre">antichain</span></code> and each <span class="math notranslate nohighlight">\(i\)</span> satisfies
<code class="docutils literal notranslate"><span class="pre">self.order_ideal_complement_generators(I[i])</span> <span class="pre">==</span> <span class="pre">I[i+1]</span></code>,
where <code class="docutils literal notranslate"><span class="pre">I[i+1]</span></code> has to be understood as <code class="docutils literal notranslate"><span class="pre">I[0]</span></code> if it is
undefined.
The entries <code class="docutils literal notranslate"><span class="pre">I[i]</span></code> are sets by default, but depending on
the optional keyword variable <code class="docutils literal notranslate"><span class="pre">element_constructors</span></code>
they can also be tuples, lists etc.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}, {3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[{1, 2}, {3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">[{1, 2}, {3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[1, 2], [3], []]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">))</span>
<span class="go">[frozenset({1, 2}), frozenset({3}), frozenset()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[(1, 2), (3,), ()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">([]))</span>
<span class="go">[set()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">Piter</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">([</span><span class="mi">2</span><span class="p">],</span> <span class="n">stop</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{3}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbits">
<code class="descname">panyushev_orbits</code><span class="sig-paren">(</span><em>element_constructor=&lt;type 'set'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Panyushev orbits of antichains in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The Panyushev orbit of an antichain is its orbit under
Panyushev complementation (see
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">panyushev_complement()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">element_constructor</span></code> (defaults to <code class="docutils literal notranslate"><span class="pre">set</span></code>) – a type
constructor (<code class="docutils literal notranslate"><span class="pre">set</span></code>, <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">frozenset</span></code>,
<code class="docutils literal notranslate"><span class="pre">iter</span></code>, etc.) which is to be applied to the antichains
before they are returned.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the partition of the set of all antichains of <code class="docutils literal notranslate"><span class="pre">self</span></code> into
orbits under Panyushev complementation. This is returned as
a list of lists <code class="docutils literal notranslate"><span class="pre">L</span></code> such that for each <code class="docutils literal notranslate"><span class="pre">L</span></code> and <code class="docutils literal notranslate"><span class="pre">i</span></code>,
cyclically:
<code class="docutils literal notranslate"><span class="pre">self.order_ideal_complement_generators(L[i])</span> <span class="pre">==</span> <span class="pre">L[i+1]</span></code>.
The entries <code class="docutils literal notranslate"><span class="pre">L[i]</span></code> are sets by default, but depending on
the optional keyword variable <code class="docutils literal notranslate"><span class="pre">element_constructors</span></code>
they can also be tuples, lists etc.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">()</span>
<span class="go">[[{2}, {1}], [set(), {1, 2}, {3}]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
<span class="go">[[[2], [1]], [[], [1, 2], [3]]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">)</span>
<span class="go">[[frozenset({2}), frozenset({1})],</span>
<span class="go"> [frozenset(), frozenset({1, 2}), frozenset({3})]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">)</span>
<span class="go">[[(2,), (1,)], [(), (1, 2), (3,)]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">()</span>
<span class="go">[[set()]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion">
<code class="descname">rowmotion</code><span class="sig-paren">(</span><em>order_ideal</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="Permalink to this definition">¶</a></dt>
<dd><p>The image of the order ideal <code class="docutils literal notranslate"><span class="pre">order_ideal</span></code> under rowmotion
in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Rowmotion on a finite poset <span class="math notranslate nohighlight">\(P\)</span> is an automorphism of the set
<span class="math notranslate nohighlight">\(J(P)\)</span> of all order ideals of <span class="math notranslate nohighlight">\(P\)</span>. One way to define it is as
follows: Given an order ideal <span class="math notranslate nohighlight">\(I \in J(P)\)</span>, we let <span class="math notranslate nohighlight">\(F\)</span> be the
set-theoretic complement of <span class="math notranslate nohighlight">\(I\)</span> in <span class="math notranslate nohighlight">\(P\)</span>. Furthermore we let
<span class="math notranslate nohighlight">\(A\)</span> be the antichain consisting of all minimal elements of
<span class="math notranslate nohighlight">\(F\)</span>. Then, the rowmotion of <span class="math notranslate nohighlight">\(I\)</span> is defined to be the order
ideal of <span class="math notranslate nohighlight">\(P\)</span> generated by the antichain <span class="math notranslate nohighlight">\(A\)</span> (that is, the
order ideal consisting of each element of <span class="math notranslate nohighlight">\(P\)</span> which has some
element of <span class="math notranslate nohighlight">\(A\)</span> above it).</p>
<p>Rowmotion is related (actually, isomorphic) to Panyushev
complementation (<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">panyushev_complement()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">order_ideal</span></code> – an order ideal of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as a set</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the image of <code class="docutils literal notranslate"><span class="pre">order_ideal</span></code> under rowmotion, as a set again</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">8</span><span class="p">:</span> <span class="p">[]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Set</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">{1, 3, 4, 5, 6, 7}</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Set</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">{}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbit_iter">
<code class="descname">rowmotion_orbit_iter</code><span class="sig-paren">(</span><em>oideal</em>, <em>element_constructor=&lt;type 'set'&gt;</em>, <em>stop=True</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbit_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the rowmotion orbit of an order ideal
<code class="docutils literal notranslate"><span class="pre">oideal</span></code> of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The rowmotion orbit of an order ideal is its orbit under
rowmotion (see <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rowmotion()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">oideal</span></code> – an order ideal of <code class="docutils literal notranslate"><span class="pre">self</span></code>, given as an
iterable.</li>
<li><code class="docutils literal notranslate"><span class="pre">element_constructor</span></code> (defaults to <code class="docutils literal notranslate"><span class="pre">set</span></code>) – a type
constructor (<code class="docutils literal notranslate"><span class="pre">set</span></code>, <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">frozenset</span></code>,
<code class="docutils literal notranslate"><span class="pre">iter</span></code>, etc.) which is to be applied to the order
ideals before they are yielded.</li>
<li><code class="docutils literal notranslate"><span class="pre">stop</span></code> – a Boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) determining
whether the iterator should stop once it completes its
cycle (this happens when it is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>) or go on
forever (this happens when it is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>).</li>
<li><code class="docutils literal notranslate"><span class="pre">check</span></code> – a Boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) determining
whether <code class="docutils literal notranslate"><span class="pre">oideal</span></code> should be checked for being an
order ideal.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an iterator over the orbit of the order ideal <code class="docutils literal notranslate"><span class="pre">oideal</span></code>
under rowmotion. This iterator <span class="math notranslate nohighlight">\(I\)</span> has the property that
<code class="docutils literal notranslate"><span class="pre">I[0]</span> <span class="pre">==</span> <span class="pre">oideal</span></code> and that every <span class="math notranslate nohighlight">\(i\)</span> satisfies
<code class="docutils literal notranslate"><span class="pre">self.rowmotion(I[i])</span> <span class="pre">==</span> <span class="pre">I[i+1]</span></code>, where <code class="docutils literal notranslate"><span class="pre">I[i+1]</span></code> has
to be understood as <code class="docutils literal notranslate"><span class="pre">I[0]</span></code> if it is undefined.
The entries <code class="docutils literal notranslate"><span class="pre">I[i]</span></code> are sets by default, but depending on
the optional keyword variable <code class="docutils literal notranslate"><span class="pre">element_constructors</span></code>
they can also be tuples, lists etc.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}, {1, 2, 3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[{1, 2}, {1, 2, 3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">[{1, 2}, {1, 2, 3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[1, 2], [1, 2, 3], []]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">))</span>
<span class="go">[frozenset({1, 2}), frozenset({1, 2, 3}), frozenset()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 2, 3), ()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([]))</span>
<span class="go">[set()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">Piter</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">stop</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3, 4}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3}</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[1, 2], [1, 2, 3, 4], [2, 3, 5], [1], [2, 3], [1, 2, 3, 5], [1, 2, 4], [3]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbits">
<code class="descname">rowmotion_orbits</code><span class="sig-paren">(</span><em>element_constructor=&lt;type 'set'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the rowmotion orbits of order ideals in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The rowmotion orbit of an order ideal is its orbit under
rowmotion (see <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rowmotion()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">element_constructor</span></code> (defaults to <code class="docutils literal notranslate"><span class="pre">set</span></code>) – a type
constructor (<code class="docutils literal notranslate"><span class="pre">set</span></code>, <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">frozenset</span></code>,
<code class="docutils literal notranslate"><span class="pre">iter</span></code>, etc.) which is to be applied to the antichains
before they are returned.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the partition of the set of all order ideals of <code class="docutils literal notranslate"><span class="pre">self</span></code>
into orbits under rowmotion. This is returned as
a list of lists <code class="docutils literal notranslate"><span class="pre">L</span></code> such that for each <code class="docutils literal notranslate"><span class="pre">L</span></code> and <code class="docutils literal notranslate"><span class="pre">i</span></code>,
cyclically: <code class="docutils literal notranslate"><span class="pre">self.rowmotion(L[i])</span> <span class="pre">==</span> <span class="pre">L[i+1]</span></code>.
The entries <code class="docutils literal notranslate"><span class="pre">L[i]</span></code> are sets by default, but depending on
the optional keyword variable <code class="docutils literal notranslate"><span class="pre">element_constructors</span></code>
they can also be tuples, lists etc.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits</span><span class="p">())</span>
<span class="go">[3, 5]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[[1, 3], [4], [1], [4, 1, 3], [4, 1, 2]], [[4, 1], [4, 1, 2, 3], []]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[[(1, 3), (4,), (1,), (4, 1, 3), (4, 1, 2)], [(4, 1), (4, 1, 2, 3), ()]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[[()]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbits_plots">
<code class="descname">rowmotion_orbits_plots</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbits_plots" title="Permalink to this definition">¶</a></dt>
<dd><p>Return plots of the rowmotion orbits of order ideals in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The rowmotion orbit of an order ideal is its orbit under
rowmotion (see <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rowmotion()</span></code></a>).</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits_plots</span><span class="p">()</span>
<span class="go">Graphics Array of size 2 x 5</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits_plots</span><span class="p">()</span>
<span class="go">Graphics Array of size 2 x 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbit_iter">
<code class="descname">toggling_orbit_iter</code><span class="sig-paren">(</span><em>vs</em>, <em>oideal</em>, <em>element_constructor=&lt;type 'set'&gt;</em>, <em>stop=True</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbit_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the orbit of an order ideal <code class="docutils literal notranslate"><span class="pre">oideal</span></code> of
<code class="docutils literal notranslate"><span class="pre">self</span></code> under the operation of toggling the vertices
<code class="docutils literal notranslate"><span class="pre">vs[0],</span> <span class="pre">vs[1],</span> <span class="pre">...</span></code> in this order.</p>
<p>See <a class="reference internal" href="posets.html#sage.categories.posets.Posets.ParentMethods.order_ideal_toggle" title="sage.categories.posets.Posets.ParentMethods.order_ideal_toggle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_ideal_toggle()</span></code></a> for a definition of toggling.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The orbit is that under the composition of toggles,
<em>not</em> under the single toggles themselves. Thus, for
example, if <code class="docutils literal notranslate"><span class="pre">vs</span> <span class="pre">==</span> <span class="pre">[1,2]</span></code>, then the orbit has the
form <span class="math notranslate nohighlight">\((I, T_2 T_1 I, T_2 T_1 T_2 T_1 I, \ldots)\)</span>
(where <span class="math notranslate nohighlight">\(I\)</span> denotes <code class="docutils literal notranslate"><span class="pre">oideal</span></code> and <span class="math notranslate nohighlight">\(T_i\)</span> means
toggling at <span class="math notranslate nohighlight">\(i\)</span>) rather than
<span class="math notranslate nohighlight">\((I, T_1 I, T_2 T_1 I, T_1 T_2 T_1 I, \ldots)\)</span>.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">vs</span></code>: a list (or other iterable) of elements of <code class="docutils literal notranslate"><span class="pre">self</span></code>
(but since the output depends on the order, sets should
not be used as <code class="docutils literal notranslate"><span class="pre">vs</span></code>).</li>
<li><code class="docutils literal notranslate"><span class="pre">oideal</span></code> – an order ideal of <code class="docutils literal notranslate"><span class="pre">self</span></code>, given as an
iterable.</li>
<li><code class="docutils literal notranslate"><span class="pre">element_constructor</span></code> (defaults to <code class="docutils literal notranslate"><span class="pre">set</span></code>) – a type
constructor (<code class="docutils literal notranslate"><span class="pre">set</span></code>, <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code>, <code class="docutils literal notranslate"><span class="pre">frozenset</span></code>,
<code class="docutils literal notranslate"><span class="pre">iter</span></code>, etc.) which is to be applied to the order
ideals before they are yielded.</li>
<li><code class="docutils literal notranslate"><span class="pre">stop</span></code> – a Boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) determining
whether the iterator should stop once it completes its
cycle (this happens when it is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>) or go on
forever (this happens when it is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>).</li>
<li><code class="docutils literal notranslate"><span class="pre">check</span></code> – a Boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) determining
whether <code class="docutils literal notranslate"><span class="pre">oideal</span></code> should be checked for being an
order ideal.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an iterator over the orbit of the order ideal <code class="docutils literal notranslate"><span class="pre">oideal</span></code>
under toggling the vertices in the list <code class="docutils literal notranslate"><span class="pre">vs</span></code> in this
order. This iterator <span class="math notranslate nohighlight">\(I\)</span> has the property that
<code class="docutils literal notranslate"><span class="pre">I[0]</span> <span class="pre">==</span> <span class="pre">oideal</span></code> and that every <span class="math notranslate nohighlight">\(i\)</span> satisfies
<code class="docutils literal notranslate"><span class="pre">self.order_ideal_toggles(I[i],</span> <span class="pre">vs)</span> <span class="pre">==</span> <span class="pre">I[i+1]</span></code>, where
<code class="docutils literal notranslate"><span class="pre">I[i+1]</span></code> has to be understood as <code class="docutils literal notranslate"><span class="pre">I[0]</span></code> if it is
undefined.
The entries <code class="docutils literal notranslate"><span class="pre">I[i]</span></code> are sets by default, but depending on
the optional keyword variable <code class="docutils literal notranslate"><span class="pre">element_constructors</span></code>
they can also be tuples, lists etc.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}, set(), {1, 2, 3}]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}, {1, 2, 3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[1, 2], [1, 2, 3], []]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">))</span>
<span class="go">[frozenset({1, 2}), frozenset({1, 2, 3}), frozenset()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 2, 3), ()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 2, 3), ()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([],</span> <span class="p">[]))</span>
<span class="go">[set()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">Piter</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">stop</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits">
<code class="descname">toggling_orbits</code><span class="sig-paren">(</span><em>vs</em>, <em>element_constructor=&lt;type 'set'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the orbits of order ideals in <code class="docutils literal notranslate"><span class="pre">self</span></code> under the
operation of toggling the vertices <code class="docutils literal notranslate"><span class="pre">vs[0],</span> <span class="pre">vs[1],</span> <span class="pre">...</span></code>
in this order.</p>
<p>See <a class="reference internal" href="posets.html#sage.categories.posets.Posets.ParentMethods.order_ideal_toggle" title="sage.categories.posets.Posets.ParentMethods.order_ideal_toggle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_ideal_toggle()</span></code></a> for a definition of toggling.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The orbits are those under the composition of toggles,
<em>not</em> under the single toggles themselves. Thus, for
example, if <code class="docutils literal notranslate"><span class="pre">vs</span> <span class="pre">==</span> <span class="pre">[1,2]</span></code>, then the orbits have the
form <span class="math notranslate nohighlight">\((I, T_2 T_1 I, T_2 T_1 T_2 T_1 I, \ldots)\)</span>
(where <span class="math notranslate nohighlight">\(I\)</span> denotes an order ideal and <span class="math notranslate nohighlight">\(T_i\)</span> means
toggling at <span class="math notranslate nohighlight">\(i\)</span>) rather than
<span class="math notranslate nohighlight">\((I, T_1 I, T_2 T_1 I, T_1 T_2 T_1 I, \ldots)\)</span>.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">vs</span></code>: a list (or other iterable) of elements of <code class="docutils literal notranslate"><span class="pre">self</span></code>
(but since the output depends on the order, sets should
not be used as <code class="docutils literal notranslate"><span class="pre">vs</span></code>).</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a partition of the order ideals of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as a list of
sets <code class="docutils literal notranslate"><span class="pre">L</span></code> such that for each <code class="docutils literal notranslate"><span class="pre">L</span></code> and <code class="docutils literal notranslate"><span class="pre">i</span></code>, cyclically:
<code class="docutils literal notranslate"><span class="pre">self.order_ideal_toggles(L[i],</span> <span class="pre">vs)</span> <span class="pre">==</span> <span class="pre">L[i+1]</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">toggling_orbits</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[2, 3, 3]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">toggling_orbits</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
<span class="go">[3, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits_plots">
<code class="descname">toggling_orbits_plots</code><span class="sig-paren">(</span><em>vs</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits_plots" title="Permalink to this definition">¶</a></dt>
<dd><p>Return plots of the orbits of order ideals in <code class="docutils literal notranslate"><span class="pre">self</span></code> under the
operation of toggling the vertices <code class="docutils literal notranslate"><span class="pre">vs[0],</span> <span class="pre">vs[1],</span> <span class="pre">...</span></code>
in this order.</p>
<p>See <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits" title="sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits"><code class="xref py py-meth docutils literal notranslate"><span class="pre">toggling_orbits()</span></code></a> for more information.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbits_plots</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="go">Graphics Array of size 2 x 5</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbits_plots</span><span class="p">([])</span>
<span class="go">Graphics Array of size 2 x 1</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="finite_permutation_groups.html"
                        title="previous chapter">Finite Permutation Groups</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="finite_semigroups.html"
                        title="next chapter">Finite semigroups</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/categories/finite_posets.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="finite_semigroups.html" title="Finite semigroups"
             >next</a> |</li>
        <li class="right" >
          <a href="finite_permutation_groups.html" title="Finite Permutation Groups"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Category Framework</a> &#187;</li>
 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2018, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.6.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>