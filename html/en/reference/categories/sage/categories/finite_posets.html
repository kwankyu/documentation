<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=600, initial-scale=1">
    <title>Finite posets &#8212; Sage Reference Manual v8.0: Category Framework</title>
    
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '8.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Finite semigroups" href="finite_semigroups.html" />
    <link rel="prev" title="Finite Permutation Groups" href="finite_permutation_groups.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="finite_semigroups.html" title="Finite semigroups"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="finite_permutation_groups.html" title="Finite Permutation Groups"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Category Framework</a> &#187;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="finite-posets">
<span id="sage-categories-finite-posets"></span><h1>Finite posets<a class="headerlink" href="#finite-posets" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.categories.finite_posets"></span><p>Here is some terminology used in this file:</p>
<ul class="simple">
<li>An <em>order filter</em> (or <em>upper set</em>) of a poset <span class="math">\(P\)</span> is a subset <span class="math">\(S\)</span> of <span class="math">\(P\)</span>
such that if <span class="math">\(x \leq y\)</span> and <span class="math">\(x\in S\)</span> then <span class="math">\(y\in S\)</span>.</li>
<li>An <em>order ideal</em> (or <em>lower set</em>) of a poset <span class="math">\(P\)</span> is a subset <span class="math">\(S\)</span> of <span class="math">\(P\)</span>
such that if <span class="math">\(x \leq y\)</span> and <span class="math">\(y\in S\)</span> then <span class="math">\(x\in S\)</span>.</li>
</ul>
<dl class="class">
<dt id="sage.categories.finite_posets.FinitePosets">
<em class="property">class </em><code class="descclassname">sage.categories.finite_posets.</code><code class="descname">FinitePosets</code><span class="sig-paren">(</span><em>base_category</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="category_with_axiom.html#sage.categories.category_with_axiom.CategoryWithAxiom" title="sage.categories.category_with_axiom.CategoryWithAxiom"><code class="xref py py-class docutils literal"><span class="pre">sage.categories.category_with_axiom.CategoryWithAxiom</span></code></a></p>
<p>The category of finite posets i.e. finite sets with a partial
order structure.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FinitePosets</span><span class="p">()</span>
<span class="go">Category of finite posets</span>
<span class="gp">sage: </span><span class="n">FinitePosets</span><span class="p">()</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of posets, Category of finite sets]</span>
<span class="gp">sage: </span><span class="n">FinitePosets</span><span class="p">()</span><span class="o">.</span><span class="n">example</span><span class="p">()</span>
<span class="go">NotImplemented</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="posets.html#sage.categories.posets.Posets" title="sage.categories.posets.Posets"><code class="xref py py-class docutils literal"><span class="pre">Posets</span></code></a>, <a class="reference external" href="../../../combinat/sage/combinat/posets/posets.html#sage.combinat.posets.posets.Poset" title="(in Sage Reference Manual: Combinatorics v8.0)"><code class="xref py py-func docutils literal"><span class="pre">Poset()</span></code></a></p>
</div>
<dl class="class">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods">
<em class="property">class </em><code class="descname">ParentMethods</code><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.antichains">
<code class="descname">antichains</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.antichains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all antichains of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span><span class="o">.</span><span class="n">antichains</span><span class="p">();</span> <span class="n">A</span>
<span class="go">Set of antichains of Finite lattice containing 5 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[[], [0], [1], [1, 2], [1, 3], [2], [3], [4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling">
<code class="descname">birational_free_labelling</code><span class="sig-paren">(</span><em>linear_extension=None</em>, <em>prefix='x'</em>, <em>base_field=None</em>, <em>reduced=False</em>, <em>addvars=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the birational free labelling of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>Let us hold back defining this, and introduce birational
toggles and birational rowmotion first. These notions have
been introduced in <a class="reference internal" href="../../../references/index.html#ep2013" id="id1">[EP2013]</a> as generalizations of the notions
of toggles (<code class="xref py py-meth docutils literal"><span class="pre">order_ideal_toggle()</span></code>) and <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal"><span class="pre">rowmotion</span></code></a> on order ideals of a finite poset. They
have been studied further in <a class="reference internal" href="../../../references/index.html#gr2013" id="id2">[GR2013]</a>.</p>
<p>Let <span class="math">\(\mathbf{K}\)</span> be a field, and <span class="math">\(P\)</span> be a finite poset. Let
<span class="math">\(\widehat{P}\)</span> denote the poset obtained from <span class="math">\(P\)</span> by adding a
new element <span class="math">\(1\)</span> which is greater than all existing elements
of <span class="math">\(P\)</span>, and a new element <span class="math">\(0\)</span> which is smaller than all
existing elements of <span class="math">\(P\)</span> and <span class="math">\(1\)</span>. Now, a <span class="math">\(\mathbf{K}\)</span>-<em>labelling
of</em> <span class="math">\(P\)</span> will mean any function from <span class="math">\(\widehat{P}\)</span> to <span class="math">\(\mathbf{K}\)</span>.
The image of an element <span class="math">\(v\)</span> of <span class="math">\(\widehat{P}\)</span> under this labelling
will be called the <em>label</em> of this labelling at <span class="math">\(v\)</span>. The set
of all <span class="math">\(\mathbf{K}\)</span>-labellings of <span class="math">\(P\)</span> is clearly
<span class="math">\(\mathbf{K}^{\widehat{P}}\)</span>.</p>
<p>For any <span class="math">\(v \in P\)</span>, we now define a rational map
<span class="math">\(T_v : \mathbf{K}^{\widehat{P}} \dashrightarrow
\mathbf{K}^{\widehat{P}}\)</span> as follows: For every <span class="math">\(f \in
\mathbf{K}^{\widehat{P}}\)</span>, the image <span class="math">\(T_v f\)</span> should send every
element <span class="math">\(u \in \widehat{P}\)</span> distinct from <span class="math">\(v\)</span> to <span class="math">\(f(u)\)</span> (so the
labels at all <span class="math">\(u \neq v\)</span> don&#8217;t change), while <span class="math">\(v\)</span> is sent to</p>
<div class="math">
\[\frac{1}{f(v)} \cdot
\frac{\sum_{u \lessdot v} f(u)}
{\sum_{u \gtrdot v} \frac{1}{f(u)}}\]</div>
<p>(both sums are over all <span class="math">\(u \in \widehat{P}\)</span> satisfying the
respectively given conditions). Here, <span class="math">\(\lessdot\)</span> and <span class="math">\(\gtrdot\)</span>
mean (respectively) &#8220;covered by&#8221; and &#8220;covers&#8221;, interpreted with
respect to the poset <span class="math">\(\widehat{P}\)</span>. This rational map <span class="math">\(T_v\)</span>
is an involution and is called the <em>(birational)</em> <span class="math">\(v\)</span>-<em>toggle</em>; see
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle"><code class="xref py py-meth docutils literal"><span class="pre">birational_toggle()</span></code></a> for its implementation.</p>
<p>Now, <em>birational rowmotion</em> is defined as the composition
<span class="math">\(T_{v_1} \circ T_{v_2} \circ \cdots \circ T_{v_n}\)</span>, where
<span class="math">\((v_1, v_2, \ldots, v_n)\)</span> is a linear extension of <span class="math">\(P\)</span>
(written as a linear ordering of the elements of <span class="math">\(P\)</span>). This
is a rational map
<span class="math">\(\mathbf{K}^{\widehat{P}} \dashrightarrow \mathbf{K}^{\widehat{P}}\)</span>
which does not depend on the choice of the linear extension;
it is denoted by <span class="math">\(R\)</span>. See <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion"><code class="xref py py-meth docutils literal"><span class="pre">birational_rowmotion()</span></code></a> for
its implementation.</p>
<p>The definitions of birational toggles and birational
rowmotion extend to the case of <span class="math">\(\mathbf{K}\)</span> being any semifield
rather than necessarily a field (although it becomes less
clear what constitutes a rational map in this generality).
The most useful case is that of the <a class="reference external" href="../../../semirings/sage/rings/semirings/tropical_semiring.html#sage.rings.semirings.tropical_semiring.TropicalSemiring" title="(in Sage Reference Manual: Standard Semirings v8.0)"><code class="xref py py-class docutils literal"><span class="pre">tropical</span> <span class="pre">semiring</span></code></a>,
in which case birational rowmotion relates to classical
constructions such as promotion of rectangular semistandard
Young tableaux (page 5 of <a class="reference internal" href="../../../references/index.html#ep2013b" id="id3">[EP2013b]</a> and future work, via the
related notion of birational <em>promotion</em>) and rowmotion on
order ideals of the poset (<a class="reference internal" href="../../../references/index.html#ep2013" id="id4">[EP2013]</a>).</p>
<p>The <em>birational free labelling</em> is a special labelling
defined for every finite poset <span class="math">\(P\)</span> and every linear extension
<span class="math">\((v_1, v_2, \ldots, v_n)\)</span> of <span class="math">\(P\)</span>. It is given by sending
every element <span class="math">\(v_i\)</span> in <span class="math">\(P\)</span> to <span class="math">\(x_i\)</span>, sending the element <span class="math">\(0\)</span>
of <span class="math">\(\widehat{P}\)</span> to <span class="math">\(a\)</span>, and sending the element <span class="math">\(1\)</span> of
<span class="math">\(\widehat{P}\)</span> to <span class="math">\(b\)</span>, where the ground field <span class="math">\(\mathbf{K}\)</span> is the
field of rational functions in <span class="math">\(n+2\)</span> indeterminates
<span class="math">\(a, x_1, x_2, \ldots, x_n, b\)</span> over <span class="math">\(\mathbb Q\)</span>.</p>
<p>In Sage, a labelling <span class="math">\(f\)</span> of a poset <span class="math">\(P\)</span> is encoded as a
<span class="math">\(4\)</span>-tuple <span class="math">\((\mathbf{K}, d, u, v)\)</span>, where <span class="math">\(\mathbf{K}\)</span> is the
ground field of the labelling (i. e., its target), <span class="math">\(d\)</span> is the
dictionary containing the values of <span class="math">\(f\)</span> at the elements of
<span class="math">\(P\)</span> (the keys being the respective elements of <span class="math">\(P\)</span>), <span class="math">\(u\)</span>
is the label of <span class="math">\(f\)</span> at <span class="math">\(0\)</span>, and <span class="math">\(v\)</span> is the label of <span class="math">\(f\)</span> at
<span class="math">\(1\)</span>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The dictionary <span class="math">\(d\)</span> is labelled by the elements of <span class="math">\(P\)</span>.
If <span class="math">\(P\)</span> is a poset with <code class="docutils literal"><span class="pre">facade</span></code> option set to
<code class="docutils literal"><span class="pre">False</span></code>, these might not be what they seem to be!
(For instance, if
<code class="docutils literal"><span class="pre">P</span> <span class="pre">==</span> <span class="pre">Poset({1:</span> <span class="pre">[2,</span> <span class="pre">3]},</span> <span class="pre">facade=False)</span></code>, then the
value of <span class="math">\(d\)</span> at <span class="math">\(1\)</span> has to be accessed by <code class="docutils literal"><span class="pre">d[P(1)]</span></code>, not
by <code class="docutils literal"><span class="pre">d[1]</span></code>.)</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Dictionaries are mutable. They do compare correctly,
but are not hashable and need to be cloned to avoid
spooky action at a distance. Be careful!</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">linear_extension</span></code> &#8211; (default: the default linear
extension of <code class="docutils literal"><span class="pre">self</span></code>) a linear extension of <code class="docutils literal"><span class="pre">self</span></code>
(as a linear extension or as a list), or more generally
a list of all elements of all elements of <code class="docutils literal"><span class="pre">self</span></code> each
occurring exactly once</li>
<li><code class="docutils literal"><span class="pre">prefix</span></code> &#8211; (default: <code class="docutils literal"><span class="pre">'x'</span></code>) the prefix to name
the indeterminates corresponding to the elements of
<code class="docutils literal"><span class="pre">self</span></code> in the labelling (so, setting it to
<code class="docutils literal"><span class="pre">'frog'</span></code> will result in these indeterminates being
called <code class="docutils literal"><span class="pre">frog1,</span> <span class="pre">frog2,</span> <span class="pre">...,</span> <span class="pre">frogn</span></code> rather than
<code class="docutils literal"><span class="pre">x1,</span> <span class="pre">x2,</span> <span class="pre">...,</span> <span class="pre">xn</span></code>).</li>
<li><code class="docutils literal"><span class="pre">base_field</span></code> &#8211; (default: <code class="docutils literal"><span class="pre">QQ</span></code>) the base field to
be used instead of <span class="math">\(\QQ\)</span> to define the rational
function field over; this is not going to be the base
field of the labelling, because the latter will have
indeterminates adjoined!</li>
<li><code class="docutils literal"><span class="pre">reduced</span></code> &#8211; (default: <code class="docutils literal"><span class="pre">False</span></code>) if set to
<code class="docutils literal"><span class="pre">True</span></code>, the result will be the <em>reduced</em> birational
free labelling, which differs from the regular one by
having <span class="math">\(0\)</span> and <span class="math">\(1\)</span> both sent to <span class="math">\(1\)</span> instead of <span class="math">\(a\)</span> and
<span class="math">\(b\)</span> (the indeterminates <span class="math">\(a\)</span> and <span class="math">\(b\)</span> then also won&#8217;t
appear in the ground field)</li>
<li><code class="docutils literal"><span class="pre">addvars</span></code> &#8211; (default: <code class="docutils literal"><span class="pre">''</span></code>) a string containing
names of extra variables to be adjoined to the ground
field (these don&#8217;t have an effect on the labels)</li>
</ul>
<p>OUTPUT:</p>
<p>The birational free labelling of the poset <code class="docutils literal"><span class="pre">self</span></code> and the
linear extension <code class="docutils literal"><span class="pre">linear_extension</span></code>. Or, if <code class="docutils literal"><span class="pre">reduced</span></code>
is set to <code class="docutils literal"><span class="pre">True</span></code>, the reduced birational free labelling.</p>
<p>EXAMPLES:</p>
<p>We construct the birational free labelling on a simple
poset:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">();</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x2), (3, x3)]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x3), (3, x2)]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">reduced</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in x1, x2, x3, spam, eggs over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x3), (3, x2)]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;wut&quot;</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in wut1, wut2, wut3, spam, eggs over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, wut1), (2, wut3), (3, wut2)]</span>

<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">reduced</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b, spam, eggs over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x3), (3, x2)]</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="go">x3</span>
</pre></div>
</div>
<p>Illustrating the warning about facade:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">reduced</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;spam, eggs&quot;</span><span class="p">);</span> <span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b, spam, eggs over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">KeyError</span>: <span class="n">2</span>
<span class="gp">sage: </span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">P</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">x3</span>
</pre></div>
</div>
<p>Another poset:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">SSTPoset</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">lext</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">lext</span><span class="p">,</span> <span class="n">addvars</span><span class="o">=</span><span class="s2">&quot;ohai&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">l</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, x5, x6, x7, x8, b, ohai over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[([[1, 1], [2]], x1), ([[1, 1], [3]], x2), ([[1, 2], [2]], x3), ([[1, 2], [3]], x4),</span>
<span class="go"> ([[1, 3], [2]], x5), ([[1, 3], [3]], x6), ([[2, 2], [3]], x7), ([[2, 3], [3]], x8)]</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion"><code class="xref py py-meth docutils literal"><span class="pre">birational_rowmotion()</span></code></a>, <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle"><code class="xref py py-meth docutils literal"><span class="pre">birational_toggle()</span></code></a> and
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles"><code class="xref py py-meth docutils literal"><span class="pre">birational_toggles()</span></code></a> for more substantial examples of what
one can do with the birational free labelling.</p>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion">
<code class="descname">birational_rowmotion</code><span class="sig-paren">(</span><em>labelling</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_rowmotion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of applying birational rowmotion to the
<span class="math">\(\mathbf{K}\)</span>-labelling <code class="docutils literal"><span class="pre">labelling</span></code> of the poset <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>See the documentation of <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal"><span class="pre">birational_free_labelling()</span></code></a>
for a definition of birational rowmotion and
<span class="math">\(\mathbf{K}\)</span>-labellings and for an explanation of how
<span class="math">\(\mathbf{K}\)</span>-labellings are to be encoded to be understood
by Sage. This implementation allows <span class="math">\(\mathbf{K}\)</span> to be a
semifield, not just a field. Birational rowmotion is only a
rational map, so an exception (most likely, <code class="docutils literal"><span class="pre">ZeroDivisionError</span></code>)
will be thrown if the denominator is zero.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">labelling</span></code> &#8211; a <span class="math">\(\mathbf{K}\)</span>-labelling of <code class="docutils literal"><span class="pre">self</span></code> in the
sense as defined in the documentation of
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal"><span class="pre">birational_free_labelling()</span></code></a></li>
</ul>
<p>OUTPUT:</p>
<p>The image of the <span class="math">\(\mathbf{K}\)</span>-labelling <span class="math">\(f\)</span> under birational
rowmotion.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">lex</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">lex</span><span class="p">);</span> <span class="n">t</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x2), (3, x3), (4, x4)]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_rowmotion</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="n">t</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, x4, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, a*b/x4), (2, (x1*x2*b + x1*x3*b)/(x2*x4)),</span>
<span class="go"> (3, (x1*x2*b + x1*x3*b)/(x3*x4)), (4, (x2*b + x3*b)/x4)]</span>
</pre></div>
</div>
<p>A result of <a class="reference internal" href="../../../references/index.html#gr2013" id="id5">[GR2013]</a> states that applying birational rowmotion
<span class="math">\(n+m\)</span> times to a <span class="math">\(\mathbf{K}\)</span>-labelling <span class="math">\(f\)</span> of the poset
<span class="math">\([n] \times [m]\)</span> gives back <span class="math">\(f\)</span>. Let us check this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_rectangle_periodicity</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="go">....:     P = Posets.ChainPoset(n).product(Posets.ChainPoset(m))</span>
<span class="go">....:     t0 = P.birational_free_labelling(P)</span>
<span class="go">....:     t = t0</span>
<span class="go">....:     for i in range(k):</span>
<span class="go">....:         t = P.birational_rowmotion(t)</span>
<span class="go">....:     return t == t0</span>
<span class="gp">sage: </span><span class="n">test_rectangle_periodicity</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_rectangle_periodicity</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">test_rectangle_periodicity</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>While computations with the birational free labelling quickly
run out of memory due to the complexity of the rational
functions involved, it is computationally cheap to check
properties of birational rowmotion on examples in the tropical
semiring:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_rectangle_periodicity_tropical</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="go">....:     P = Posets.ChainPoset(n).product(Posets.ChainPoset(m))</span>
<span class="go">....:     TT = TropicalSemiring(ZZ)</span>
<span class="go">....:     t0 = (TT, {v: TT(floor(random()*100)) for v in P}, TT(0), TT(124))</span>
<span class="go">....:     t = t0</span>
<span class="go">....:     for i in range(k):</span>
<span class="go">....:         t = P.birational_rowmotion(t)</span>
<span class="go">....:     return t == t0</span>
<span class="gp">sage: </span><span class="n">test_rectangle_periodicity_tropical</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Tropicalization is also what relates birational rowmotion to
classical rowmotion on order ideals. In fact, if <span class="math">\(T\)</span> denotes
the <a class="reference external" href="../../../semirings/sage/rings/semirings/tropical_semiring.html#sage.rings.semirings.tropical_semiring.TropicalSemiring" title="(in Sage Reference Manual: Standard Semirings v8.0)"><code class="xref py py-class docutils literal"><span class="pre">tropical</span> <span class="pre">semiring</span></code></a> of
<span class="math">\(\ZZ\)</span> and <span class="math">\(P\)</span> is a finite poset, then we can define an embedding
<span class="math">\(\phi\)</span> from the set <span class="math">\(J(P)\)</span> of all order ideals of <span class="math">\(P\)</span> into the
set <span class="math">\(T^{\widehat{P}}\)</span> of all <span class="math">\(T\)</span>-labellings of <span class="math">\(P\)</span> by sending
every <span class="math">\(I \in J(P)\)</span> to the indicator function of <span class="math">\(I\)</span> extended by
the value <span class="math">\(1\)</span> at the element <span class="math">\(0\)</span> and the value <span class="math">\(0\)</span> at the
element <span class="math">\(1\)</span>. This map <span class="math">\(\phi\)</span> has the property that
<span class="math">\(R \circ \phi = \phi \circ r\)</span>, where <span class="math">\(R\)</span> denotes birational
rowmotion, and <span class="math">\(r\)</span> denotes <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal"><span class="pre">classical</span> <span class="pre">rowmotion</span></code></a>
on <span class="math">\(J(P)\)</span>. An example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">IntegerPartitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">TT</span> <span class="o">=</span> <span class="n">TropicalSemiring</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">indicator_labelling</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
<span class="go">....:     # send order ideal `I` to a `T`-labelling of `P`.</span>
<span class="go">....:     dct = {v: TT(v in I) for v in P}</span>
<span class="go">....:     return (TT, dct, TT(1), TT(0))</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">indicator_labelling</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion</span><span class="p">(</span><span class="n">I</span><span class="p">))</span>
<span class="go">....:     == P.birational_rowmotion(indicator_labelling(I))</span>
<span class="go">....:     for I in P.order_ideals_lattice(facade=True))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle">
<code class="descname">birational_toggle</code><span class="sig-paren">(</span><em>v</em>, <em>labelling</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of applying the birational <span class="math">\(v\)</span>-toggle <span class="math">\(T_v\)</span>
to the <span class="math">\(\mathbf{K}\)</span>-labelling <code class="docutils literal"><span class="pre">labelling</span></code> of the poset <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>See the documentation of <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal"><span class="pre">birational_free_labelling()</span></code></a>
for a definition of this toggle and of <span class="math">\(\mathbf{K}\)</span>-labellings as
well as an explanation of how <span class="math">\(\mathbf{K}\)</span>-labellings are to be
encoded to be understood by Sage. This implementation allows
<span class="math">\(\mathbf{K}\)</span> to be a semifield, not just a field. The birational
<span class="math">\(v\)</span>-toggle is only a rational map, so an exception (most
likely, <code class="docutils literal"><span class="pre">ZeroDivisionError</span></code>) will be thrown if the
denominator is zero.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">v</span></code> &#8211; an element of <code class="docutils literal"><span class="pre">self</span></code> (must have <code class="docutils literal"><span class="pre">self</span></code> as
parent if <code class="docutils literal"><span class="pre">self</span></code> is a <code class="docutils literal"><span class="pre">facade=False</span></code> poset)</li>
<li><code class="docutils literal"><span class="pre">labelling</span></code> &#8211; a <span class="math">\(\mathbf{K}\)</span>-labelling of <code class="docutils literal"><span class="pre">self</span></code> in the
sense as defined in the documentation of
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal"><span class="pre">birational_free_labelling()</span></code></a></li>
</ul>
<p>OUTPUT:</p>
<p>The <span class="math">\(\mathbf{K}\)</span>-labelling <span class="math">\(T_v f\)</span> of <code class="docutils literal"><span class="pre">self</span></code>, where <span class="math">\(f\)</span> is
<code class="docutils literal"><span class="pre">labelling</span></code>.</p>
<p>EXAMPLES:</p>
<p>Let us start with the birational free labelling of the
&#8220;V&#8221;-poset (the three-element poset with Hasse diagram looking
like a &#8220;V&#8221;):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">();</span> <span class="n">s</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x2), (3, x3)]</span>
</pre></div>
</div>
<p>The image of <span class="math">\(s\)</span> under the <span class="math">\(1\)</span>-toggle <span class="math">\(T_1\)</span> is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="n">s1</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, a*x2*x3/(x1*x2 + x1*x3)), (2, x2), (3, x3)]</span>
</pre></div>
</div>
<p>Now let us apply the <span class="math">\(2\)</span>-toggle <span class="math">\(T_2\)</span> (to the old <code class="docutils literal"><span class="pre">s</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s2</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="n">s2</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, x1), (2, x1*b/x2), (3, x3)]</span>
</pre></div>
</div>
<p>On the other hand, we can also apply <span class="math">\(T_2\)</span> to the image of <span class="math">\(s\)</span>
under <span class="math">\(T_1\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s12</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">s1</span><span class="p">);</span> <span class="n">s12</span>
<span class="go">(Fraction Field of Multivariate Polynomial Ring in a, x1, x2, x3, b over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> a,</span>
<span class="go"> b)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s12</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, a*x2*x3/(x1*x2 + x1*x3)), (2, a*x3*b/(x1*x2 + x1*x3)), (3, x3)]</span>
</pre></div>
</div>
<p>Each toggle is an involution:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="o">==</span> <span class="n">s</span>
<span class="go">....:      for i in V )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can also start with a less generic labelling:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">(Rational Field, {...}, 2, 10)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 28/13), (2, 6), (3, 7)]</span>
<span class="gp">sage: </span><span class="n">t13</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span> <span class="n">t13</span>
<span class="go">(Rational Field, {...}, 2, 10)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t13</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 28/13), (2, 6), (3, 40/13)]</span>
</pre></div>
</div>
<p>However, labellings have to be sufficiently generic, lest
denominators vanish:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">rational division by zero</span>
</pre></div>
</div>
<p>We don&#8217;t get into zero-division issues in the tropical
semiring (unless the zero of the tropical semiring appears
in the labelling):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">TT</span> <span class="o">=</span> <span class="n">TropicalSemiring</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">3</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">)},</span> <span class="n">TT</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">TT</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 6, 0)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 8), (2, 4), (3, 1)]</span>
<span class="gp">sage: </span><span class="n">t12</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span> <span class="n">t12</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 6, 0)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t12</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 8), (2, 4), (3, 1)]</span>
<span class="gp">sage: </span><span class="n">t123</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">t12</span><span class="p">);</span> <span class="n">t123</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 6, 0)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t123</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 8), (2, 4), (3, 7)]</span>
</pre></div>
</div>
<p>We turn to more interesting posets. Here is the <span class="math">\(6\)</span>-element
poset arising from the weak order on <span class="math">\(S_3\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">SymmetricGroupWeakOrderPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">))</span>
<span class="go">[&#39;123&#39;, &#39;132&#39;, &#39;213&#39;, &#39;231&#39;, &#39;312&#39;, &#39;321&#39;]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;123&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="s1">&#39;132&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;213&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;231&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;321&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;312&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">)},</span> <span class="n">TT</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 7, 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;123&#39;, 6), (&#39;132&#39;, 2), (&#39;213&#39;, 3), (&#39;231&#39;, 1), (&#39;312&#39;, 2), (&#39;321&#39;, 1)]</span>
<span class="gp">sage: </span><span class="n">t13</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="s1">&#39;213&#39;</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span> <span class="n">t13</span>
<span class="go">(Tropical semiring over Rational Field, {...}, 7, 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t13</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;123&#39;, 6), (&#39;132&#39;, 2), (&#39;213&#39;, 4), (&#39;231&#39;, 1), (&#39;312&#39;, 2), (&#39;321&#39;, 1)]</span>
</pre></div>
</div>
<p>Let us verify on this example some basic properties of
toggles. First of all, again let us check that <span class="math">\(T_v\)</span> is an
involution for every <span class="math">\(v\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span> <span class="o">==</span> <span class="n">t</span>
<span class="go">....:      for v in P )</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Furthermore, two toggles <span class="math">\(T_v\)</span> and <span class="math">\(T_w\)</span> commute unless
one of <span class="math">\(v\)</span> or <span class="math">\(w\)</span> covers the other:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">or</span> <span class="n">P</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="go">....:      or P.birational_toggle(v, P.birational_toggle(w, t))</span>
<span class="go">....:         == P.birational_toggle(w, P.birational_toggle(v, t))</span>
<span class="go">....:      for v in P for w in P )</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles">
<code class="descname">birational_toggles</code><span class="sig-paren">(</span><em>vs</em>, <em>labelling</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_toggles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of applying a sequence of birational
toggles (specified by <code class="docutils literal"><span class="pre">vs</span></code>) to the <span class="math">\(\mathbf{K}\)</span>-labelling
<code class="docutils literal"><span class="pre">labelling</span></code> of the poset <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>See the documentation of <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal"><span class="pre">birational_free_labelling()</span></code></a>
for a definition of birational toggles and <span class="math">\(\mathbf{K}\)</span>-labellings
and for an explanation of how <span class="math">\(\mathbf{K}\)</span>-labellings are to be
encoded to be understood by Sage. This implementation allows
<span class="math">\(\mathbf{K}\)</span> to be a semifield, not just a field. The birational
<span class="math">\(v\)</span>-toggle is only a rational map, so an exception (most
likely, <code class="docutils literal"><span class="pre">ZeroDivisionError</span></code>) will be thrown if the
denominator is zero.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">vs</span></code> &#8211; an iterable comprising elements of <code class="docutils literal"><span class="pre">self</span></code>
(which must have <code class="docutils literal"><span class="pre">self</span></code> as parent if <code class="docutils literal"><span class="pre">self</span></code> is a
<code class="docutils literal"><span class="pre">facade=False</span></code> poset)</li>
<li><code class="docutils literal"><span class="pre">labelling</span></code> &#8211; a <span class="math">\(\mathbf{K}\)</span>-labelling of <code class="docutils literal"><span class="pre">self</span></code> in the
sense as defined in the documentation of
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling" title="sage.categories.finite_posets.FinitePosets.ParentMethods.birational_free_labelling"><code class="xref py py-meth docutils literal"><span class="pre">birational_free_labelling()</span></code></a></li>
</ul>
<p>OUTPUT:</p>
<p>The <span class="math">\(\mathbf{K}\)</span>-labelling <span class="math">\(T_{v_n} T_{v_{n-1}} \cdots T_{v_1} f\)</span>
of <code class="docutils literal"><span class="pre">self</span></code>, where <span class="math">\(f\)</span> is <code class="docutils literal"><span class="pre">labelling</span></code> and
<span class="math">\((v_1, v_2, \ldots, v_n)\)</span> is <code class="docutils literal"><span class="pre">vs</span></code> (written as list).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">SymmetricGroupBruhatOrderPoset</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">))</span>
<span class="go">[&#39;123&#39;, &#39;132&#39;, &#39;213&#39;, &#39;231&#39;, &#39;312&#39;, &#39;321&#39;]</span>
<span class="gp">sage: </span><span class="n">TT</span> <span class="o">=</span> <span class="n">TropicalSemiring</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;123&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="s1">&#39;132&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;213&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;231&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;321&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;312&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="p">(</span><span class="mi">2</span><span class="p">)},</span> <span class="n">TT</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">TT</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">tA</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">([</span><span class="s1">&#39;123&#39;</span><span class="p">,</span> <span class="s1">&#39;231&#39;</span><span class="p">,</span> <span class="s1">&#39;312&#39;</span><span class="p">],</span> <span class="n">t</span><span class="p">);</span> <span class="n">tA</span>
<span class="go">(Tropical semiring over Integer Ring, {...}, 7, 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">tA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;123&#39;, 6), (&#39;132&#39;, 2), (&#39;213&#39;, 3), (&#39;231&#39;, 2), (&#39;312&#39;, 1), (&#39;321&#39;, 1)]</span>
<span class="gp">sage: </span><span class="n">tAB</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">([</span><span class="s1">&#39;132&#39;</span><span class="p">,</span> <span class="s1">&#39;213&#39;</span><span class="p">,</span> <span class="s1">&#39;321&#39;</span><span class="p">],</span> <span class="n">tA</span><span class="p">);</span> <span class="n">tAB</span>
<span class="go">(Tropical semiring over Integer Ring, {...}, 7, 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">tAB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;123&#39;, 6), (&#39;132&#39;, 6), (&#39;213&#39;, 5), (&#39;231&#39;, 2), (&#39;312&#39;, 1), (&#39;321&#39;, 1)]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">Qx</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">Qx</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">Qx</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">},</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)),</span> <span class="n">t</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">(Fraction Field of Univariate Polynomial Ring in x over Rational Field,</span>
<span class="go"> {...},</span>
<span class="go"> 1,</span>
<span class="go"> 1)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, (x^2 + x)/(x^2 + x + 1)), (2, (x^3 + x^2)/(x^2 + x + 1)), (3, x^4/(x^2 + x + 1)), (4, 1)]</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)),</span> <span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">t2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 1/x^2), (2, (x^2 + x + 1)/x^4), (3, (x^2 + x + 1)/(x^3 + x^2)), (4, (x^2 + x + 1)/x^3)]</span>
</pre></div>
</div>
<p>Facade set to <code class="docutils literal"><span class="pre">False</span></code> works:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">],</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">],</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]},</span> <span class="n">facade</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">lex</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">birational_free_labelling</span><span class="p">(</span><span class="n">linear_extension</span><span class="o">=</span><span class="n">lex</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">birational_toggles</span><span class="p">([</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">P</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)],</span> <span class="n">t</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(x, a*x2*x3/(x1*x2 + x1*x3)), (y, a*x3*x4/(x1*x2 + x1*x3)), (w, x3), (z, x4)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.directed_subsets">
<code class="descname">directed_subsets</code><span class="sig-paren">(</span><em>direction</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.directed_subsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the order filters (resp. order ideals) of <code class="docutils literal"><span class="pre">self</span></code>, as lists.</p>
<p>If <code class="docutils literal"><span class="pre">direction</span></code> is &#8216;up&#8217;, returns the order filters (upper sets).</p>
<p>If <code class="docutils literal"><span class="pre">direction</span></code> is &#8216;down&#8217;, returns the order ideals (lower sets).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">direction</span></code> &#8211; &#8216;up&#8217; or &#8216;down&#8217;</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)),</span> <span class="n">facade</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">directed_subsets</span><span class="p">(</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="go">[[], [1, 2, 4, 3, 6, 12], [2, 4, 3, 6, 12], [2, 4, 6, 12], [3, 6, 12], [4, 3, 6, 12], [4, 6, 12], [4, 12], [6, 12], [12]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_lattice">
<code class="descname">is_lattice</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether this poset is both a meet and a join semilattice.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[</span><span class="mi">7</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[]])</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lattice</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span><span class="mi">0</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_lattice</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism">
<code class="descname">is_poset_isomorphism</code><span class="sig-paren">(</span><em>f</em>, <em>codomain</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <span class="math">\(f\)</span> is an isomorphism of posets from
<code class="docutils literal"><span class="pre">self</span></code> to <code class="docutils literal"><span class="pre">codomain</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">f</span></code> &#8211; a function from <code class="docutils literal"><span class="pre">self</span></code> to <code class="docutils literal"><span class="pre">codomain</span></code></li>
<li><code class="docutils literal"><span class="pre">codomain</span></code> &#8211; a poset</li>
</ul>
<p>EXAMPLES:</p>
<p>We build the poset <span class="math">\(D\)</span> of divisors of 30, and check that
it is isomorphic to the boolean lattice <span class="math">\(B\)</span> of the subsets
of <span class="math">\(\{2,3,5\}\)</span> ordered by inclusion, via the reverse
function <span class="math">\(f: B \to D, b \mapsto \prod_{x\in b} x\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])],</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">D</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_isomorphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>On the other hand, <span class="math">\(f\)</span> is not an isomorphism to the chain
of divisors of 30, ordered by usual comparison:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">P</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_isomorphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A non surjective case:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])],</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">D</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_isomorphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A non injective case:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])],</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">D</span><span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_isomorphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">since <code class="docutils literal"><span class="pre">D</span></code> and <code class="docutils literal"><span class="pre">B</span></code> are not facade posets, <code class="docutils literal"><span class="pre">f</span></code> is
responsible for the conversions between integers and subsets to
elements of <code class="docutils literal"><span class="pre">D</span></code> and <code class="docutils literal"><span class="pre">B</span></code> and back.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="finite_lattice_posets.html#sage.categories.finite_lattice_posets.FiniteLatticePosets.ParentMethods.is_lattice_morphism" title="sage.categories.finite_lattice_posets.FiniteLatticePosets.ParentMethods.is_lattice_morphism"><code class="xref py py-meth docutils literal"><span class="pre">FiniteLatticePosets.ParentMethods.is_lattice_morphism()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_morphism">
<code class="descname">is_poset_morphism</code><span class="sig-paren">(</span><em>f</em>, <em>codomain</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_morphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <span class="math">\(f\)</span> is a morphism of posets from <code class="docutils literal"><span class="pre">self</span></code>
to <code class="docutils literal"><span class="pre">codomain</span></code>, that is</p>
<div class="math">
\[x\leq y \Longrightarrow f(x) \leq f(y)\]</div>
<p>for all <span class="math">\(x\)</span> and <span class="math">\(y\)</span> in <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">f</span></code> &#8211; a function from <code class="docutils literal"><span class="pre">self</span></code> to <code class="docutils literal"><span class="pre">codomain</span></code></li>
<li><code class="docutils literal"><span class="pre">codomain</span></code> &#8211; a poset</li>
</ul>
<p>EXAMPLES:</p>
<p>We build the boolean lattice of the subsets of
<span class="math">\(\{2,3,5,6\}\)</span> and the lattice of divisors of <span class="math">\(30\)</span>, and
check that the map <span class="math">\(b \mapsto \gcd(\prod_{x\in b} x, 30)\)</span>
is a morphism of posets:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;divides&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Subsets</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])],</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">D</span><span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">since <code class="docutils literal"><span class="pre">D</span></code> and <code class="docutils literal"><span class="pre">B</span></code> are not facade posets, <code class="docutils literal"><span class="pre">f</span></code> is responsible
for the conversions between integers and subsets to elements of
<code class="docutils literal"><span class="pre">D</span></code> and <code class="docutils literal"><span class="pre">B</span></code> and back.</p>
</div>
<p><span class="math">\(f\)</span> is also a morphism of posets to the chain of divisors
of 30, ordered by usual comparison:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">divisors</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">))</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">P</span><span class="p">(</span><span class="n">gcd</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="mi">30</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_poset_morphism</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>FIXME: should this be <code class="docutils literal"><span class="pre">is_order_preserving_morphism</span></code>?</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism" title="sage.categories.finite_posets.FinitePosets.ParentMethods.is_poset_isomorphism"><code class="xref py py-meth docutils literal"><span class="pre">is_poset_isomorphism()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.is_selfdual">
<code class="descname">is_selfdual</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.is_selfdual" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether this poset is <em>self-dual</em>, that is
isomorphic to its dual poset.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]),</span><span class="n">cover_relations</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_selfdual</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]),</span><span class="n">cover_relations</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">is_selfdual</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<ul class="last simple">
<li>Stronger properties: <code class="xref py py-meth docutils literal"><span class="pre">is_orthocomplemented()</span></code></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.order_filter_generators">
<code class="descname">order_filter_generators</code><span class="sig-paren">(</span><em>filter</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_filter_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Generators for an order filter</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">filter</span></code> &#8211; an order filter of <code class="docutils literal"><span class="pre">self</span></code>, as a list (or iterable)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">Subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_filter</span><span class="p">([</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">])]);</span> <span class="n">I</span>
<span class="go">[{2, 3}, {1}, {1, 2}, {1, 3}, {1, 2, 3}]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_filter_generators</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">{{2, 3}, {1}}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators" title="sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators"><code class="xref py py-meth docutils literal"><span class="pre">order_ideal_generators()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_complement_generators">
<code class="descname">order_ideal_complement_generators</code><span class="sig-paren">(</span><em>antichain</em>, <em>direction='up'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_complement_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Panyushev complement of the antichain
<code class="docutils literal"><span class="pre">antichain</span></code>.</p>
<p>Given an antichain <span class="math">\(A\)</span> of a poset <span class="math">\(P\)</span>, the Panyushev
complement of <span class="math">\(A\)</span> is defined to be the antichain consisting
of the minimal elements of the order filter <span class="math">\(B\)</span>, where <span class="math">\(B\)</span>
is the (set-theoretic) complement of the order ideal of
<span class="math">\(P\)</span> generated by <span class="math">\(A\)</span>.</p>
<p>Setting the optional keyword variable <code class="docutils literal"><span class="pre">direction</span></code> to
<code class="docutils literal"><span class="pre">'down'</span></code> leads to the inverse Panyushev complement being
computed instead of the Panyushev complement. The inverse
Panyushev complement of an antichain <span class="math">\(A\)</span> is the antichain
whose Panyushev complement is <span class="math">\(A\)</span>. It can be found as the
antichain consisting of the maximal elements of the order
ideal <span class="math">\(C\)</span>, where <span class="math">\(C\)</span> is the (set-theoretic) complement of
the order filter of <span class="math">\(P\)</span> generated by <span class="math">\(A\)</span>.</p>
<p><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><code class="xref py py-meth docutils literal"><span class="pre">panyushev_complement()</span></code></a> is an alias for this method.</p>
<p>Panyushev complementation is related (actually, isomorphic)
to rowmotion (<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal"><span class="pre">rowmotion()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">antichain</span></code> &#8211; an antichain of <code class="docutils literal"><span class="pre">self</span></code>, as a list (or
iterable), or, more generally, generators of an order ideal
(resp. order filter)</li>
<li><code class="docutils literal"><span class="pre">direction</span></code> &#8211; &#8216;up&#8217; or &#8216;down&#8217; (default: &#8216;up&#8217;)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the generating antichain of the complement order filter
(resp. order ideal) of the order ideal (resp. order filter)
generated by the antichain <code class="docutils literal"><span class="pre">antichain</span></code></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">{3}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">set()</span>

<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">{1, 2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">set()</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is a brute force implementation, building the
order ideal generated by the antichain, and searching
for order filter generators of its complement</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators">
<code class="descname">order_ideal_generators</code><span class="sig-paren">(</span><em>ideal</em>, <em>direction='down'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideal_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the antichain of (minimal) generators of the order
ideal (resp. order filter) <code class="docutils literal"><span class="pre">ideal</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">ideal</span></code> &#8211; an order ideal <span class="math">\(I\)</span> (resp. order filter)
of <code class="docutils literal"><span class="pre">self</span></code>, as a list (or iterable); this should be
an order ideal if <code class="docutils literal"><span class="pre">direction</span></code> is set to <code class="docutils literal"><span class="pre">'down'</span></code>,
and an order filter if <code class="docutils literal"><span class="pre">direction</span></code> is set to
<code class="docutils literal"><span class="pre">'up'</span></code>.</li>
<li><code class="docutils literal"><span class="pre">direction</span></code> &#8211; <code class="docutils literal"><span class="pre">'up'</span></code> or <code class="docutils literal"><span class="pre">'down'</span></code> (default:
<code class="docutils literal"><span class="pre">'down'</span></code>).</li>
</ul>
<p>The antichain of (minimal) generators of an order ideal
<span class="math">\(I\)</span> in a poset <span class="math">\(P\)</span> is the set of all minimal elements of
<span class="math">\(P\)</span>. In the case of an order filter, the definition is
similar, but with &#8220;maximal&#8221; used instead of &#8220;minimal&#8221;.</p>
<p>EXAMPLES:</p>
<p>We build the boolean lattice of all subsets of <span class="math">\(\{1,2,3\}\)</span>
ordered by inclusion, and compute an order ideal there:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">((</span><span class="n">Subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;issubset&quot;</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideal</span><span class="p">([</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">])]);</span> <span class="n">I</span>
<span class="go">[{}, {3}, {2}, {2, 3}, {1}, {1, 2}]</span>
</pre></div>
</div>
<p>Then, we retrieve the generators of this ideal:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_generators</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">{{1, 2}, {2, 3}}</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">direction</span></code> is &#8216;up&#8217;, then this instead computes
the minimal generators for an order filter:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_filter</span><span class="p">([</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">])]);</span> <span class="n">I</span>
<span class="go">[{2, 3}, {1}, {1, 2}, {1, 3}, {1, 2, 3}]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_generators</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>
<span class="go">{{2, 3}, {1}}</span>
</pre></div>
</div>
<p>Complexity: <span class="math">\(O(n+m)\)</span> where <span class="math">\(n\)</span> is the cardinality of <span class="math">\(I\)</span>,
and <span class="math">\(m\)</span> the number of upper covers of elements of <span class="math">\(I\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideals_lattice">
<code class="descname">order_ideals_lattice</code><span class="sig-paren">(</span><em>as_ideals=True</em>, <em>facade=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.order_ideals_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the lattice of order ideals of a poset <code class="docutils literal"><span class="pre">self</span></code>,
ordered by inclusion.</p>
<p>The lattice of order ideals of a poset <span class="math">\(P\)</span> is usually
denoted by <span class="math">\(J(P)\)</span>. Its underlying set is the set of order
ideals of <span class="math">\(P\)</span>, and its partial order is given by
inclusion.</p>
<p>The order ideals of <span class="math">\(P\)</span> are in a canonical bijection
with the antichains of <span class="math">\(P\)</span>. The bijection maps every
order ideal to the antichain formed by its maximal
elements. By setting the <code class="docutils literal"><span class="pre">as_ideals</span></code> keyword variable to
<code class="docutils literal"><span class="pre">False</span></code>, one can make this method apply this bijection
before returning the lattice.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">as_ideals</span></code> &#8211; Boolean, if <code class="docutils literal"><span class="pre">True</span></code> (default) returns
a poset on the set of order ideals, otherwise on the set
of antichains</li>
<li><code class="docutils literal"><span class="pre">facade</span></code> &#8211; Boolean or <code class="docutils literal"><span class="pre">None</span></code> (default). Whether to
return a facade lattice or not. By default return facade
lattice if the poset is a facade poset.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Posets</span><span class="o">.</span><span class="n">PentagonPoset</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[0, 1], [0, 2], [1, 4], [2, 3], [3, 4]]</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideals_lattice</span><span class="p">();</span> <span class="n">J</span>
<span class="go">Finite lattice containing 8 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
<span class="go">[{}, {0}, {0, 2}, {0, 2, 3}, {0, 1}, {0, 1, 2}, {0, 1, 2, 3}, {0, 1, 2, 3, 4}]</span>
</pre></div>
</div>
<p>As a lattice on antichains:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">J2</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">order_ideals_lattice</span><span class="p">(</span><span class="bp">False</span><span class="p">);</span> <span class="n">J2</span>
<span class="go">Finite lattice containing 8 elements</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">J2</span><span class="p">)</span>
<span class="go">[(0,), (1, 2), (1, 3), (1,), (2,), (3,), (4,), ()]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement">
<code class="descname">panyushev_complement</code><span class="sig-paren">(</span><em>antichain</em>, <em>direction='up'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Panyushev complement of the antichain
<code class="docutils literal"><span class="pre">antichain</span></code>.</p>
<p>Given an antichain <span class="math">\(A\)</span> of a poset <span class="math">\(P\)</span>, the Panyushev
complement of <span class="math">\(A\)</span> is defined to be the antichain consisting
of the minimal elements of the order filter <span class="math">\(B\)</span>, where <span class="math">\(B\)</span>
is the (set-theoretic) complement of the order ideal of
<span class="math">\(P\)</span> generated by <span class="math">\(A\)</span>.</p>
<p>Setting the optional keyword variable <code class="docutils literal"><span class="pre">direction</span></code> to
<code class="docutils literal"><span class="pre">'down'</span></code> leads to the inverse Panyushev complement being
computed instead of the Panyushev complement. The inverse
Panyushev complement of an antichain <span class="math">\(A\)</span> is the antichain
whose Panyushev complement is <span class="math">\(A\)</span>. It can be found as the
antichain consisting of the maximal elements of the order
ideal <span class="math">\(C\)</span>, where <span class="math">\(C\)</span> is the (set-theoretic) complement of
the order filter of <span class="math">\(P\)</span> generated by <span class="math">\(A\)</span>.</p>
<p><a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><code class="xref py py-meth docutils literal"><span class="pre">panyushev_complement()</span></code></a> is an alias for this method.</p>
<p>Panyushev complementation is related (actually, isomorphic)
to rowmotion (<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal"><span class="pre">rowmotion()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">antichain</span></code> &#8211; an antichain of <code class="docutils literal"><span class="pre">self</span></code>, as a list (or
iterable), or, more generally, generators of an order ideal
(resp. order filter)</li>
<li><code class="docutils literal"><span class="pre">direction</span></code> &#8211; &#8216;up&#8217; or &#8216;down&#8217; (default: &#8216;up&#8217;)</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the generating antichain of the complement order filter
(resp. order ideal) of the order ideal (resp. order filter)
generated by the antichain <code class="docutils literal"><span class="pre">antichain</span></code></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">{3}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">set()</span>

<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">{1, 2}</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">order_ideal_complement_generators</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;down&quot;</span><span class="p">)</span>
<span class="go">set()</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is a brute force implementation, building the
order ideal generated by the antichain, and searching
for order filter generators of its complement</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbit_iter">
<code class="descname">panyushev_orbit_iter</code><span class="sig-paren">(</span><em>antichain</em>, <em>element_constructor=&lt;type 'set'&gt;</em>, <em>stop=True</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbit_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the Panyushev orbit of an antichain
<code class="docutils literal"><span class="pre">antichain</span></code> of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>The Panyushev orbit of an antichain is its orbit under
Panyushev complementation (see
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><code class="xref py py-meth docutils literal"><span class="pre">panyushev_complement()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">antichain</span></code> &#8211; an antichain of <code class="docutils literal"><span class="pre">self</span></code>, given as an
iterable.</li>
<li><code class="docutils literal"><span class="pre">element_constructor</span></code> (defaults to <code class="docutils literal"><span class="pre">set</span></code>) &#8211; a type
constructor (<code class="docutils literal"><span class="pre">set</span></code>, <code class="docutils literal"><span class="pre">tuple</span></code>, <code class="docutils literal"><span class="pre">list</span></code>, <code class="docutils literal"><span class="pre">frozenset</span></code>,
<code class="docutils literal"><span class="pre">iter</span></code>, etc.) which is to be applied to the antichains
before they are yielded.</li>
<li><code class="docutils literal"><span class="pre">stop</span></code> &#8211; a Boolean (default: <code class="docutils literal"><span class="pre">True</span></code>) determining
whether the iterator should stop once it completes its
cycle (this happens when it is set to <code class="docutils literal"><span class="pre">True</span></code>) or go on
forever (this happens when it is set to <code class="docutils literal"><span class="pre">False</span></code>).</li>
<li><code class="docutils literal"><span class="pre">check</span></code> &#8211; a Boolean (default: <code class="docutils literal"><span class="pre">True</span></code>) determining
whether <code class="docutils literal"><span class="pre">antichain</span></code> should be checked for being an
antichain.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an iterator over the orbit of the antichain <code class="docutils literal"><span class="pre">antichain</span></code>
under Panyushev complementation. This iterator <span class="math">\(I\)</span> has the
property that <code class="docutils literal"><span class="pre">I[0]</span> <span class="pre">==</span> <span class="pre">antichain</span></code> and each <span class="math">\(i\)</span> satisfies
<code class="docutils literal"><span class="pre">self.order_ideal_complement_generators(I[i])</span> <span class="pre">==</span> <span class="pre">I[i+1]</span></code>,
where <code class="docutils literal"><span class="pre">I[i+1]</span></code> has to be understood as <code class="docutils literal"><span class="pre">I[0]</span></code> if it is
undefined.
The entries <code class="docutils literal"><span class="pre">I[i]</span></code> are sets by default, but depending on
the optional keyword variable <code class="docutils literal"><span class="pre">element_constructors</span></code>
they can also be tuples, lists etc.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}, {3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[{1, 2}, {3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">[{1, 2}, {3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[1, 2], [3], []]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">))</span>
<span class="go">[frozenset({1, 2}), frozenset({3}), frozenset()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[(1, 2), (3,), ()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">([]))</span>
<span class="go">[set()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">Piter</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbit_iter</span><span class="p">([</span><span class="mi">2</span><span class="p">],</span> <span class="n">stop</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{3}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{2}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{3}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbits">
<code class="descname">panyushev_orbits</code><span class="sig-paren">(</span><em>element_constructor=&lt;type 'set'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_orbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Panyushev orbits of antichains in <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>The Panyushev orbit of an antichain is its orbit under
Panyushev complementation (see
<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><code class="xref py py-meth docutils literal"><span class="pre">panyushev_complement()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">element_constructor</span></code> (defaults to <code class="docutils literal"><span class="pre">set</span></code>) &#8211; a type
constructor (<code class="docutils literal"><span class="pre">set</span></code>, <code class="docutils literal"><span class="pre">tuple</span></code>, <code class="docutils literal"><span class="pre">list</span></code>, <code class="docutils literal"><span class="pre">frozenset</span></code>,
<code class="docutils literal"><span class="pre">iter</span></code>, etc.) which is to be applied to the antichains
before they are returned.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the partition of the set of all antichains of <code class="docutils literal"><span class="pre">self</span></code> into
orbits under Panyushev complementation. This is returned as
a list of lists <code class="docutils literal"><span class="pre">L</span></code> such that for each <code class="docutils literal"><span class="pre">L</span></code> and <code class="docutils literal"><span class="pre">i</span></code>,
cyclically:
<code class="docutils literal"><span class="pre">self.order_ideal_complement_generators(L[i])</span> <span class="pre">==</span> <span class="pre">L[i+1]</span></code>.
The entries <code class="docutils literal"><span class="pre">L[i]</span></code> are sets by default, but depending on
the optional keyword variable <code class="docutils literal"><span class="pre">element_constructors</span></code>
they can also be tuples, lists etc.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">()</span>
<span class="go">[[{2}, {1}], [set(), {1, 2}, {3}]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
<span class="go">[[[2], [1]], [[], [1, 2], [3]]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">)</span>
<span class="go">[[frozenset({2}), frozenset({1})],</span>
<span class="go"> [frozenset(), frozenset({1, 2}), frozenset({3})]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">)</span>
<span class="go">[[(2,), (1,)], [(), (1, 2), (3,)]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">panyushev_orbits</span><span class="p">()</span>
<span class="go">[[set()]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion">
<code class="descname">rowmotion</code><span class="sig-paren">(</span><em>order_ideal</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="Permalink to this definition">¶</a></dt>
<dd><p>The image of the order ideal <code class="docutils literal"><span class="pre">order_ideal</span></code> under rowmotion
in <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>Rowmotion on a finite poset <span class="math">\(P\)</span> is an automorphism of the set
<span class="math">\(J(P)\)</span> of all order ideals of <span class="math">\(P\)</span>. One way to define it is as
follows: Given an order ideal <span class="math">\(I \in J(P)\)</span>, we let <span class="math">\(F\)</span> be the
set-theoretic complement of <span class="math">\(I\)</span> in <span class="math">\(P\)</span>. Furthermore we let
<span class="math">\(A\)</span> be the antichain consisting of all minimal elements of
<span class="math">\(F\)</span>. Then, the rowmotion of <span class="math">\(I\)</span> is defined to be the order
ideal of <span class="math">\(P\)</span> generated by the antichain <span class="math">\(A\)</span> (that is, the
order ideal consisting of each element of <span class="math">\(P\)</span> which has some
element of <span class="math">\(A\)</span> above it).</p>
<p>Rowmotion is related (actually, isomorphic) to Panyushev
complementation (<a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement" title="sage.categories.finite_posets.FinitePosets.ParentMethods.panyushev_complement"><code class="xref py py-meth docutils literal"><span class="pre">panyushev_complement()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">order_ideal</span></code> &#8211; an order ideal of <code class="docutils literal"><span class="pre">self</span></code>, as a set</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the image of <code class="docutils literal"><span class="pre">order_ideal</span></code> under rowmotion, as a set again</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">7</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">8</span><span class="p">:</span> <span class="p">[]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Set</span><span class="p">({</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">{1, 3, 4, 5, 6, 7}</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">Set</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">{}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbit_iter">
<code class="descname">rowmotion_orbit_iter</code><span class="sig-paren">(</span><em>oideal</em>, <em>element_constructor=&lt;type 'set'&gt;</em>, <em>stop=True</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbit_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the rowmotion orbit of an order ideal
<code class="docutils literal"><span class="pre">oideal</span></code> of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>The rowmotion orbit of an order ideal is its orbit under
rowmotion (see <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal"><span class="pre">rowmotion()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">oideal</span></code> &#8211; an order ideal of <code class="docutils literal"><span class="pre">self</span></code>, given as an
iterable.</li>
<li><code class="docutils literal"><span class="pre">element_constructor</span></code> (defaults to <code class="docutils literal"><span class="pre">set</span></code>) &#8211; a type
constructor (<code class="docutils literal"><span class="pre">set</span></code>, <code class="docutils literal"><span class="pre">tuple</span></code>, <code class="docutils literal"><span class="pre">list</span></code>, <code class="docutils literal"><span class="pre">frozenset</span></code>,
<code class="docutils literal"><span class="pre">iter</span></code>, etc.) which is to be applied to the order
ideals before they are yielded.</li>
<li><code class="docutils literal"><span class="pre">stop</span></code> &#8211; a Boolean (default: <code class="docutils literal"><span class="pre">True</span></code>) determining
whether the iterator should stop once it completes its
cycle (this happens when it is set to <code class="docutils literal"><span class="pre">True</span></code>) or go on
forever (this happens when it is set to <code class="docutils literal"><span class="pre">False</span></code>).</li>
<li><code class="docutils literal"><span class="pre">check</span></code> &#8211; a Boolean (default: <code class="docutils literal"><span class="pre">True</span></code>) determining
whether <code class="docutils literal"><span class="pre">oideal</span></code> should be checked for being an
order ideal.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an iterator over the orbit of the order ideal <code class="docutils literal"><span class="pre">oideal</span></code>
under rowmotion. This iterator <span class="math">\(I\)</span> has the property that
<code class="docutils literal"><span class="pre">I[0]</span> <span class="pre">==</span> <span class="pre">oideal</span></code> and that every <span class="math">\(i\)</span> satisfies
<code class="docutils literal"><span class="pre">self.rowmotion(I[i])</span> <span class="pre">==</span> <span class="pre">I[i+1]</span></code>, where <code class="docutils literal"><span class="pre">I[i+1]</span></code> has
to be understood as <code class="docutils literal"><span class="pre">I[0]</span></code> if it is undefined.
The entries <code class="docutils literal"><span class="pre">I[i]</span></code> are sets by default, but depending on
the optional keyword variable <code class="docutils literal"><span class="pre">element_constructors</span></code>
they can also be tuples, lists etc.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}, {1, 2, 3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[{1, 2}, {1, 2, 3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">[{1, 2}, {1, 2, 3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[1, 2], [1, 2, 3], []]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">))</span>
<span class="go">[frozenset({1, 2}), frozenset({1, 2, 3}), frozenset()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 2, 3), ()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([]))</span>
<span class="go">[set()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">Piter</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">stop</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3, 4}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3}</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[1, 2], [1, 2, 3, 4], [2, 3, 5], [1], [2, 3], [1, 2, 3, 5], [1, 2, 4], [3]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbits">
<code class="descname">rowmotion_orbits</code><span class="sig-paren">(</span><em>element_constructor=&lt;type 'set'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion_orbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the rowmotion orbits of order ideals in <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>The rowmotion orbit of an order ideal is its orbit under
rowmotion (see <a class="reference internal" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion" title="sage.categories.finite_posets.FinitePosets.ParentMethods.rowmotion"><code class="xref py py-meth docutils literal"><span class="pre">rowmotion()</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">element_constructor</span></code> (defaults to <code class="docutils literal"><span class="pre">set</span></code>) &#8211; a type
constructor (<code class="docutils literal"><span class="pre">set</span></code>, <code class="docutils literal"><span class="pre">tuple</span></code>, <code class="docutils literal"><span class="pre">list</span></code>, <code class="docutils literal"><span class="pre">frozenset</span></code>,
<code class="docutils literal"><span class="pre">iter</span></code>, etc.) which is to be applied to the antichains
before they are returned.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>the partition of the set of all order ideals of <code class="docutils literal"><span class="pre">self</span></code>
into orbits under rowmotion. This is returned as
a list of lists <code class="docutils literal"><span class="pre">L</span></code> such that for each <code class="docutils literal"><span class="pre">L</span></code> and <code class="docutils literal"><span class="pre">i</span></code>,
cyclically: <code class="docutils literal"><span class="pre">self.rowmotion(L[i])</span> <span class="pre">==</span> <span class="pre">L[i+1]</span></code>.
The entries <code class="docutils literal"><span class="pre">L[i]</span></code> are sets by default, but depending on
the optional keyword variable <code class="docutils literal"><span class="pre">element_constructors</span></code>
they can also be tuples, lists etc.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits</span><span class="p">())</span>
<span class="go">[3, 5]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[[1, 3], [4], [1], [4, 1, 3], [4, 1, 2]], [[4, 1], [4, 1, 2, 3], []]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[[(1, 3), (4,), (1,), (4, 1, 3), (4, 1, 2)], [(4, 1), (4, 1, 2, 3), ()]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({})</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">rowmotion_orbits</span><span class="p">(</span><span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[[()]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbit_iter">
<code class="descname">toggling_orbit_iter</code><span class="sig-paren">(</span><em>vs</em>, <em>oideal</em>, <em>element_constructor=&lt;type 'set'&gt;</em>, <em>stop=True</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbit_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the orbit of an order ideal <code class="docutils literal"><span class="pre">oideal</span></code> of
<code class="docutils literal"><span class="pre">self</span></code> under the operation of toggling the vertices
<code class="docutils literal"><span class="pre">vs[0],</span> <span class="pre">vs[1],</span> <span class="pre">...</span></code> in this order.</p>
<p>See <code class="xref py py-meth docutils literal"><span class="pre">order_ideal_toggle()</span></code> for a definition of toggling.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The orbit is that under the composition of toggles,
<em>not</em> under the single toggles themselves. Thus, for
example, if <code class="docutils literal"><span class="pre">vs</span> <span class="pre">==</span> <span class="pre">[1,2]</span></code>, then the orbit has the
form <span class="math">\((I, T_2 T_1 I, T_2 T_1 T_2 T_1 I, \ldots)\)</span>
(where <span class="math">\(I\)</span> denotes <code class="docutils literal"><span class="pre">oideal</span></code> and <span class="math">\(T_i\)</span> means
toggling at <span class="math">\(i\)</span>) rather than
<span class="math">\((I, T_1 I, T_2 T_1 I, T_1 T_2 T_1 I, \ldots)\)</span>.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">vs</span></code>: a list (or other iterable) of elements of <code class="docutils literal"><span class="pre">self</span></code>
(but since the output depends on the order, sets should
not be used as <code class="docutils literal"><span class="pre">vs</span></code>).</li>
<li><code class="docutils literal"><span class="pre">oideal</span></code> &#8211; an order ideal of <code class="docutils literal"><span class="pre">self</span></code>, given as an
iterable.</li>
<li><code class="docutils literal"><span class="pre">element_constructor</span></code> (defaults to <code class="docutils literal"><span class="pre">set</span></code>) &#8211; a type
constructor (<code class="docutils literal"><span class="pre">set</span></code>, <code class="docutils literal"><span class="pre">tuple</span></code>, <code class="docutils literal"><span class="pre">list</span></code>, <code class="docutils literal"><span class="pre">frozenset</span></code>,
<code class="docutils literal"><span class="pre">iter</span></code>, etc.) which is to be applied to the order
ideals before they are yielded.</li>
<li><code class="docutils literal"><span class="pre">stop</span></code> &#8211; a Boolean (default: <code class="docutils literal"><span class="pre">True</span></code>) determining
whether the iterator should stop once it completes its
cycle (this happens when it is set to <code class="docutils literal"><span class="pre">True</span></code>) or go on
forever (this happens when it is set to <code class="docutils literal"><span class="pre">False</span></code>).</li>
<li><code class="docutils literal"><span class="pre">check</span></code> &#8211; a Boolean (default: <code class="docutils literal"><span class="pre">True</span></code>) determining
whether <code class="docutils literal"><span class="pre">oideal</span></code> should be checked for being an
order ideal.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an iterator over the orbit of the order ideal <code class="docutils literal"><span class="pre">oideal</span></code>
under toggling the vertices in the list <code class="docutils literal"><span class="pre">vs</span></code> in this
order. This iterator <span class="math">\(I\)</span> has the property that
<code class="docutils literal"><span class="pre">I[0]</span> <span class="pre">==</span> <span class="pre">oideal</span></code> and that every <span class="math">\(i\)</span> satisfies
<code class="docutils literal"><span class="pre">self.order_ideal_toggles(I[i],</span> <span class="pre">vs)</span> <span class="pre">==</span> <span class="pre">I[i+1]</span></code>, where
<code class="docutils literal"><span class="pre">I[i+1]</span></code> has to be understood as <code class="docutils literal"><span class="pre">I[0]</span></code> if it is
undefined.
The entries <code class="docutils literal"><span class="pre">I[i]</span></code> are sets by default, but depending on
the optional keyword variable <code class="docutils literal"><span class="pre">element_constructors</span></code>
they can also be tuples, lists etc.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}, set(), {1, 2, 3}]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])))</span>
<span class="go">[{1, 2}, {1, 2, 3}, set()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">list</span><span class="p">))</span>
<span class="go">[[1, 2], [1, 2, 3], []]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">))</span>
<span class="go">[frozenset({1, 2}), frozenset({1, 2, 3}), frozenset()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 2, 3), ()]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">element_constructor</span><span class="o">=</span><span class="nb">tuple</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 2, 3), ()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([],</span> <span class="p">[]))</span>
<span class="go">[set()]</span>

<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">({</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]</span> <span class="p">})</span>
<span class="gp">sage: </span><span class="n">Piter</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">toggling_orbit_iter</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">stop</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">set()</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1, 2, 3}</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">Piter</span><span class="p">)</span>
<span class="go">{1}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits">
<code class="descname">toggling_orbits</code><span class="sig-paren">(</span><em>vs</em>, <em>element_constructor=&lt;type 'set'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.categories.finite_posets.FinitePosets.ParentMethods.toggling_orbits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the orbits of order ideals in <code class="docutils literal"><span class="pre">self</span></code> under the
operation of toggling the vertices <code class="docutils literal"><span class="pre">vs[0],</span> <span class="pre">vs[1],</span> <span class="pre">...</span></code>
in this order.</p>
<p>See <code class="xref py py-meth docutils literal"><span class="pre">order_ideal_toggle()</span></code> for a definition of toggling.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The orbits are those under the composition of toggles,
<em>not</em> under the single toggles themselves. Thus, for
example, if <code class="docutils literal"><span class="pre">vs</span> <span class="pre">==</span> <span class="pre">[1,2]</span></code>, then the orbits have the
form <span class="math">\((I, T_2 T_1 I, T_2 T_1 T_2 T_1 I, \ldots)\)</span>
(where <span class="math">\(I\)</span> denotes an order ideal and <span class="math">\(T_i\)</span> means
toggling at <span class="math">\(i\)</span>) rather than
<span class="math">\((I, T_1 I, T_2 T_1 I, T_1 T_2 T_1 I, \ldots)\)</span>.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">vs</span></code>: a list (or other iterable) of elements of <code class="docutils literal"><span class="pre">self</span></code>
(but since the output depends on the order, sets should
not be used as <code class="docutils literal"><span class="pre">vs</span></code>).</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a partition of the order ideals of <code class="docutils literal"><span class="pre">self</span></code>, as a list of
sets <code class="docutils literal"><span class="pre">L</span></code> such that for each <code class="docutils literal"><span class="pre">L</span></code> and <code class="docutils literal"><span class="pre">i</span></code>, cyclically:
<code class="docutils literal"><span class="pre">self.order_ideal_toggles(L[i],</span> <span class="pre">vs)</span> <span class="pre">==</span> <span class="pre">L[i+1]</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">toggling_orbits</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[2, 3, 3]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Poset</span><span class="p">(</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]}</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">P</span><span class="o">.</span><span class="n">toggling_orbits</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
<span class="go">[3, 3]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="finite_permutation_groups.html"
                                  title="previous chapter">Finite Permutation Groups</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="finite_semigroups.html"
                                  title="next chapter">Finite semigroups</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/categories/finite_posets.rst.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="finite_semigroups.html" title="Finite semigroups"
             >next</a> |</li>
        <li class="right" >
          <a href="finite_permutation_groups.html" title="Finite Permutation Groups"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Category Framework</a> &#187;</li>
 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2017, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>