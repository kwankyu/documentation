
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Coercion &#8212; Sage Reference Manual v8.8: Coercion</title>
    <link rel="stylesheet" href="../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The Coercion Model" href="sage/structure/coerce.html" />
    <link rel="icon" href="../_static/sageicon.png" type="image/x-icon" />
    <script src="../_static/thebe.js" type="text/javascript"></script>
    <script src="../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="sage/structure/coerce.html" title="The Coercion Model"
             accesskey="N">next</a> |</li>
  
    
      <a href="../../index.html"><img src="../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
      <a href="../index.html"> Sage Reference Manual </a> &raquo;
    
  
  
        <li class="nav-item nav-item-0"><a href="#">Coercion</a> &#187;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="coercion">
<h1>Coercion<a class="headerlink" href="#coercion" title="Permalink to this headline">¶</a></h1>
<div class="section" id="preliminaries">
<h2>Preliminaries<a class="headerlink" href="#preliminaries" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-is-coercion-all-about">
<h3>What is coercion all about?<a class="headerlink" href="#what-is-coercion-all-about" title="Permalink to this headline">¶</a></h3>
<p><em>The primary goal of coercion is to be able to transparently do arithmetic, comparisons, etc. between elements of distinct sets.</em></p>
<p>As a concrete example, when one writes <span class="math notranslate nohighlight">\(1 + 1/2\)</span> one wants to perform
arithmetic on the operands as rational numbers, despite the left being
an integer. This makes sense given the obvious and natural inclusion
of the integers into the rational numbers. The goal of the coercion
system is to facilitate this (and more complicated arithmetic) without
having to explicitly map everything over into the same domain, and at
the same time being strict enough to not resolve ambiguity or accept
nonsense. Here are some examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
<span class="go">3/2</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[]</span>
<span class="gp">sage: </span><span class="n">R</span>
<span class="go">Multivariate Polynomial Ring in x, y over Integer Ring</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">Multivariate Polynomial Ring in x, y over Integer Ring</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Rational Field</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
<span class="go">x + 1/3</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Multivariate Polynomial Ring in x, y over Rational Field</span>

<span class="gp">sage: </span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">)(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">CC</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: unsupported operand parent(s) for +: &#39;Finite Field of size 5&#39; and &#39;Complex Field with 53 bits of precision&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="parents-and-elements">
<h3>Parents and Elements<a class="headerlink" href="#parents-and-elements" title="Permalink to this headline">¶</a></h3>
<p>Parents are objects in concrete categories, and Elements are their
members. Parents are first-class objects.  Most things in Sage are
either parents or have a parent. Typically whenever one sees the word
<em>Parent</em> one can think <em>Set</em>. Here are some examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Integer Ring</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ZZ</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">ZZ</span>
<span class="go">Integer Ring</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="mf">1.50000000000000000000000000000000000</span><span class="p">)</span>
<span class="go">Real Field with 120 bits of precision</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">Symbolic Ring</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">^</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">x^sin(x)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Qp</span><span class="p">(</span><span class="mi">5</span><span class="p">)[]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">t</span><span class="o">^</span><span class="mi">3</span><span class="o">-</span><span class="mi">5</span><span class="p">;</span> <span class="n">f</span>
<span class="go">(1 + O(5^20))*t^3 + 4*5 + 4*5^2 + 4*5^3 + 4*5^4 + 4*5^5 + 4*5^6 + 4*5^7 + 4*5^8 + 4*5^9 + 4*5^10 + 4*5^11 + 4*5^12 + 4*5^13 + 4*5^14 + 4*5^15 + 4*5^16 + 4*5^17 + 4*5^18 + 4*5^19 + 4*5^20 + O(5^21)</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">Univariate Polynomial Ring in t over 5-adic Field with capped relative precision 20</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s1">&#39;37a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lseries</span><span class="p">()</span><span class="o">.</span><span class="n">taylor_series</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="n">f</span>
<span class="go">0.990010459847588 + 0.0191338632530789*z - 0.0197489006172923*z^2 + 0.0137240085327618*z^3 - 0.00703880791607153*z^4 + 0.00280906165766519*z^5 + O(z^6)           # 32-bit</span>
<span class="go">0.997997869801216 + 0.00140712894524925*z - 0.000498127610960097*z^2 + 0.000118835596665956*z^3 - 0.0000215906522442707*z^4 + (3.20363155418419e-6)*z^5 + O(z^6)  # 64-bit</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">Power Series Ring in z over Complex Field with 53 bits of precision</span>
</pre></div>
</div>
<p>There is an important distinction between Parents and types:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;type &#39;sage.rings.finite_rings.integer_mod.IntegerMod_int&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&lt;type &#39;sage.rings.finite_rings.integer_mod.IntegerMod_int&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">Finite Field of size 5</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">parent</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>However, non-Sage objects don’t really have parents, but we still want
to be able to reason with them, so their type is used instead:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&lt;... &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>In fact, under the hood, a special kind of parent “The set of all
Python objects of class T” is used in these cases.</p>
<p>Note that parents are <strong>not</strong> always as tight as possible.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Rational Field</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Rational Field</span>
</pre></div>
</div>
</div>
<div class="section" id="maps-between-parents">
<h3>Maps between Parents<a class="headerlink" href="#maps-between-parents" title="Permalink to this headline">¶</a></h3>
<p>Many parents come with maps to and from other parents.</p>
<p>Sage makes a distinction between being able to <strong>convert</strong> between
various parents, and <strong>coerce</strong> between them. Conversion is explicit
and tries to make sense of an object in the target domain if at all
possible. It is invoked by calling:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="mi">10</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">QQ</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">QQ</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Rational Field</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">)(</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">Finite Field of size 5</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">ZZ</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="go">Integer Ring</span>
<span class="gp">sage: </span><span class="n">GF</span><span class="p">(</span><span class="mi">71</span><span class="p">)(</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>
<span class="go">57</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: no conversion of this rational to integer</span>
</pre></div>
</div>
<p>Conversions need not be canonical (they may for example involve a
choice of lift) or even make sense mathematically (e.g. constructions
of some kind).</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="s2">&quot;123&quot;</span><span class="p">)</span>
<span class="go">123</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">)(</span><span class="mi">14</span><span class="p">))</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]([</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">x^3 + 2*x^2 + 3*x + 4</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">Qp</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">);</span> <span class="n">a</span>
<span class="go">2 + 3*5 + 5^2 + 3*5^3 + 5^4 + 3*5^5 + 5^6 + 3*5^7 + 5^8 + 3*5^9 + O(5^10)</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">6510417</span>
</pre></div>
</div>
<p>On the other hand, Sage has the notion of a <strong>coercion</strong>, which is a
canonical morphism (occasionally up to a conventional choice made by
developers) between parents. A coercion from one parent to another
<strong>must</strong> be defined on the whole domain, and always succeeds. As it
may be invoked implicitly, it should be obvious and natural (in both
the mathematically rigorous and colloquial sense of the word). Up to
inescapable rounding issues that arise with inexact representations,
these coercion morphisms should all commute.  In particular, if there
are coercion maps <span class="math notranslate nohighlight">\(A \to B\)</span> and <span class="math notranslate nohighlight">\(B \to A\)</span>, then their composites
must be the identity maps.</p>
<p>Coercions can be discovered via the <a class="reference external" href="../structure/sage/structure/parent.html#sage.structure.parent.Parent.has_coerce_map_from" title="(in Sage Reference Manual: Parents and Elements v8.8)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Parent.has_coerce_map_from()</span></code></a>
method, and if needed explicitly invoked with the
<a class="reference external" href="../structure/sage/structure/parent.html#sage.structure.parent.Parent.coerce" title="(in Sage Reference Manual: Parents and Elements v8.8)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Parent.coerce()</span></code></a> method:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QQ</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">QQ</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">RR</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Univariate Polynomial Ring in x over Integer Ring</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: no canonical coercion from Rational Field to Univariate Polynomial Ring in x over Integer Ring</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="basic-arithmetic-rules">
<h2>Basic Arithmetic Rules<a class="headerlink" href="#basic-arithmetic-rules" title="Permalink to this headline">¶</a></h2>
<p>Suppose we want to add two element, a and b, whose parents are A and B
respectively. When we type <code class="docutils literal notranslate"><span class="pre">a+b</span></code> then</p>
<ol class="arabic simple">
<li>If A <code class="docutils literal notranslate"><span class="pre">is</span></code> B, call a._add_(b)</li>
<li>If there is a coercion <span class="math notranslate nohighlight">\(\phi: B \rightarrow A\)</span>, call a._add_( <span class="math notranslate nohighlight">\(\phi\)</span> (b))</li>
<li>If there is a coercion <span class="math notranslate nohighlight">\(\phi: A \rightarrow B\)</span>, call <span class="math notranslate nohighlight">\(\phi\)</span> (a)._add_(b)</li>
<li>Look for <span class="math notranslate nohighlight">\(Z\)</span> such that there is a coercion <span class="math notranslate nohighlight">\(\phi_A: A \rightarrow Z\)</span> and
<span class="math notranslate nohighlight">\(\phi_B: B \rightarrow Z\)</span>, call <span class="math notranslate nohighlight">\(\phi_A\)</span> (a)._add_( <span class="math notranslate nohighlight">\(\phi_B\)</span> (b))</li>
</ol>
<p>These rules are evaluated in order; therefore if there are coercions
in both directions, then the parent of a._add_b is A – the parent
of the left-hand operand is used in such cases.</p>
<p>The same rules are used for subtraction, multiplication, and
division. This logic is embedded in a coercion model object, which can
be obtained and queried.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Rational Field</span>
<span class="gp">sage: </span><span class="n">cm</span> <span class="o">=</span> <span class="n">coercion_model</span><span class="p">;</span> <span class="n">cm</span>
<span class="go">&lt;sage.structure.coerce.CoercionModel object at ...&gt;</span>
<span class="gp">sage: </span><span class="n">cm</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="n">QQ</span><span class="p">)</span>
<span class="go">Coercion on left operand via</span>
<span class="go">   Natural morphism:</span>
<span class="go">     From: Integer Ring</span>
<span class="go">     To:   Rational Field</span>
<span class="go">Arithmetic performed after coercions.</span>
<span class="go">Result lives in Rational Field</span>
<span class="go">Rational Field</span>

<span class="gp">sage: </span><span class="n">cm</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
<span class="go">Coercion on left operand via</span>
<span class="go">   Coercion map:</span>
<span class="go">     From: Multivariate Polynomial Ring in x, y over Integer Ring</span>
<span class="go">     To:   Multivariate Polynomial Ring in x, y over Rational Field</span>
<span class="go">Coercion on right operand via</span>
<span class="go">   Coercion map:</span>
<span class="go">     From: Univariate Polynomial Ring in x over Rational Field</span>
<span class="go">     To:   Multivariate Polynomial Ring in x, y over Rational Field</span>
<span class="go">Arithmetic performed after coercions.</span>
<span class="go">Result lives in Multivariate Polynomial Ring in x, y over Rational Field</span>
<span class="go">Multivariate Polynomial Ring in x, y over Rational Field</span>
</pre></div>
</div>
<p>The coercion model can be used directly for any binary operation
(callable taking two arguments).</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cm</span><span class="o">.</span><span class="n">bin_op</span><span class="p">(</span><span class="mi">77</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">gcd</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>There are also <strong>actions</strong> in the sense that a field <span class="math notranslate nohighlight">\(K\)</span> acts on a
module over <span class="math notranslate nohighlight">\(K\)</span>, or a permutation group acts on a set. These are
discovered between steps 1 and 2 above.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cm</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">ZZ</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">)</span>
<span class="go">Action discovered.</span>
<span class="go">   Right scalar multiplication by Integer Ring on Univariate Polynomial Ring in x over Integer Ring</span>
<span class="go">Result lives in Univariate Polynomial Ring in x over Integer Ring</span>
<span class="go">Univariate Polynomial Ring in x over Integer Ring</span>

<span class="gp">sage: </span><span class="n">cm</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">ZZ</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">truediv</span><span class="p">)</span>
<span class="go">Action discovered.</span>
<span class="go">   Right inverse action by Rational Field on Univariate Polynomial Ring in x over Integer Ring</span>
<span class="go">   with precomposition on right by Natural morphism:</span>
<span class="go">     From: Integer Ring</span>
<span class="go">     To:   Rational Field</span>
<span class="go">Result lives in Univariate Polynomial Ring in x over Rational Field</span>
<span class="go">Univariate Polynomial Ring in x over Rational Field</span>

<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">QQ</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Rational Field</span>
</pre></div>
</div>
<p>Note that by <a class="reference external" href="https://trac.sagemath.org/14711">trac ticket #14711</a> Sage’s coercion system uses maps with weak
references to the domain. Such maps should only be used internally, and so a
copy should be used instead (unless one knows what one is doing):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QQ</span><span class="o">.</span><span class="n">_internal_coerce_map_from</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">(map internal to coercion system -- copy before use)</span>
<span class="go">Native morphism:</span>
<span class="go">  From: Set of Python objects of class &#39;int&#39;</span>
<span class="go">  To:   Rational Field</span>
<span class="gp">sage: </span><span class="n">copy</span><span class="p">(</span><span class="n">QQ</span><span class="o">.</span><span class="n">_internal_coerce_map_from</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
<span class="go">Native morphism:</span>
<span class="go">  From: Set of Python objects of class &#39;int&#39;</span>
<span class="go">  To:   Rational Field</span>
</pre></div>
</div>
<p>Note that the user-visible method (without underscore) automates this copy:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">copy</span><span class="p">(</span><span class="n">QQ</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
<span class="go">Native morphism:</span>
<span class="go">  From: Set of Python objects of class &#39;int&#39;</span>
<span class="go">  To:   Rational Field</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QQ</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">RR</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get_action</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Right scalar multiplication by Rational Field on Univariate Polynomial Ring in x over Rational Field</span>
<span class="gp">sage: </span><span class="n">QQ2</span> <span class="o">=</span> <span class="n">QQ</span><span class="o">^</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">QQ2</span><span class="p">)</span><span class="o">.</span><span class="n">get_action</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Right scalar multiplication by Rational Field on Vector space of dimension 2 over Rational Field</span>
<span class="gp">sage: </span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get_action</span><span class="p">(</span><span class="n">RR</span><span class="p">)</span>
<span class="go">Right scalar multiplication by Real Field with 53 bits of precision on Univariate Polynomial Ring in x over Rational Field</span>
</pre></div>
</div>
</div>
<div class="section" id="how-to-implement">
<h2>How to Implement<a class="headerlink" href="#how-to-implement" title="Permalink to this headline">¶</a></h2>
<div class="section" id="methods-to-implement">
<h3>Methods to implement<a class="headerlink" href="#methods-to-implement" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">Arithmetic on Elements: <code class="docutils literal notranslate"><span class="pre">_add_</span></code>, <code class="docutils literal notranslate"><span class="pre">_sub_</span></code>, <code class="docutils literal notranslate"><span class="pre">_mul_</span></code>, <code class="docutils literal notranslate"><span class="pre">_div_</span></code></p>
<p>This is where the binary arithmetic operators should be
implemented. Unlike Python’s <code class="docutils literal notranslate"><span class="pre">__add__</span></code>, both operands are
<em>guaranteed</em> to have the same Parent at this point.</p>
</li>
<li><p class="first">Coercion for Parents: <code class="docutils literal notranslate"><span class="pre">_coerce_map_from_</span></code></p>
<p>Given two parents R and S, <code class="docutils literal notranslate"><span class="pre">R._coerce_map_from_(S)</span></code> is called to
determine if there is a coercion <span class="math notranslate nohighlight">\(\phi: S \rightarrow R\)</span>.  Note that
the function is called on the potential codomain.  To indicate that
there is no coercion from S to R (self), return <code class="docutils literal notranslate"><span class="pre">False</span></code> or
<code class="docutils literal notranslate"><span class="pre">None</span></code>. This is the default behavior.  If there is a coercion,
return <code class="docutils literal notranslate"><span class="pre">True</span></code> (in which case an morphism using
<code class="docutils literal notranslate"><span class="pre">R._element_constructor_</span></code> will be created) or an actual
<a class="reference external" href="../categories/sage/categories/morphism.html#sage.categories.morphism.Morphism" title="(in Sage Reference Manual: Category Framework v8.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Morphism</span></code></a> object with S as the domain and R as the codomain.</p>
</li>
<li><p class="first">Actions for Parents: <code class="docutils literal notranslate"><span class="pre">_get_action_</span></code> or <code class="docutils literal notranslate"><span class="pre">_rmul_</span></code>, <code class="docutils literal notranslate"><span class="pre">_lmul_</span></code>, <code class="docutils literal notranslate"><span class="pre">_r_action_</span></code>, <code class="docutils literal notranslate"><span class="pre">_l_action_</span></code></p>
<p>Suppose one wants R to act on S. Some examples of this could be
<span class="math notranslate nohighlight">\(R = \QQ\)</span>, <span class="math notranslate nohighlight">\(S = \QQ[x]\)</span> or <span class="math notranslate nohighlight">\(R = {\rm Gal}(S/\QQ)\)</span>
where <span class="math notranslate nohighlight">\(S\)</span>  is a number field. There are several ways to implement this:</p>
<ul class="simple">
<li>If <span class="math notranslate nohighlight">\(R\)</span> is the base of <span class="math notranslate nohighlight">\(S\)</span> (as in the first example), simply
implement <code class="docutils literal notranslate"><span class="pre">_rmul_</span></code> and/or <code class="docutils literal notranslate"><span class="pre">_lmul_</span></code> on the Elements of <span class="math notranslate nohighlight">\(S\)</span>.
In this case <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">*</span> <span class="pre">s</span></code> gets handled as <code class="docutils literal notranslate"><span class="pre">s._rmul_(r)</span></code> and
<code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">*</span> <span class="pre">r</span></code> as <code class="docutils literal notranslate"><span class="pre">s._lmul_(r)</span></code>.  The argument to <code class="docutils literal notranslate"><span class="pre">_rmul_</span></code>
and <code class="docutils literal notranslate"><span class="pre">_lmul_</span></code> are <em>guaranteed</em> to be Elements of the base of
<span class="math notranslate nohighlight">\(S\)</span> (with coercion happening beforehand if necessary).</li>
<li>If <span class="math notranslate nohighlight">\(R\)</span> acts on <span class="math notranslate nohighlight">\(S\)</span>, one can alternatively define the methods
<code class="docutils literal notranslate"><span class="pre">_r_action_</span></code> and/or <code class="docutils literal notranslate"><span class="pre">_l_action_</span></code> on the Elements of <span class="math notranslate nohighlight">\(R\)</span>.
There is no constraint on the type or parents of objects passed to
these methods; raise a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> or <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> if the
wrong kind of object is passed in to indicate the action is not
appropriate here.</li>
<li>If either <span class="math notranslate nohighlight">\(R\)</span> acts on <span class="math notranslate nohighlight">\(S\)</span> <em>or</em> <span class="math notranslate nohighlight">\(S\)</span> acts on <span class="math notranslate nohighlight">\(R\)</span>, one may implement
<code class="docutils literal notranslate"><span class="pre">R._get_action_</span></code> to return an actual
<a class="reference internal" href="sage/categories/action.html#sage.categories.action.Action" title="sage.categories.action.Action"><code class="xref py py-class docutils literal notranslate"><span class="pre">Action</span></code></a> object to be used.  This
is how non-multiplicative actions must be implemented, and is the
most powerful (and completed) way to do things.</li>
</ul>
</li>
<li><p class="first">Element conversion/construction for Parents: use
<code class="docutils literal notranslate"><span class="pre">_element_constructor_</span></code> <strong>not</strong> <code class="docutils literal notranslate"><span class="pre">__call__</span></code></p>
<p>The <a class="reference external" href="../structure/sage/structure/parent.html#sage.structure.parent.Parent.__call__" title="(in Sage Reference Manual: Parents and Elements v8.8)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Parent.__call__()</span></code></a> method dispatches to
<code class="docutils literal notranslate"><span class="pre">_element_constructor_</span></code>. When someone writes <code class="docutils literal notranslate"><span class="pre">R(x,</span> <span class="pre">...)</span></code>, this is
the method that eventually gets called in most cases.  See the
documentation on the <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method below.</p>
</li>
</ul>
<p>Parents may also call the <code class="docutils literal notranslate"><span class="pre">self._populate_coercion_lists_</span></code> method in
their <code class="docutils literal notranslate"><span class="pre">__init__</span></code> functions to pass any callable for use instead of
<code class="docutils literal notranslate"><span class="pre">_element_constructor_</span></code>, provide a list of Parents with coercions to
self (as an alternative to implementing <code class="docutils literal notranslate"><span class="pre">_coerce_map_from_</span></code>),
provide special construction methods (like <code class="docutils literal notranslate"><span class="pre">_integer_</span></code> for ZZ),
etc. This also allows one to specify a single coercion embedding <em>out</em>
of self (whereas the rest of the coercion functions all specify maps
<em>into</em> self). There is extensive documentation in the docstring of the
<code class="docutils literal notranslate"><span class="pre">_populate_coercion_lists_</span></code> method.</p>
</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>Sometimes a simple example is worth a thousand words. Here is a
minimal example of setting up a simple Ring that handles coercion. (It
is easy to imagine much more sophisticated and powerful localizations,
but that would obscure the main points being made here.)</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">class Localization(Ring):</span>
<span class="go">   def __init__(self, primes):</span>
<span class="go">       &quot;&quot;&quot;</span>
<span class="go">       Localization of `\ZZ` away from primes.</span>
<span class="go">       &quot;&quot;&quot;</span>
<span class="go">       Ring.__init__(self, base=ZZ)</span>
<span class="go">       self._primes = primes</span>
<span class="go">       self._populate_coercion_lists_()</span>

<span class="go">   def _repr_(self):</span>
<span class="go">       &quot;&quot;&quot;</span>
<span class="go">       How to print self.</span>
<span class="go">       &quot;&quot;&quot;</span>
<span class="go">       return &quot;%s localized at %s&quot; % (self.base(), self._primes)</span>

<span class="go">   def _element_constructor_(self, x):</span>
<span class="go">       &quot;&quot;&quot;</span>
<span class="go">       Make sure x is a valid member of self, and return the constructed element.</span>
<span class="go">       &quot;&quot;&quot;</span>
<span class="go">       if isinstance(x, LocalizationElement):</span>
<span class="go">           x = x._value</span>
<span class="go">       else:</span>
<span class="go">           x = QQ(x)</span>
<span class="go">       for p, e in x.denominator().factor():</span>
<span class="go">           if p not in self._primes:</span>
<span class="go">               raise ValueError(&quot;Not integral at %s&quot; % p)</span>
<span class="go">       return LocalizationElement(self, x)</span>

<span class="go">   def _coerce_map_from_(self, S):</span>
<span class="go">       &quot;&quot;&quot;</span>
<span class="go">       The only things that coerce into this ring are:</span>

<span class="go">       - the integer ring</span>

<span class="go">       - other localizations away from fewer primes</span>
<span class="go">       &quot;&quot;&quot;</span>
<span class="go">       if S is ZZ:</span>
<span class="go">           return True</span>
<span class="go">       elif isinstance(S, Localization):</span>
<span class="go">           return all(p in self._primes for p in S._primes)</span>


<span class="go">class LocalizationElement(RingElement):</span>

<span class="go">   def __init__(self, parent, x):</span>
<span class="go">       RingElement.__init__(self, parent)</span>
<span class="go">       self._value = x</span>


<span class="go">   # We&#39;re just printing out this way to make it easy to see what&#39;s going on in the examples.</span>

<span class="go">   def _repr_(self):</span>
<span class="go">       return &quot;LocalElt(%s)&quot; % self._value</span>

<span class="go">   # Now define addition, subtraction, and multiplication of elements.</span>
<span class="go">   # Note that left and right always have the same parent.</span>

<span class="go">   def _add_(left, right):</span>
<span class="go">       return LocalizationElement(left.parent(), left._value + right._value)</span>

<span class="go">   def _sub_(left, right):</span>
<span class="go">       return LocalizationElement(left.parent(), left._value - right._value)</span>

<span class="go">   def _mul_(left, right):</span>
<span class="go">       return LocalizationElement(left.parent(), left._value * right._value)</span>

<span class="go">   # The basering was set to ZZ, so c is guaranteed to be in ZZ</span>

<span class="go">   def _rmul_(self, c):</span>
<span class="go">       return LocalizationElement(self.parent(), c * self._value)</span>

<span class="go">   def _lmul_(self, c):</span>
<span class="go">       return LocalizationElement(self.parent(), self._value * c)</span>
</pre></div>
</div>
<p>That’s all there is to it. Now we can test it out:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">Localization</span><span class="p">([</span><span class="mi">2</span><span class="p">]);</span> <span class="n">R</span>
<span class="go">Integer Ring localized at [2]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">LocalElt(1)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">LocalElt(1/2)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: Not integral at 3</span>

<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">LocalElt(1)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Traceback (click to the left for traceback)</span>
<span class="go">...</span>
<span class="go">TypeError: no canonical coercion from Rational Field to Integer Ring localized at [2]</span>

<span class="gp">sage: </span><span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">R</span><span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="go">LocalElt(5/4)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span>
<span class="go">LocalElt(11/2)</span>
<span class="gp">sage: </span><span class="mi">5</span> <span class="o">+</span> <span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">LocalElt(11/2)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">7</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: unsupported operand parent(s) for +: &#39;Integer Ring localized at [2]&#39; and &#39;Rational Field&#39;</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">7</span>
<span class="go">LocalElt(21/4)</span>

<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">get_action</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Right scalar multiplication by Integer Ring on Integer Ring localized at [2]</span>
<span class="gp">sage: </span><span class="n">cm</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">get_coercion_model</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">cm</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">)</span>
<span class="go">Coercion on right operand via</span>
<span class="go">   Conversion map:</span>
<span class="go">     From: Integer Ring</span>
<span class="go">     To:   Integer Ring localized at [2]</span>
<span class="go">Arithmetic performed after coercions.</span>
<span class="go">Result lives in Integer Ring localized at [2]</span>
<span class="go">Integer Ring localized at [2]</span>

<span class="gp">sage: </span><span class="n">cm</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">)</span>
<span class="go">Action discovered.</span>
<span class="go">   Right scalar multiplication by Integer Ring on Integer Ring localized at [2]</span>
<span class="go">Result lives in Integer Ring localized at [2]</span>
<span class="go">Integer Ring localized at [2]</span>

<span class="gp">sage: </span><span class="n">R6</span> <span class="o">=</span> <span class="n">Localization</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">R6</span>
<span class="go">Integer Ring localized at [2, 3]</span>
<span class="gp">sage: </span><span class="n">R6</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">LocalElt(-1/6)</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">R6</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Integer Ring localized at [2, 3]</span>

<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">has_coerce_map_from</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="go">Conversion map:</span>
<span class="go"> From: Integer Ring</span>
<span class="go"> To:   Integer Ring localized at [2]</span>

<span class="gp">sage: </span><span class="n">R6</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
<span class="go">Conversion map:</span>
<span class="go"> From: Integer Ring localized at [2]</span>
<span class="go"> To:   Integer Ring localized at [2, 3]</span>

<span class="gp">sage: </span><span class="n">R6</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="go">LocalElt(1/2)</span>

<span class="gp">sage: </span><span class="n">cm</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">R6</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">)</span>
<span class="go">Coercion on left operand via</span>
<span class="go">   Conversion map:</span>
<span class="go">     From: Integer Ring localized at [2]</span>
<span class="go">     To:   Integer Ring localized at [2, 3]</span>
<span class="go">Arithmetic performed after coercions.</span>
<span class="go">Result lives in Integer Ring localized at [2, 3]</span>
<span class="go">Integer Ring localized at [2, 3]</span>
</pre></div>
</div>
</div>
<div class="section" id="provided-methods">
<h3>Provided Methods<a class="headerlink" href="#provided-methods" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">__call__</span></code></p>
<p>This provides a consistent interface for element construction. In
particular, it makes sure that conversion always gives the same
result as coercion, if a coercion exists. (This used to be violated
for some Rings in Sage as the code for conversion and coercion got
edited separately.) Let R be a Parent and assume the user types
R(x), where x has parent X.  Roughly speaking, the following occurs:</p>
<ol class="arabic simple">
<li>If X <code class="docutils literal notranslate"><span class="pre">is</span></code> R, return x (*)</li>
<li>If there is a coercion <span class="math notranslate nohighlight">\(f: X \rightarrow R\)</span>, return <span class="math notranslate nohighlight">\(f(x)\)</span></li>
<li>If there is a coercion <span class="math notranslate nohighlight">\(f: R \rightarrow X\)</span>, try to return <span class="math notranslate nohighlight">\({f^{-1}}(x)\)</span></li>
<li>Return <code class="docutils literal notranslate"><span class="pre">R._element_constructor_(x)</span></code> (**)</li>
</ol>
<p>Keywords and extra arguments are passed on. The result of all this logic is cached.</p>
<p>(*) Unless there is a “copy” keyword like R(x, copy=False)</p>
<p>(**) Technically, a generic morphism is created from X to R, which
may use magic methods like <code class="docutils literal notranslate"><span class="pre">_integer_</span></code> or other data provided by
<code class="docutils literal notranslate"><span class="pre">_populate_coercion_lists_</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">coerce</span></code></p>
<p>Coerces elements into self, raising a type error if there is no
coercion map.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">coerce_map_from,</span> <span class="pre">convert_map_from</span></code></p>
<p>Returns an actual <code class="docutils literal notranslate"><span class="pre">Morphism</span></code> object to coerce/convert from
another Parent to self. Barring direct construction of elements of
R, <code class="docutils literal notranslate"><span class="pre">R.convert_map_from(S)</span></code> will provide a callable Python object
which is the fastest way to convert elements of S to elements of
R.  From Cython, it can be invoked via the cdef <code class="docutils literal notranslate"><span class="pre">_call_</span></code> method.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">has_coerce_map_from</span></code></p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> depending on whether or not there is
a coercion.  <code class="docutils literal notranslate"><span class="pre">R.has_coerce_map_from(S)</span></code> is shorthand for
<code class="docutils literal notranslate"><span class="pre">R.coerce_map_from(S)</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code></p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">get_action</span></code></p>
<p>This will unwind all the
<code class="docutils literal notranslate"><span class="pre">_rmul_,</span> <span class="pre">_lmul_,</span> <span class="pre">_r_action_,</span> <span class="pre">_l_action_,</span> <span class="pre">...</span></code> methods to provide
an actual <code class="docutils literal notranslate"><span class="pre">Action</span></code> object, if one exists.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="discovering-new-parents">
<h2>Discovering new parents<a class="headerlink" href="#discovering-new-parents" title="Permalink to this headline">¶</a></h2>
<p>New parents are discovered using an algorithm in
sage/category/pushout.py.  The fundamental idea is that most Parents
in Sage are constructed from simpler objects via various functors.
These are accessed via the <code class="xref py py-meth docutils literal notranslate"><span class="pre">construction()</span></code> method, which returns a
(simpler) Parent along with a functor with which one can create self.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">CC</span><span class="o">.</span><span class="n">construction</span><span class="p">()</span>
<span class="go">(AlgebraicClosureFunctor, Real Field with 53 bits of precision)</span>
<span class="gp">sage: </span><span class="n">RR</span><span class="o">.</span><span class="n">construction</span><span class="p">()</span>
<span class="go">(Completion[+Infinity, prec=53], Rational Field)</span>
<span class="gp">sage: </span><span class="n">QQ</span><span class="o">.</span><span class="n">construction</span><span class="p">()</span>
<span class="go">(FractionField, Integer Ring)</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="o">.</span><span class="n">construction</span><span class="p">()</span>  <span class="c1"># None</span>

<span class="gp">sage: </span><span class="n">Zp</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">construction</span><span class="p">()</span>
<span class="go">(Completion[5, prec=20], Integer Ring)</span>
<span class="gp">sage: </span><span class="n">QQ</span><span class="o">.</span><span class="n">completion</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="p">{})</span>
<span class="go">5-adic Field with capped relative precision 100</span>
<span class="gp">sage: </span><span class="n">c</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">RR</span><span class="o">.</span><span class="n">construction</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">construction</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">commutes</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">RR</span> <span class="o">==</span> <span class="n">c</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">pushout</span><span class="o">.</span><span class="n">construction_tower</span><span class="p">(</span><span class="n">Frac</span><span class="p">(</span><span class="n">CDF</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]))</span>
<span class="go">[(None,</span>
<span class="go">  Fraction Field of Univariate Polynomial Ring in x over Complex Double Field),</span>
<span class="go"> (FractionField, Univariate Polynomial Ring in x over Complex Double Field),</span>
<span class="go"> (Poly[x], Complex Double Field),</span>
<span class="go"> (AlgebraicClosureFunctor, Real Double Field),</span>
<span class="go"> (Completion[+Infinity, prec=53], Rational Field),</span>
<span class="go"> (FractionField, Integer Ring)]</span>
</pre></div>
</div>
<p>Given Parents R and S, such that there is no coercion either from R to
S or from S to R, one can find a common Z with coercions
<span class="math notranslate nohighlight">\(R \rightarrow Z\)</span> and <span class="math notranslate nohighlight">\(S \rightarrow Z\)</span> by considering the sequence of
construction functors to get from a common ancestor to both R and S.
We then use a <em>heuristic</em> algorithm to interleave these constructors
in an attempt to arrive at a suitable Z (if one exists). For example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">construction</span><span class="p">()</span>
<span class="go">(Poly[x], Integer Ring)</span>
<span class="gp">sage: </span><span class="n">QQ</span><span class="o">.</span><span class="n">construction</span><span class="p">()</span>
<span class="go">(FractionField, Integer Ring)</span>
<span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">pushout</span><span class="o">.</span><span class="n">pushout</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">QQ</span><span class="p">)</span>
<span class="go">Univariate Polynomial Ring in x over Rational Field</span>
<span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">pushout</span><span class="o">.</span><span class="n">pushout</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">construction</span><span class="p">()</span>
<span class="go">(Poly[x], Rational Field)</span>
</pre></div>
</div>
<p>The common ancestor is <span class="math notranslate nohighlight">\(Z\)</span> and our options for Z are
<span class="math notranslate nohighlight">\(\mathrm{Frac}(\ZZ[x])\)</span> or <span class="math notranslate nohighlight">\(\mathrm{Frac}(\ZZ)[x]\)</span>.
In Sage we choose the later, treating the fraction
field functor as binding “more tightly” than the polynomial functor,
as most people agree that <span class="math notranslate nohighlight">\(\QQ[x]\)</span> is the more natural choice. The same
procedure is applied to more complicated Parents, returning a new
Parent if one can be unambiguously determined.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">pushout</span><span class="o">.</span><span class="n">pushout</span><span class="p">(</span><span class="n">Frac</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;x,y,z&#39;</span><span class="p">]),</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;z, t&#39;</span><span class="p">])</span>
<span class="go">Univariate Polynomial Ring in t over Fraction Field of Multivariate Polynomial Ring in x, y, z over Rational Field</span>
</pre></div>
</div>
</div>
<div class="section" id="modules">
<h2>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="sage/structure/coerce.html">The Coercion Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="sage/structure/coerce_actions.html">Coerce actions</a></li>
<li class="toctree-l1"><a class="reference internal" href="sage/structure/coerce_maps.html">Coerce maps</a></li>
<li class="toctree-l1"><a class="reference internal" href="sage/categories/pushout.html">Coercion via Construction Functors</a></li>
<li class="toctree-l1"><a class="reference internal" href="sage/categories/action.html">Group, ring, etc. actions on objects.</a></li>
<li class="toctree-l1"><a class="reference internal" href="sage/structure/coerce_dict.html">Containers for storing coercion data</a></li>
<li class="toctree-l1"><a class="reference internal" href="sage/structure/coerce_exceptions.html">Exceptions raised by the coercion model</a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and Tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference external" href="../genindex.html">Index</a></li>
<li><a class="reference external" href="../py-modindex.html">Module Index</a></li>
<li><a class="reference external" href="../search.html">Search Page</a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Coercion</a><ul>
<li><a class="reference internal" href="#preliminaries">Preliminaries</a><ul>
<li><a class="reference internal" href="#what-is-coercion-all-about">What is coercion all about?</a></li>
<li><a class="reference internal" href="#parents-and-elements">Parents and Elements</a></li>
<li><a class="reference internal" href="#maps-between-parents">Maps between Parents</a></li>
</ul>
</li>
<li><a class="reference internal" href="#basic-arithmetic-rules">Basic Arithmetic Rules</a></li>
<li><a class="reference internal" href="#how-to-implement">How to Implement</a><ul>
<li><a class="reference internal" href="#methods-to-implement">Methods to implement</a></li>
<li><a class="reference internal" href="#example">Example</a></li>
<li><a class="reference internal" href="#provided-methods">Provided Methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#discovering-new-parents">Discovering new parents</a></li>
<li><a class="reference internal" href="#modules">Modules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and Tables</a></li>
</ul>

  <h4>Next topic</h4>
  <p class="topless"><a href="sage/structure/coerce.html"
                        title="next chapter">The Coercion Model</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="sage/structure/coerce.html" title="The Coercion Model"
             >next</a> |</li>
  
    
      <a href="../../index.html"><img src="../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
      <a href="../index.html"> Sage Reference Manual </a> &raquo;
    
  
  
        <li class="nav-item nav-item-0"><a href="#">Coercion</a> &#187;</li>
 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2019, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>