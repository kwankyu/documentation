
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Convex rational polyhedral cones &#8212; Sage Reference Manual v8.3: Combinatorial and Discrete Geometry</title>
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Rational polyhedral fans" href="fan.html" />
    <link rel="prev" title="Toric lattices" href="toric_lattice.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="fan.html" title="Rational polyhedral fans"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="toric_lattice.html" title="Toric lattices"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Combinatorial and Discrete Geometry</a> &#187;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="convex-rational-polyhedral-cones">
<span id="sage-geometry-cone"></span><h1>Convex rational polyhedral cones<a class="headerlink" href="#convex-rational-polyhedral-cones" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.geometry.cone"></span><p>This module was designed as a part of framework for toric varieties
(<a class="reference external" href="../../../schemes/sage/schemes/toric/variety.html#module-sage.schemes.toric.variety" title="(in Sage Reference Manual: Schemes v8.3)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">variety</span></code></a>,
<a class="reference external" href="../../../schemes/sage/schemes/toric/fano_variety.html#module-sage.schemes.toric.fano_variety" title="(in Sage Reference Manual: Schemes v8.3)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fano_variety</span></code></a>). While the emphasis is on
strictly convex cones, non-strictly convex cones are supported as well. Work
with distinct lattices (in the sense of discrete subgroups spanning vector
spaces) is supported. The default lattice is <a class="reference internal" href="toric_lattice.html#sage.geometry.toric_lattice.ToricLatticeFactory" title="sage.geometry.toric_lattice.ToricLatticeFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">ToricLattice</span></code></a> <span class="math notranslate nohighlight">\(N\)</span> of the appropriate
dimension. The only case when you must specify lattice explicitly is creation
of a 0-dimensional cone, where dimension of the ambient space cannot be
guessed.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li>Andrey Novoseltsev (2010-05-13): initial version.</li>
<li>Andrey Novoseltsev (2010-06-17): substantial improvement during review by
Volker Braun.</li>
<li>Volker Braun (2010-06-21): various spanned/quotient/dual lattice
computations added.</li>
<li>Volker Braun (2010-12-28): Hilbert basis for cones.</li>
<li>Andrey Novoseltsev (2012-02-23): switch to PointCollection container.</li>
</ul>
<p>EXAMPLES:</p>
<p>Use <a class="reference internal" href="#sage.geometry.cone.Cone" title="sage.geometry.cone.Cone"><code class="xref py py-func docutils literal notranslate"><span class="pre">Cone()</span></code></a> to construct cones:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">octant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">halfspace</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">positive_xy</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">four_rays</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
</pre></div>
</div>
<p>For all of the cones above we have provided primitive generating rays, but in
fact this is not necessary - a cone can be constructed from any collection of
rays (from the same space, of course). If there are non-primitive (or even
non-integral) rays, they will be replaced with primitive ones. If there are
extra rays, they will be discarded. Of course, this means that <a class="reference internal" href="#sage.geometry.cone.Cone" title="sage.geometry.cone.Cone"><code class="xref py py-func docutils literal notranslate"><span class="pre">Cone()</span></code></a>
has to do some work before actually constructing the cone and sometimes it is
not desirable, if you know for sure that your input is already “good”. In this
case you can use options <code class="docutils literal notranslate"><span class="pre">check=False</span></code> to force <a class="reference internal" href="#sage.geometry.cone.Cone" title="sage.geometry.cone.Cone"><code class="xref py py-func docutils literal notranslate"><span class="pre">Cone()</span></code></a> to use
exactly the directions that you have specified and <code class="docutils literal notranslate"><span class="pre">normalize=False</span></code> to
force it to use exactly the rays that you have specified. However, it is
better not to use these possibilities without necessity, since cones are
assumed to be represented by a minimal set of primitive generating rays.
See <a class="reference internal" href="#sage.geometry.cone.Cone" title="sage.geometry.cone.Cone"><code class="xref py py-func docutils literal notranslate"><span class="pre">Cone()</span></code></a> for further documentation on construction.</p>
<p>Once you have a cone, you can perform numerous operations on it. The most
important ones are, probably, ray accessing methods:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rays</span> <span class="o">=</span> <span class="n">halfspace</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">rays</span>
<span class="go">N( 0,  0, 1),</span>
<span class="go">N( 0,  1, 0),</span>
<span class="go">N( 0, -1, 0),</span>
<span class="go">N( 1,  0, 0),</span>
<span class="go">N(-1,  0, 0)</span>
<span class="go">in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">rays</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
<span class="go">frozenset({N(-1, 0, 0), N(0, -1, 0), N(0, 0, 1), N(0, 1, 0), N(1, 0, 0)})</span>
<span class="gp">sage: </span><span class="n">rays</span><span class="o">.</span><span class="n">matrix</span><span class="p">()</span>
<span class="go">[ 0  0  1]</span>
<span class="go">[ 0  1  0]</span>
<span class="go">[ 0 -1  0]</span>
<span class="go">[ 1  0  0]</span>
<span class="go">[-1  0  0]</span>
<span class="gp">sage: </span><span class="n">rays</span><span class="o">.</span><span class="n">column_matrix</span><span class="p">()</span>
<span class="go">[ 0  0  0  1 -1]</span>
<span class="go">[ 0  1 -1  0  0]</span>
<span class="go">[ 1  0  0  0  0]</span>
<span class="gp">sage: </span><span class="n">rays</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">N(1, 0, 0)</span>
<span class="go">in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">rays</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">N(1, 0, 0)</span>
<span class="gp">sage: </span><span class="n">halfspace</span><span class="o">.</span><span class="n">ray</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">N(1, 0, 0)</span>
</pre></div>
</div>
<p>The method <a class="reference internal" href="#sage.geometry.cone.IntegralRayCollection.rays" title="sage.geometry.cone.IntegralRayCollection.rays"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rays()</span></code></a> returns a
<a class="reference internal" href="point_collection.html#sage.geometry.point_collection.PointCollection" title="sage.geometry.point_collection.PointCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointCollection</span></code></a> with the
<span class="math notranslate nohighlight">\(i\)</span>-th element being the primitive integral generator of the <span class="math notranslate nohighlight">\(i\)</span>-th
ray. It is possible to convert this collection to a matrix with either
rows or columns corresponding to these generators. You may also change
the default
<a class="reference internal" href="point_collection.html#sage.geometry.point_collection.PointCollection.output_format" title="sage.geometry.point_collection.PointCollection.output_format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">output_format()</span></code></a>
of all point collections to be such a matrix.</p>
<p>If you want to do something with each ray of a cone, you can write</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">ray</span> <span class="ow">in</span> <span class="n">positive_xy</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="n">ray</span><span class="p">)</span>
<span class="go">N(1, 0, 0)</span>
<span class="go">N(0, 1, 0)</span>
</pre></div>
</div>
<p>There are two dimensions associated to each cone - the dimension of the
subspace spanned by the cone and the dimension of the space where it lives:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">positive_xy</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">positive_xy</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>You also may be interested in this dimension:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dim</span><span class="p">(</span><span class="n">positive_xy</span><span class="o">.</span><span class="n">linear_subspace</span><span class="p">())</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">dim</span><span class="p">(</span><span class="n">halfspace</span><span class="o">.</span><span class="n">linear_subspace</span><span class="p">())</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Or, perhaps, all you care about is whether it is zero or not:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">positive_xy</span><span class="o">.</span><span class="n">is_strictly_convex</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">halfspace</span><span class="o">.</span><span class="n">is_strictly_convex</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>You can also perform these checks:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">positive_xy</span><span class="o">.</span><span class="n">is_simplicial</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">four_rays</span><span class="o">.</span><span class="n">is_simplicial</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">positive_xy</span><span class="o">.</span><span class="n">is_smooth</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>You can work with subcones that form faces of other cones:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">face</span> <span class="o">=</span> <span class="n">four_rays</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">face</span>
<span class="go">2-d face of 3-d cone in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">face</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(-1, -1, 1),</span>
<span class="go">N(-1,  1, 1)</span>
<span class="go">in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">face</span><span class="o">.</span><span class="n">ambient_ray_indices</span><span class="p">()</span>
<span class="go">(2, 3)</span>
<span class="gp">sage: </span><span class="n">four_rays</span><span class="o">.</span><span class="n">rays</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">ambient_ray_indices</span><span class="p">())</span>
<span class="go">N(-1, -1, 1),</span>
<span class="go">N(-1,  1, 1)</span>
<span class="go">in 3-d lattice N</span>
</pre></div>
</div>
<p>If you need to know inclusion relations between faces, you can use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">four_rays</span><span class="o">.</span><span class="n">face_lattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">level_sets</span><span class="p">()]</span>
<span class="go">[1, 4, 4, 1]</span>
<span class="gp">sage: </span><span class="n">face</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">level_sets</span><span class="p">()[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">face</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(1,  1, 1),</span>
<span class="go">N(1, -1, 1)</span>
<span class="go">in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span><span class="o">.</span><span class="n">neighbors_in</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
<span class="go">[1-d face of 3-d cone in 3-d lattice N,</span>
<span class="go"> 1-d face of 3-d cone in 3-d lattice N]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The order of faces in level sets of
the face lattice may differ from the order of faces returned by
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.faces" title="sage.geometry.cone.ConvexRationalPolyhedralCone.faces"><code class="xref py py-meth docutils literal notranslate"><span class="pre">faces()</span></code></a>. While the first order is
random, the latter one ensures that one-dimensional faces are listed in
the same order as generating rays.</p>
</div>
<p>When all the functionality provided by cones is not enough, you may want to
check if you can do necessary things using polyhedra corresponding to cones:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">four_rays</span><span class="o">.</span><span class="n">polyhedron</span><span class="p">()</span>
<span class="go">A 3-dimensional polyhedron in ZZ^3 defined as</span>
<span class="go">the convex hull of 1 vertex and 4 rays</span>
</pre></div>
</div>
<p>And of course you are always welcome to suggest new features that should be
added to cones!</p>
<p>REFERENCES:</p>
<ul class="simple">
<li><a class="reference internal" href="../../../references/index.html#fu1993" id="id1">[Fu1993]</a></li>
</ul>
<dl class="function">
<dt id="sage.geometry.cone.Cone">
<code class="descclassname">sage.geometry.cone.</code><code class="descname">Cone</code><span class="sig-paren">(</span><em>rays</em>, <em>lattice=None</em>, <em>check=True</em>, <em>normalize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.Cone" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a (not necessarily strictly) convex rational polyhedral cone.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">rays</span></code> – a list of rays. Each ray should be given as a list
or a vector convertible to the rational extension of the given
<code class="docutils literal notranslate"><span class="pre">lattice</span></code>. May also be specified by a
<a class="reference internal" href="polyhedron/base.html#sage.geometry.polyhedron.base.Polyhedron_base" title="sage.geometry.polyhedron.base.Polyhedron_base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Polyhedron_base</span></code></a> object;</li>
<li><code class="docutils literal notranslate"><span class="pre">lattice</span></code> – <a class="reference internal" href="toric_lattice.html#sage.geometry.toric_lattice.ToricLatticeFactory" title="sage.geometry.toric_lattice.ToricLatticeFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">ToricLattice</span></code></a>, <span class="math notranslate nohighlight">\(\ZZ^n\)</span>, or any
other object that behaves like these. If not specified, an attempt will
be made to determine an appropriate toric lattice automatically;</li>
<li><code class="docutils literal notranslate"><span class="pre">check</span></code> – by default the input data will be checked for
correctness (e.g. that all rays have the same number of
components) and generating rays will be constructed from
<code class="docutils literal notranslate"><span class="pre">rays</span></code>. If you know that the input is a minimal set of
generators of a valid cone, you may significantly decrease
construction time using <code class="docutils literal notranslate"><span class="pre">check=False</span></code> option;</li>
<li><code class="docutils literal notranslate"><span class="pre">normalize</span></code> – you can further speed up construction using
<code class="docutils literal notranslate"><span class="pre">normalize=False</span></code> option. In this case <code class="docutils literal notranslate"><span class="pre">rays</span></code> must be a list of
immutable primitive rays in <code class="docutils literal notranslate"><span class="pre">lattice</span></code>. In general, you should not use
this option, it is designed for code optimization and does not give as
drastic improvement in speed as the previous one.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>convex rational polyhedral cone determined by <code class="docutils literal notranslate"><span class="pre">rays</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<p>Let’s define a cone corresponding to the first quadrant of the plane
(note, you can even mix objects of different types to represent rays, as
long as you let this function to perform all the checks and necessary
conversions!):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">quadrant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">quadrant</span>
<span class="go">2-d cone in 2-d lattice N</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(1, 0),</span>
<span class="go">N(0, 1)</span>
<span class="go">in 2-d lattice N</span>
</pre></div>
</div>
<p>If you give more rays than necessary, the extra ones will be discarded:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(0, 1),</span>
<span class="go">N(1, 0)</span>
<span class="go">in 2-d lattice N</span>
</pre></div>
</div>
<p>However, this work is not done with <code class="docutils literal notranslate"><span class="pre">check=False</span></code> option, so use it
carefully!</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(1, 0),</span>
<span class="go">N(0, 1),</span>
<span class="go">N(1, 1),</span>
<span class="go">N(0, 1)</span>
<span class="go">in 2-d lattice N</span>
</pre></div>
</div>
<p>Even worse things can happen with <code class="docutils literal notranslate"><span class="pre">normalize=False</span></code> option:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">check</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;tuple&#39; object has no attribute &#39;parent&#39;</span>
</pre></div>
</div>
<p>You can construct different “not” cones: not full-dimensional, not
strictly convex, not containing any rays:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">one_dimensional_cone</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">one_dimensional_cone</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">half_plane</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">half_plane</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N( 0, 1),</span>
<span class="go">N( 1, 0),</span>
<span class="go">N(-1, 0)</span>
<span class="go">in 2-d lattice N</span>
<span class="gp">sage: </span><span class="n">half_plane</span><span class="o">.</span><span class="n">is_strictly_convex</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">origin</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">origin</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">Empty collection</span>
<span class="go">in 2-d lattice N</span>
<span class="gp">sage: </span><span class="n">origin</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">origin</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>You may construct the cone above without giving any rays, but in this case
you must provide <code class="docutils literal notranslate"><span class="pre">lattice</span></code> explicitly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">origin</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">lattice must be given explicitly if there are no rays!</span>
<span class="gp">sage: </span><span class="n">origin</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">ToricLattice</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">origin</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">origin</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">origin</span><span class="o">.</span><span class="n">lattice</span><span class="p">()</span>
<span class="go">2-d lattice N</span>
</pre></div>
</div>
<p>Of course, you can also provide <code class="docutils literal notranslate"><span class="pre">lattice</span></code> in other cases:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">ToricLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c1</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">L</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c1</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">L(1, 0, 0),</span>
<span class="go">L(1, 1, 1)</span>
<span class="go">in 3-d lattice L</span>
</pre></div>
</div>
<p>Or you can construct cones from rays of a particular lattice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ray1</span> <span class="o">=</span> <span class="n">L</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ray2</span> <span class="o">=</span> <span class="n">L</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c2</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([</span><span class="n">ray1</span><span class="p">,</span> <span class="n">ray2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">c2</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">L(1, 0, 0),</span>
<span class="go">L(1, 1, 1)</span>
<span class="go">in 3-d lattice L</span>
<span class="gp">sage: </span><span class="n">c1</span> <span class="o">==</span> <span class="n">c2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>When the cone in question is not strictly convex, the standard form for
the “generating rays” of the linear subspace is “basis vectors and their
negatives”, as in the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">plane</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">plane</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N( 0,  1),</span>
<span class="go">N( 0, -1),</span>
<span class="go">N( 1,  0),</span>
<span class="go">N(-1,  0)</span>
<span class="go">in 2-d lattice N</span>
</pre></div>
</div>
<p>The cone can also be specified by a
<a class="reference internal" href="polyhedron/base.html#sage.geometry.polyhedron.base.Polyhedron_base" title="sage.geometry.polyhedron.base.Polyhedron_base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Polyhedron_base</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">plane</span><span class="o">.</span><span class="n">polyhedron</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">2-d cone in 2-d lattice N</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">plane</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone">
<em class="property">class </em><code class="descclassname">sage.geometry.cone.</code><code class="descname">ConvexRationalPolyhedralCone</code><span class="sig-paren">(</span><em>rays=None</em>, <em>lattice=None</em>, <em>ambient=None</em>, <em>ambient_ray_indices=None</em>, <em>PPL=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.geometry.cone.IntegralRayCollection" title="sage.geometry.cone.IntegralRayCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.geometry.cone.IntegralRayCollection</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">_abcoll.Container</span></code></p>
<p>Create a convex rational polyhedral cone.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This class does not perform any checks of correctness of input nor
does it convert input into the standard representation. Use
<a class="reference internal" href="#sage.geometry.cone.Cone" title="sage.geometry.cone.Cone"><code class="xref py py-func docutils literal notranslate"><span class="pre">Cone()</span></code></a> to construct cones.</p>
</div>
<p>Cones are immutable, but they cache most of the returned values.</p>
<p>INPUT:</p>
<p>The input can be either:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">rays</span></code> – list of immutable primitive vectors in <code class="docutils literal notranslate"><span class="pre">lattice</span></code>;</li>
<li><code class="docutils literal notranslate"><span class="pre">lattice</span></code> – <a class="reference internal" href="toric_lattice.html#sage.geometry.toric_lattice.ToricLatticeFactory" title="sage.geometry.toric_lattice.ToricLatticeFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">ToricLattice</span></code></a>, <span class="math notranslate nohighlight">\(\ZZ^n\)</span>, or any
other object that behaves like these. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, it will be determined
as <a class="reference external" href="../../../structure/sage/structure/element.html#sage.structure.element.parent" title="(in Sage Reference Manual: Parents and Elements v8.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">parent()</span></code></a> of the first ray. Of course, this cannot be done if
there are no rays, so in this case you must give an appropriate
<code class="docutils literal notranslate"><span class="pre">lattice</span></code> directly.</li>
</ul>
<p>or (these parameters must be given as keywords):</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ambient</span></code> – ambient structure of this cone, a bigger <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone" title="sage.geometry.cone.ConvexRationalPolyhedralCone"><code class="xref py py-class docutils literal notranslate"><span class="pre">cone</span></code></a> or a <a class="reference internal" href="fan.html#sage.geometry.fan.RationalPolyhedralFan" title="sage.geometry.fan.RationalPolyhedralFan"><code class="xref py py-class docutils literal notranslate"><span class="pre">fan</span></code></a>, this cone <em>must be a face
of</em> <code class="docutils literal notranslate"><span class="pre">ambient</span></code>;</li>
<li><code class="docutils literal notranslate"><span class="pre">ambient_ray_indices</span></code> – increasing list or tuple of integers, indices
of rays of <code class="docutils literal notranslate"><span class="pre">ambient</span></code> generating this cone.</li>
</ul>
<p>In both cases, the following keyword parameter may be specified in addition:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">PPL</span></code> – either <code class="docutils literal notranslate"><span class="pre">None</span></code> (default) or a
<a class="reference external" href="../../../libs/sage/libs/ppl.html#sage.libs.ppl.C_Polyhedron" title="(in Sage Reference Manual: C/C++ Library Interfaces v8.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">C_Polyhedron</span></code></a> representing the cone. This
serves only to cache the polyhedral data if you know it
already. The polyhedron will be set immutable.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>convex rational polyhedral cone.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Every cone has its ambient structure. If it was not specified, it is
this cone itself.</p>
</div>
<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.Hilbert_basis">
<code class="descname">Hilbert_basis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.Hilbert_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Hilbert basis of the cone.</p>
<p>Given a strictly convex cone <span class="math notranslate nohighlight">\(C\subset \RR^d\)</span>, the Hilbert
basis of <span class="math notranslate nohighlight">\(C\)</span> is the set of all irreducible elements in the
semigroup <span class="math notranslate nohighlight">\(C\cap \ZZ^d\)</span>. It is the unique minimal generating
set over <span class="math notranslate nohighlight">\(\ZZ\)</span> for the integral points <span class="math notranslate nohighlight">\(C\cap \ZZ^d\)</span>.</p>
<p>If the cone <span class="math notranslate nohighlight">\(C\)</span> is not strictly convex, this method finds the
(unique) minimal set of lattice points that need to be added
to the defining rays of the cone to generate the whole
semigroup <span class="math notranslate nohighlight">\(C\cap \ZZ^d\)</span>. But because the rays of the cone are
not unique nor necessarily minimal in this case, neither is
the returned generating set (consisting of the rays plus
additional generators).</p>
<p>See also <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.semigroup_generators" title="sage.geometry.cone.ConvexRationalPolyhedralCone.semigroup_generators"><code class="xref py py-meth docutils literal notranslate"><span class="pre">semigroup_generators()</span></code></a> if you are not
interested in a minimal set of generators.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a
<a class="reference internal" href="point_collection.html#sage.geometry.point_collection.PointCollection" title="sage.geometry.point_collection.PointCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointCollection</span></code></a>. The
rays of <code class="docutils literal notranslate"><span class="pre">self</span></code> are the first <code class="docutils literal notranslate"><span class="pre">self.nrays()</span></code> entries.</li>
</ul>
<p>EXAMPLES:</p>
<p>The following command ensures that the output ordering in the examples
below is independent of TOPCOM, you don’t have to use it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">PointConfiguration</span><span class="o">.</span><span class="n">set_engine</span><span class="p">(</span><span class="s1">&#39;internal&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We start with a simple case of a non-smooth 2-dimensional cone:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cone</span><span class="p">([</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="p">])</span><span class="o">.</span><span class="n">Hilbert_basis</span><span class="p">()</span>
<span class="go">N(1, 0),</span>
<span class="go">N(1, 2),</span>
<span class="go">N(1, 1)</span>
<span class="go">in 2-d lattice N</span>
</pre></div>
</div>
<p>Two more complicated example from GAP/toric:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cone</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">Hilbert_basis</span><span class="p">()</span>
<span class="go">M(0,  1),</span>
<span class="go">M(4, -3),</span>
<span class="go">M(3, -2),</span>
<span class="go">M(2, -1),</span>
<span class="go">M(1,  0)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">Hilbert_basis</span><span class="p">()</span>           <span class="c1"># long time</span>
<span class="go">M(10,  -7,  0,  1),</span>
<span class="go">M(-5,  21,  0, -3),</span>
<span class="go">M( 0,  -2,  0,  1),</span>
<span class="go">M(15, -63, 25,  9),</span>
<span class="go">M( 2,  -3,  0,  1),</span>
<span class="go">M( 1,  -4,  1,  1),</span>
<span class="go">M(-1,   3,  0,  0),</span>
<span class="go">M( 4,  -4,  0,  1),</span>
<span class="go">M( 1,  -5,  2,  1),</span>
<span class="go">M( 3,  -5,  1,  1),</span>
<span class="go">M( 6,  -5,  0,  1),</span>
<span class="go">M( 3, -13,  5,  2),</span>
<span class="go">M( 2,  -6,  2,  1),</span>
<span class="go">M( 5,  -6,  1,  1),</span>
<span class="go">M( 0,   1,  0,  0),</span>
<span class="go">M( 8,  -6,  0,  1),</span>
<span class="go">M(-2,   8,  0, -1),</span>
<span class="go">M(10, -42, 17,  6),</span>
<span class="go">M( 7, -28, 11,  4),</span>
<span class="go">M( 5, -21,  9,  3),</span>
<span class="go">M( 6, -21,  8,  3),</span>
<span class="go">M( 5, -14,  5,  2),</span>
<span class="go">M( 2,  -7,  3,  1),</span>
<span class="go">M( 4,  -7,  2,  1),</span>
<span class="go">M( 7,  -7,  1,  1),</span>
<span class="go">M( 0,   0,  1,  0),</span>
<span class="go">M(-3,  14,  0, -2),</span>
<span class="go">M(-1,   7,  0, -1),</span>
<span class="go">M( 1,   0,  0,  0)</span>
<span class="go">in 4-d lattice M</span>
</pre></div>
</div>
<p>Not a strictly convex cone:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">wedge</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">])</span>
<span class="gp">sage: </span><span class="n">wedge</span><span class="o">.</span><span class="n">semigroup_generators</span><span class="p">()</span>
<span class="go">(N(1, 0, 0), N(1, 1, 0), N(1, 2, 0), N(0, 0, 1), N(0, 0, -1))</span>
<span class="gp">sage: </span><span class="n">wedge</span><span class="o">.</span><span class="n">Hilbert_basis</span><span class="p">()</span>
<span class="go">N(1, 2,  0),</span>
<span class="go">N(1, 0,  0),</span>
<span class="go">N(0, 0,  1),</span>
<span class="go">N(0, 0, -1),</span>
<span class="go">N(1, 1,  0)</span>
<span class="go">in 3-d lattice N</span>
</pre></div>
</div>
<p>Not full-dimensional cones are ok, too (see
<a class="reference external" href="http://trac.sagemath.org/sage_trac/ticket/11312">http://trac.sagemath.org/sage_trac/ticket/11312</a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span><span class="o">.</span><span class="n">Hilbert_basis</span><span class="p">()</span>
<span class="go">N( 1, 1, 0),</span>
<span class="go">N(-1, 1, 0),</span>
<span class="go">N( 0, 1, 0)</span>
<span class="go">in 3-d lattice N</span>
</pre></div>
</div>
<p>ALGORITHM:</p>
<p>The primal Normaliz algorithm, see <a class="reference internal" href="../../../references/index.html#normaliz" id="id2">[Normaliz]</a>.</p>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.Hilbert_coefficients">
<code class="descname">Hilbert_coefficients</code><span class="sig-paren">(</span><em>point</em>, <em>solver=None</em>, <em>verbose=0</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.Hilbert_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expansion coefficients of <code class="docutils literal notranslate"><span class="pre">point</span></code> with respect to
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.Hilbert_basis" title="sage.geometry.cone.ConvexRationalPolyhedralCone.Hilbert_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Hilbert_basis()</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">point</span></code> – a <a class="reference internal" href="#sage.geometry.cone.IntegralRayCollection.lattice" title="sage.geometry.cone.IntegralRayCollection.lattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lattice()</span></code></a> point
in the cone, or something that can be converted to a
point. For example, a list or tuple of integers.</li>
<li><code class="docutils literal notranslate"><span class="pre">solver</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) Specify a Linear Program (LP) solver
to be used. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the default one is used. For more
information on LP solvers and which default solver is used, see the
method <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram.solve" title="(in Sage Reference Manual: Numerical Optimization v8.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a> of
the class <a class="reference external" href="../../../numerical/sage/numerical/mip.html#sage.numerical.mip.MixedIntegerLinearProgram" title="(in Sage Reference Manual: Numerical Optimization v8.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">MixedIntegerLinearProgram</span></code></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">0</span></code>). Sets the level of verbosity
of the LP solver. Set to 0 by default, which means quiet.</li>
</ul>
<p>OUTPUT:</p>
<p>A <span class="math notranslate nohighlight">\(\ZZ\)</span>-vector of length <code class="docutils literal notranslate"><span class="pre">len(self.Hilbert_basis())</span></code> with nonnegative
components.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since the Hilbert basis elements are not necessarily linearly
independent, the expansion coefficients are not unique. However,
this method will always return the same expansion coefficients when
invoked with the same argument.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(1, 0),</span>
<span class="go">N(0, 1)</span>
<span class="go">in 2-d lattice N</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">Hilbert_coefficients</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(3, 2)</span>
</pre></div>
</div>
<p>A more complicated example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">ToricLattice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([</span><span class="n">N</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">N</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">Hilbert_basis</span><span class="p">()</span>
<span class="go">N(1, 0),</span>
<span class="go">N(1, 2),</span>
<span class="go">N(1, 1)</span>
<span class="go">in 2-d lattice N</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">Hilbert_coefficients</span><span class="p">(</span> <span class="n">N</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
<span class="go">(0, 0, 1)</span>
</pre></div>
</div>
<p>The cone need not be strictly convex:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">ToricLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([</span><span class="n">N</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">N</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">N</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">N</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">Hilbert_basis</span><span class="p">()</span>
<span class="go">N(1, 2,  0),</span>
<span class="go">N(1, 0,  0),</span>
<span class="go">N(0, 0,  1),</span>
<span class="go">N(0, 0, -1),</span>
<span class="go">N(1, 1,  0)</span>
<span class="go">in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">Hilbert_coefficients</span><span class="p">(</span> <span class="n">N</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">(0, 0, 3, 0, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.Z_operators_gens">
<code class="descname">Z_operators_gens</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.Z_operators_gens" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute minimal generators of the Z-operators on this cone.</p>
<p>The Z-operators on a cone generalize the Z-matrices over the
nonnegative orthant. They are simply negations of the
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.cross_positive_operators_gens" title="sage.geometry.cone.ConvexRationalPolyhedralCone.cross_positive_operators_gens"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cross_positive_operators_gens()</span></code></a>.</p>
<p>OUTPUT:</p>
<p>A list of <span class="math notranslate nohighlight">\(n\)</span>-by-<span class="math notranslate nohighlight">\(n\)</span> matrices where <span class="math notranslate nohighlight">\(n\)</span> is the ambient dimension
of this cone. Each matrix <span class="math notranslate nohighlight">\(L\)</span> in the list has the property that
<span class="math notranslate nohighlight">\(s(L(x)) \le 0\)</span> whenever <span class="math notranslate nohighlight">\((x,s)\)</span> is an element of this cone’s
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.discrete_complementarity_set" title="sage.geometry.cone.ConvexRationalPolyhedralCone.discrete_complementarity_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">discrete_complementarity_set()</span></code></a>.</p>
<p>The returned matrices generate the cone of Z-operators on this
cone; that is,</p>
<ul class="simple">
<li>Any nonnegative linear combination of the returned matrices
is a Z-operator on this cone.</li>
<li>Every Z-operator on this cone is some nonnegative linear
combination of the returned matrices.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.cross_positive_operators_gens" title="sage.geometry.cone.ConvexRationalPolyhedralCone.cross_positive_operators_gens"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cross_positive_operators_gens()</span></code></a>,
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.lyapunov_like_basis" title="sage.geometry.cone.ConvexRationalPolyhedralCone.lyapunov_like_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lyapunov_like_basis()</span></code></a>,
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.positive_operators_gens" title="sage.geometry.cone.ConvexRationalPolyhedralCone.positive_operators_gens"><code class="xref py py-meth docutils literal notranslate"><span class="pre">positive_operators_gens()</span></code></a></p>
</div>
<p>REFERENCES:</p>
<p>A. Berman and R. J. Plemmons. Nonnegative Matrices in the
Mathematical Sciences. SIAM, Philadelphia, 1994.</p>
<p>M. Orlitzky.
Positive and Z-operators on closed convex cones.
<a class="reference external" href="http://www.optimization-online.org/DB_HTML/2016/09/5650.html">http://www.optimization-online.org/DB_HTML/2016/09/5650.html</a></p>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.adjacent">
<code class="descname">adjacent</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.adjacent" title="Permalink to this definition">¶</a></dt>
<dd><p>Return faces adjacent to <code class="docutils literal notranslate"><span class="pre">self</span></code> in the ambient face lattice.</p>
<p>Two <em>distinct</em> faces <span class="math notranslate nohighlight">\(F_1\)</span> and <span class="math notranslate nohighlight">\(F_2\)</span> of the same face lattice are
<strong>adjacent</strong> if all of the following conditions hold:</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\(F_1\)</span> and <span class="math notranslate nohighlight">\(F_2\)</span> have the same dimension <span class="math notranslate nohighlight">\(d\)</span>;</li>
<li><span class="math notranslate nohighlight">\(F_1\)</span> and <span class="math notranslate nohighlight">\(F_2\)</span> share a facet of dimension <span class="math notranslate nohighlight">\(d-1\)</span>;</li>
<li><span class="math notranslate nohighlight">\(F_1\)</span> and <span class="math notranslate nohighlight">\(F_2\)</span> are facets of some face of dimension <span class="math notranslate nohighlight">\(d+1\)</span>, unless
<span class="math notranslate nohighlight">\(d\)</span> is the dimension of the ambient structure.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference external" href="https://docs.python.org/library/functions.html#tuple" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone" title="sage.geometry.cone.ConvexRationalPolyhedralCone"><code class="xref py py-class docutils literal notranslate"><span class="pre">cones</span></code></a>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">octant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">octant</span><span class="o">.</span><span class="n">adjacent</span><span class="p">()</span>
<span class="go">()</span>
<span class="gp">sage: </span><span class="n">one_face</span> <span class="o">=</span> <span class="n">octant</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">one_face</span><span class="o">.</span><span class="n">adjacent</span><span class="p">())</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">one_face</span><span class="o">.</span><span class="n">adjacent</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">1-d face of 3-d cone in 3-d lattice N</span>
</pre></div>
</div>
<p>Things are a little bit subtle with fans, as we illustrate below.</p>
<p>First, we create a fan from two cones in the plane:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fan</span> <span class="o">=</span> <span class="n">Fan</span><span class="p">(</span><span class="n">cones</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span>
<span class="go">....:           rays=[(1,0), (0,1), (-1,0)])</span>
<span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">fan</span><span class="o">.</span><span class="n">generating_cone</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">cone</span><span class="o">.</span><span class="n">adjacent</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The second generating cone is adjacent to this one. Now we create the
same fan, but embedded into the 3-dimensional space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fan</span> <span class="o">=</span> <span class="n">Fan</span><span class="p">(</span><span class="n">cones</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span>
<span class="go">....:           rays=[(1,0,0), (0,1,0), (-1,0,0)])</span>
<span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">fan</span><span class="o">.</span><span class="n">generating_cone</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">cone</span><span class="o">.</span><span class="n">adjacent</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The result is as before, since we still have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fan</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Now we add another cone to make the fan 3-dimensional:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fan</span> <span class="o">=</span> <span class="n">Fan</span><span class="p">(</span><span class="n">cones</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)],</span>
<span class="go">....:           rays=[(1,0,0), (0,1,0), (-1,0,0), (0,0,1)])</span>
<span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">fan</span><span class="o">.</span><span class="n">generating_cone</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">cone</span><span class="o">.</span><span class="n">adjacent</span><span class="p">())</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Since now <code class="docutils literal notranslate"><span class="pre">cone</span></code> has smaller dimension than <code class="docutils literal notranslate"><span class="pre">fan</span></code>, it and its
adjacent cones must be facets of a bigger one, but since <code class="docutils literal notranslate"><span class="pre">cone</span></code>
in this example is generating, it is not contained in any other.</p>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.ambient">
<code class="descname">ambient</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.ambient" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ambient structure of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>cone or fan containing <code class="docutils literal notranslate"><span class="pre">self</span></code> as a face.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">ambient</span><span class="p">()</span>
<span class="go">3-d cone in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">ambient</span><span class="p">()</span> <span class="ow">is</span> <span class="n">cone</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">face</span> <span class="o">=</span> <span class="n">cone</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">face</span>
<span class="go">1-d face of 3-d cone in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">face</span><span class="o">.</span><span class="n">ambient</span><span class="p">()</span>
<span class="go">3-d cone in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">face</span><span class="o">.</span><span class="n">ambient</span><span class="p">()</span> <span class="ow">is</span> <span class="n">cone</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.ambient_ray_indices">
<code class="descname">ambient_ray_indices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.ambient_ray_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return indices of rays of the ambient structure generating <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>increasing <a class="reference external" href="https://docs.python.org/library/functions.html#tuple" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of integers.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">quadrant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">ambient_ray_indices</span><span class="p">()</span>
<span class="go">(0, 1)</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">facets</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ambient_ray_indices</span><span class="p">()</span>
<span class="go">(1,)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.cartesian_product">
<code class="descname">cartesian_product</code><span class="sig-paren">(</span><em>other</em>, <em>lattice=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.cartesian_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Cartesian product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">other</span></code> – a <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone" title="sage.geometry.cone.ConvexRationalPolyhedralCone"><code class="xref py py-class docutils literal notranslate"><span class="pre">cone</span></code></a>;</li>
<li><code class="docutils literal notranslate"><span class="pre">lattice</span></code> – (optional) the ambient lattice for the
Cartesian product cone. By default, the direct sum of the
ambient lattices of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> is constructed.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone" title="sage.geometry.cone.ConvexRationalPolyhedralCone"><code class="xref py py-class docutils literal notranslate"><span class="pre">cone</span></code></a>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,)])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">2-d cone in 2-d lattice N+N</span>
<span class="gp">sage: </span><span class="n">_</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N+N(1, 0),</span>
<span class="go">N+N(0, 1)</span>
<span class="go">in 2-d lattice N+N</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a given point is contained in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li>anything. An attempt will be made to convert all arguments into a
single element of the ambient space of <code class="docutils literal notranslate"><span class="pre">self</span></code>. If it fails,
<code class="docutils literal notranslate"><span class="pre">False</span></code> will be returned.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">True</span></code> if the given point is contained in <code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code>
otherwise.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">lattice</span><span class="p">()(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dual_lattice</span><span class="p">()(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="c1">#random output (warning)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dual_lattice</span><span class="p">()(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.cross_positive_operators_gens">
<code class="descname">cross_positive_operators_gens</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.cross_positive_operators_gens" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute minimal generators of the cross-positive operators on this
cone.</p>
<p>Any positive operator <span class="math notranslate nohighlight">\(P\)</span> on this cone will have <span class="math notranslate nohighlight">\(s(P(x)) \ge 0\)</span>
whenever <span class="math notranslate nohighlight">\(x\)</span> is an element of this cone and <span class="math notranslate nohighlight">\(s\)</span> is an element of
its dual. By contrast, the cross-positive operators need only
satisfy that property on the <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.discrete_complementarity_set" title="sage.geometry.cone.ConvexRationalPolyhedralCone.discrete_complementarity_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">discrete_complementarity_set()</span></code></a>;
that is, when <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(s\)</span> are “cross” (orthogonal).</p>
<p>The cross-positive operators (on some fixed cone) themselves
form a closed convex cone. This method computes and returns
the generators of that cone as a list of matrices.</p>
<p>Cross-positive operators are also called exponentially-positive,
since they become positive operators when exponentiated. Other
equivalent names are resolvent-positive, essentially-positive,
and quasimonotone.</p>
<p>OUTPUT:</p>
<p>A list of <span class="math notranslate nohighlight">\(n\)</span>-by-<span class="math notranslate nohighlight">\(n\)</span> matrices where <span class="math notranslate nohighlight">\(n\)</span> is the ambient dimension
of this cone. Each matrix <span class="math notranslate nohighlight">\(L\)</span> in the list has the property that
<span class="math notranslate nohighlight">\(s(L(x)) \ge 0\)</span> whenever <span class="math notranslate nohighlight">\((x,s)\)</span> is an element of this cone’s
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.discrete_complementarity_set" title="sage.geometry.cone.ConvexRationalPolyhedralCone.discrete_complementarity_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">discrete_complementarity_set()</span></code></a>.</p>
<p>The returned matrices generate the cone of cross-positive operators
on this cone; that is,</p>
<ul class="simple">
<li>Any nonnegative linear combination of the returned matrices
is cross-positive on this cone.</li>
<li>Every cross-positive operator on this cone is some nonnegative
linear combination of the returned matrices.</li>
</ul>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.lyapunov_like_basis" title="sage.geometry.cone.ConvexRationalPolyhedralCone.lyapunov_like_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lyapunov_like_basis()</span></code></a>,
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.positive_operators_gens" title="sage.geometry.cone.ConvexRationalPolyhedralCone.positive_operators_gens"><code class="xref py py-meth docutils literal notranslate"><span class="pre">positive_operators_gens()</span></code></a>,
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.Z_operators_gens" title="sage.geometry.cone.ConvexRationalPolyhedralCone.Z_operators_gens"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Z_operators_gens()</span></code></a></p>
</div>
<p>REFERENCES:</p>
<p>H. Schneider and M. Vidyasagar. Cross-positive matrices. SIAM
Journal on Numerical Analysis, 7:508-519, 1970.</p>
<p>M. Orlitzky.
Positive and Z-operators on closed convex cones.
<a class="reference external" href="http://www.optimization-online.org/DB_HTML/2016/09/5650.html">http://www.optimization-online.org/DB_HTML/2016/09/5650.html</a></p>
<p>EXAMPLES:</p>
<p>Cross-positive operators on the nonnegative orthant are
negations of Z-matrices; that is, matrices whose off-diagonal
elements are nonnegative:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">cross_positive_operators_gens</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">[0 1]  [0 0]  [1 0]  [-1  0]  [0 0]  [ 0  0]</span>
<span class="go">[0 0], [1 0], [0 0], [ 0  0], [0 1], [ 0 -1]</span>
<span class="go">]</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">K</span><span class="o">.</span><span class="n">cross_positive_operators_gens</span><span class="p">()</span>
<span class="go">....:                    for i in range(c.nrows())</span>
<span class="go">....:                    for j in range(c.ncols())</span>
<span class="go">....:                    if i != j ])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The trivial cone in a trivial space has no cross-positive
operators:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([],</span> <span class="n">ToricLattice</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">cross_positive_operators_gens</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Every operator is a cross-positive operator on the ambient
vector space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_full_space</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">cross_positive_operators_gens</span><span class="p">()</span>
<span class="go">[[1], [-1]]</span>

<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_full_space</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">cross_positive_operators_gens</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">[1 0]  [-1  0]  [0 1]  [ 0 -1]  [0 0]  [ 0  0]  [0 0]  [ 0  0]</span>
<span class="go">[0 0], [ 0  0], [0 0], [ 0  0], [1 0], [-1  0], [0 1], [ 0 -1]</span>
<span class="go">]</span>
</pre></div>
</div>
<p>A non-obvious application is to find the cross-positive
operators on the right half-plane <a class="reference internal" href="#orlitzkyposz" id="id3">[OrlitzkyPosZ]</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">cross_positive_operators_gens</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">[1 0]  [-1  0]  [0 0]  [ 0  0]  [0 0]  [ 0  0]</span>
<span class="go">[0 0], [ 0  0], [1 0], [-1  0], [0 1], [ 0 -1]</span>
<span class="go">]</span>
</pre></div>
</div>
<p>Cross-positive operators on a subspace are Lyapunov-like and
vice-versa:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_full_space</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">lls</span> <span class="o">=</span> <span class="n">span</span><span class="p">([</span> <span class="n">vector</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">....:              for l in K.lyapunov_like_basis() ])</span>
<span class="gp">sage: </span><span class="n">cs</span>  <span class="o">=</span> <span class="n">span</span><span class="p">([</span> <span class="n">vector</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
<span class="go">....:               for c in K.cross_positive_operators_gens() ])</span>
<span class="gp">sage: </span><span class="n">cs</span> <span class="o">==</span> <span class="n">lls</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.discrete_complementarity_set">
<code class="descname">discrete_complementarity_set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.discrete_complementarity_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a discrete complementarity set of this cone.</p>
<p>A discrete complementarity set of a cone is the set of all
orthogonal pairs <span class="math notranslate nohighlight">\((x,s)\)</span> where <span class="math notranslate nohighlight">\(x\)</span> is in some fixed generating
set of the cone, and <span class="math notranslate nohighlight">\(s\)</span> is in some fixed generating set of its
dual. The generators chosen for this cone and its dual are
simply their <a class="reference internal" href="#sage.geometry.cone.IntegralRayCollection.rays" title="sage.geometry.cone.IntegralRayCollection.rays"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rays()</span></code></a>.</p>
<p>OUTPUT:</p>
<p>A tuple of pairs <span class="math notranslate nohighlight">\((x,s)\)</span> such that,</p>
<blockquote>
<div><ul class="simple">
<li><span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(s\)</span> are nonzero.</li>
<li><span class="math notranslate nohighlight">\(s(x)\)</span> is zero.</li>
<li><span class="math notranslate nohighlight">\(x\)</span> is one of this cone’s <a class="reference internal" href="#sage.geometry.cone.IntegralRayCollection.rays" title="sage.geometry.cone.IntegralRayCollection.rays"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rays()</span></code></a>.</li>
<li><span class="math notranslate nohighlight">\(s\)</span> is one of the <a class="reference internal" href="#sage.geometry.cone.IntegralRayCollection.rays" title="sage.geometry.cone.IntegralRayCollection.rays"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rays()</span></code></a> of this
cone’s <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.dual" title="sage.geometry.cone.ConvexRationalPolyhedralCone.dual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dual()</span></code></a>.</li>
</ul>
</div></blockquote>
<p>REFERENCES:</p>
<ul class="simple">
<li><a class="reference internal" href="../../../references/index.html#or2016" id="id4">[Or2016]</a></li>
</ul>
<p>EXAMPLES:</p>
<p>Pairs of standard basis elements form a discrete complementarity
set for the nonnegative orthant:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">discrete_complementarity_set</span><span class="p">()</span>
<span class="go">((N(1, 0), M(0, 1)), (N(0, 1), M(1, 0)))</span>
</pre></div>
</div>
<p>If a cone consists of a single ray, then the second components
of a discrete complementarity set for that cone should generate
the orthogonal complement of the ray:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">discrete_complementarity_set</span><span class="p">()</span>
<span class="go">((N(1, 0), M(0, 1)), (N(1, 0), M(0, -1)))</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">discrete_complementarity_set</span><span class="p">()</span>
<span class="go">((N(1, 0, 0), M(0, 1, 0)),</span>
<span class="go"> (N(1, 0, 0), M(0, -1, 0)),</span>
<span class="go"> (N(1, 0, 0), M(0, 0, 1)),</span>
<span class="go"> (N(1, 0, 0), M(0, 0, -1)))</span>
</pre></div>
</div>
<p>When a cone is the entire space, its dual is the trivial cone,
so the only discrete complementarity set for it is empty:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_full_space</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">discrete_complementarity_set</span><span class="p">()</span>
<span class="go">()</span>
</pre></div>
</div>
<p>Likewise for trivial cones, whose duals are the entire space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">ToricLattice</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([],</span> <span class="n">ToricLattice</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">discrete_complementarity_set</span><span class="p">()</span>
<span class="go">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.dual">
<code class="descname">dual</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual cone of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone" title="sage.geometry.cone.ConvexRationalPolyhedralCone"><code class="xref py py-class docutils literal notranslate"><span class="pre">cone</span></code></a>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">M(0, 1),</span>
<span class="go">M(3, 1)</span>
<span class="go">in 2-d lattice M</span>
</pre></div>
</div>
<p>Now let’s look at a more complicated case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">is_strictly_convex</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">M(7, -18, -2),</span>
<span class="go">M(1,  -4,  0)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span> <span class="ow">is</span> <span class="n">cone</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We correctly handle the degenerate cases:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">ToricLattice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">([],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>  <span class="c1"># empty cone</span>
<span class="go">M( 1,  0),</span>
<span class="go">M(-1,  0),</span>
<span class="go">M( 0,  1),</span>
<span class="go">M( 0, -1)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>  <span class="c1"># ray in 2d</span>
<span class="go">M(1,  0),</span>
<span class="go">M(0,  1),</span>
<span class="go">M(0, -1)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>  <span class="c1"># line in 2d</span>
<span class="go">M(0,  1),</span>
<span class="go">M(0, -1)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>  <span class="c1"># strictly convex cone</span>
<span class="go">M(0, 1),</span>
<span class="go">M(1, 0)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>  <span class="c1"># half space</span>
<span class="go">M(0, 1)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>  <span class="c1"># whole space</span>
<span class="go">Empty collection</span>
<span class="go">in 2-d lattice M</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.embed">
<code class="descname">embed</code><span class="sig-paren">(</span><em>cone</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.embed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cone equivalent to the given one, but sitting in <code class="docutils literal notranslate"><span class="pre">self</span></code> as
a face.</p>
<p>You may need to use this method before calling methods of <code class="docutils literal notranslate"><span class="pre">cone</span></code> that
depend on the ambient structure, such as
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.ambient_ray_indices" title="sage.geometry.cone.ConvexRationalPolyhedralCone.ambient_ray_indices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ambient_ray_indices()</span></code></a>
or
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.facet_of" title="sage.geometry.cone.ConvexRationalPolyhedralCone.facet_of"><code class="xref py py-meth docutils literal notranslate"><span class="pre">facet_of()</span></code></a>. The
cone returned by this method will have <code class="docutils literal notranslate"><span class="pre">self</span></code> as ambient. If <code class="docutils literal notranslate"><span class="pre">cone</span></code>
does not represent a valid cone of <code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> exception
is raised.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is very quick if <code class="docutils literal notranslate"><span class="pre">self</span></code> is already the ambient
structure of <code class="docutils literal notranslate"><span class="pre">cone</span></code>, so you can use without extra checks and
performance hit even if <code class="docutils literal notranslate"><span class="pre">cone</span></code> is likely to sit in <code class="docutils literal notranslate"><span class="pre">self</span></code> but
in principle may not.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">cone</span></code> – a <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone" title="sage.geometry.cone.ConvexRationalPolyhedralCone"><code class="xref py py-class docutils literal notranslate"><span class="pre">cone</span></code></a>.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone" title="sage.geometry.cone.ConvexRationalPolyhedralCone"><code class="xref py py-class docutils literal notranslate"><span class="pre">cone</span></code></a>,
equivalent to <code class="docutils literal notranslate"><span class="pre">cone</span></code> but sitting inside <code class="docutils literal notranslate"><span class="pre">self</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<p>Let’s take a 3-d cone on 4 rays:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
</pre></div>
</div>
<p>Then any ray generates a 1-d face of this cone, but if you construct
such a face directly, it will not “sit” inside the cone:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ray</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">ray</span>
<span class="go">1-d cone in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">ray</span><span class="o">.</span><span class="n">ambient_ray_indices</span><span class="p">()</span>
<span class="go">(0,)</span>
<span class="gp">sage: </span><span class="n">ray</span><span class="o">.</span><span class="n">adjacent</span><span class="p">()</span>
<span class="go">()</span>
<span class="gp">sage: </span><span class="n">ray</span><span class="o">.</span><span class="n">ambient</span><span class="p">()</span>
<span class="go">1-d cone in 3-d lattice N</span>
</pre></div>
</div>
<p>If we want to operate with this ray as a face of the cone, we need to
embed it first:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e_ray</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">embed</span><span class="p">(</span><span class="n">ray</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e_ray</span>
<span class="go">1-d face of 3-d cone in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">e_ray</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(0, -1, 1)</span>
<span class="go">in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">e_ray</span> <span class="ow">is</span> <span class="n">ray</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">e_ray</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">ray</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">e_ray</span><span class="o">.</span><span class="n">ambient_ray_indices</span><span class="p">()</span>
<span class="go">(3,)</span>
<span class="gp">sage: </span><span class="n">e_ray</span><span class="o">.</span><span class="n">adjacent</span><span class="p">()</span>
<span class="go">(1-d face of 3-d cone in 3-d lattice N,</span>
<span class="go"> 1-d face of 3-d cone in 3-d lattice N)</span>
<span class="gp">sage: </span><span class="n">e_ray</span><span class="o">.</span><span class="n">ambient</span><span class="p">()</span>
<span class="go">3-d cone in 3-d lattice N</span>
</pre></div>
</div>
<p>Not every cone can be embedded into a fixed ambient cone:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">embed</span><span class="p">(</span><span class="n">Cone</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)]))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">1-d cone in 3-d lattice N is not a face</span>
<span class="go">of 3-d cone in 3-d lattice N!</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">embed</span><span class="p">(</span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)]))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">2-d cone in 3-d lattice N is not a face</span>
<span class="go">of 3-d cone in 3-d lattice N!</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.face_lattice">
<code class="descname">face_lattice</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.face_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the face lattice of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This lattice will have the origin as the bottom (we do not include the
empty set as a face) and this cone itself as the top.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference external" href="../../../combinat/sage/combinat/posets/posets.html#sage.combinat.posets.posets.FinitePoset" title="(in Sage Reference Manual: Combinatorics v8.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">finite</span> <span class="pre">poset</span></code></a> of
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone" title="sage.geometry.cone.ConvexRationalPolyhedralCone"><code class="xref py py-class docutils literal notranslate"><span class="pre">cones</span></code></a>.</li>
</ul>
<p>EXAMPLES:</p>
<p>Let’s take a look at the face lattice of the first quadrant:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">quadrant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">quadrant</span><span class="o">.</span><span class="n">face_lattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span>
<span class="go">Finite lattice containing 4 elements with distinguished linear extension</span>
</pre></div>
</div>
<p>To see all faces arranged by dimension, you can do this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">L</span><span class="o">.</span><span class="n">level_sets</span><span class="p">():</span> <span class="k">print</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
<span class="go">[0-d face of 2-d cone in 2-d lattice N]</span>
<span class="go">[1-d face of 2-d cone in 2-d lattice N,</span>
<span class="go"> 1-d face of 2-d cone in 2-d lattice N]</span>
<span class="go">[2-d cone in 2-d lattice N]</span>
</pre></div>
</div>
<p>For a particular face you can look at its actual rays…</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">face</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">level_sets</span><span class="p">()[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">face</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(1, 0)</span>
<span class="go">in 2-d lattice N</span>
</pre></div>
</div>
<p>… or you can see the index of the ray of the original cone that
corresponds to the above one:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">face</span><span class="o">.</span><span class="n">ambient_ray_indices</span><span class="p">()</span>
<span class="go">(0,)</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">ray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">N(1, 0)</span>
</pre></div>
</div>
<p>An alternative to extracting faces from the face lattice is to use
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.faces" title="sage.geometry.cone.ConvexRationalPolyhedralCone.faces"><code class="xref py py-meth docutils literal notranslate"><span class="pre">faces()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">face</span> <span class="ow">is</span> <span class="n">quadrant</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The advantage of working with the face lattice directly is that you
can (relatively easily) get faces that are related to the given one:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">face</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">level_sets</span><span class="p">()[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">hasse_diagram</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
<span class="go">[2-d cone in 2-d lattice N,</span>
<span class="go"> 0-d face of 2-d cone in 2-d lattice N]</span>
</pre></div>
</div>
<p>However, you can achieve some of this functionality using
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.facets" title="sage.geometry.cone.ConvexRationalPolyhedralCone.facets"><code class="xref py py-meth docutils literal notranslate"><span class="pre">facets()</span></code></a>, <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.facet_of" title="sage.geometry.cone.ConvexRationalPolyhedralCone.facet_of"><code class="xref py py-meth docutils literal notranslate"><span class="pre">facet_of()</span></code></a>, and <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.adjacent" title="sage.geometry.cone.ConvexRationalPolyhedralCone.adjacent"><code class="xref py py-meth docutils literal notranslate"><span class="pre">adjacent()</span></code></a> methods:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">face</span> <span class="o">=</span> <span class="n">quadrant</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">face</span>
<span class="go">1-d face of 2-d cone in 2-d lattice N</span>
<span class="gp">sage: </span><span class="n">face</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(1, 0)</span>
<span class="go">in 2-d lattice N</span>
<span class="gp">sage: </span><span class="n">face</span><span class="o">.</span><span class="n">facets</span><span class="p">()</span>
<span class="go">(0-d face of 2-d cone in 2-d lattice N,)</span>
<span class="gp">sage: </span><span class="n">face</span><span class="o">.</span><span class="n">facet_of</span><span class="p">()</span>
<span class="go">(2-d cone in 2-d lattice N,)</span>
<span class="gp">sage: </span><span class="n">face</span><span class="o">.</span><span class="n">adjacent</span><span class="p">()</span>
<span class="go">(1-d face of 2-d cone in 2-d lattice N,)</span>
<span class="gp">sage: </span><span class="n">face</span><span class="o">.</span><span class="n">adjacent</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(0, 1)</span>
<span class="go">in 2-d lattice N</span>
</pre></div>
</div>
<p>Note that if <code class="docutils literal notranslate"><span class="pre">cone</span></code> is a face of <code class="docutils literal notranslate"><span class="pre">supercone</span></code>, then the face
lattice of <code class="docutils literal notranslate"><span class="pre">cone</span></code> consists of (appropriate) faces of <code class="docutils literal notranslate"><span class="pre">supercone</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">supercone</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span>
<span class="go">....:                   (1,2,4,8), (1,3,9,7)])</span>
<span class="gp">sage: </span><span class="n">supercone</span><span class="o">.</span><span class="n">face_lattice</span><span class="p">()</span>
<span class="go">Finite lattice containing 16 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">supercone</span><span class="o">.</span><span class="n">face_lattice</span><span class="p">()</span><span class="o">.</span><span class="n">top</span><span class="p">()</span>
<span class="go">4-d cone in 4-d lattice N</span>
<span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">supercone</span><span class="o">.</span><span class="n">facets</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">cone</span>
<span class="go">3-d face of 4-d cone in 4-d lattice N</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">face_lattice</span><span class="p">()</span>
<span class="go">Finite poset containing 8 elements with distinguished linear extension</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">face_lattice</span><span class="p">()</span><span class="o">.</span><span class="n">bottom</span><span class="p">()</span>
<span class="go">0-d face of 4-d cone in 4-d lattice N</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">face_lattice</span><span class="p">()</span><span class="o">.</span><span class="n">top</span><span class="p">()</span>
<span class="go">3-d face of 4-d cone in 4-d lattice N</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">face_lattice</span><span class="p">()</span><span class="o">.</span><span class="n">top</span><span class="p">()</span> <span class="o">==</span> <span class="n">cone</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.faces">
<code class="descname">faces</code><span class="sig-paren">(</span><em>dim=None</em>, <em>codim=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Return faces of <code class="docutils literal notranslate"><span class="pre">self</span></code> of specified (co)dimension.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">dim</span></code> – integer, dimension of the requested faces;</li>
<li><code class="docutils literal notranslate"><span class="pre">codim</span></code> – integer, codimension of the requested faces.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You can specify at most one parameter. If you don’t give any, then
all faces will be returned.</p>
</div>
<p>OUTPUT:</p>
<ul class="simple">
<li>if either <code class="docutils literal notranslate"><span class="pre">dim</span></code> or <code class="docutils literal notranslate"><span class="pre">codim</span></code> is given, the output will be a
<a class="reference external" href="https://docs.python.org/library/functions.html#tuple" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone" title="sage.geometry.cone.ConvexRationalPolyhedralCone"><code class="xref py py-class docutils literal notranslate"><span class="pre">cones</span></code></a>;</li>
<li>if neither <code class="docutils literal notranslate"><span class="pre">dim</span></code> nor <code class="docutils literal notranslate"><span class="pre">codim</span></code> is given, the output will be the
<a class="reference external" href="https://docs.python.org/library/functions.html#tuple" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of tuples as above, giving faces of all existing
dimensions. If you care about inclusion relations between faces,
consider using <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.face_lattice" title="sage.geometry.cone.ConvexRationalPolyhedralCone.face_lattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">face_lattice()</span></code></a> or <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.adjacent" title="sage.geometry.cone.ConvexRationalPolyhedralCone.adjacent"><code class="xref py py-meth docutils literal notranslate"><span class="pre">adjacent()</span></code></a>,
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.facet_of" title="sage.geometry.cone.ConvexRationalPolyhedralCone.facet_of"><code class="xref py py-meth docutils literal notranslate"><span class="pre">facet_of()</span></code></a>, and <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.facets" title="sage.geometry.cone.ConvexRationalPolyhedralCone.facets"><code class="xref py py-meth docutils literal notranslate"><span class="pre">facets()</span></code></a>.</li>
</ul>
<p>EXAMPLES:</p>
<p>Let’s take a look at the faces of the first quadrant:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">quadrant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>
<span class="go">((0-d face of 2-d cone in 2-d lattice N,),</span>
<span class="go"> (1-d face of 2-d cone in 2-d lattice N,</span>
<span class="go">  1-d face of 2-d cone in 2-d lattice N),</span>
<span class="go"> (2-d cone in 2-d lattice N,))</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(1-d face of 2-d cone in 2-d lattice N,</span>
<span class="go"> 1-d face of 2-d cone in 2-d lattice N)</span>
<span class="gp">sage: </span><span class="n">face</span> <span class="o">=</span> <span class="n">quadrant</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Now you can look at the actual rays of this face…</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">face</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(1, 0)</span>
<span class="go">in 2-d lattice N</span>
</pre></div>
</div>
<p>… or you can see indices of the rays of the original cone that
correspond to the above ray:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">face</span><span class="o">.</span><span class="n">ambient_ray_indices</span><span class="p">()</span>
<span class="go">(0,)</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">ray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">N(1, 0)</span>
</pre></div>
</div>
<p>Note that it is OK to ask for faces of too small or high dimension:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">()</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">()</span>
</pre></div>
</div>
<p>In the case of non-strictly convex cones even faces of small
non-negative dimension may be missing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">halfplane</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">halfplane</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">()</span>
<span class="gp">sage: </span><span class="n">halfplane</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>
<span class="go">((1-d face of 2-d cone in 2-d lattice N,),</span>
<span class="go"> (2-d cone in 2-d lattice N,))</span>
<span class="gp">sage: </span><span class="n">plane</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">plane</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">()</span>
<span class="gp">sage: </span><span class="n">plane</span><span class="o">.</span><span class="n">faces</span><span class="p">()</span>
<span class="go">((2-d cone in 2-d lattice N,),)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.facet_normals">
<code class="descname">facet_normals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.facet_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return inward normals to facets of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic simple">
<li>For a not full-dimensional cone facet normals will specify
hyperplanes whose intersections with the space spanned by
<code class="docutils literal notranslate"><span class="pre">self</span></code> give facets of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</li>
<li>For a not strictly convex cone facet normals will be orthogonal
to the linear subspace of <code class="docutils literal notranslate"><span class="pre">self</span></code>, i.e. they always will be
elements of the dual cone of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</li>
<li>The order of normals is random, but consistent with
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.facets" title="sage.geometry.cone.ConvexRationalPolyhedralCone.facets"><code class="xref py py-meth docutils literal notranslate"><span class="pre">facets()</span></code></a>.</li>
</ol>
</div>
<p>OUTPUT:</p>
<ul class="simple">
<li>a <a class="reference internal" href="point_collection.html#sage.geometry.point_collection.PointCollection" title="sage.geometry.point_collection.PointCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointCollection</span></code></a>.</li>
</ul>
<p>If the ambient <a class="reference internal" href="#sage.geometry.cone.IntegralRayCollection.lattice" title="sage.geometry.cone.IntegralRayCollection.lattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lattice()</span></code></a> of <code class="docutils literal notranslate"><span class="pre">self</span></code> is a
<a class="reference internal" href="toric_lattice.html#sage.geometry.toric_lattice.ToricLatticeFactory" title="sage.geometry.toric_lattice.ToricLatticeFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">toric</span> <span class="pre">lattice</span></code></a>, the facet normals
will be elements of the dual lattice. If it is a general lattice (like
<code class="docutils literal notranslate"><span class="pre">ZZ^n</span></code>) that does not have a <code class="docutils literal notranslate"><span class="pre">dual()</span></code> method, the facet normals
will be returned as integral vectors.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">facet_normals</span><span class="p">()</span>
<span class="go">M(0, 1),</span>
<span class="go">M(3, 1)</span>
<span class="go">in 2-d lattice M</span>
</pre></div>
</div>
<p>Now let’s look at a more complicated case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">is_strictly_convex</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">linear_subspace</span><span class="p">()</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">lsg</span> <span class="o">=</span> <span class="p">(</span><span class="n">QQ</span><span class="o">^</span><span class="mi">3</span><span class="p">)(</span><span class="n">cone</span><span class="o">.</span><span class="n">linear_subspace</span><span class="p">()</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span> <span class="n">lsg</span>
<span class="go">(1, 1/4, 5/4)</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">facet_normals</span><span class="p">()</span>
<span class="go">M(7, -18, -2),</span>
<span class="go">M(1,  -4,  0)</span>
<span class="go">in 3-d lattice M</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">lsg</span><span class="o">*</span><span class="n">normal</span> <span class="k">for</span> <span class="n">normal</span> <span class="ow">in</span> <span class="n">cone</span><span class="o">.</span><span class="n">facet_normals</span><span class="p">()]</span>
<span class="go">[0, 0]</span>
</pre></div>
</div>
<p>A lattice that does not have a <code class="docutils literal notranslate"><span class="pre">dual()</span></code> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">ZZ</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">facet_normals</span><span class="p">()</span>
<span class="go">(-1, 1),</span>
<span class="go">( 1, 0)</span>
<span class="go">in Ambient free module of rank 2</span>
<span class="go">over the principal ideal domain Integer Ring</span>
</pre></div>
</div>
<p>We correctly handle the degenerate cases:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">ToricLattice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">([],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">facet_normals</span><span class="p">()</span>  <span class="c1"># empty cone</span>
<span class="go">Empty collection</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">facet_normals</span><span class="p">()</span>  <span class="c1"># ray in 2d</span>
<span class="go">M(1, 0)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">facet_normals</span><span class="p">()</span>  <span class="c1"># line in 2d</span>
<span class="go">Empty collection</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">facet_normals</span><span class="p">()</span>  <span class="c1"># strictly convex cone</span>
<span class="go">M(0, 1),</span>
<span class="go">M(1, 0)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">facet_normals</span><span class="p">()</span>  <span class="c1"># half space</span>
<span class="go">M(0, 1)</span>
<span class="go">in 2-d lattice M</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">facet_normals</span><span class="p">()</span>  <span class="c1"># whole space</span>
<span class="go">Empty collection</span>
<span class="go">in 2-d lattice M</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.facet_of">
<code class="descname">facet_of</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.facet_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <em>cones</em> of the ambient face lattice having <code class="docutils literal notranslate"><span class="pre">self</span></code> as a facet.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference external" href="https://docs.python.org/library/functions.html#tuple" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone" title="sage.geometry.cone.ConvexRationalPolyhedralCone"><code class="xref py py-class docutils literal notranslate"><span class="pre">cones</span></code></a>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">octant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">octant</span><span class="o">.</span><span class="n">facet_of</span><span class="p">()</span>
<span class="go">()</span>
<span class="gp">sage: </span><span class="n">one_face</span> <span class="o">=</span> <span class="n">octant</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">one_face</span><span class="o">.</span><span class="n">facet_of</span><span class="p">())</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">one_face</span><span class="o">.</span><span class="n">facet_of</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">2-d face of 3-d cone in 3-d lattice N</span>
</pre></div>
</div>
<p>While fan is the top element of its own cone lattice, which is a
variant of a face lattice, we do not refer to cones as its facets:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fan</span> <span class="o">=</span> <span class="n">Fan</span><span class="p">([</span><span class="n">octant</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">fan</span><span class="o">.</span><span class="n">generating_cone</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">facet_of</span><span class="p">()</span>
<span class="go">()</span>
</pre></div>
</div>
<p>Subcones of generating cones work as before:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">one_cone</span> <span class="o">=</span> <span class="n">fan</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">one_cone</span><span class="o">.</span><span class="n">facet_of</span><span class="p">())</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.facets">
<code class="descname">facets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.facets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return facets (faces of codimension 1) of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference external" href="https://docs.python.org/library/functions.html#tuple" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone" title="sage.geometry.cone.ConvexRationalPolyhedralCone"><code class="xref py py-class docutils literal notranslate"><span class="pre">cones</span></code></a>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">quadrant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">facets</span><span class="p">()</span>
<span class="go">(1-d face of 2-d cone in 2-d lattice N,</span>
<span class="go"> 1-d face of 2-d cone in 2-d lattice N)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.interior_contains">
<code class="descname">interior_contains</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.interior_contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a given point is contained in the interior of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>For a cone of strictly lower-dimension than the ambient space,
the interior is always empty. You probably want to use
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.relative_interior_contains" title="sage.geometry.cone.ConvexRationalPolyhedralCone.relative_interior_contains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">relative_interior_contains()</span></code></a> in this case.</p>
<p>INPUT:</p>
<ul class="simple">
<li>anything. An attempt will be made to convert all arguments into a
single element of the ambient space of <code class="docutils literal notranslate"><span class="pre">self</span></code>. If it fails,
<code class="docutils literal notranslate"><span class="pre">False</span></code> will be returned.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">True</span></code> if the given point is contained in the interior of
<code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">interior_contains</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">interior_contains</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the intersection of two cones.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">other</span></code> - <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone" title="sage.geometry.cone.ConvexRationalPolyhedralCone"><code class="xref py py-class docutils literal notranslate"><span class="pre">cone</span></code></a>.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone" title="sage.geometry.cone.ConvexRationalPolyhedralCone"><code class="xref py py-class docutils literal notranslate"><span class="pre">cone</span></code></a>.</li>
</ul>
<p>Raises <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> if the ambient space dimensions are not
compatible.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cone1</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone2</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cone2</span><span class="p">)</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(-1, 3),</span>
<span class="go">N( 2, 5)</span>
<span class="go">in 2-d lattice N</span>
</pre></div>
</div>
<p>It is OK to intersect cones living in sublattices of the same ambient
lattice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">cone1</span><span class="o">.</span><span class="n">lattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Ns</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">submodule</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone3</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">Ns</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">cone1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cone3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(1, 1)</span>
<span class="go">in Sublattice &lt;N(1, 1)&gt;</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">lattice</span><span class="p">()</span>
<span class="go">Sublattice &lt;N(1, 1)&gt;</span>
</pre></div>
</div>
<p>But you cannot intersect cones from incompatible lattices without
explicit conversion:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cone1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cone1</span><span class="o">.</span><span class="n">dual</span><span class="p">())</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">2-d lattice N and 2-d lattice M</span>
<span class="go">have different ambient lattices!</span>
<span class="gp">sage: </span><span class="n">cone1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">Cone</span><span class="p">(</span><span class="n">cone1</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">rays</span><span class="p">(),</span> <span class="n">N</span><span class="p">))</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(3, 1),</span>
<span class="go">N(0, 1)</span>
<span class="go">in 2-d lattice N</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.is_equivalent">
<code class="descname">is_equivalent</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.is_equivalent" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <code class="docutils literal notranslate"><span class="pre">self</span></code> is “mathematically” the same as <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">other</span></code> - cone.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> define the same cones as sets of
points in the same lattice, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</li>
</ul>
<p>There are three different equivalences between cones <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span>
in the same lattice:</p>
<ol class="arabic simple">
<li>They have the same generating rays in the same order.
This is tested by <code class="docutils literal notranslate"><span class="pre">C1</span> <span class="pre">==</span> <span class="pre">C2</span></code>.</li>
<li>They describe the same sets of points.
This is tested by <code class="docutils literal notranslate"><span class="pre">C1.is_equivalent(C2)</span></code>.</li>
<li>They are in the same orbit of <span class="math notranslate nohighlight">\(GL(n,\ZZ)\)</span> (and, therefore,
correspond to isomorphic affine toric varieties).
This is tested by <code class="docutils literal notranslate"><span class="pre">C1.is_isomorphic(C2)</span></code>.</li>
</ol>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cone1</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone2</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone1</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N( 1, 0),</span>
<span class="go">N(-1, 3)</span>
<span class="go">in 2-d lattice N</span>
<span class="gp">sage: </span><span class="n">cone2</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(-1, 3),</span>
<span class="go">N( 1, 0)</span>
<span class="go">in 2-d lattice N</span>
<span class="gp">sage: </span><span class="n">cone1</span> <span class="o">==</span> <span class="n">cone2</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">cone1</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">cone2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.is_face_of">
<code class="descname">is_face_of</code><span class="sig-paren">(</span><em>cone</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.is_face_of" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <code class="docutils literal notranslate"><span class="pre">self</span></code> forms a face of another <code class="docutils literal notranslate"><span class="pre">cone</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">cone</span></code> – cone.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">self</span></code> is a face of <code class="docutils literal notranslate"><span class="pre">cone</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">quadrant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone1</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone2</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">is_face_of</span><span class="p">(</span><span class="n">quadrant</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">cone1</span><span class="o">.</span><span class="n">is_face_of</span><span class="p">(</span><span class="n">quadrant</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">cone2</span><span class="o">.</span><span class="n">is_face_of</span><span class="p">(</span><span class="n">quadrant</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Being a face means more than just saturating a facet
inequality:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">octant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">is_face_of</span><span class="p">(</span><span class="n">octant</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.is_full_space">
<code class="descname">is_full_space</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.is_full_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if this cone is equal to its ambient vector space.</p>
<p>OUTPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> if this cone equals its entire ambient vector
space and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<p>A single ray in two dimensions is not equal to the entire
space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_full_space</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Neither is the nonnegative orthant:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_full_space</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The right half-space contains a vector subspace, but it is
still not equal to the entire space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_full_space</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>However, if we allow conic combinations of both axes, then
the resulting cone is the entire two-dimensional space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_full_space</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.is_isomorphic">
<code class="descname">is_isomorphic</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.is_isomorphic" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <code class="docutils literal notranslate"><span class="pre">self</span></code> is in the same <span class="math notranslate nohighlight">\(GL(n, \ZZ)\)</span>-orbit as <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">other</span></code> - cone.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> are in the same
<span class="math notranslate nohighlight">\(GL(n, \ZZ)\)</span>-orbit, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</li>
</ul>
<p>There are three different equivalences between cones <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span>
in the same lattice:</p>
<ol class="arabic simple">
<li>They have the same generating rays in the same order.
This is tested by <code class="docutils literal notranslate"><span class="pre">C1</span> <span class="pre">==</span> <span class="pre">C2</span></code>.</li>
<li>They describe the same sets of points.
This is tested by <code class="docutils literal notranslate"><span class="pre">C1.is_equivalent(C2)</span></code>.</li>
<li>They are in the same orbit of <span class="math notranslate nohighlight">\(GL(n,\ZZ)\)</span> (and, therefore,
correspond to isomorphic affine toric varieties).
This is tested by <code class="docutils literal notranslate"><span class="pre">C1.is_isomorphic(C2)</span></code>.</li>
</ol>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cone1</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span> <span class="c1"># a GL(2,ZZ)-matrix</span>
<span class="gp">sage: </span><span class="n">cone2</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([</span><span class="n">m</span><span class="o">*</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">cone1</span><span class="o">.</span><span class="n">rays</span><span class="p">()])</span>
<span class="gp">sage: </span><span class="n">cone1</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">cone2</span><span class="p">)</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">cone1</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone2</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone1</span><span class="o">.</span><span class="n">is_isomorphic</span><span class="p">(</span><span class="n">cone2</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.is_proper">
<code class="descname">is_proper</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.is_proper" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if this cone is proper.</p>
<p>A cone is said to be proper if it is closed, convex, solid,
and contains no lines. This cone is assumed to be closed and
convex; therefore it is proper if it is solid and contains no
lines.</p>
<p>OUTPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> if this cone is proper, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.is_strictly_convex" title="sage.geometry.cone.ConvexRationalPolyhedralCone.is_strictly_convex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_strictly_convex()</span></code></a>, <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.is_solid" title="sage.geometry.cone.ConvexRationalPolyhedralCone.is_solid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_solid()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<p>The nonnegative orthant is always proper:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">quadrant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">is_proper</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">octant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">octant</span><span class="o">.</span><span class="n">is_proper</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>However, if we embed the two-dimensional nonnegative quadrant
into three-dimensional space, then the resulting cone no longer
has interior, so it is not solid, and thus not proper:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">quadrant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">is_proper</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Likewise, a half-space contains at least one line, so it is not
proper:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">halfspace</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">halfspace</span><span class="o">.</span><span class="n">is_proper</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.is_simplicial">
<code class="descname">is_simplicial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.is_simplicial" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <code class="docutils literal notranslate"><span class="pre">self</span></code> is simplicial.</p>
<p>A cone is called <strong>simplicial</strong> if primitive vectors along its
generating rays form a part of a <em>rational</em> basis of the ambient
space.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">self</span></code> is simplicial, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cone1</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone2</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone1</span><span class="o">.</span><span class="n">is_simplicial</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">cone2</span><span class="o">.</span><span class="n">is_simplicial</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.is_smooth">
<code class="descname">is_smooth</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.is_smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <code class="docutils literal notranslate"><span class="pre">self</span></code> is smooth.</p>
<p>A cone is called <strong>smooth</strong> if primitive vectors along its
generating rays form a part of an <em>integral</em> basis of the
ambient space. Equivalently, they generate the whole lattice
on the linear subspace spanned by the rays.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">self</span></code> is smooth, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cone1</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone2</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone1</span><span class="o">.</span><span class="n">is_smooth</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">cone2</span><span class="o">.</span><span class="n">is_smooth</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The following cones are the same up to a <span class="math notranslate nohighlight">\(SL(2,\ZZ)\)</span>
coordinate transformation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span><span class="o">.</span><span class="n">is_smooth</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span><span class="o">.</span><span class="n">is_smooth</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span><span class="o">.</span><span class="n">is_smooth</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.is_solid">
<code class="descname">is_solid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.is_solid" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if this cone is solid.</p>
<p>A cone is said to be solid if it has nonempty interior. That
is, if its extreme rays span the entire ambient space.</p>
<p>OUTPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code> if this cone is solid, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.is_proper" title="sage.geometry.cone.ConvexRationalPolyhedralCone.is_proper"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_proper()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<p>The nonnegative orthant is always solid:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">quadrant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">is_solid</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">octant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">octant</span><span class="o">.</span><span class="n">is_solid</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>However, if we embed the two-dimensional nonnegative quadrant
into three-dimensional space, then the resulting cone no longer
has interior, so it is not solid:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">quadrant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">is_solid</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.is_strictly_convex">
<code class="descname">is_strictly_convex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.is_strictly_convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <code class="docutils literal notranslate"><span class="pre">self</span></code> is strictly convex.</p>
<p>A cone is called <strong>strictly convex</strong> if it does not contain any lines.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">self</span></code> is strictly convex, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cone1</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone2</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone1</span><span class="o">.</span><span class="n">is_strictly_convex</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">cone2</span><span class="o">.</span><span class="n">is_strictly_convex</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.is_trivial">
<code class="descname">is_trivial</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.is_trivial" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the cone has no rays.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">True</span></code> if the cone has no rays, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c0</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">ToricLattice</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">c0</span><span class="o">.</span><span class="n">is_trivial</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c0</span><span class="o">.</span><span class="n">nrays</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.lineality">
<code class="descname">lineality</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.lineality" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the lineality of this cone.</p>
<p>The lineality of a cone is the dimension of the largest linear
subspace contained in that cone.</p>
<p>OUTPUT:</p>
<p>A nonnegative integer; the dimension of the largest subspace
contained within this cone.</p>
<p>REFERENCES:</p>
<ul class="simple">
<li><a class="reference internal" href="../../../references/index.html#roc1970" id="id5">[Roc1970]</a></li>
</ul>
<p>EXAMPLES:</p>
<p>The lineality of the nonnegative orthant is zero, since it clearly
contains no lines:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lineality</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>However, if we add another ray so that the entire <span class="math notranslate nohighlight">\(x\)</span>-axis belongs
to the cone, then the resulting cone will have lineality one:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lineality</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<p>If our cone is all of <span class="math notranslate nohighlight">\(\mathbb{R}^{2}\)</span>, then its lineality is equal
to the dimension of the ambient space (i.e. two):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_full_space</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lineality</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Per the definition, the lineality of the trivial cone in a trivial
space is zero:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">ToricLattice</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lineality</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.linear_subspace">
<code class="descname">linear_subspace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.linear_subspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the largest linear subspace contained inside of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>subspace of the ambient space of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">halfplane</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">halfplane</span><span class="o">.</span><span class="n">linear_subspace</span><span class="p">()</span>
<span class="go">Vector space of degree 2 and dimension 1 over Rational Field</span>
<span class="go">Basis matrix:</span>
<span class="go">[1 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.lines">
<code class="descname">lines</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Return lines generating the linear subspace of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference external" href="https://docs.python.org/library/functions.html#tuple" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> of primitive vectors in the lattice of <code class="docutils literal notranslate"><span class="pre">self</span></code>
giving directions of lines that span the linear subspace of
<code class="docutils literal notranslate"><span class="pre">self</span></code>. These lines are arbitrary, but fixed. If you do not care
about the order, see also <code class="xref py py-meth docutils literal notranslate"><span class="pre">line_set()</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">halfplane</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">halfplane</span><span class="o">.</span><span class="n">lines</span><span class="p">()</span>
<span class="go">N(1, 0)</span>
<span class="go">in 2-d lattice N</span>
<span class="gp">sage: </span><span class="n">fullplane</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">fullplane</span><span class="o">.</span><span class="n">lines</span><span class="p">()</span>
<span class="go">N(0, 1),</span>
<span class="go">N(1, 0)</span>
<span class="go">in 2-d lattice N</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.lyapunov_like_basis">
<code class="descname">lyapunov_like_basis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.lyapunov_like_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a basis of Lyapunov-like transformations on this cone.</p>
<p>A linear transformation <span class="math notranslate nohighlight">\(L\)</span> is said to be Lyapunov-like on this
cone if <span class="math notranslate nohighlight">\(L(x)\)</span> and <span class="math notranslate nohighlight">\(s\)</span> are orthogonal for every pair <span class="math notranslate nohighlight">\((x,s)\)</span> in
its <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.discrete_complementarity_set" title="sage.geometry.cone.ConvexRationalPolyhedralCone.discrete_complementarity_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">discrete_complementarity_set()</span></code></a>. The set of all such
transformations forms a vector space, namely the Lie algebra of
the automorphism group of this cone.</p>
<p>OUTPUT:</p>
<p>A list of matrices forming a basis for the space of all
Lyapunov-like transformations on this cone.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.cross_positive_operators_gens" title="sage.geometry.cone.ConvexRationalPolyhedralCone.cross_positive_operators_gens"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cross_positive_operators_gens()</span></code></a>,
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.positive_operators_gens" title="sage.geometry.cone.ConvexRationalPolyhedralCone.positive_operators_gens"><code class="xref py py-meth docutils literal notranslate"><span class="pre">positive_operators_gens()</span></code></a>,
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.Z_operators_gens" title="sage.geometry.cone.ConvexRationalPolyhedralCone.Z_operators_gens"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Z_operators_gens()</span></code></a></p>
</div>
<p>REFERENCES:</p>
<ul class="simple">
<li><a class="reference internal" href="../../../references/index.html#or2016" id="id6">[Or2016]</a></li>
<li><a class="reference internal" href="../../../references/index.html#rnpa2011" id="id7">[RNPA2011]</a></li>
</ul>
<p>EXAMPLES:</p>
<p>Every transformation is Lyapunov-like on the trivial cone:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">MatrixSpace</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">lattice</span><span class="p">()</span><span class="o">.</span><span class="n">base_field</span><span class="p">(),</span> <span class="n">K</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">())</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">basis</span><span class="p">())</span> <span class="o">==</span> <span class="n">K</span><span class="o">.</span><span class="n">lyapunov_like_basis</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>And by duality, every transformation is Lyapunov-like on the
ambient space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_full_space</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">MatrixSpace</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">lattice</span><span class="p">()</span><span class="o">.</span><span class="n">base_field</span><span class="p">(),</span> <span class="n">K</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">())</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">basis</span><span class="p">())</span> <span class="o">==</span> <span class="n">K</span><span class="o">.</span><span class="n">lyapunov_like_basis</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>However, in a trivial space, there are no non-trivial linear maps,
so there can be no Lyapunov-like basis:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">ToricLattice</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">L</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lyapunov_like_basis</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>The Lyapunov-like transformations on the nonnegative orthant are
diagonal matrices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lyapunov_like_basis</span><span class="p">()</span>
<span class="go">[[1]]</span>

<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lyapunov_like_basis</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">[1 0]  [0 0]</span>
<span class="go">[0 0], [0 1]</span>
<span class="go">]</span>

<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lyapunov_like_basis</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">[1 0 0]  [0 0 0]  [0 0 0]</span>
<span class="go">[0 0 0]  [0 1 0]  [0 0 0]</span>
<span class="go">[0 0 0], [0 0 0], [0 0 1]</span>
<span class="go">]</span>
</pre></div>
</div>
<p>Only the identity matrix is Lyapunov-like on the pyramids
defined by the one- and infinity-norms <a class="reference internal" href="../../../references/index.html#rnpa2011" id="id8">[RNPA2011]</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">l31</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">l31</span><span class="o">.</span><span class="n">lyapunov_like_basis</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">[1 0 0]</span>
<span class="go">[0 1 0]</span>
<span class="go">[0 0 1]</span>
<span class="go">]</span>

<span class="gp">sage: </span><span class="n">l3infty</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">l3infty</span><span class="o">.</span><span class="n">lyapunov_like_basis</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">[1 0 0]</span>
<span class="go">[0 1 0]</span>
<span class="go">[0 0 1]</span>
<span class="go">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.lyapunov_rank">
<code class="descname">lyapunov_rank</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.lyapunov_rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Lyapunov rank of this cone.</p>
<p>The Lyapunov rank of a cone is the dimension of the space of its
Lyapunov-like transformations — that is, the length of a
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.lyapunov_like_basis" title="sage.geometry.cone.ConvexRationalPolyhedralCone.lyapunov_like_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lyapunov_like_basis()</span></code></a>. Equivalently, the Lyapunov rank is
the dimension of the Lie algebra of the automorphism group of
the cone.</p>
<p>OUTPUT:</p>
<p>A nonnegative integer representing the Lyapunov rank of this cone.</p>
<p>If the ambient space is trivial, then the Lyapunov rank will be
zero. On the other hand, if the dimension of the ambient vector
space is <span class="math notranslate nohighlight">\(n &gt; 0\)</span>, then the resulting Lyapunov rank will be
between <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(n^2\)</span> inclusive. If this cone <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.is_proper" title="sage.geometry.cone.ConvexRationalPolyhedralCone.is_proper"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_proper()</span></code></a>,
then that upper bound reduces from <span class="math notranslate nohighlight">\(n^2\)</span> to <span class="math notranslate nohighlight">\(n\)</span>. A Lyapunov rank
of <span class="math notranslate nohighlight">\(n-1\)</span> is not possible (by Lemma 5 <a class="reference internal" href="../../../references/index.html#or2016" id="id9">[Or2016]</a>) in either case.</p>
<p>ALGORITHM:</p>
<p>Algorithm 3 <a class="reference internal" href="../../../references/index.html#or2016" id="id10">[Or2016]</a> is used. Every closed convex cone is
isomorphic to a Cartesian product of a proper cone, a subspace,
and a trivial cone. The Lyapunov ranks of the subspace and
trivial cone are easy to compute. Essentially, we “peel off”
those easy parts of the cone and compute their Lyapunov ranks
separately. We then compute the rank of the proper cone by
counting a <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.lyapunov_like_basis" title="sage.geometry.cone.ConvexRationalPolyhedralCone.lyapunov_like_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lyapunov_like_basis()</span></code></a> for it. Summing the
individual ranks gives the Lyapunov rank of the original cone.</p>
<p>REFERENCES:</p>
<ul class="simple">
<li><a class="reference internal" href="../../../references/index.html#gt2014" id="id11">[GT2014]</a></li>
<li><a class="reference internal" href="../../../references/index.html#or2016" id="id12">[Or2016]</a></li>
<li><a class="reference internal" href="../../../references/index.html#rnpa2011" id="id13">[RNPA2011]</a></li>
</ul>
<p>EXAMPLES:</p>
<p>The Lyapunov rank of the nonnegative orthant is the same as the
dimension of the ambient space <a class="reference internal" href="../../../references/index.html#rnpa2011" id="id14">[RNPA2011]</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">positives</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,)])</span>
<span class="gp">sage: </span><span class="n">positives</span><span class="o">.</span><span class="n">lyapunov_rank</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">quadrant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">lyapunov_rank</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">octant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">octant</span><span class="o">.</span><span class="n">lyapunov_rank</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>A vector space of dimension <span class="math notranslate nohighlight">\(n\)</span> has Lyapunov rank <span class="math notranslate nohighlight">\(n^{2}\)</span>
<a class="reference internal" href="../../../references/index.html#or2016" id="id15">[Or2016]</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Q5</span> <span class="o">=</span> <span class="n">VectorSpace</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">gs</span> <span class="o">=</span> <span class="n">Q5</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span> <span class="o">-</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">Q5</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span> <span class="p">]</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lyapunov_rank</span><span class="p">()</span>
<span class="go">25</span>
</pre></div>
</div>
<p>A pyramid in three dimensions has Lyapunov rank one <a class="reference internal" href="../../../references/index.html#rnpa2011" id="id16">[RNPA2011]</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">l31</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">l31</span><span class="o">.</span><span class="n">lyapunov_rank</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">l3infty</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">l3infty</span><span class="o">.</span><span class="n">lyapunov_rank</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<p>A ray in <span class="math notranslate nohighlight">\(n\)</span> dimensions has Lyapunov rank <span class="math notranslate nohighlight">\(n^{2} - n + 1\)</span>
<a class="reference internal" href="../../../references/index.html#or2016" id="id17">[Or2016]</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lyapunov_rank</span><span class="p">()</span>
<span class="go">21</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">K</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">21</span>
</pre></div>
</div>
<p>A subspace of dimension <span class="math notranslate nohighlight">\(m\)</span> in an <span class="math notranslate nohighlight">\(n\)</span>-dimensional ambient space
has Lyapunov rank <span class="math notranslate nohighlight">\(n^{2} - m(n - m)\)</span> <a class="reference internal" href="../../../references/index.html#or2016" id="id18">[Or2016]</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e1</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">e2</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span> <span class="o">-</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="o">-</span><span class="n">e2</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lyapunov_rank</span><span class="p">()</span>
<span class="go">19</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">K</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span><span class="o">*</span><span class="n">K</span><span class="o">.</span><span class="n">codim</span><span class="p">()</span>
<span class="go">19</span>
</pre></div>
</div>
<p>Lyapunov rank is additive on a product of proper cones <a class="reference internal" href="../../../references/index.html#rnpa2011" id="id19">[RNPA2011]</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">l31</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">octant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">l31</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">octant</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lyapunov_rank</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">l31</span><span class="o">.</span><span class="n">lyapunov_rank</span><span class="p">()</span> <span class="o">+</span> <span class="n">octant</span><span class="o">.</span><span class="n">lyapunov_rank</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
<p>Two linearly-isomorphic cones have the same Lyapunov rank
<a class="reference internal" href="../../../references/index.html#rnpa2011" id="id20">[RNPA2011]</a>. A cone linearly-isomorphic to the nonnegative octant
will have Lyapunov rank <code class="docutils literal notranslate"><span class="pre">3</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lyapunov_rank</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Lyapunov rank is invariant under <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.dual" title="sage.geometry.cone.ConvexRationalPolyhedralCone.dual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dual()</span></code></a> <a class="reference internal" href="../../../references/index.html#rnpa2011" id="id21">[RNPA2011]</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lyapunov_rank</span><span class="p">()</span> <span class="o">==</span> <span class="n">K</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">lyapunov_rank</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.orthogonal_sublattice">
<code class="descname">orthogonal_sublattice</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.orthogonal_sublattice" title="Permalink to this definition">¶</a></dt>
<dd><p>The sublattice (in the dual lattice) orthogonal to the
sublattice spanned by the cone.</p>
<p>Let <span class="math notranslate nohighlight">\(M=\)</span> <code class="docutils literal notranslate"><span class="pre">self.dual_lattice()</span></code> be the lattice dual to the
ambient lattice of the given cone <span class="math notranslate nohighlight">\(\sigma\)</span>. Then, in the
notation of <a class="reference internal" href="../../../references/index.html#fu1993" id="id22">[Fu1993]</a>, this method returns the sublattice</p>
<div class="math notranslate nohighlight">
\[M(\sigma) \stackrel{\text{def}}{=}
\sigma^\perp \cap M
\subset M\]</div>
<p>INPUT:</p>
<ul class="simple">
<li>either nothing or something that can be turned into an element of
this lattice.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>if no arguments were given, a <a class="reference internal" href="toric_lattice.html#sage.geometry.toric_lattice.ToricLattice_sublattice_with_basis" title="sage.geometry.toric_lattice.ToricLattice_sublattice_with_basis"><code class="xref py py-class docutils literal notranslate"><span class="pre">toric</span> <span class="pre">sublattice</span></code></a>,
otherwise the corresponding element of it.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">orthogonal_sublattice</span><span class="p">()</span>
<span class="go">Sublattice &lt;&gt;</span>
<span class="gp">sage: </span><span class="n">c12</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">c12</span><span class="o">.</span><span class="n">sublattice</span><span class="p">()</span>
<span class="go">Sublattice &lt;N(1, -1, 1), N(0, 1, 0)&gt;</span>
<span class="gp">sage: </span><span class="n">c12</span><span class="o">.</span><span class="n">orthogonal_sublattice</span><span class="p">()</span>
<span class="go">Sublattice &lt;M(1, 0, -1)&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>**options</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li>any options for toric plots (see <a class="reference internal" href="toric_plotter.html#sage.geometry.toric_plotter.options" title="sage.geometry.toric_plotter.options"><code class="xref py py-func docutils literal notranslate"><span class="pre">toric_plotter.options</span></code></a>), none are mandatory.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a plot.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">quadrant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 9 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.polyhedron">
<code class="descname">polyhedron</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.polyhedron" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the polyhedron associated to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Mathematically this polyhedron is the same as <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference internal" href="polyhedron/base.html#sage.geometry.polyhedron.base.Polyhedron_base" title="sage.geometry.polyhedron.base.Polyhedron_base"><code class="xref py py-class docutils literal notranslate"><span class="pre">Polyhedron_base</span></code></a>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">quadrant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">polyhedron</span><span class="p">()</span>
<span class="go">A 2-dimensional polyhedron in ZZ^2 defined as the convex hull</span>
<span class="go">of 1 vertex and 2 rays</span>
<span class="gp">sage: </span><span class="n">line</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">line</span><span class="o">.</span><span class="n">polyhedron</span><span class="p">()</span>
<span class="go">A 1-dimensional polyhedron in ZZ^2 defined as the convex hull</span>
<span class="go">of 1 vertex and 1 line</span>
</pre></div>
</div>
<p>Here is an example of a trivial cone (see <a class="reference external" href="https://trac.sagemath.org/10237">trac ticket #10237</a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">origin</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">ZZ</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">origin</span><span class="o">.</span><span class="n">polyhedron</span><span class="p">()</span>
<span class="go">A 0-dimensional polyhedron in ZZ^2 defined as the convex hull</span>
<span class="go">of 1 vertex</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.positive_operators_gens">
<code class="descname">positive_operators_gens</code><span class="sig-paren">(</span><em>K2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.positive_operators_gens" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute minimal generators of the positive operators on this cone.</p>
<p>A linear operator on a cone is positive if the image of
the cone under the operator is a subset of the cone. This
concept can be extended to two cones: the image of the
first cone under a positive operator is a subset of the
second cone, which may live in a different space.</p>
<p>The positive operators (on one or two fixed cones) themselves
form a closed convex cone. This method computes and returns
the generators of that cone as a list of matrices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">K2</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">self</span></code>) the codomain cone; the image of
this cone under the returned generators is a subset of <code class="docutils literal notranslate"><span class="pre">K2</span></code>.</li>
</ul>
<p>OUTPUT:</p>
<p>A list of <span class="math notranslate nohighlight">\(m\)</span>-by-<span class="math notranslate nohighlight">\(n\)</span> matrices where <span class="math notranslate nohighlight">\(m\)</span> is the ambient dimension
of <code class="docutils literal notranslate"><span class="pre">K2</span></code> and <span class="math notranslate nohighlight">\(n\)</span> is the ambient dimension of this cone. Each
matrix <span class="math notranslate nohighlight">\(P\)</span> in the list has the property that <span class="math notranslate nohighlight">\(P(x)\)</span> is an
element of <code class="docutils literal notranslate"><span class="pre">K2</span></code> whenever <span class="math notranslate nohighlight">\(x\)</span> is an element of this cone.</p>
<p>The returned matrices generate the cone of positive operators
from this cone to <code class="docutils literal notranslate"><span class="pre">K2</span></code>; that is,</p>
<ul class="simple">
<li>Any nonnegative linear combination of the returned matrices
sends elements of this cone to <code class="docutils literal notranslate"><span class="pre">K2</span></code>.</li>
<li>Every positive operator on this cone (with respect to <code class="docutils literal notranslate"><span class="pre">K2</span></code>)
is some nonnegative linear combination of the returned matrices.</li>
</ul>
<p>ALGORITHM:</p>
<p>Computing positive operators directly is difficult, but
computing their dual is straightforward using the generators of
Berman and Gaiha. We construct the dual of the positive
operators, and then return the dual of that, which is guaranteed
to be the desired positive operators because everything is
closed, convex, and polyhedral.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.cross_positive_operators_gens" title="sage.geometry.cone.ConvexRationalPolyhedralCone.cross_positive_operators_gens"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cross_positive_operators_gens()</span></code></a>,
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.lyapunov_like_basis" title="sage.geometry.cone.ConvexRationalPolyhedralCone.lyapunov_like_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lyapunov_like_basis()</span></code></a>,
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.Z_operators_gens" title="sage.geometry.cone.ConvexRationalPolyhedralCone.Z_operators_gens"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Z_operators_gens()</span></code></a></p>
</div>
<p>REFERENCES:</p>
<p>A. Berman and P. Gaiha. A generalization of irreducible
monotonicity. Linear Algebra and its Applications, 5:29-38,
1972.</p>
<p>A. Berman and R. J. Plemmons. Nonnegative Matrices in the
Mathematical Sciences. SIAM, Philadelphia, 1994.</p>
<table class="docutils citation" frame="void" id="orlitzkyposz" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[OrlitzkyPosZ]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id23">2</a>)</em> M. Orlitzky.
Positive and Z-operators on closed convex cones.
<a class="reference external" href="http://www.optimization-online.org/DB_HTML/2016/09/5650.html">http://www.optimization-online.org/DB_HTML/2016/09/5650.html</a></td></tr>
</tbody>
</table>
<p>EXAMPLES:</p>
<p>Positive operators on the nonnegative orthant are nonnegative
matrices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">positive_operators_gens</span><span class="p">()</span>
<span class="go">[[1]]</span>

<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">positive_operators_gens</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">[1 0]  [0 1]  [0 0]  [0 0]</span>
<span class="go">[0 0], [0 0], [1 0], [0 1]</span>
<span class="go">]</span>
</pre></div>
</div>
<p>The trivial cone in a trivial space has no positive operators:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([],</span> <span class="n">ToricLattice</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">positive_operators_gens</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Every operator is positive on the trivial cone:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">0</span><span class="p">,)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">positive_operators_gens</span><span class="p">()</span>
<span class="go">[[1], [-1]]</span>

<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_trivial</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">positive_operators_gens</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">[1 0]  [-1  0]  [0 1]  [ 0 -1]  [0 0]  [ 0  0]  [0 0]  [ 0  0]</span>
<span class="go">[0 0], [ 0  0], [0 0], [ 0  0], [1 0], [-1  0], [0 1], [ 0 -1]</span>
<span class="go">]</span>
</pre></div>
</div>
<p>Every operator is positive on the ambient vector space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_full_space</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">positive_operators_gens</span><span class="p">()</span>
<span class="go">[[1], [-1]]</span>

<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_full_space</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">positive_operators_gens</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">[1 0]  [-1  0]  [0 1]  [ 0 -1]  [0 0]  [ 0  0]  [0 0]  [ 0  0]</span>
<span class="go">[0 0], [ 0  0], [0 0], [ 0  0], [1 0], [-1  0], [0 1], [ 0 -1]</span>
<span class="go">]</span>
</pre></div>
</div>
<p>A non-obvious application is to find the positive operators on the
right half-plane <a class="reference internal" href="#orlitzkyposz" id="id23">[OrlitzkyPosZ]</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">positive_operators_gens</span><span class="p">()</span>
<span class="go">[</span>
<span class="go">[1 0]  [0 0]  [ 0  0]  [0 0]  [ 0  0]</span>
<span class="go">[0 0], [1 0], [-1  0], [0 1], [ 0 -1]</span>
<span class="go">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.random_element">
<code class="descname">random_element</code><span class="sig-paren">(</span><em>ring=Integer Ring</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.random_element" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random element of this cone.</p>
<p>All elements of a convex cone can be represented as a
nonnegative linear combination of its generators. A random
element is thus constructed by assigning random nonnegative
weights to the generators of this cone.  By default, these
weights are integral and the resulting random element will live
in the same lattice as the cone.</p>
<p>The random nonnegative weights are chosen from <code class="docutils literal notranslate"><span class="pre">ring</span></code> which
defaults to <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>. When <code class="docutils literal notranslate"><span class="pre">ring</span></code> is not <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>, the random
element returned will be a vector. Only the rings <code class="docutils literal notranslate"><span class="pre">ZZ</span></code> and
<code class="docutils literal notranslate"><span class="pre">QQ</span></code> are currently supported.</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ring</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>) the ring from which the random
generator weights are chosen; either <code class="docutils literal notranslate"><span class="pre">ZZ</span></code> or <code class="docutils literal notranslate"><span class="pre">QQ</span></code>.</li>
</ul>
</div></blockquote>
<p>OUTPUT:</p>
<p>Either a lattice element or vector contained in both this cone
and its ambient vector space. If <code class="docutils literal notranslate"><span class="pre">ring</span></code> is <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>, a lattice
element is returned; otherwise a vector is returned. If <code class="docutils literal notranslate"><span class="pre">ring</span></code>
is neither <code class="docutils literal notranslate"><span class="pre">ZZ</span></code> nor <code class="docutils literal notranslate"><span class="pre">QQ</span></code>, then a <code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code> is
raised.</p>
<p>EXAMPLES:</p>
<p>The trivial element <code class="docutils literal notranslate"><span class="pre">()</span></code> is always returned in a trivial space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([],</span> <span class="n">ToricLattice</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="go">N()</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">random_element</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">()</span>
</pre></div>
</div>
<p>A random element of the trivial cone in a nontrivial space is zero:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="go">N(0, 0, 0)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">random_element</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">(0, 0, 0)</span>
</pre></div>
</div>
<p>A random element of the nonnegative orthant should have all
components nonnegative:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">K</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span> <span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">([</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">K</span><span class="o">.</span><span class="n">random_element</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span> <span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">ring</span></code> is not <code class="docutils literal notranslate"><span class="pre">ZZ</span></code> or <code class="docutils literal notranslate"><span class="pre">QQ</span></code>, an error is raised:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">random_element</span><span class="p">(</span><span class="n">ring</span><span class="o">=</span><span class="n">RR</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">ring must be either ZZ or QQ.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.relative_interior_contains">
<code class="descname">relative_interior_contains</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.relative_interior_contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a given point is contained in the relative interior of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>For a full-dimensional cone the relative interior is simply
the interior, so this method will do the same check as
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.interior_contains" title="sage.geometry.cone.ConvexRationalPolyhedralCone.interior_contains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interior_contains()</span></code></a>. For a strictly lower-dimensional cone, the
relative interior is the cone without its facets.</p>
<p>INPUT:</p>
<ul class="simple">
<li>anything. An attempt will be made to convert all arguments into a
single element of the ambient space of <code class="docutils literal notranslate"><span class="pre">self</span></code>. If it fails,
<code class="docutils literal notranslate"><span class="pre">False</span></code> will be returned.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">True</span></code> if the given point is contained in the relative
interior of <code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">relative_interior_contains</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">interior_contains</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">contains</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">relative_interior_contains</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">interior_contains</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.relative_orthogonal_quotient">
<code class="descname">relative_orthogonal_quotient</code><span class="sig-paren">(</span><em>supercone</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.relative_orthogonal_quotient" title="Permalink to this definition">¶</a></dt>
<dd><p>The quotient of the dual spanned lattice by the dual of the
supercone’s spanned lattice.</p>
<p>In the notation of <a class="reference internal" href="../../../references/index.html#fu1993" id="id24">[Fu1993]</a>, if <code class="docutils literal notranslate"><span class="pre">supercone</span></code> = <span class="math notranslate nohighlight">\(\rho &gt;
\sigma\)</span> = <code class="docutils literal notranslate"><span class="pre">self</span></code> is a cone that contains <span class="math notranslate nohighlight">\(\sigma\)</span> as a face,
then <span class="math notranslate nohighlight">\(M(\rho)\)</span> = <code class="docutils literal notranslate"><span class="pre">supercone.orthogonal_sublattice()</span></code> is a
saturated sublattice of <span class="math notranslate nohighlight">\(M(\sigma)\)</span> =
<code class="docutils literal notranslate"><span class="pre">self.orthogonal_sublattice()</span></code>. This method returns the
quotient lattice. The lifts of the quotient generators are
<span class="math notranslate nohighlight">\(\dim(\rho)-\dim(\sigma)\)</span> linearly independent M-lattice
lattice points that, together with <span class="math notranslate nohighlight">\(M(\rho)\)</span>, generate
<span class="math notranslate nohighlight">\(M(\sigma)\)</span>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference internal" href="toric_lattice.html#sage.geometry.toric_lattice.ToricLattice_quotient" title="sage.geometry.toric_lattice.ToricLattice_quotient"><code class="xref py py-class docutils literal notranslate"><span class="pre">toric</span> <span class="pre">lattice</span> <span class="pre">quotient</span></code></a>.</li>
</ul>
<p>If we call the output <code class="docutils literal notranslate"><span class="pre">Mrho</span></code>, then</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Mrho.cover()</span> <span class="pre">==</span> <span class="pre">self.orthogonal_sublattice()</span></code>, and</li>
<li><code class="docutils literal notranslate"><span class="pre">Mrho.relations()</span> <span class="pre">==</span> <span class="pre">supercone.orthogonal_sublattice()</span></code>.</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li><span class="math notranslate nohighlight">\(M(\sigma) / M(\rho)\)</span> has no torsion since the sublattice
<span class="math notranslate nohighlight">\(M(\rho)\)</span> is saturated.</li>
<li>In the codimension one case, (a lift of) the generator of
<span class="math notranslate nohighlight">\(M(\sigma) / M(\rho)\)</span> is chosen to be positive on <span class="math notranslate nohighlight">\(\sigma\)</span>.</li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rho</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">rho</span><span class="o">.</span><span class="n">orthogonal_sublattice</span><span class="p">()</span>
<span class="go">Sublattice &lt;M(0, 0, 3, -1)&gt;</span>
<span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">rho</span><span class="o">.</span><span class="n">facets</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">sigma</span><span class="o">.</span><span class="n">orthogonal_sublattice</span><span class="p">()</span>
<span class="go">Sublattice &lt;M(0, 1, 1, 0), M(0, 0, 3, -1)&gt;</span>
<span class="gp">sage: </span><span class="n">sigma</span><span class="o">.</span><span class="n">is_face_of</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">relative_orthogonal_quotient</span><span class="p">(</span><span class="n">rho</span><span class="p">);</span> <span class="n">Q</span>
<span class="go">1-d lattice, quotient</span>
<span class="go">of Sublattice &lt;M(0, 1, 1, 0), M(0, 0, 3, -1)&gt;</span>
<span class="go">by Sublattice &lt;M(0, 0, 3, -1)&gt;</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="go">(M[0, 1, 1, 0],)</span>
</pre></div>
</div>
<p>Different codimension:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rho</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">rho</span><span class="o">.</span><span class="n">facets</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">sigma</span><span class="o">.</span><span class="n">orthogonal_sublattice</span><span class="p">()</span>
<span class="go">Sublattice &lt;M(1, 0, 2, -1), M(0, 1, 1, 0), M(0, 0, 3, -1)&gt;</span>
<span class="gp">sage: </span><span class="n">rho</span><span class="o">.</span><span class="n">orthogonal_sublattice</span><span class="p">()</span>
<span class="go">Sublattice &lt;M(0, 1, 1, 0), M(0, 0, 3, -1)&gt;</span>
<span class="gp">sage: </span><span class="n">sigma</span><span class="o">.</span><span class="n">relative_orthogonal_quotient</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="go">(M[-1, 0, -2, 1],)</span>
</pre></div>
</div>
<p>Sign choice in the codimension one case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sigma1</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>  <span class="c1"># 3d</span>
<span class="gp">sage: </span><span class="n">sigma2</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)])</span>  <span class="c1"># 3d</span>
<span class="gp">sage: </span><span class="n">rho</span> <span class="o">=</span> <span class="n">sigma1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">sigma2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rho</span><span class="o">.</span><span class="n">relative_orthogonal_quotient</span><span class="p">(</span><span class="n">sigma1</span><span class="p">)</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="go">(M[-5, -2, 3],)</span>
<span class="gp">sage: </span><span class="n">rho</span><span class="o">.</span><span class="n">relative_orthogonal_quotient</span><span class="p">(</span><span class="n">sigma2</span><span class="p">)</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="go">(M[5, 2, -3],)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.relative_quotient">
<code class="descname">relative_quotient</code><span class="sig-paren">(</span><em>subcone</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.relative_quotient" title="Permalink to this definition">¶</a></dt>
<dd><p>The quotient of the spanned lattice by the lattice spanned by
a subcone.</p>
<p>In the notation of <a class="reference internal" href="../../../references/index.html#fu1993" id="id25">[Fu1993]</a>, let <span class="math notranslate nohighlight">\(N\)</span> be the ambient lattice
and <span class="math notranslate nohighlight">\(N_\sigma\)</span> the sublattice spanned by the given cone
<span class="math notranslate nohighlight">\(\sigma\)</span>. If <span class="math notranslate nohighlight">\(\rho &lt; \sigma\)</span> is a subcone, then <span class="math notranslate nohighlight">\(N_\rho\)</span> =
<code class="docutils literal notranslate"><span class="pre">rho.sublattice()</span></code> is a saturated sublattice of <span class="math notranslate nohighlight">\(N_\sigma\)</span> =
<code class="docutils literal notranslate"><span class="pre">self.sublattice()</span></code>. This method returns the quotient
lattice. The lifts of the quotient generators are
<span class="math notranslate nohighlight">\(\dim(\sigma)-\dim(\rho)\)</span> linearly independent primitive
lattice points that, together with <span class="math notranslate nohighlight">\(N_\rho\)</span>, generate
<span class="math notranslate nohighlight">\(N_\sigma\)</span>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><a class="reference internal" href="toric_lattice.html#sage.geometry.toric_lattice.ToricLattice_quotient" title="sage.geometry.toric_lattice.ToricLattice_quotient"><code class="xref py py-class docutils literal notranslate"><span class="pre">toric</span> <span class="pre">lattice</span> <span class="pre">quotient</span></code></a>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>The quotient <span class="math notranslate nohighlight">\(N_\sigma / N_\rho\)</span> of spanned sublattices
has no torsion since the sublattice <span class="math notranslate nohighlight">\(N_\rho\)</span> is saturated.</li>
<li>In the codimension one case, the generator of
<span class="math notranslate nohighlight">\(N_\sigma / N_\rho\)</span> is chosen to be in the same direction as the
image <span class="math notranslate nohighlight">\(\sigma / N_\rho\)</span></li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">rho</span>   <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">sigma</span><span class="o">.</span><span class="n">sublattice</span><span class="p">()</span>
<span class="go">Sublattice &lt;N(-1, -1, 1, 3), N(1, 0, 0, 0), N(1, 1, 0, 0)&gt;</span>
<span class="gp">sage: </span><span class="n">rho</span><span class="o">.</span><span class="n">sublattice</span><span class="p">()</span>
<span class="go">Sublattice &lt;N(-1, 1, 1, 3), N(0, -1, 0, 0)&gt;</span>
<span class="gp">sage: </span><span class="n">sigma</span><span class="o">.</span><span class="n">relative_quotient</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="go">1-d lattice, quotient</span>
<span class="go">of Sublattice &lt;N(-1, -1, 1, 3), N(1, 0, 0, 0), N(1, 1, 0, 0)&gt;</span>
<span class="go">by Sublattice &lt;N(1, 0, -1, -3), N(0, 1, 0, 0)&gt;</span>
<span class="gp">sage: </span><span class="n">sigma</span><span class="o">.</span><span class="n">relative_quotient</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="go">(N[1, 1, 0, 0],)</span>
</pre></div>
</div>
<p>More complicated example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">rho</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">N_sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">.</span><span class="n">sublattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">N_sigma</span>
<span class="go">Sublattice &lt;N(-1, 1, 1), N(1, 2, 3), N(0, 1, 1)&gt;</span>
<span class="gp">sage: </span><span class="n">N_rho</span> <span class="o">=</span> <span class="n">rho</span><span class="o">.</span><span class="n">sublattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">N_rho</span>
<span class="go">Sublattice &lt;N(1, -1, 1), N(1, 2, 3)&gt;</span>
<span class="gp">sage: </span><span class="n">sigma</span><span class="o">.</span><span class="n">relative_quotient</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="go">(N[0, 1, 1],)</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">rho</span><span class="o">.</span><span class="n">lattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">N_sigma</span> <span class="o">==</span> <span class="n">N</span><span class="o">.</span><span class="n">span</span><span class="p">(</span><span class="n">N_rho</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">lift</span><span class="p">()</span>
<span class="go">....:            for q in sigma.relative_quotient(rho).gens()))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Sign choice in the codimension one case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sigma1</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>  <span class="c1"># 3d</span>
<span class="gp">sage: </span><span class="n">sigma2</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)])</span>  <span class="c1"># 3d</span>
<span class="gp">sage: </span><span class="n">rho</span> <span class="o">=</span> <span class="n">sigma1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">sigma2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">rho</span><span class="o">.</span><span class="n">sublattice</span><span class="p">()</span>
<span class="go">Sublattice &lt;N(1, -1, 1), N(1, 2, 3)&gt;</span>
<span class="gp">sage: </span><span class="n">sigma1</span><span class="o">.</span><span class="n">relative_quotient</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="go">1-d lattice, quotient</span>
<span class="go">of Sublattice &lt;N(-1, 1, 1), N(1, 2, 3), N(0, 1, 1)&gt;</span>
<span class="go">by Sublattice &lt;N(1, 2, 3), N(0, 3, 2)&gt;</span>
<span class="gp">sage: </span><span class="n">sigma1</span><span class="o">.</span><span class="n">relative_quotient</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="go">(N[0, 1, 1],)</span>
<span class="gp">sage: </span><span class="n">sigma2</span><span class="o">.</span><span class="n">relative_quotient</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="go">(N[-1, 0, -2],)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.semigroup_generators">
<code class="descname">semigroup_generators</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.semigroup_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return generators for the semigroup of lattice points of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>a <a class="reference internal" href="point_collection.html#sage.geometry.point_collection.PointCollection" title="sage.geometry.point_collection.PointCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointCollection</span></code></a>
of lattice points generating the semigroup of lattice points
contained in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No attempt is made to return a minimal set of generators, see
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.Hilbert_basis" title="sage.geometry.cone.ConvexRationalPolyhedralCone.Hilbert_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Hilbert_basis()</span></code></a> for that.</p>
</div>
<p>EXAMPLES:</p>
<p>The following command ensures that the output ordering in the examples
below is independent of TOPCOM, you don’t have to use it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">PointConfiguration</span><span class="o">.</span><span class="n">set_engine</span><span class="p">(</span><span class="s1">&#39;internal&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We start with a simple case of a non-smooth 2-dimensional cone:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cone</span><span class="p">([</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="p">])</span><span class="o">.</span><span class="n">semigroup_generators</span><span class="p">()</span>
<span class="go">N(1, 1),</span>
<span class="go">N(1, 0),</span>
<span class="go">N(1, 2)</span>
<span class="go">in 2-d lattice N</span>
</pre></div>
</div>
<p>A non-simplicial cone works, too:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">semigroup_generators</span><span class="p">()</span>
<span class="go">(N(1, 0, 0), N(0, 0, 1), N(0, 1, 0), N(3, 0, -1), N(1, -1, 0))</span>
</pre></div>
</div>
<p>GAP’s toric package thinks this is challenging:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span> <span class="n">cone</span><span class="o">.</span><span class="n">semigroup_generators</span><span class="p">()</span> <span class="p">)</span>
<span class="go">2806</span>
</pre></div>
</div>
<p>The cone need not be strictly convex:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">halfplane</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">halfplane</span><span class="o">.</span><span class="n">semigroup_generators</span><span class="p">()</span>
<span class="go">(N(0, 1), N(1, 0), N(-1, 0))</span>
<span class="gp">sage: </span><span class="n">line</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">line</span><span class="o">.</span><span class="n">semigroup_generators</span><span class="p">()</span>
<span class="go">(N(1, 1, 1), N(-1, -1, -1))</span>
<span class="gp">sage: </span><span class="n">wedge</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">])</span>
<span class="gp">sage: </span><span class="n">wedge</span><span class="o">.</span><span class="n">semigroup_generators</span><span class="p">()</span>
<span class="go">(N(1, 0, 0), N(1, 1, 0), N(1, 2, 0), N(0, 0, 1), N(0, 0, -1))</span>
</pre></div>
</div>
<p>Nor does it have to be full-dimensional (see
<a class="reference external" href="http://trac.sagemath.org/sage_trac/ticket/11312">http://trac.sagemath.org/sage_trac/ticket/11312</a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span><span class="o">.</span><span class="n">semigroup_generators</span><span class="p">()</span>
<span class="go">N( 0, 1, 0),</span>
<span class="go">N( 1, 1, 0),</span>
<span class="go">N(-1, 1, 0)</span>
<span class="go">in 3-d lattice N</span>
</pre></div>
</div>
<p>Neither full-dimensional nor simplicial:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">elementary_divisors</span><span class="p">()</span>
<span class="go">[1, 1, 1, 0]</span>
<span class="gp">sage: </span><span class="n">cone3d</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">rays</span> <span class="o">=</span> <span class="p">[</span> <span class="n">A</span><span class="o">*</span><span class="n">vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cone3d</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span> <span class="p">]</span>
<span class="gp">sage: </span><span class="n">gens</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">(</span><span class="n">rays</span><span class="p">)</span><span class="o">.</span><span class="n">semigroup_generators</span><span class="p">();</span> <span class="n">gens</span>
<span class="go">(N(1, -1, 1, 15), N(0, 1, -2, 0), N(-2, -1, 0, 17), N(3, -4, 5, 45), N(3, 0, 1, -2))</span>
<span class="gp">sage: </span><span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span><span class="n">gens</span><span class="p">))</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">cone3d</span><span class="o">.</span><span class="n">semigroup_generators</span><span class="p">()</span> <span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>ALGORITHM:</p>
<p>If the cone is not simplicial, it is first triangulated. Each
simplicial subcone has the integral points of the spaned
parallelotope as generators. This is the first step of the
primal Normaliz algorithm, see <a class="reference internal" href="../../../references/index.html#normaliz" id="id26">[Normaliz]</a>. For each
simplicial cone (of dimension <span class="math notranslate nohighlight">\(d\)</span>), the integral points of the
open parallelotope</p>
<div class="math notranslate nohighlight">
\[par \langle x_1, \dots, x_d \rangle =
\ZZ^n \cap
\left\{
q_1 x_1 + \cdots +q_d x_d
:~
0 \leq q_i &lt; 1
\right\}\]</div>
<p>are then computed <a class="reference internal" href="../../../references/index.html#bk2001" id="id27">[BK2001]</a>.</p>
<p>Finally, the union of the generators of all simplicial
subcones is returned.</p>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.solid_restriction">
<code class="descname">solid_restriction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.solid_restriction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a solid representation of this cone in terms of a basis
of its <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.sublattice" title="sage.geometry.cone.ConvexRationalPolyhedralCone.sublattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sublattice()</span></code></a>.</p>
<p>We define the <strong>solid restriction</strong> of a cone to be a
representation of that cone in a basis of its own
sublattice. Since a cone’s sublattice is just large enough to
hold the cone (by definition), the resulting solid restriction
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.is_solid" title="sage.geometry.cone.ConvexRationalPolyhedralCone.is_solid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_solid()</span></code></a>. For convenience, the solid restriction lives
in a new lattice (of the appropriate dimension) and not actually
in the sublattice object returned by <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.sublattice" title="sage.geometry.cone.ConvexRationalPolyhedralCone.sublattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sublattice()</span></code></a>.</p>
<p>OUTPUT:</p>
<p>A solid cone in a new lattice having the same dimension as this
cone’s <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.sublattice" title="sage.geometry.cone.ConvexRationalPolyhedralCone.sublattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sublattice()</span></code></a>.</p>
<p>EXAMPLES:</p>
<p>The nonnegative quadrant in the plane is left after we take its
solid restriction in space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">solid_restriction</span><span class="p">()</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(1, 0),</span>
<span class="go">N(0, 1)</span>
<span class="go">in 2-d lattice N</span>
</pre></div>
</div>
<p>The solid restriction of a single ray has the same
representation regardless of the ambient space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">solid_restriction</span><span class="p">()</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(1)</span>
<span class="go">in 1-d lattice N</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">solid_restriction</span><span class="p">()</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(1)</span>
<span class="go">in 1-d lattice N</span>
</pre></div>
</div>
<p>The solid restriction of the trivial cone lives in a trivial space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([],</span> <span class="n">ToricLattice</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">solid_restriction</span><span class="p">()</span>
<span class="go">0-d cone in 0-d lattice N</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">solid_restriction</span><span class="p">()</span>
<span class="go">0-d cone in 0-d lattice N</span>
</pre></div>
</div>
<p>The solid restriction of a solid cone is itself:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">solid_restriction</span><span class="p">()</span> <span class="ow">is</span> <span class="n">K</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.strict_quotient">
<code class="descname">strict_quotient</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.strict_quotient" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the quotient of <code class="docutils literal notranslate"><span class="pre">self</span></code> by the linear subspace.</p>
<p>We define the <strong>strict quotient</strong> of a cone to be the image of this
cone in the quotient of the ambient space by the linear subspace of
the cone, i.e. it is the “complementary part” to the linear subspace.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>cone.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">halfplane</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">ssc</span> <span class="o">=</span> <span class="n">halfplane</span><span class="o">.</span><span class="n">strict_quotient</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ssc</span>
<span class="go">1-d cone in 1-d lattice N</span>
<span class="gp">sage: </span><span class="n">ssc</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(1)</span>
<span class="go">in 1-d lattice N</span>
<span class="gp">sage: </span><span class="n">line</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">ssc</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strict_quotient</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ssc</span>
<span class="go">0-d cone in 1-d lattice N</span>
<span class="gp">sage: </span><span class="n">ssc</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">Empty collection</span>
<span class="go">in 1-d lattice N</span>
</pre></div>
</div>
<p>The quotient of the trivial cone is trivial:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([],</span> <span class="n">ToricLattice</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">strict_quotient</span><span class="p">()</span>
<span class="go">0-d cone in 0-d lattice N</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">strict_quotient</span><span class="p">()</span>
<span class="go">0-d cone in 4-d lattice N</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.sublattice">
<code class="descname">sublattice</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.sublattice" title="Permalink to this definition">¶</a></dt>
<dd><p>The sublattice spanned by the cone.</p>
<p>Let <span class="math notranslate nohighlight">\(\sigma\)</span> be the given cone and <span class="math notranslate nohighlight">\(N=\)</span> <code class="docutils literal notranslate"><span class="pre">self.lattice()</span></code> the
ambient lattice. Then, in the notation of <a class="reference internal" href="../../../references/index.html#fu1993" id="id28">[Fu1993]</a>, this
method returns the sublattice</p>
<div class="math notranslate nohighlight">
\[N_\sigma \stackrel{\text{def}}{=} \mathop{span}( N\cap \sigma )\]</div>
<p>INPUT:</p>
<ul class="simple">
<li>either nothing or something that can be turned into an element of
this lattice.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>if no arguments were given, a <a class="reference internal" href="toric_lattice.html#sage.geometry.toric_lattice.ToricLattice_sublattice_with_basis" title="sage.geometry.toric_lattice.ToricLattice_sublattice_with_basis"><code class="xref py py-class docutils literal notranslate"><span class="pre">toric</span> <span class="pre">sublattice</span></code></a>,
otherwise the corresponding element of it.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>The sublattice spanned by the cone is the saturation of
the sublattice generated by the rays of the cone.</li>
<li>If you only need a <span class="math notranslate nohighlight">\(\QQ\)</span>-basis, you may want to try the
<a class="reference internal" href="point_collection.html#sage.geometry.point_collection.PointCollection.basis" title="sage.geometry.point_collection.PointCollection.basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">basis()</span></code></a>
method on the result of <a class="reference internal" href="#sage.geometry.cone.IntegralRayCollection.rays" title="sage.geometry.cone.IntegralRayCollection.rays"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rays()</span></code></a>.</li>
<li>The returned lattice points are usually not rays of the
cone. In fact, for a non-smooth cone the rays do not
generate the sublattice <span class="math notranslate nohighlight">\(N_\sigma\)</span>, but only a finite
index sublattice.</li>
</ul>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">cone</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="go">N( 1,  1, 1),</span>
<span class="go">N( 1, -1, 1),</span>
<span class="go">N(-1, -1, 1)</span>
<span class="go">in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span><span class="o">.</span><span class="n">matrix</span><span class="p">()</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
<span class="go">-4</span>
<span class="gp">sage: </span><span class="n">cone</span><span class="o">.</span><span class="n">sublattice</span><span class="p">()</span>
<span class="go">Sublattice &lt;N(-1, -1, 1), N(1, 0, 0), N(1, 1, 0)&gt;</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">(</span> <span class="n">cone</span><span class="o">.</span><span class="n">sublattice</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span> <span class="p">)</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Another example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">c</span>
<span class="go">2-d cone in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N(1,  2, 3),</span>
<span class="go">N(4, -5, 1)</span>
<span class="go">in 3-d lattice N</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">sublattice</span><span class="p">()</span>
<span class="go">Sublattice &lt;N(1, 2, 3), N(4, -5, 1)&gt;</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">sublattice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">N(5, -3, 4)</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">sublattice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">element [1, 0, 0] is not in free module</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.sublattice_complement">
<code class="descname">sublattice_complement</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.sublattice_complement" title="Permalink to this definition">¶</a></dt>
<dd><p>A complement of the sublattice spanned by the cone.</p>
<p>In other words, <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.sublattice" title="sage.geometry.cone.ConvexRationalPolyhedralCone.sublattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sublattice()</span></code></a> and
<a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.sublattice_complement" title="sage.geometry.cone.ConvexRationalPolyhedralCone.sublattice_complement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sublattice_complement()</span></code></a> together form a
<span class="math notranslate nohighlight">\(\ZZ\)</span>-basis for the ambient <a class="reference internal" href="#sage.geometry.cone.IntegralRayCollection.lattice" title="sage.geometry.cone.IntegralRayCollection.lattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lattice()</span></code></a>.</p>
<p>In the notation of <a class="reference internal" href="../../../references/index.html#fu1993" id="id29">[Fu1993]</a>, let <span class="math notranslate nohighlight">\(\sigma\)</span> be the given cone
and <span class="math notranslate nohighlight">\(N=\)</span> <code class="docutils literal notranslate"><span class="pre">self.lattice()</span></code> the ambient lattice. Then this
method returns</p>
<div class="math notranslate nohighlight">
\[N(\sigma) \stackrel{\text{def}}{=} N / N_\sigma\]</div>
<p>lifted (non-canonically) to a sublattice of <span class="math notranslate nohighlight">\(N\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li>either nothing or something that can be turned into an element of
this lattice.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>if no arguments were given, a <a class="reference internal" href="toric_lattice.html#sage.geometry.toric_lattice.ToricLattice_sublattice_with_basis" title="sage.geometry.toric_lattice.ToricLattice_sublattice_with_basis"><code class="xref py py-class docutils literal notranslate"><span class="pre">toric</span> <span class="pre">sublattice</span></code></a>,
otherwise the corresponding element of it.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C2_Z2</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>     <span class="c1"># C^2/Z_2</span>
<span class="gp">sage: </span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">C2_Z2</span><span class="o">.</span><span class="n">facets</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">c2</span><span class="o">.</span><span class="n">sublattice</span><span class="p">()</span>
<span class="go">Sublattice &lt;N(1, 2)&gt;</span>
<span class="gp">sage: </span><span class="n">c2</span><span class="o">.</span><span class="n">sublattice_complement</span><span class="p">()</span>
<span class="go">Sublattice &lt;N(0, 1)&gt;</span>
</pre></div>
</div>
<p>A more complicated example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">sublattice</span><span class="p">()</span>
<span class="go">Sublattice &lt;N(1, 2, 3), N(4, -5, 1)&gt;</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">sublattice_complement</span><span class="p">()</span>
<span class="go">Sublattice &lt;N(0, -6, -5)&gt;</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span> <span class="n">c</span><span class="o">.</span><span class="n">sublattice</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">sublattice_complement</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span>
<span class="go">[ 1  2  3]</span>
<span class="go">[ 4 -5  1]</span>
<span class="go">[ 0 -6 -5]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
<span class="go">-1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.ConvexRationalPolyhedralCone.sublattice_quotient">
<code class="descname">sublattice_quotient</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.ConvexRationalPolyhedralCone.sublattice_quotient" title="Permalink to this definition">¶</a></dt>
<dd><p>The quotient of the ambient lattice by the sublattice spanned
by the cone.</p>
<p>INPUT:</p>
<ul class="simple">
<li>either nothing or something that can be turned into an element of
this lattice.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>if no arguments were given, a <a class="reference internal" href="toric_lattice.html#sage.geometry.toric_lattice.ToricLattice_quotient" title="sage.geometry.toric_lattice.ToricLattice_quotient"><code class="xref py py-class docutils literal notranslate"><span class="pre">quotient</span> <span class="pre">of</span> <span class="pre">a</span> <span class="pre">toric</span> <span class="pre">lattice</span></code></a>,
otherwise the corresponding element of it.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C2_Z2</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>     <span class="c1"># C^2/Z_2</span>
<span class="gp">sage: </span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">C2_Z2</span><span class="o">.</span><span class="n">facets</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">c2</span><span class="o">.</span><span class="n">sublattice_quotient</span><span class="p">()</span>
<span class="go">1-d lattice, quotient of 2-d lattice N by Sublattice &lt;N(1, 2)&gt;</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">C2_Z2</span><span class="o">.</span><span class="n">lattice</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">N</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">n_bar</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">sublattice_quotient</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="n">n_bar</span>
<span class="go">N[1, 1]</span>
<span class="gp">sage: </span><span class="n">n_bar</span><span class="o">.</span><span class="n">lift</span><span class="p">()</span>
<span class="go">N(1, 1)</span>
<span class="gp">sage: </span><span class="n">vector</span><span class="p">(</span><span class="n">n_bar</span><span class="p">)</span>
<span class="go">(-1)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.geometry.cone.IntegralRayCollection">
<em class="property">class </em><code class="descclassname">sage.geometry.cone.</code><code class="descname">IntegralRayCollection</code><span class="sig-paren">(</span><em>rays</em>, <em>lattice</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.IntegralRayCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Parents and Elements v8.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.sage_object.SageObject</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">_abcoll.Hashable</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">_abcoll.Iterable</span></code></p>
<p>Create a collection of integral rays.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">No correctness check or normalization is performed on the input data.
This class is designed for internal operations and you probably should
not use it directly.</p>
</div>
<p>This is a base class for <a class="reference internal" href="#sage.geometry.cone.ConvexRationalPolyhedralCone" title="sage.geometry.cone.ConvexRationalPolyhedralCone"><code class="xref py py-class docutils literal notranslate"><span class="pre">convex</span> <span class="pre">rational</span> <span class="pre">polyhedral</span> <span class="pre">cones</span></code></a> and <a class="reference internal" href="fan.html#sage.geometry.fan.RationalPolyhedralFan" title="sage.geometry.fan.RationalPolyhedralFan"><code class="xref py py-class docutils literal notranslate"><span class="pre">fans</span></code></a>.</p>
<p>Ray collections are immutable, but they cache most of the returned values.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">rays</span></code> – list of immutable vectors in <code class="docutils literal notranslate"><span class="pre">lattice</span></code>;</li>
<li><code class="docutils literal notranslate"><span class="pre">lattice</span></code> – <a class="reference internal" href="toric_lattice.html#sage.geometry.toric_lattice.ToricLatticeFactory" title="sage.geometry.toric_lattice.ToricLatticeFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">ToricLattice</span></code></a>, <span class="math notranslate nohighlight">\(\ZZ^n\)</span>, or any
other object that behaves like these. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, it will be determined
as <a class="reference external" href="../../../structure/sage/structure/element.html#sage.structure.element.parent" title="(in Sage Reference Manual: Parents and Elements v8.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">parent()</span></code></a> of the first ray. Of course, this cannot be done if
there are no rays, so in this case you must give an appropriate
<code class="docutils literal notranslate"><span class="pre">lattice</span></code> directly. Note that <code class="docutils literal notranslate"><span class="pre">None</span></code> is <em>not</em> the default value -
you always <em>must</em> give this argument explicitly, even if it is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>collection of given integral rays.</li>
</ul>
<dl class="method">
<dt id="sage.geometry.cone.IntegralRayCollection.cartesian_product">
<code class="descname">cartesian_product</code><span class="sig-paren">(</span><em>other</em>, <em>lattice=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.IntegralRayCollection.cartesian_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Cartesian product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">other</span></code> – an <a class="reference internal" href="#sage.geometry.cone.IntegralRayCollection" title="sage.geometry.cone.IntegralRayCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegralRayCollection</span></code></a>;</li>
<li><code class="docutils literal notranslate"><span class="pre">lattice</span></code> – (optional) the ambient lattice for the result. By
default, the direct sum of the ambient lattices of <code class="docutils literal notranslate"><span class="pre">self</span></code> and
<code class="docutils literal notranslate"><span class="pre">other</span></code> is constructed.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>an <a class="reference internal" href="#sage.geometry.cone.IntegralRayCollection" title="sage.geometry.cone.IntegralRayCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegralRayCollection</span></code></a>.</li>
</ul>
<p>By the Cartesian product of ray collections <span class="math notranslate nohighlight">\((r_0, \dots, r_{n-1})\)</span> and
<span class="math notranslate nohighlight">\((s_0, \dots, s_{m-1})\)</span> we understand the ray collection of the form
<span class="math notranslate nohighlight">\(((r_0, 0), \dots, (r_{n-1}, 0), (0, s_0), \dots, (0, s_{m-1}))\)</span>, which
is suitable for Cartesian products of cones and fans. The ray order is
guaranteed to be as described.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,)])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>    <span class="c1"># indirect doctest</span>
<span class="go">2-d cone in 2-d lattice N+N</span>
<span class="gp">sage: </span><span class="n">_</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N+N(1, 0),</span>
<span class="go">N+N(0, 1)</span>
<span class="go">in 2-d lattice N+N</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.IntegralRayCollection.codim">
<code class="descname">codim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.IntegralRayCollection.codim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the codimension of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The codimension of a collection of rays (of a cone/fan) is the
difference between the dimension of the ambient space and the
dimension of the subspace spanned by those rays (of the cone/fan).</p>
<p>OUTPUT:</p>
<p>A nonnegative integer representing the codimension of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.geometry.cone.IntegralRayCollection.dim" title="sage.geometry.cone.IntegralRayCollection.dim"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dim()</span></code></a>, <a class="reference internal" href="#sage.geometry.cone.IntegralRayCollection.lattice_dim" title="sage.geometry.cone.IntegralRayCollection.lattice_dim"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lattice_dim()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<p>The codimension of the nonnegative orthant is zero, since the
span of its generators equals the entire ambient space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">codim</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>However, if we remove a ray so that the entire cone is contained
within the <span class="math notranslate nohighlight">\(x\)</span>-<span class="math notranslate nohighlight">\(y\)</span> plane, then the resulting cone will have
codimension one, because the <span class="math notranslate nohighlight">\(z\)</span>-axis is perpendicular to every
element of the cone:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">codim</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<p>If our cone is all of <span class="math notranslate nohighlight">\(\mathbb{R}^{2}\)</span>, then its codimension is
zero:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_full_space</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">codim</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>And if the cone is trivial in any space, then its codimension is
equal to the dimension of the ambient space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">ToricLattice</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">codim</span><span class="p">()</span>
<span class="go">0</span>

<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">0</span><span class="p">,)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">codim</span><span class="p">()</span>
<span class="go">1</span>

<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">codim</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.IntegralRayCollection.dim">
<code class="descname">dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.IntegralRayCollection.dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension of the subspace spanned by rays of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>integer.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.IntegralRayCollection.dual_lattice">
<code class="descname">dual_lattice</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.IntegralRayCollection.dual_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual of the ambient lattice of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>lattice. If possible (that is, if <a class="reference internal" href="#sage.geometry.cone.IntegralRayCollection.lattice" title="sage.geometry.cone.IntegralRayCollection.lattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lattice()</span></code></a> has a
<code class="docutils literal notranslate"><span class="pre">dual()</span></code> method), the dual lattice is returned. Otherwise,
<span class="math notranslate nohighlight">\(\ZZ^n\)</span> is returned, where <span class="math notranslate nohighlight">\(n\)</span> is the dimension of <a class="reference internal" href="#sage.geometry.cone.IntegralRayCollection.lattice" title="sage.geometry.cone.IntegralRayCollection.lattice"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lattice()</span></code></a>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">dual_lattice</span><span class="p">()</span>
<span class="go">2-d lattice M</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">([],</span> <span class="n">ZZ</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">dual_lattice</span><span class="p">()</span>
<span class="go">Ambient free module of rank 3</span>
<span class="go">over the principal ideal domain Integer Ring</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.IntegralRayCollection.lattice">
<code class="descname">lattice</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.IntegralRayCollection.lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ambient lattice of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>lattice.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">lattice</span><span class="p">()</span>
<span class="go">2-d lattice N</span>
<span class="gp">sage: </span><span class="n">Cone</span><span class="p">([],</span> <span class="n">ZZ</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">lattice</span><span class="p">()</span>
<span class="go">Ambient free module of rank 3</span>
<span class="go">over the principal ideal domain Integer Ring</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.IntegralRayCollection.lattice_dim">
<code class="descname">lattice_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.IntegralRayCollection.lattice_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dimension of the ambient lattice of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>integer.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.IntegralRayCollection.nrays">
<code class="descname">nrays</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.IntegralRayCollection.nrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of rays of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li>integer.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">nrays</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.IntegralRayCollection.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>**options</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.IntegralRayCollection.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li>any options for toric plots (see <a class="reference internal" href="toric_plotter.html#sage.geometry.toric_plotter.options" title="sage.geometry.toric_plotter.options"><code class="xref py py-func docutils literal notranslate"><span class="pre">toric_plotter.options</span></code></a>), none are mandatory.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a plot.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">quadrant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">quadrant</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="go">Graphics object consisting of 9 graphics primitives</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.IntegralRayCollection.ray">
<code class="descname">ray</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.IntegralRayCollection.ray" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <code class="docutils literal notranslate"><span class="pre">n</span></code>-th ray of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code> – integer, an index of a ray of <code class="docutils literal notranslate"><span class="pre">self</span></code>. Enumeration of rays
starts with zero.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>ray, an element of the lattice of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">ray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">N(1, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.IntegralRayCollection.rays">
<code class="descname">rays</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.IntegralRayCollection.rays" title="Permalink to this definition">¶</a></dt>
<dd><p>Return (some of the) rays of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ray_list</span></code> – a list of integers, the indices of the requested
rays. If not specified, all rays of <code class="docutils literal notranslate"><span class="pre">self</span></code> will be returned.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>a <a class="reference internal" href="point_collection.html#sage.geometry.point_collection.PointCollection" title="sage.geometry.point_collection.PointCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointCollection</span></code></a>
of primitive integral ray generators.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">rays</span><span class="p">()</span>
<span class="go">N( 0, 1),</span>
<span class="go">N( 1, 0),</span>
<span class="go">N(-1, 0)</span>
<span class="go">in 2-d lattice N</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">rays</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">N( 0, 1),</span>
<span class="go">N(-1, 0)</span>
<span class="go">in 2-d lattice N</span>
</pre></div>
</div>
<p>You can also give ray indices directly, without packing them into a
list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">rays</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">N( 0, 1),</span>
<span class="go">N(-1, 0)</span>
<span class="go">in 2-d lattice N</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.geometry.cone.IntegralRayCollection.span">
<code class="descname">span</code><span class="sig-paren">(</span><em>base_ring=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.IntegralRayCollection.span" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the span of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> – (default: from lattice) the base ring to use</dt>
<dd>for the generated module.</dd>
</dl>
</li>
</ul>
<p>OUTPUT:</p>
<p>A module spanned by the generators of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<p>The span of a single ray is a one-dimensional sublattice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K1</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,)])</span>
<span class="gp">sage: </span><span class="n">K1</span><span class="o">.</span><span class="n">span</span><span class="p">()</span>
<span class="go">Sublattice &lt;N(1)&gt;</span>
<span class="gp">sage: </span><span class="n">K2</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K2</span><span class="o">.</span><span class="n">span</span><span class="p">()</span>
<span class="go">Sublattice &lt;N(1, 0)&gt;</span>
</pre></div>
</div>
<p>The span of the nonnegative orthant is the entire ambient lattice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">span</span><span class="p">()</span> <span class="o">==</span> <span class="n">K</span><span class="o">.</span><span class="n">lattice</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>By specifying a <code class="docutils literal notranslate"><span class="pre">base_ring</span></code>, we can obtain a vector space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">span</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">Vector space of degree 3 and dimension 3 over Rational Field</span>
<span class="go">Basis matrix:</span>
<span class="go">[1 0 0]</span>
<span class="go">[0 1 0]</span>
<span class="go">[0 0 1]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.geometry.cone.classify_cone_2d">
<code class="descclassname">sage.geometry.cone.</code><code class="descname">classify_cone_2d</code><span class="sig-paren">(</span><em>ray0</em>, <em>ray1</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.classify_cone_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <span class="math notranslate nohighlight">\((d,k)\)</span> classifying the lattice cone spanned by the two rays.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ray0</span></code>, <code class="docutils literal notranslate"><span class="pre">ray1</span></code> – two primitive integer vectors. The
generators of the two rays generating the two-dimensional cone.</li>
<li><code class="docutils literal notranslate"><span class="pre">check</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>). Whether to check the
input rays for consistency.</li>
</ul>
<p>OUTPUT:</p>
<p>A pair <span class="math notranslate nohighlight">\((d,k)\)</span> of integers classifying the cone up to <span class="math notranslate nohighlight">\(GL(2, \ZZ)\)</span>
equivalence. See Proposition 10.1.1 of <a class="reference internal" href="../../../schemes/sage/schemes/toric/variety.html#cls" id="id30">[CLS]</a> for the
definition. We return the unique <span class="math notranslate nohighlight">\((d,k)\)</span> with minimal <span class="math notranslate nohighlight">\(k\)</span>, see
Proposition 10.1.3 of <a class="reference internal" href="../../../schemes/sage/schemes/toric/variety.html#cls" id="id31">[CLS]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ray0</span> <span class="o">=</span> <span class="n">vector</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">ray1</span> <span class="o">=</span> <span class="n">vector</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.geometry.cone</span> <span class="kn">import</span> <span class="n">classify_cone_2d</span>
<span class="gp">sage: </span><span class="n">classify_cone_2d</span><span class="p">(</span><span class="n">ray0</span><span class="p">,</span> <span class="n">ray1</span><span class="p">)</span>
<span class="go">(3, 2)</span>

<span class="gp">sage: </span><span class="n">ray0</span> <span class="o">=</span> <span class="n">vector</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">ray1</span> <span class="o">=</span> <span class="n">vector</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">11</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">classify_cone_2d</span><span class="p">(</span><span class="n">ray0</span><span class="p">,</span> <span class="n">ray1</span><span class="p">)</span>
<span class="go">(3, 1)</span>

<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="p">[(</span><span class="mi">19</span><span class="p">,</span> <span class="o">-</span><span class="mi">14</span><span class="p">,</span> <span class="o">-</span><span class="mi">115</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span> <span class="p">(</span><span class="mi">43</span><span class="p">,</span> <span class="o">-</span><span class="mi">42</span><span class="p">,</span> <span class="o">-</span><span class="mi">298</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>   <span class="c1"># check that it is in GL(3,ZZ)</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">classify_cone_2d</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">ray0</span><span class="p">,</span> <span class="n">m</span><span class="o">*</span><span class="n">ray1</span><span class="p">)</span>
<span class="go">(3, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.cone.integral_length">
<code class="descclassname">sage.geometry.cone.</code><code class="descname">integral_length</code><span class="sig-paren">(</span><em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.integral_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the integral length of a given rational vector.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">v</span></code> – any object which can be converted to a list of rationals</li>
</ul>
<p>OUTPUT:</p>
<p>Rational number <span class="math notranslate nohighlight">\(r`\)</span> such that <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">r</span> <span class="pre">*</span> <span class="pre">u</span></code>, where <code class="docutils literal notranslate"><span class="pre">u</span></code> is the
primitive integral vector in the direction of <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.geometry.cone</span> <span class="kn">import</span> <span class="n">integral_length</span>
<span class="gp">sage: </span><span class="n">integral_length</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">integral_length</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">integral_length</span><span class="p">([</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">2/3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.cone.is_Cone">
<code class="descclassname">sage.geometry.cone.</code><code class="descname">is_Cone</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.is_Cone" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <code class="docutils literal notranslate"><span class="pre">x</span></code> is a cone.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">x</span></code> – anything.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">x</span></code> is a cone and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.geometry.cone</span> <span class="kn">import</span> <span class="n">is_Cone</span>
<span class="gp">sage: </span><span class="n">is_Cone</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">quadrant</span> <span class="o">=</span> <span class="n">Cone</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">quadrant</span>
<span class="go">2-d cone in 2-d lattice N</span>
<span class="gp">sage: </span><span class="n">is_Cone</span><span class="p">(</span><span class="n">quadrant</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.cone.normalize_rays">
<code class="descclassname">sage.geometry.cone.</code><code class="descname">normalize_rays</code><span class="sig-paren">(</span><em>rays</em>, <em>lattice</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.normalize_rays" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize a list of rational rays: make them primitive and immutable.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">rays</span></code> – list of rays which can be converted to the rational
extension of <code class="docutils literal notranslate"><span class="pre">lattice</span></code>;</li>
<li><code class="docutils literal notranslate"><span class="pre">lattice</span></code> – <a class="reference internal" href="toric_lattice.html#sage.geometry.toric_lattice.ToricLatticeFactory" title="sage.geometry.toric_lattice.ToricLatticeFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">ToricLattice</span></code></a>, <span class="math notranslate nohighlight">\(\ZZ^n\)</span>, or any
other object that behaves like these. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, an attempt will
be made to determine an appropriate toric lattice automatically.</li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li>list of immutable primitive vectors of the <code class="docutils literal notranslate"><span class="pre">lattice</span></code> in the same
directions as original <code class="docutils literal notranslate"><span class="pre">rays</span></code>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.geometry.cone</span> <span class="kn">import</span> <span class="n">normalize_rays</span>
<span class="gp">sage: </span><span class="n">normalize_rays</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="o">/</span><span class="mi">3</span><span class="p">)],</span> <span class="bp">None</span><span class="p">)</span>
<span class="go">[N(0, 1), N(0, 1), N(3, 2), N(3, 14)]</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">ToricLattice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">normalize_rays</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="o">/</span><span class="mi">3</span><span class="p">)],</span> <span class="n">L</span><span class="o">.</span><span class="n">dual</span><span class="p">())</span>
<span class="go">[L*(0, 1), L*(0, 1), L*(3, 2), L*(3, 14)]</span>
<span class="gp">sage: </span><span class="n">ray_in_L</span> <span class="o">=</span> <span class="n">L</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">normalize_rays</span><span class="p">([</span><span class="n">ray_in_L</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="o">/</span><span class="mi">3</span><span class="p">)],</span> <span class="bp">None</span><span class="p">)</span>
<span class="go">[L(0, 1), L(0, 1), L(3, 2), L(3, 14)]</span>
<span class="gp">sage: </span><span class="n">normalize_rays</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="o">/</span><span class="mi">3</span><span class="p">)],</span> <span class="n">ZZ</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[(0, 1), (0, 1), (3, 2), (3, 14)]</span>
<span class="gp">sage: </span><span class="n">normalize_rays</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="o">/</span><span class="mi">3</span><span class="p">)],</span> <span class="n">ZZ</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">cannot convert (0, 1) to</span>
<span class="go">Vector space of dimension 3 over Rational Field!</span>
<span class="gp">sage: </span><span class="n">normalize_rays</span><span class="p">([],</span> <span class="n">ZZ</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.geometry.cone.random_cone">
<code class="descclassname">sage.geometry.cone.</code><code class="descname">random_cone</code><span class="sig-paren">(</span><em>lattice=None</em>, <em>min_ambient_dim=0</em>, <em>max_ambient_dim=None</em>, <em>min_rays=0</em>, <em>max_rays=None</em>, <em>strictly_convex=None</em>, <em>solid=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.geometry.cone.random_cone" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a random convex rational polyhedral cone.</p>
<p>Lower and upper bounds may be provided for both the dimension of the
ambient space and the number of generating rays of the cone. If a
lower bound is left unspecified, it defaults to zero. Unspecified
upper bounds will be chosen randomly, unless you set <code class="docutils literal notranslate"><span class="pre">solid</span></code>, in
which case they are chosen a little more wisely.</p>
<p>You may specify the ambient <code class="docutils literal notranslate"><span class="pre">lattice</span></code> for the returned cone. In
that case, the <code class="docutils literal notranslate"><span class="pre">min_ambient_dim</span></code> and <code class="docutils literal notranslate"><span class="pre">max_ambient_dim</span></code>
parameters are ignored.</p>
<p>You may also request that the returned cone be strictly convex (or
not). Likewise you may request that it be (non-)solid.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>If you request a large number of rays in a low-dimensional
space, you might be waiting for a while. For example, in three
dimensions, it is possible to obtain an octagon raised up to height
one (all z-coordinates equal to one). But in practice, we usually
generate the entire three-dimensional space with six rays before we
get to the eight rays needed for an octagon. We therefore have to
throw the cone out and start over from scratch. This process repeats
until we get lucky.</p>
<p>We also refrain from “adjusting” the min/max parameters given to
us when a (non-)strictly convex or (non-)solid cone is
requested. This means that it may take a long time to generate
such a cone if the parameters are chosen unwisely.</p>
<p class="last">For example, you may want to set <code class="docutils literal notranslate"><span class="pre">min_rays</span></code> close to
<code class="docutils literal notranslate"><span class="pre">min_ambient_dim</span></code> if you desire a solid cone. Or, if you desire a
non-strictly-convex cone, then they all contain at least two
generating rays. So that might be a good candidate for
<code class="docutils literal notranslate"><span class="pre">min_rays</span></code>.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">lattice</span></code> (default: random) – A <code class="docutils literal notranslate"><span class="pre">ToricLattice</span></code> object in
which the returned cone will live. By default a new lattice will
be constructed with a randomly-chosen rank (subject to
<code class="docutils literal notranslate"><span class="pre">min_ambient_dim</span></code> and <code class="docutils literal notranslate"><span class="pre">max_ambient_dim</span></code>).</li>
<li><code class="docutils literal notranslate"><span class="pre">min_ambient_dim</span></code> (default: zero) – A nonnegative integer
representing the minimum dimension of the ambient lattice.</li>
<li><code class="docutils literal notranslate"><span class="pre">max_ambient_dim</span></code> (default: random) – A nonnegative integer
representing the maximum dimension of the ambient lattice.</li>
<li><code class="docutils literal notranslate"><span class="pre">min_rays</span></code> (default: zero) – A nonnegative integer representing
the minimum number of generating rays of the cone.</li>
<li><code class="docutils literal notranslate"><span class="pre">max_rays</span></code> (default: random) – A nonnegative integer representing
the maximum number of generating rays of the cone.</li>
<li><code class="docutils literal notranslate"><span class="pre">strictly_convex</span></code> (default: random) – Whether or not to make the
returned cone strictly convex. Specify <code class="docutils literal notranslate"><span class="pre">True</span></code> for a strictly convex
cone, <code class="docutils literal notranslate"><span class="pre">False</span></code> for a non-strictly-convex cone, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if you
don’t care.</li>
<li><code class="docutils literal notranslate"><span class="pre">solid</span></code> (default: random) – Whether or not to make the returned
cone solid. Specify <code class="docutils literal notranslate"><span class="pre">True</span></code> for a solid cone, <code class="docutils literal notranslate"><span class="pre">False</span></code> for a
non-solid cone, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if you don’t care.</li>
</ul>
<p>OUTPUT:</p>
<p>A new, randomly generated cone.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> will be thrown under the following conditions:</p>
<ul class="simple">
<li>Any of <code class="docutils literal notranslate"><span class="pre">min_ambient_dim</span></code>, <code class="docutils literal notranslate"><span class="pre">max_ambient_dim</span></code>, <code class="docutils literal notranslate"><span class="pre">min_rays</span></code>, or
<code class="docutils literal notranslate"><span class="pre">max_rays</span></code> are negative.</li>
<li><code class="docutils literal notranslate"><span class="pre">max_ambient_dim</span></code> is less than <code class="docutils literal notranslate"><span class="pre">min_ambient_dim</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">max_rays</span></code> is less than <code class="docutils literal notranslate"><span class="pre">min_rays</span></code>.</li>
<li>Both <code class="docutils literal notranslate"><span class="pre">max_ambient_dim</span></code> and <code class="docutils literal notranslate"><span class="pre">lattice</span></code> are specified.</li>
<li><code class="docutils literal notranslate"><span class="pre">min_rays</span></code> is greater than four but <code class="docutils literal notranslate"><span class="pre">max_ambient_dim</span></code> is less than
three.</li>
<li><code class="docutils literal notranslate"><span class="pre">min_rays</span></code> is greater than four but <code class="docutils literal notranslate"><span class="pre">lattice</span></code> has dimension
less than three.</li>
<li><code class="docutils literal notranslate"><span class="pre">min_rays</span></code> is greater than two but <code class="docutils literal notranslate"><span class="pre">max_ambient_dim</span></code> is less than
two.</li>
<li><code class="docutils literal notranslate"><span class="pre">min_rays</span></code> is greater than two but <code class="docutils literal notranslate"><span class="pre">lattice</span></code> has dimension less
than two.</li>
<li><code class="docutils literal notranslate"><span class="pre">min_rays</span></code> is positive but <code class="docutils literal notranslate"><span class="pre">max_ambient_dim</span></code> is zero.</li>
<li><code class="docutils literal notranslate"><span class="pre">min_rays</span></code> is positive but <code class="docutils literal notranslate"><span class="pre">lattice</span></code> has dimension zero.</li>
<li>A trivial lattice is supplied and a non-strictly-convex cone
is requested.</li>
<li>A non-strictly-convex cone is requested but <code class="docutils literal notranslate"><span class="pre">max_rays</span></code> is less
than two.</li>
<li>A solid cone is requested but <code class="docutils literal notranslate"><span class="pre">max_rays</span></code> is less than
<code class="docutils literal notranslate"><span class="pre">min_ambient_dim</span></code>.</li>
<li>A solid cone is requested but <code class="docutils literal notranslate"><span class="pre">max_rays</span></code> is less than the
dimension of <code class="docutils literal notranslate"><span class="pre">lattice</span></code>.</li>
<li>A non-solid cone is requested but <code class="docutils literal notranslate"><span class="pre">max_ambient_dim</span></code> is zero.</li>
<li>A non-solid cone is requested but <code class="docutils literal notranslate"><span class="pre">lattice</span></code> has dimension zero.</li>
<li>A non-solid cone is requested but <code class="docutils literal notranslate"><span class="pre">min_rays</span></code> is so large that
it guarantees a solid cone.</li>
</ul>
<p>ALGORITHM:</p>
<p>First, a lattice is determined from <code class="docutils literal notranslate"><span class="pre">min_ambient_dim</span></code> and
<code class="docutils literal notranslate"><span class="pre">max_ambient_dim</span></code> (or from the supplied <code class="docutils literal notranslate"><span class="pre">lattice</span></code>).</p>
<p>Then, lattice elements are generated one at a time and added to a
cone. This continues until either the cone meets the user’s
requirements, or the cone is equal to the entire space (at which
point it is futile to generate more).</p>
<p>We check whether or not the resulting cone meets the user’s
requirements; if it does, it is returned. If not, we throw it away
and start over. This process repeats indefinitely until an
appropriate cone is generated.</p>
<p>EXAMPLES:</p>
<p>Generate a trivial cone in a trivial space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">random_cone</span><span class="p">(</span><span class="n">max_ambient_dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_rays</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0-d cone in 0-d lattice N</span>
</pre></div>
</div>
<p>We can predict the ambient dimension when
<code class="docutils literal notranslate"><span class="pre">min_ambient_dim</span> <span class="pre">==</span> <span class="pre">max_ambient_dim</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">random_cone</span><span class="p">(</span><span class="n">min_ambient_dim</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">max_ambient_dim</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">()</span>
<span class="go">4</span>
</pre></div>
</div>
<p>Likewise for the number of rays when <code class="docutils literal notranslate"><span class="pre">min_rays</span> <span class="pre">==</span> <span class="pre">max_rays</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">random_cone</span><span class="p">(</span><span class="n">min_rays</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_rays</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">nrays</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>If we specify a lattice, then the returned cone will live in it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">ToricLattice</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">random_cone</span><span class="p">(</span><span class="n">lattice</span><span class="o">=</span><span class="n">L</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">lattice</span><span class="p">()</span> <span class="ow">is</span> <span class="n">L</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can also request a strictly convex cone:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">random_cone</span><span class="p">(</span><span class="n">max_ambient_dim</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">max_rays</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="go">....:                 strictly_convex=True)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_strictly_convex</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Or one that isn’t strictly convex:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">random_cone</span><span class="p">(</span><span class="n">min_ambient_dim</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">min_rays</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="go">....:                 strictly_convex=False)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_strictly_convex</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>An example with all parameters set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">set_random_seed</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">random_cone</span><span class="p">(</span><span class="n">min_ambient_dim</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">max_ambient_dim</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
<span class="go">....:                 min_rays=2, max_rays=10,</span>
<span class="go">....:                 strictly_convex=False, solid=True)</span>
<span class="gp">sage: </span><span class="mi">4</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">()</span> <span class="ow">and</span> <span class="n">K</span><span class="o">.</span><span class="n">lattice_dim</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">7</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="o">.</span><span class="n">nrays</span><span class="p">()</span> <span class="ow">and</span> <span class="n">K</span><span class="o">.</span><span class="n">nrays</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">10</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_strictly_convex</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_solid</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="toric_lattice.html"
                        title="previous chapter">Toric lattices</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="fan.html"
                        title="next chapter">Rational polyhedral fans</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/geometry/cone.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="fan.html" title="Rational polyhedral fans"
             >next</a> |</li>
        <li class="right" >
          <a href="toric_lattice.html" title="Toric lattices"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Combinatorial and Discrete Geometry</a> &#187;</li>
 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2018, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>