
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Robinson-Schensted-Knuth correspondence &#8212; Combinatorics</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sage.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/thebelab.css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Schubert Polynomials" href="schubert_polynomial.html" />
    <link rel="prev" title="Rooted (Unordered) Trees" href="rooted_tree.html" />
  <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
  <!-- <script src="../../../_static/thebe.js" type="text/javascript"></script> -->
  <!-- <script src="../../../_static/thebe-sage.js" type="text/javascript"></script> -->

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="schubert_polynomial.html" title="Schubert Polynomials"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="rooted_tree.html" title="Rooted (Unordered) Trees"
             accesskey="P">previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="../../../_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../../../../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="../../../index.html">Reference Manual</a> &#187;
      
      <a href="../../index.html">Combinatorics</a> &#187;
    
  </li>

          <li class="nav-item nav-item-1"><a href="../../module_list.html" accesskey="U">Comprehensive Module List</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Robinson-Schensted-Knuth correspondence</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="robinson-schensted-knuth-correspondence">
<span id="sage-combinat-rsk"></span><h1>Robinson-Schensted-Knuth correspondence<a class="headerlink" href="#robinson-schensted-knuth-correspondence" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.rsk"></span><p>AUTHORS:</p>
<ul class="simple">
<li><p>Travis Scrimshaw (2012-12-07): Initial version</p></li>
<li><p>Chaman Agrawal (2019-06-24): Refactoring on the Rule class</p></li>
<li><p>Matthew Lancellotti (2018): initial version of super RSK</p></li>
<li><p>Jianping Pan, Wencin Poh, Anne Schilling (2020-08-31): initial version of RuleStar</p></li>
</ul>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The Robinson-Schensted-Knuth (RSK) correspondence is most naturally
stated as a bijection between generalized permutations (also known
as two-line arrays, biwords, …) and pairs of semi-standard Young
tableaux <span class="math notranslate nohighlight">\((P, Q)\)</span> of identical shape.</p>
<p>The basic operation in the RSK correspondence is a row insertion
<span class="math notranslate nohighlight">\(P \leftarrow k\)</span> (where <span class="math notranslate nohighlight">\(P\)</span> is a given semi-standard Young tableau,
and <span class="math notranslate nohighlight">\(k\)</span> is an integer). Different insertion algorithms have been
implemented for the RSK correspondence and can be specified as
an argument in the function call.</p>
<p>EXAMPLES:</p>
<p>We can perform RSK and its inverse map on a variety of objects:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">gp</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span> <span class="n">gp</span>
<span class="go">[[1, 2, 3, 3], [2, 1, 2, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="o">*</span><span class="n">gp</span><span class="p">)</span> <span class="c1"># RSK of a biword</span>
<span class="go">[[[1, 2, 2], [2]], [[1, 3, 3], [2]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="c1"># Robinson-Schensted of a word</span>
<span class="go">[[[1, 2, 2, 3], [2], [3]], [[1, 2, 5, 6], [3], [4]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">EG</span><span class="p">)</span> <span class="c1"># Edelman-Greene</span>
<span class="go">[[[1, 2, 3], [2, 3], [3]], [[1, 2, 6], [3, 5], [4]]]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">);</span> <span class="n">m</span> <span class="c1"># output as matrix</span>
<span class="go">[0 1]</span>
<span class="go">[1 0]</span>
<span class="go">[0 2]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="c1"># RSK of a matrix</span>
<span class="go">[[[1, 2, 2], [2]], [[1, 3, 3], [2]]]</span>
</pre></div>
</div>
<section id="insertions-currently-available">
<h3>Insertions currently available<a class="headerlink" href="#insertions-currently-available" title="Permalink to this headline">¶</a></h3>
<p>The following insertion algorithms for RSK correspondence are currently
available:</p>
<ul class="simple">
<li><p>RSK insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleRSK" title="sage.combinat.rsk.RuleRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleRSK</span></code></a>).</p></li>
<li><p>Edelman-Greene insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleEG" title="sage.combinat.rsk.RuleEG"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleEG</span></code></a>), an algorithm
defined in <a class="reference internal" href="#eg1987" id="id1"><span>[EG1987]</span></a> Definition 6.20 (where it is referred to as
Coxeter-Knuth insertion).</p></li>
<li><p>Hecke RSK algorithm (<a class="reference internal" href="#sage.combinat.rsk.RuleHecke" title="sage.combinat.rsk.RuleHecke"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleHecke</span></code></a>) , defined
using the Hecke insertion studied in <a class="reference internal" href="#bksty06" id="id2"><span>[BKSTY06]</span></a> (but using rows instead
of columns).</p></li>
<li><p>Dual RSK insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleDualRSK" title="sage.combinat.rsk.RuleDualRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleDualRSK</span></code></a>).</p></li>
<li><p>CoRSK insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleCoRSK" title="sage.combinat.rsk.RuleCoRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleCoRSK</span></code></a>), defined in
<a class="reference internal" href="#gr2018v5sol" id="id3"><span>[GR2018v5sol]</span></a>.</p></li>
<li><p>Super RSK insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK" title="sage.combinat.rsk.RuleSuperRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleSuperRSK</span></code></a>), a
combination of row and column insertions defined in <a class="reference internal" href="../../../references/index.html#muth2019" id="id4"><span>[Muth2019]</span></a>.</p></li>
<li><p>Star insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleStar" title="sage.combinat.rsk.RuleStar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleStar</span></code></a>), defined in <a class="reference internal" href="../../../references/index.html#mpps2020" id="id5"><span>[MPPS2020]</span></a>.</p></li>
</ul>
</section>
<section id="implementing-your-own-insertion-rule">
<h3>Implementing your own insertion rule<a class="headerlink" href="#implementing-your-own-insertion-rule" title="Permalink to this headline">¶</a></h3>
<p>The functions <a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a> and <a class="reference internal" href="#sage.combinat.rsk.RSK_inverse" title="sage.combinat.rsk.RSK_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK_inverse()</span></code></a> are written so that it
is easy to implement insertion algorithms you come across in your research.</p>
<p>To implement your own insertion algorithm, you first need to import the
base class for a rule:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">Rule</span>
</pre></div>
</div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">Rule</span></code> class as parent class for your insertion rule,
first implement the insertion and the reverse insertion algorithm
for <a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a> and <a class="reference internal" href="#sage.combinat.rsk.RSK_inverse" title="sage.combinat.rsk.RSK_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK_inverse()</span></code></a> respectively (as methods
<code class="docutils literal notranslate"><span class="pre">forward_rule</span></code> and <code class="docutils literal notranslate"><span class="pre">backward_rule</span></code>). If your insertion algorithm
uses the same forward and backward rules as <code class="docutils literal notranslate"><span class="pre">RuleRSK</span></code>, differing
only in how an entry is inserted into a row, then this is not
necessary, and it suffices to merely implement the
<code class="docutils literal notranslate"><span class="pre">insertion</span></code> and <code class="docutils literal notranslate"><span class="pre">reverse_insertion</span></code> methods.</p>
<p>For more information, see <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rule</span></code></a>.</p>
<p>REFERENCES:</p>
<dl class="citation">
<dt class="label" id="knu1970"><span class="brackets">Knu1970</span><span class="fn-backref">(<a href="#id6">1</a>,<a href="#id23">2</a>)</span></dt>
<dd><p>Donald E. Knuth.
<em>Permutations, matrices, and generalized Young tableaux</em>.
Pacific J. Math. Volume 34, Number 3 (1970), pp. 709-727.
<a class="reference external" href="http://projecteuclid.org/euclid.pjm/1102971948">http://projecteuclid.org/euclid.pjm/1102971948</a></p>
</dd>
<dt class="label" id="eg1987"><span class="brackets">EG1987</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id12">2</a>,<a href="#id13">3</a>,<a href="#id14">4</a>)</span></dt>
<dd><p>Paul Edelman, Curtis Greene.
<em>Balanced Tableaux</em>.
Advances in Mathematics 63 (1987), pp. 42-99.
<a class="reference external" href="https://doi.org/10.1016/0001-8708(87)90063-6">doi:10.1016/0001-8708(87)90063-6</a></p>
</dd>
<dt class="label" id="bksty06"><span class="brackets">BKSTY06</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id15">2</a>,<a href="#id16">3</a>)</span></dt>
<dd><p>A. Buch, A. Kresch, M. Shimozono, H. Tamvakis, and A. Yong.
<em>Stable Grothendieck polynomials and</em> <span class="math notranslate nohighlight">\(K\)</span>-<em>theoretic factor sequences</em>.
Math. Ann. <strong>340</strong> Issue 2, (2008), pp. 359–382.
<a class="reference external" href="https://arxiv.org/abs/math/0601514v1">arXiv math/0601514v1</a>.</p>
</dd>
<dt class="label" id="gr2018v5sol"><span class="brackets">GR2018v5sol</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id9">2</a>,<a href="#id11">3</a>)</span></dt>
<dd><p>Darij Grinberg, Victor Reiner.
<em>Hopf Algebras In Combinatorics</em>,
<a class="reference external" href="https://arxiv.org/abs/1409.8356v5">arXiv 1409.8356v5</a>, available with solutions at
<a class="reference external" href="https://arxiv.org/src/1409.8356v5/anc/HopfComb-v73-with-solutions.pdf">https://arxiv.org/src/1409.8356v5/anc/HopfComb-v73-with-solutions.pdf</a></p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.InsertionRules">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">InsertionRules</span></span><a class="headerlink" href="#sage.combinat.rsk.InsertionRules" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Catalog of rules for RSK-like insertion algorithms.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.rsk.InsertionRules.EG">
<span class="sig-name descname"><span class="pre">EG</span></span><a class="headerlink" href="#sage.combinat.rsk.InsertionRules.EG" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.rsk.RuleEG" title="sage.combinat.rsk.RuleEG"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleEG</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.rsk.InsertionRules.Hecke">
<span class="sig-name descname"><span class="pre">Hecke</span></span><a class="headerlink" href="#sage.combinat.rsk.InsertionRules.Hecke" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.rsk.RuleHecke" title="sage.combinat.rsk.RuleHecke"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleHecke</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.rsk.InsertionRules.RSK">
<span class="sig-name descname"><span class="pre">RSK</span></span><a class="headerlink" href="#sage.combinat.rsk.InsertionRules.RSK" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.rsk.RuleRSK" title="sage.combinat.rsk.RuleRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleRSK</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.rsk.InsertionRules.Star">
<span class="sig-name descname"><span class="pre">Star</span></span><a class="headerlink" href="#sage.combinat.rsk.InsertionRules.Star" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.rsk.RuleStar" title="sage.combinat.rsk.RuleStar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleStar</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.rsk.InsertionRules.coRSK">
<span class="sig-name descname"><span class="pre">coRSK</span></span><a class="headerlink" href="#sage.combinat.rsk.InsertionRules.coRSK" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.rsk.RuleCoRSK" title="sage.combinat.rsk.RuleCoRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleCoRSK</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.rsk.InsertionRules.dualRSK">
<span class="sig-name descname"><span class="pre">dualRSK</span></span><a class="headerlink" href="#sage.combinat.rsk.InsertionRules.dualRSK" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.rsk.RuleDualRSK" title="sage.combinat.rsk.RuleDualRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleDualRSK</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.rsk.InsertionRules.superRSK">
<span class="sig-name descname"><span class="pre">superRSK</span></span><a class="headerlink" href="#sage.combinat.rsk.InsertionRules.superRSK" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK" title="sage.combinat.rsk.RuleSuperRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleSuperRSK</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.rsk.RSK">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RSK</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">insertion=&lt;class</span> <span class="pre">'sage.combinat.rsk.RuleRSK'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_standard=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RSK" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the Robinson-Schensted-Knuth (RSK) correspondence.</p>
<p>The Robinson-Schensted-Knuth (RSK) correspondence (also known
as the RSK algorithm) is most naturally stated as a bijection
between generalized permutations (also known as two-line arrays,
biwords, …) and pairs of semi-standard Young tableaux <span class="math notranslate nohighlight">\((P, Q)\)</span>
of identical shape. The tableau <span class="math notranslate nohighlight">\(P\)</span> is known as the insertion
tableau, and <span class="math notranslate nohighlight">\(Q\)</span> is known as the recording tableau.</p>
<p>The basic operation is known as row insertion <span class="math notranslate nohighlight">\(P \leftarrow k\)</span>
(where <span class="math notranslate nohighlight">\(P\)</span> is a given semi-standard Young tableau, and <span class="math notranslate nohighlight">\(k\)</span> is an
integer). Row insertion is a recursive algorithm which starts by
setting <span class="math notranslate nohighlight">\(k_0 = k\)</span>, and in its <span class="math notranslate nohighlight">\(i\)</span>-th step inserts the number <span class="math notranslate nohighlight">\(k_i\)</span>
into the <span class="math notranslate nohighlight">\(i\)</span>-th row of <span class="math notranslate nohighlight">\(P\)</span> (we start counting the rows at <span class="math notranslate nohighlight">\(0\)</span>) by
replacing the first integer greater than <span class="math notranslate nohighlight">\(k_i\)</span> in the row by <span class="math notranslate nohighlight">\(k_i\)</span>
and defines <span class="math notranslate nohighlight">\(k_{i+1}\)</span> as the integer that has been replaced. If no
integer greater than <span class="math notranslate nohighlight">\(k_i\)</span> exists in the <span class="math notranslate nohighlight">\(i\)</span>-th row, then <span class="math notranslate nohighlight">\(k_i\)</span> is
simply appended to the row and the algorithm terminates at this point.</p>
<p>A <em>generalized permutation</em> (or <em>biword</em>) is a list
<span class="math notranslate nohighlight">\(((j_0, k_0), (j_1, k_1), \ldots, (j_{\ell-1}, k_{\ell-1}))\)</span>
of pairs such that the letters <span class="math notranslate nohighlight">\(j_0, j_1, \ldots, j_{\ell-1}\)</span>
are weakly increasing (that is,
<span class="math notranslate nohighlight">\(j_0 \leq j_1 \leq \cdots \leq j_{\ell-1}\)</span>), whereas the letters
<span class="math notranslate nohighlight">\(k_i\)</span> satisfy <span class="math notranslate nohighlight">\(k_i \leq k_{i+1}\)</span> whenever <span class="math notranslate nohighlight">\(j_i = j_{i+1}\)</span>.
The <span class="math notranslate nohighlight">\(\ell\)</span>-tuple <span class="math notranslate nohighlight">\((j_0, j_1, \ldots, j_{\ell-1})\)</span> is called the
<em>top line</em> of this generalized permutation,
whereas the <span class="math notranslate nohighlight">\(\ell\)</span>-tuple <span class="math notranslate nohighlight">\((k_0, k_1, \ldots, k_{\ell-1})\)</span> is
called its <em>bottom line</em>.</p>
<p>Now the RSK algorithm, applied to a generalized permutation
<span class="math notranslate nohighlight">\(p = ((j_0, k_0), (j_1, k_1), \ldots, (j_{\ell-1}, k_{\ell-1}))\)</span>
(encoded as a lexicographically sorted list of pairs) starts by
initializing two semi-standard tableaux <span class="math notranslate nohighlight">\(P_0\)</span> and <span class="math notranslate nohighlight">\(Q_0\)</span> as empty
tableaux. For each nonnegative integer <span class="math notranslate nohighlight">\(t\)</span> starting at <span class="math notranslate nohighlight">\(0\)</span>, take
the pair <span class="math notranslate nohighlight">\((j_t, k_t)\)</span> from <span class="math notranslate nohighlight">\(p\)</span> and set
<span class="math notranslate nohighlight">\(P_{t+1} = P_t \leftarrow k_t\)</span>, and define <span class="math notranslate nohighlight">\(Q_{t+1}\)</span> by adding a
new box filled with <span class="math notranslate nohighlight">\(j_t\)</span> to the tableau <span class="math notranslate nohighlight">\(Q_t\)</span> at the same
location the row insertion on <span class="math notranslate nohighlight">\(P_t\)</span> ended (that is to say, adding
a new box with entry <span class="math notranslate nohighlight">\(j_t\)</span> such that <span class="math notranslate nohighlight">\(P_{t+1}\)</span> and <span class="math notranslate nohighlight">\(Q_{t+1}\)</span> have
the same shape). The iterative process stops when <span class="math notranslate nohighlight">\(t\)</span> reaches the
size of <span class="math notranslate nohighlight">\(p\)</span>, and the pair <span class="math notranslate nohighlight">\((P_t, Q_t)\)</span> at this point is the image
of <span class="math notranslate nohighlight">\(p\)</span> under the Robinson-Schensted-Knuth correspondence.</p>
<p>This correspondence has been introduced in <a class="reference internal" href="#knu1970" id="id6"><span>[Knu1970]</span></a>, where it has
been referred to as “Construction A”.</p>
<p>For more information, see Chapter 7 in <a class="reference internal" href="dyck_word.html#sta-ec2" id="id7"><span>[Sta-EC2]</span></a>.</p>
<p>We also note that integer matrices are in bijection with generalized
permutations. Furthermore, we can convert any word <span class="math notranslate nohighlight">\(w\)</span> (and, in
particular, any permutation) to a generalized permutation by
considering the top row to be <span class="math notranslate nohighlight">\((1, 2, \ldots, n)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the
length of <span class="math notranslate nohighlight">\(w\)</span>.</p>
<p>The optional argument <code class="docutils literal notranslate"><span class="pre">insertion</span></code> allows to specify an alternative
insertion procedure to be used instead of the standard
Robinson-Schensted-Knuth insertion.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – can be one of the following:</p>
<ul>
<li><p>a word in an ordered alphabet (in this case, <code class="docutils literal notranslate"><span class="pre">obj1</span></code> is said
word, and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p>an integer matrix</p></li>
<li><p>two lists of equal length representing a generalized permutation
(namely, the lists <span class="math notranslate nohighlight">\((j_0, j_1, \ldots, j_{\ell-1})\)</span> and
<span class="math notranslate nohighlight">\((k_0, k_1, \ldots, k_{\ell-1})\)</span> represent the generalized
permutation
<span class="math notranslate nohighlight">\(((j_0, k_0), (j_1, k_1), \ldots, (j_{\ell-1}, k_{\ell-1}))\)</span>)</p></li>
<li><p>any object which has a method <code class="docutils literal notranslate"><span class="pre">_rsk_iter()</span></code> which returns an
iterator over the object represented as generalized permutation or
a pair of lists (in this case, <code class="docutils literal notranslate"><span class="pre">obj1</span></code> is said object,
and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">insertion</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">RSK.rules.RSK</span></code>) the following types
of insertion are currently supported:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.RSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'RSK'</span></code>) – Robinson-Schensted-Knuth
insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleRSK" title="sage.combinat.rsk.RuleRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.EG</span></code> (or <code class="docutils literal notranslate"><span class="pre">'EG'</span></code>) – Edelman-Greene insertion
(only for reduced words of permutations/elements of a type <span class="math notranslate nohighlight">\(A\)</span>
Coxeter group) (<a class="reference internal" href="#sage.combinat.rsk.RuleEG" title="sage.combinat.rsk.RuleEG"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleEG</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.Hecke</span></code> (or <code class="docutils literal notranslate"><span class="pre">'hecke'</span></code>) – Hecke insertion (only
guaranteed for generalized permutations whose top row is strictly
increasing) (<a class="reference internal" href="#sage.combinat.rsk.RuleHecke" title="sage.combinat.rsk.RuleHecke"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleHecke</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.dualRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'dualRSK'</span></code>) – Dual RSK insertion
(only for strict biwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleDualRSK" title="sage.combinat.rsk.RuleDualRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleDualRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.coRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'coRSK'</span></code>) – CoRSK insertion (only
for strict cobiwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleCoRSK" title="sage.combinat.rsk.RuleCoRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleCoRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.superRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'super'</span></code>) – Super RSK insertion (only for
restricted super biwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK" title="sage.combinat.rsk.RuleSuperRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleSuperRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.Star</span></code> (or <code class="docutils literal notranslate"><span class="pre">'Star'</span></code>) – <span class="math notranslate nohighlight">\(\star\)</span>-insertion (only for
fully commutative words in the 0-Hecke monoid)
(<a class="reference internal" href="#sage.combinat.rsk.RuleStar" title="sage.combinat.rsk.RuleStar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleStar</span></code></a>)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_standard</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) check if either of the
resulting tableaux is a standard tableau, and if so, typecast it
as such</p></li>
</ul>
<p>For precise information about constraints on the input and output,
as well as the definition of the algorithm (if it is not standard
RSK), see the particular <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rule</span></code></a> class.</p>
<p>EXAMPLES:</p>
<p>If we only input one row, it is understood that the top row
should be <span class="math notranslate nohighlight">\((1, 2, \ldots, n)\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[[[1, 3, 4], [2], [3]], [[1, 2, 4], [3], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">[[[1, 3, 4], [2], [3]], [[1, 2, 4], [3], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">[[[1, 2, 2, 3, 3], [2, 3], [3]], [[1, 2, 3, 6, 8], [4, 7], [5]]]</span>
</pre></div>
</div>
<p>We can provide a generalized permutation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">[[[1, 1, 2], [2]], [[1, 2, 2], [2]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">[[[1, 1, 3], [2], [4]], [[1, 1, 4], [3], [4]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">Word</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">]))</span>
<span class="go">[[[1, 2, 7], [2], [6]], [[1, 3, 4], [3], [4]]]</span>
</pre></div>
</div>
<p>We can provide a matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]))</span>
<span class="go">[[[1, 1, 2], [2]], [[1, 2, 2], [2]]]</span>
</pre></div>
</div>
<p>We can also provide something looking like a matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="go">[[[1, 1, 2], [2]], [[1, 2, 2], [2]]]</span>
</pre></div>
</div>
<p>There is also <a class="reference internal" href="#sage.combinat.rsk.RSK_inverse" title="sage.combinat.rsk.RSK_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK_inverse()</span></code></a> which performs
the inverse of the bijection on a pair of semistandard tableaux. We
note that the inverse function takes 2 separate tableaux as inputs, so
to compose with <a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a>, we need to use the
python <code class="docutils literal notranslate"><span class="pre">*</span></code> on the output:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[[1, 2, 2, 2], [2, 1, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
<span class="go">[[1, 2, 2, 2], [2, 1, 1, 2]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.rsk.RSK_inverse">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RSK_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output='array'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">insertion=&lt;class</span> <span class="pre">'sage.combinat.rsk.RuleRSK'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RSK_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the generalized permutation corresponding to the pair of
tableaux <span class="math notranslate nohighlight">\((p, q)\)</span> under the inverse of the Robinson-Schensted-Knuth
correspondence.</p>
<p>For more information on the bijection, see <a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code> – two semi-standard tableaux of the same shape, or
(in the case when Hecke insertion is used) an increasing tableau and
a set-valued tableau of the same shape (see the note below for the
format of the set-valued tableau)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'array'</span></code>) if <code class="docutils literal notranslate"><span class="pre">q</span></code> is semi-standard:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'array'</span></code> – as a two-line array (i.e. generalized permutation or
biword)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'matrix'</span></code> – as an integer matrix</p></li>
</ul>
<p>and if <code class="docutils literal notranslate"><span class="pre">q</span></code> is standard, we can also have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'word'</span></code> – as a word</p></li>
</ul>
<p>and additionally if <code class="docutils literal notranslate"><span class="pre">p</span></code> is standard, we can also have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'permutation'</span></code> – as a permutation</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">insertion</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">RSK.rules.RSK</span></code>) the insertion algorithm
used in the bijection. Currently the following are supported:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.RSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'RSK'</span></code>) – Robinson-Schensted-Knuth
insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleRSK" title="sage.combinat.rsk.RuleRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.EG</span></code> (or <code class="docutils literal notranslate"><span class="pre">'EG'</span></code>) – Edelman-Greene insertion
(only for reduced words of permutations/elements of a type <span class="math notranslate nohighlight">\(A\)</span>
Coxeter group) (<a class="reference internal" href="#sage.combinat.rsk.RuleEG" title="sage.combinat.rsk.RuleEG"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleEG</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.Hecke</span></code> (or <code class="docutils literal notranslate"><span class="pre">'hecke'</span></code>) – Hecke insertion (only
guaranteed for generalized permutations whose top row is strictly
increasing) (<a class="reference internal" href="#sage.combinat.rsk.RuleHecke" title="sage.combinat.rsk.RuleHecke"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleHecke</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.dualRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'dualRSK'</span></code>) – Dual RSK insertion
(only for strict biwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleDualRSK" title="sage.combinat.rsk.RuleDualRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleDualRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.coRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'coRSK'</span></code>) – CoRSK insertion (only
for strict cobiwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleCoRSK" title="sage.combinat.rsk.RuleCoRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleCoRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.superRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'super'</span></code>) – Super RSK insertion (only for
restricted super biwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK" title="sage.combinat.rsk.RuleSuperRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleSuperRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.Star</span></code> (or <code class="docutils literal notranslate"><span class="pre">'Star'</span></code>) – <span class="math notranslate nohighlight">\(\star\)</span>-insertion (only for
fully commutative words in the 0-Hecke monoid)
(<a class="reference internal" href="#sage.combinat.rsk.RuleStar" title="sage.combinat.rsk.RuleStar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleStar</span></code></a>)</p></li>
</ul>
</li>
</ul>
<p>For precise information about constraints on the input and
output, see the particular <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rule</span></code></a> class.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the case of Hecke insertion, the input variable <code class="docutils literal notranslate"><span class="pre">q</span></code> should
be a set-valued tableau, encoded as a tableau whose entries are
strictly increasing tuples of positive integers. Each such tuple
encodes the set of its entries.</p>
</div>
<p>EXAMPLES:</p>
<p>If both <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> are standard:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [1, 4, 5, 3, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">)</span>
<span class="go">word: 14532</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">)</span>
<span class="go">[1 0 0 0 0]</span>
<span class="go">[0 0 0 1 0]</span>
<span class="go">[0 0 0 0 1]</span>
<span class="go">[0 0 1 0 0]</span>
<span class="go">[0 1 0 0 0]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">)</span>
<span class="go">[1, 4, 5, 3, 2]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">)</span>
<span class="go">[1, 4, 3, 2, 5]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">)</span>
<span class="go">[1, 2, 5, 4, 3]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">)</span>
<span class="go">[1, 5, 4, 2, 3]</span>
</pre></div>
</div>
<p>If the first tableau is semistandard:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">ret</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span> <span class="n">ret</span>
<span class="go">[[1, 2, 3, 4], [1, 3, 2, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">)</span>
<span class="go">word: 1322</span>
</pre></div>
</div>
<p>In general:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 3], [2, 1, 2, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">)</span>
<span class="go">[0 1]</span>
<span class="go">[1 0]</span>
<span class="go">[0 2]</span>
</pre></div>
</div>
<p>Using Hecke insertion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">pq</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Hecke</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">pq</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Hecke</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;list&#39;</span><span class="p">)</span>
<span class="go">[5, 4, 3, 1, 4, 2, 5, 5]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The constructor of <code class="docutils literal notranslate"><span class="pre">Tableau</span></code> accepts not only semistandard
tableaux, but also arbitrary lists that are fillings of a
partition diagram. (And such lists are used, e.g., for the
set-valued tableau <code class="docutils literal notranslate"><span class="pre">q</span></code> that is passed to
<code class="docutils literal notranslate"><span class="pre">RSK_inverse(p,</span> <span class="pre">q,</span> <span class="pre">insertion='hecke')</span></code>.)
The user is responsible for ensuring that the tableaux passed to
<code class="docutils literal notranslate"><span class="pre">RSK_inverse</span></code> are of the right types (semistandard, standard,
increasing, set-valued as needed).</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.Rule">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">Rule</span></span><a class="headerlink" href="#sage.combinat.rsk.Rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></code></a></p>
<p>Generic base class for an insertion rule for an RSK-type correspondence.</p>
<p>An instance of this class should implement a method
<code class="xref py py-meth docutils literal notranslate"><span class="pre">insertion()</span></code> (which can be applied to a letter <code class="docutils literal notranslate"><span class="pre">j</span></code>
and a list <code class="docutils literal notranslate"><span class="pre">r</span></code>, and modifies <code class="docutils literal notranslate"><span class="pre">r</span></code> in place by “bumping”
<code class="docutils literal notranslate"><span class="pre">j</span></code> into it appropriately; it then returns the bumped-out
entry or <code class="docutils literal notranslate"><span class="pre">None</span></code> if no such entry exists) and a method
<code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse_insertion()</span></code> (which does the same but for reverse
bumping).
It may also implement <code class="xref py py-meth docutils literal notranslate"><span class="pre">_backward_format_output()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">_forward_format_output()</span></code> if the RSK correspondence should
return something other than (semi)standard tableaux (in the
forward direction) and matrices or biwords (in the backward
direction).
The <a class="reference internal" href="#sage.combinat.rsk.Rule.to_pairs" title="sage.combinat.rsk.Rule.to_pairs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_pairs()</span></code></a> method should also be overridden if
the input for the (forward) RSK correspondence is not the
usual kind of biwords (i.e., pairs of two <span class="math notranslate nohighlight">\(n\)</span>-tuples
<span class="math notranslate nohighlight">\([a_1, a_2, \ldots, a_n]\)</span> and <span class="math notranslate nohighlight">\([b_1, b_2, \ldots, b_n]\)</span>
satisfying <span class="math notranslate nohighlight">\((a_1, b_1) \leq (a_2, b_2) \leq \cdots
\leq (a_n, b_n)\)</span> in lexicographic order).
Finally, it <a class="reference internal" href="#sage.combinat.rsk.Rule.forward_rule" title="sage.combinat.rsk.Rule.forward_rule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">forward_rule()</span></code></a> and <a class="reference internal" href="#sage.combinat.rsk.Rule.backward_rule" title="sage.combinat.rsk.Rule.backward_rule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">backward_rule()</span></code></a>
have to be overridden if the overall structure of the
RSK correspondence differs from that of classical RSK (see,
e.g., the case of Hecke insertion, in which a letter bumped
into a row may change a different row).</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.Rule.backward_rule">
<span class="sig-name descname"><span class="pre">backward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.Rule.backward_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the generalized permutation obtained by applying reverse
insertion to a pair of tableaux <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">q)</span></code>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code> – two tableaux of the same shape.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'array'</span></code>) if <code class="docutils literal notranslate"><span class="pre">q</span></code> is semi-standard:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'array'</span></code> – as a two-line array (i.e. generalized permutation
or biword)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'matrix'</span></code> – as an integer matrix</p></li>
</ul>
<p>and if <code class="docutils literal notranslate"><span class="pre">q</span></code> is standard, we can also have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'word'</span></code> – as a word</p></li>
</ul>
<p>and additionally if <code class="docutils literal notranslate"><span class="pre">p</span></code> is standard, we can also have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'permutation'</span></code> – as a permutation</p></li>
</ul>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleRSK</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [3, 3, 2, 4, 1]]</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [1, 1, 1, 3, 7]]</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [7, 6, 3, 3, 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.Rule.forward_rule">
<span class="sig-name descname"><span class="pre">forward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_standard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.Rule.forward_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pair of tableaux obtained by applying forward
insertion to the generalized permutation <code class="docutils literal notranslate"><span class="pre">[obj1,</span> <span class="pre">obj2]</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – can be one of the following ways to
represent a generalized permutation (or, equivalently,
biword):</p>
<ul>
<li><p>two lists <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> of equal length,
to be interpreted as the top row and the bottom row of
the biword</p></li>
<li><p>a matrix <code class="docutils literal notranslate"><span class="pre">obj1</span></code> of nonnegative integers, to be
interpreted as the generalized permutation in matrix
form (in this case, <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p>a word <code class="docutils literal notranslate"><span class="pre">obj1</span></code> in an ordered alphabet, to be
interpreted as the bottom row of the biword (in this
case, <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>; the top row of the biword
is understood to be <span class="math notranslate nohighlight">\((1, 2, \ldots, n)\)</span> by default)</p></li>
<li><p>any object <code class="docutils literal notranslate"><span class="pre">obj1</span></code> which has a method <code class="docutils literal notranslate"><span class="pre">_rsk_iter()</span></code>,
as long as this method returns an iterator yielding
pairs of numbers, which then are interperted as top
entries and bottom entries in the biword (in this case,
<code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_standard</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) check if either of the
resulting tableaux is a standard tableau, and if so, typecast it
as such</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) whether to check
that <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> actually define a valid
biword</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleRSK</span>
<span class="gp">sage: </span><span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">[[[1, 3, 4], [2], [3]], [[1, 2, 4], [3], [5]]]</span>
<span class="gp">sage: </span><span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">[[[1, 1, 1, 3, 7]], [[1, 2, 3, 4, 5]]]</span>
<span class="gp">sage: </span><span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">)</span>
<span class="go">[[[1, 3], [3], [6], [7]], [[1, 4], [2], [3], [5]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.Rule.to_pairs">
<span class="sig-name descname"><span class="pre">to_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.Rule.to_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a valid input for the RSK algorithm, such as
two <span class="math notranslate nohighlight">\(n\)</span>-tuples <code class="docutils literal notranslate"><span class="pre">obj1</span></code> <span class="math notranslate nohighlight">\(= [a_1, a_2, \ldots, a_n]\)</span>
and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> <span class="math notranslate nohighlight">\(= [b_1, b_2, \ldots, b_n]\)</span> forming a biword
(i.e., satisfying
<span class="math notranslate nohighlight">\(a_1 \leq a_2 \leq \cdots \leq a_n\)</span>, and if
<span class="math notranslate nohighlight">\(a_i = a_{i+1}\)</span>, then <span class="math notranslate nohighlight">\(b_i \leq b_{i+1}\)</span>),
or a matrix (“generalized permutation”), or a single word,
return the array
<span class="math notranslate nohighlight">\([(a_1, b_1), (a_2, b_2), \ldots, (a_n, b_n)]\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – anything representing a biword
(see the doc of <a class="reference internal" href="#sage.combinat.rsk.Rule.forward_rule" title="sage.combinat.rsk.Rule.forward_rule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">forward_rule()</span></code></a> for the
encodings accepted).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) whether to check
that <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> actually define a valid
biword.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">Rule</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Rule</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[(1, 2), (2, 1), (2, 1), (2, 2)]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="p">;</span> <span class="n">m</span>
<span class="go">[0 1]</span>
<span class="go">[1 0]</span>
<span class="go">[0 2]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">Rule</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
<span class="go">[(1, 2), (2, 1), (3, 2), (3, 2)]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleCoRSK">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RuleCoRSK</span></span><a class="headerlink" href="#sage.combinat.rsk.RuleCoRSK" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.rsk.RuleRSK" title="sage.combinat.rsk.RuleRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.rsk.RuleRSK</span></code></a></p>
<p>Rule for coRSK insertion.</p>
<p>CoRSK insertion differs from classical RSK insertion in the
following ways:</p>
<ul class="simple">
<li><p>The input (in terms of biwords) is no longer a biword,
but rather a strict cobiword – i.e., a pair of two lists
<span class="math notranslate nohighlight">\([a_1, a_2, \ldots, a_n]\)</span> and <span class="math notranslate nohighlight">\([b_1, b_2, \ldots, b_n]\)</span> that
satisfy the strict inequalities
<span class="math notranslate nohighlight">\((a_1, b_1) \widetilde{&lt;} (a_2, b_2) \widetilde{&lt;} \cdots
\widetilde{&lt;} (a_n, b_n)\)</span>, where
the binary relation <span class="math notranslate nohighlight">\(\widetilde{&lt;}\)</span> on pairs of integers
is defined by having <span class="math notranslate nohighlight">\((u_1, v_1) \widetilde{&lt;} (u_2, v_2)\)</span>
if and only if either <span class="math notranslate nohighlight">\(u_1 &lt; u_2\)</span> or (<span class="math notranslate nohighlight">\(u_1 = u_2\)</span> and
<span class="math notranslate nohighlight">\(v_1 &gt; v_2\)</span>).
In terms of matrices, this means that the input is not an
arbitrary matrix with nonnegative integer entries, but rather
a <span class="math notranslate nohighlight">\(\{0, 1\}\)</span>-matrix (i.e., a matrix whose entries are <span class="math notranslate nohighlight">\(0\)</span>’s
and <span class="math notranslate nohighlight">\(1\)</span>’s).</p></li>
<li><p>The output still consists of two tableaux <span class="math notranslate nohighlight">\((P, Q)\)</span> of equal
shapes, but rather than both of them being semistandard, now
<span class="math notranslate nohighlight">\(Q\)</span> is row-strict (i.e., its transpose is semistandard) while
<span class="math notranslate nohighlight">\(P\)</span> is semistandard.</p></li>
</ul>
<p>Bumping proceeds in the same way as for RSK insertion.</p>
<p>The RSK and coRSK algorithms agree for permutation matrices.</p>
<p>For more information, see Section A.4 in <a class="reference internal" href="../../../references/index.html#ful1997" id="id8"><span>[Ful1997]</span></a> (specifically,
construction (1d)) or the second solution to Exercise 2.7.12(a) in
<a class="reference internal" href="#gr2018v5sol" id="id9"><span>[GR2018v5sol]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">insertion</span> <span class="o">=</span> <span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[[1, 1, 3], [2], [5]], [[1, 2, 3], [4], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">insertion</span> <span class="o">=</span> <span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[[1, 2, 2, 3, 3], [2, 3], [3]], [[1, 2, 3, 6, 8], [4, 7], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">insertion</span> <span class="o">=</span> <span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[[1, 3, 4], [2], [3]], [[1, 2, 4], [3], [5]]]</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">to_matrix</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">to_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">insertion</span> <span class="o">=</span> <span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], [2], [3]], [[1, 3, 4], [1], [3]]]</span>
</pre></div>
</div>
<p>Using coRSK insertion with a <span class="math notranslate nohighlight">\(\{0, 1\}\)</span>-matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">insertion</span> <span class="o">=</span> <span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[[1], [2]], [[1], [2]]]</span>
</pre></div>
</div>
<p>We can also give it something looking like a matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">insertion</span> <span class="o">=</span> <span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[[1], [2]], [[1], [2]]]</span>
</pre></div>
</div>
<p>We can also use the inverse correspondence:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">....: </span>        <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">),</span><span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 2, 2], [2, 3, 2, 1]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span><span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 2, 2], [2, 3, 2, 1]]</span>
</pre></div>
</div>
<p>When applied to two standard tableaux, backwards coRSK
insertion behaves identically to the usual backwards RSK
insertion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [1, 4, 5, 3, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">word: 14532</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[1 0 0 0 0]</span>
<span class="go">[0 0 0 1 0]</span>
<span class="go">[0 0 0 0 1]</span>
<span class="go">[0 0 1 0 0]</span>
<span class="go">[0 1 0 0 0]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[1, 4, 5, 3, 2]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[1, 4, 3, 2, 5]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[1, 2, 5, 4, 3]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">[1, 5, 4, 2, 3]</span>
</pre></div>
</div>
<p>For coRSK, the first tableau is semistandard while the second tableau
is transpose semistandard:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">5</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">ret</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">);</span> <span class="n">ret</span>
<span class="go">[[1, 2, 3, 4], [1, 5, 2, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">coRSK</span><span class="p">)</span>
<span class="go">word: 1522</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleCoRSK.backward_rule">
<span class="sig-name descname"><span class="pre">backward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleCoRSK.backward_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the strict cobiword obtained by applying reverse
coRSK insertion to a pair of tableaux <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">q)</span></code>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code> – two tableaux of the same shape</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'array'</span></code>) if <code class="docutils literal notranslate"><span class="pre">q</span></code> is row-strict:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'array'</span></code> – as a two-line array (i.e. strict cobiword)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'matrix'</span></code> – as a <span class="math notranslate nohighlight">\(\{0, 1\}\)</span>-matrix</p></li>
</ul>
<p>and if <code class="docutils literal notranslate"><span class="pre">q</span></code> is standard, we can have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'word'</span></code> – as a word</p></li>
</ul>
<p>and additionally if <code class="docutils literal notranslate"><span class="pre">p</span></code> is standard, we can also have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'permutation'</span></code> – as a permutation</p></li>
</ul>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleCoRSK</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RuleCoRSK</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="go">[[1, 1, 2, 4, 4, 5], [4, 2, 1, 3, 1, 2]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleCoRSK.to_pairs">
<span class="sig-name descname"><span class="pre">to_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleCoRSK.to_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a valid input for the coRSK algorithm, such as
two <span class="math notranslate nohighlight">\(n\)</span>-tuples <code class="docutils literal notranslate"><span class="pre">obj1</span></code> <span class="math notranslate nohighlight">\(= [a_1, a_2, \ldots, a_n]\)</span>
and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> <span class="math notranslate nohighlight">\(= [b_1, b_2, \ldots, b_n]\)</span> forming a
strict cobiword (i.e., satisfying
<span class="math notranslate nohighlight">\(a_1 \leq a_2 \leq \cdots \leq a_n\)</span>, and if
<span class="math notranslate nohighlight">\(a_i = a_{i+1}\)</span>, then <span class="math notranslate nohighlight">\(b_i &gt; b_{i+1}\)</span>),
or a <span class="math notranslate nohighlight">\(\{0, 1\}\)</span>-matrix (“rook placement”), or a
single word, return the array
<span class="math notranslate nohighlight">\([(a_1, b_1), (a_2, b_2), \ldots, (a_n, b_n)]\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – anything representing a strict
cobiword (see the doc of <code class="xref py py-meth docutils literal notranslate"><span class="pre">forward_rule()</span></code> for
the encodings accepted)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) whether to check
that <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> actually define a valid
strict cobiword</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleCoRSK</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">RuleCoRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">[(1, 2), (2, 3), (2, 2), (2, 1)]</span>
<span class="gp">sage: </span><span class="n">RuleCoRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: invalid strict cobiword</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">;</span> <span class="n">m</span>
<span class="go">[0 1]</span>
<span class="go">[1 1]</span>
<span class="go">[0 1]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">RuleCoRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
<span class="go">[(1, 2), (2, 2), (2, 1), (3, 2)]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="p">;</span> <span class="n">m</span>
<span class="go">[0 1]</span>
<span class="go">[1 0]</span>
<span class="go">[0 2]</span>
<span class="gp">sage: </span><span class="n">RuleCoRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: coRSK requires a {0, 1}-matrix</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleDualRSK">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RuleDualRSK</span></span><a class="headerlink" href="#sage.combinat.rsk.RuleDualRSK" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.rsk.Rule</span></code></a></p>
<p>Rule for dual RSK insertion.</p>
<p>Dual RSK insertion differs from classical RSK insertion in the
following ways:</p>
<ul class="simple">
<li><p>The input (in terms of biwords) is no longer an arbitrary biword,
but rather a strict biword (i.e., a pair of two lists
<span class="math notranslate nohighlight">\([a_1, a_2, \ldots, a_n]\)</span> and <span class="math notranslate nohighlight">\([b_1, b_2, \ldots, b_n]\)</span> that
satisfy the strict inequalities
<span class="math notranslate nohighlight">\((a_1, b_1) &lt; (a_2, b_2) &lt; \cdots &lt; (a_n, b_n)\)</span> in
lexicographic order).
In terms of matrices, this means that the input is not an
arbitrary matrix with nonnegative integer entries, but rather
a <span class="math notranslate nohighlight">\(\{0, 1\}\)</span>-matrix (i.e., a matrix whose entries are <span class="math notranslate nohighlight">\(0\)</span>’s
and <span class="math notranslate nohighlight">\(1\)</span>’s).</p></li>
<li><p>The output still consists of two tableaux <span class="math notranslate nohighlight">\((P, Q)\)</span> of equal
shapes, but rather than both of them being semistandard, now
<span class="math notranslate nohighlight">\(P\)</span> is row-strict (i.e., its transpose is semistandard) while
<span class="math notranslate nohighlight">\(Q\)</span> is semistandard.</p></li>
<li><p>The main difference is in the way bumping works. Namely,
when a number <span class="math notranslate nohighlight">\(k_i\)</span> is inserted into the <span class="math notranslate nohighlight">\(i\)</span>-th row of <span class="math notranslate nohighlight">\(P\)</span>,
it bumps out the first integer greater <strong>or equal to</strong> <span class="math notranslate nohighlight">\(k_i\)</span>
in this row (rather than greater than <span class="math notranslate nohighlight">\(k_i\)</span>).</p></li>
</ul>
<p>The RSK and dual RSK algorithms agree for permutation matrices.</p>
<p>For more information, see Chapter 7, Section 14 in <a class="reference internal" href="dyck_word.html#sta-ec2" id="id10"><span>[Sta-EC2]</span></a>
(where dual RSK is called <span class="math notranslate nohighlight">\(\mathrm{RSK}^{\ast}\)</span>) or the third
solution to Exercise 2.7.12(a) in <a class="reference internal" href="#gr2018v5sol" id="id11"><span>[GR2018v5sol]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 4], [2], [3], [3]], [[1, 4], [2], [3], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 4], [2], [3], [3]], [[1, 4], [2], [3], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], [2, 3], [2, 3], [3]], [[1, 2, 8], [3, 6], [4, 7], [5]]]</span>
</pre></div>
</div>
<p>Using dual RSK insertion with a strict biword:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 2], [1, 3], [2, 4]], [[1, 1], [2, 4], [4, 5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], [1, 2], [3], [3]], [[1, 1, 3], [2, 4], [3], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 2, 4], [2]], [[1, 2, 2], [2]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], [1], [4]], [[1, 1, 4], [3], [4]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">Word</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">]),</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 2, 7], [1], [6]], [[1, 3, 4], [3], [4]]]</span>
</pre></div>
</div>
<p>Using dual RSK insertion with a <span class="math notranslate nohighlight">\(\{0, 1\}\)</span>-matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 2], [2]], [[1, 2], [2]]]</span>
</pre></div>
</div>
<p>We can also give it something looking like a matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[[1, 2], [2]], [[1, 2], [2]]]</span>
</pre></div>
</div>
<p>Let us now call the inverse correspondence:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>        <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">),</span><span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 2, 2], [2, 1, 2, 3]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 2, 2], [2, 1, 2, 3]]</span>
</pre></div>
</div>
<p>When applied to two standard tableaux, reverse dual RSK
insertion behaves identically to the usual reverse RSK insertion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [1, 4, 5, 3, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">word: 14532</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[1 0 0 0 0]</span>
<span class="go">[0 0 0 1 0]</span>
<span class="go">[0 0 0 0 1]</span>
<span class="go">[0 0 1 0 0]</span>
<span class="go">[0 1 0 0 0]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[1, 4, 5, 3, 2]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[1, 4, 3, 2, 5]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[1, 2, 5, 4, 3]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[1, 5, 4, 2, 3]</span>
</pre></div>
</div>
<p>Let us check that forward and backward dual RSK are mutually
inverse when the first tableau is merely transpose semistandard:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">ret</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">);</span> <span class="n">ret</span>
<span class="go">[[1, 2, 3, 4], [1, 2, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">word: 1212</span>
</pre></div>
</div>
<p>In general for dual RSK:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 3], [1, 1, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">dualRSK</span><span class="p">)</span>
<span class="go">[1 0]</span>
<span class="go">[1 0]</span>
<span class="go">[1 1]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleDualRSK.insertion">
<span class="sig-name descname"><span class="pre">insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleDualRSK.insertion" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert the letter <code class="docutils literal notranslate"><span class="pre">j</span></code> from the second row of the biword
into the row <span class="math notranslate nohighlight">\(r\)</span> using dual RSK insertion, if there is
bumping to be done.</p>
<p>The row <span class="math notranslate nohighlight">\(r\)</span> is modified in place if bumping occurs. The bumped-out
entry, if it exists, is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleDualRSK</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">j</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">[1, 3, 4, 5]</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">j</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">[1, 2, 3, 4, 7]</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">r</span>
<span class="go">[1, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleDualRSK.reverse_insertion">
<span class="sig-name descname"><span class="pre">reverse_insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleDualRSK.reverse_insertion" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse bump the row <code class="docutils literal notranslate"><span class="pre">row</span></code> of the current insertion tableau
with the number <code class="docutils literal notranslate"><span class="pre">x</span></code> using dual RSK insertion.</p>
<p>The row <code class="docutils literal notranslate"><span class="pre">row</span></code> is modified in place. The bumped-out entry
is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleDualRSK</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[1, 2, 4, 6, 7]</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[1, 2, 4, 6, 7]</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleDualRSK.to_pairs">
<span class="sig-name descname"><span class="pre">to_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleDualRSK.to_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a valid input for the dual RSK algorithm, such as
two <span class="math notranslate nohighlight">\(n\)</span>-tuples <code class="docutils literal notranslate"><span class="pre">obj1</span></code> <span class="math notranslate nohighlight">\(= [a_1, a_2, \ldots, a_n]\)</span>
and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> <span class="math notranslate nohighlight">\(= [b_1, b_2, \ldots, b_n]\)</span> forming a strict
biword (i.e., satisfying <span class="math notranslate nohighlight">\(a_1 \leq a_2 \leq \cdots \leq a_n\)</span>,
and if <span class="math notranslate nohighlight">\(a_i = a_{i+1}\)</span>, then <span class="math notranslate nohighlight">\(b_i &lt; b_{i+1}\)</span>) or a
<span class="math notranslate nohighlight">\(\{0, 1\}\)</span>-matrix (“rook placement”), or a single word, return
the array <span class="math notranslate nohighlight">\([(a_1, b_1), (a_2, b_2), \ldots, (a_n, b_n)]\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – anything representing a strict biword
(see the doc of <code class="xref py py-meth docutils literal notranslate"><span class="pre">forward_rule()</span></code> for the
encodings accepted)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) whether to check
that <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> actually define a valid
strict biword</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleDualRSK</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="go">[(1, 2), (2, 1), (2, 2), (2, 3)]</span>
<span class="gp">sage: </span><span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: invalid strict biword</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">;</span> <span class="n">m</span>
<span class="go">[0 1]</span>
<span class="go">[1 1]</span>
<span class="go">[0 1]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
<span class="go">[(1, 2), (2, 1), (2, 2), (3, 2)]</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="p">;</span> <span class="n">m</span>
<span class="go">[0 1]</span>
<span class="go">[1 0]</span>
<span class="go">[0 2]</span>
<span class="gp">sage: </span><span class="n">RuleDualRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: dual RSK requires a {0, 1}-matrix</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleEG">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RuleEG</span></span><a class="headerlink" href="#sage.combinat.rsk.RuleEG" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.rsk.Rule</span></code></a></p>
<p>Rule for Edelman-Greene insertion.</p>
<p>For a reduced word of a permutation (i.e., an element of a type <span class="math notranslate nohighlight">\(A\)</span>
Coxeter group), one can use Edelman-Greene insertion, an algorithm
defined in <a class="reference internal" href="#eg1987" id="id12"><span>[EG1987]</span></a> Definition 6.20 (where it is referred to as
Coxeter-Knuth insertion). The Edelman-Greene insertion is similar to the
standard row insertion except that (using the notations in
the documentation of <a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a>) if <span class="math notranslate nohighlight">\(k_i\)</span> and <span class="math notranslate nohighlight">\(k_i + 1\)</span> both
exist in row <span class="math notranslate nohighlight">\(i\)</span>, we <em>only</em> set <span class="math notranslate nohighlight">\(k_{i+1} = k_i + 1\)</span> and continue.</p>
<p>EXAMPLES:</p>
<p>Let us reproduce figure 6.4 in <a class="reference internal" href="#eg1987" id="id13"><span>[EG1987]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">EG</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], [2, 3], [3]], [[1, 2, 6], [3, 5], [4]]]</span>
</pre></div>
</div>
<p>Some more examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">pq</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">EG</span><span class="p">);</span> <span class="n">pq</span>
<span class="go">[[[1, 2, 3], [2, 3]], [[1, 3, 4], [2, 5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">pq</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">EG</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;matrix&#39;</span><span class="p">),</span>
<span class="gp">....: </span>    <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">EG</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], [2, 3]], [[1, 3, 4], [2, 5]]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">pq</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">EG</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [2, 1, 2, 3, 2]]</span>
</pre></div>
</div>
<p>The RSK algorithm (<a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a>) built using the Edelman-Greene
insertion rule <code class="docutils literal notranslate"><span class="pre">RuleEG</span></code> is a bijection from reduced words of
permutations/elements of a type <span class="math notranslate nohighlight">\(A\)</span> Coxeter group to pairs
consisting of an increasing tableau and a standard tableau
of the same shape (see <a class="reference internal" href="#eg1987" id="id14"><span>[EG1987]</span></a> Theorem 6.25).
The inverse of this bijection is obtained using <a class="reference internal" href="#sage.combinat.rsk.RSK_inverse" title="sage.combinat.rsk.RSK_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK_inverse()</span></code></a>.
If the optional parameter <code class="docutils literal notranslate"><span class="pre">output</span> <span class="pre">=</span> <span class="pre">'permutation'</span></code> is set in
<a class="reference internal" href="#sage.combinat.rsk.RSK_inverse" title="sage.combinat.rsk.RSK_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK_inverse()</span></code></a>, then the function returns not the
reduced word itself but the permutation (of smallest possible
size) whose reduced word it is (although the order of the
letters is reverse to the usual Sage convention):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">pq</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">EG</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;permutation&#39;</span><span class="p">);</span> <span class="n">w</span>
<span class="go">[4, 3, 1, 2]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">reduced_words</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleEG.insertion">
<span class="sig-name descname"><span class="pre">insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleEG.insertion" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert the letter <code class="docutils literal notranslate"><span class="pre">j</span></code> from the second row of the biword
into the row <span class="math notranslate nohighlight">\(r\)</span> using Edelman-Greene insertion,
if there is bumping to be done.</p>
<p>The row <span class="math notranslate nohighlight">\(r\)</span> is modified in place if bumping occurs. The bumped-out
entry, if it exists, is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleEG</span>
<span class="gp">sage: </span><span class="n">qr</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">RuleEG</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">qr</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">RuleEG</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[2, 3, 4, 5, 8]</span>
<span class="gp">sage: </span><span class="n">j</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">qr</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">RuleEG</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[2, 3, 3, 5, 8]</span>
<span class="gp">sage: </span><span class="n">j</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleEG.reverse_insertion">
<span class="sig-name descname"><span class="pre">reverse_insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleEG.reverse_insertion" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse bump the row <code class="docutils literal notranslate"><span class="pre">row</span></code> of the current insertion tableau
with the number <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>The row <code class="docutils literal notranslate"><span class="pre">row</span></code> is modified in place. The bumped-out entry
is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleEG</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">RuleEG</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[1, 1, 1, 2, 3, 3]</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleHecke">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RuleHecke</span></span><a class="headerlink" href="#sage.combinat.rsk.RuleHecke" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.rsk.Rule</span></code></a></p>
<p>Rule for Hecke insertion.</p>
<p>The Hecke RSK algorithm is similar to the classical RSK algorithm,
but is defined using the Hecke insertion introduced in in
<a class="reference internal" href="#bksty06" id="id15"><span>[BKSTY06]</span></a> (but using rows instead of columns).
It is not clear in what generality it works; thus, following
<a class="reference internal" href="#bksty06" id="id16"><span>[BKSTY06]</span></a>, we shall assume that our biword <span class="math notranslate nohighlight">\(p\)</span> has top row
<span class="math notranslate nohighlight">\((1, 2, \ldots, n)\)</span> (or, at least, has its top row strictly
increasing).</p>
<p>The Hecke RSK algorithm returns a pair of an increasing tableau
and a set-valued standard tableau. If
<span class="math notranslate nohighlight">\(p = ((j_0, k_0), (j_1, k_1), \ldots, (j_{\ell-1}, k_{\ell-1}))\)</span>,
then the algorithm recursively constructs pairs
<span class="math notranslate nohighlight">\((P_0, Q_0), (P_1, Q_1), \ldots, (P_\ell, Q_\ell)\)</span> of tableaux.
The construction of <span class="math notranslate nohighlight">\(P_{t+1}\)</span> and <span class="math notranslate nohighlight">\(Q_{t+1}\)</span> from <span class="math notranslate nohighlight">\(P_t\)</span>, <span class="math notranslate nohighlight">\(Q_t\)</span>,
<span class="math notranslate nohighlight">\(j_t\)</span> and <span class="math notranslate nohighlight">\(k_t\)</span> proceeds as follows: Set <span class="math notranslate nohighlight">\(i = j_t\)</span>, <span class="math notranslate nohighlight">\(x = k_t\)</span>,
<span class="math notranslate nohighlight">\(P = P_t\)</span> and <span class="math notranslate nohighlight">\(Q = Q_t\)</span>. We are going to insert <span class="math notranslate nohighlight">\(x\)</span> into the
increasing tableau <span class="math notranslate nohighlight">\(P\)</span> and update the set-valued “recording
tableau” <span class="math notranslate nohighlight">\(Q\)</span> accordingly. As in the classical RSK algorithm, we
first insert <span class="math notranslate nohighlight">\(x\)</span> into row <span class="math notranslate nohighlight">\(1\)</span> of <span class="math notranslate nohighlight">\(P\)</span>, then into row <span class="math notranslate nohighlight">\(2\)</span> of the
resulting tableau, and so on, until the construction terminates.
The details are different: Suppose we are inserting <span class="math notranslate nohighlight">\(x\)</span> into
row <span class="math notranslate nohighlight">\(R\)</span> of <span class="math notranslate nohighlight">\(P\)</span>. If (Case 1) there exists an entry <span class="math notranslate nohighlight">\(y\)</span> in row <span class="math notranslate nohighlight">\(R\)</span>
such that <span class="math notranslate nohighlight">\(x &lt; y\)</span>, then let <span class="math notranslate nohighlight">\(y\)</span> be the minimal such entry. We
replace this entry <span class="math notranslate nohighlight">\(y\)</span> with <span class="math notranslate nohighlight">\(x\)</span> if the result is still an
increasing tableau; in either subcase, we then continue
recursively, inserting <span class="math notranslate nohighlight">\(y\)</span> into the next row of <span class="math notranslate nohighlight">\(P\)</span>.
If, on the other hand, (Case 2) no such <span class="math notranslate nohighlight">\(y\)</span> exists, then we
append <span class="math notranslate nohighlight">\(x\)</span> to the end of <span class="math notranslate nohighlight">\(R\)</span> if the result is an increasing
tableau (Subcase 2.1), and otherwise (Subcase 2.2) do nothing.
Furthermore, in Subcase 2.1, we add the box that we have just
filled with <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(P\)</span> to the shape of <span class="math notranslate nohighlight">\(Q\)</span>, and fill it with
the one-element set <span class="math notranslate nohighlight">\(\{i\}\)</span>. In Subcase 2.2, we find the
bottommost box of the column containing the rightmost box of
row <span class="math notranslate nohighlight">\(R\)</span>, and add <span class="math notranslate nohighlight">\(i\)</span> to the entry of <span class="math notranslate nohighlight">\(Q\)</span> in this box (this
entry is a set, since <span class="math notranslate nohighlight">\(Q\)</span> is set-valued). In either
subcase, we terminate the recursion, and set
<span class="math notranslate nohighlight">\(P_{t+1} = P\)</span> and <span class="math notranslate nohighlight">\(Q_{t+1} = Q\)</span>.</p>
<p>Notice that set-valued tableaux are encoded as tableaux whose
entries are tuples of positive integers; each such tuple is strictly
increasing and encodes a set (namely, the set of its entries).</p>
<p>EXAMPLES:</p>
<p>As an example of Hecke insertion, we reproduce
Example 2.1 in <a class="reference external" href="https://arxiv.org/abs/0801.1319v2">arXiv 0801.1319v2</a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Hecke</span><span class="p">);</span> <span class="p">[</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">]</span>
<span class="go">[[[1, 2, 4, 5], [2, 4, 5], [3, 5], [4], [5]],</span>
<span class="go"> [[(1,), (4,), (5,), (7,)],</span>
<span class="go">  [(2,), (9,), (11, 13)],</span>
<span class="go">  [(3,), (12,)],</span>
<span class="go">  [(6,)],</span>
<span class="go">  [(8, 10)]]]</span>
<span class="gp">sage: </span><span class="n">wp</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Hecke</span><span class="p">,</span>
<span class="gp">....: </span>                   <span class="n">output</span><span class="o">=</span><span class="s1">&#39;list&#39;</span><span class="p">);</span> <span class="n">wp</span>
<span class="go">[5, 4, 1, 3, 4, 2, 5, 1, 2, 1, 4, 2, 4]</span>
<span class="gp">sage: </span><span class="n">wp</span> <span class="o">==</span> <span class="n">w</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleHecke.backward_rule">
<span class="sig-name descname"><span class="pre">backward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleHecke.backward_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the generalized permutation obtained by applying reverse
Hecke insertion to a pair of tableaux <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">q)</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code> – two tableaux of the same shape</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'array'</span></code>) if <code class="docutils literal notranslate"><span class="pre">q</span></code> is semi-standard:</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'array'</span></code> – as a two-line array (i.e. generalized permutation
or biword)</p></li>
</ul>
<p>and if <code class="docutils literal notranslate"><span class="pre">q</span></code> is standard set-valued, we can have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'word'</span></code> – as a word</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'list'</span></code> – as a list</p></li>
</ul>
</div></blockquote>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleHecke</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)],</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,)],</span> <span class="p">[(</span><span class="mi">5</span><span class="p">,)]])</span>
<span class="gp">sage: </span><span class="n">RuleHecke</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [3, 3, 2, 4, 1]]</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,)],</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,)],</span> <span class="p">[(</span><span class="mi">5</span><span class="p">,)]])</span>
<span class="gp">sage: </span><span class="n">RuleHecke</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: p(=[[1, 4], [2, 3]]) and</span>
<span class="go"> q(=[[(1, 2), (4,)], [(3,)], [(5,)]]) must have the same shape</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleHecke.forward_rule">
<span class="sig-name descname"><span class="pre">forward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_standard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleHecke.forward_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pair of tableaux obtained by applying Hecke
insertion to the generalized permutation <code class="docutils literal notranslate"><span class="pre">[obj1,</span> <span class="pre">obj2]</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – can be one of the following ways to
represent a generalized permutation (or, equivalently,
biword):</p>
<ul>
<li><p>two lists <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> of equal length,
to be interpreted as the top row and the bottom row of
the biword</p></li>
<li><p>a word <code class="docutils literal notranslate"><span class="pre">obj1</span></code> in an ordered alphabet, to be
interpreted as the bottom row of the biword (in this
case, <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>; the top row of the biword
is understood to be <span class="math notranslate nohighlight">\((1, 2, \ldots, n)\)</span> by default)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_standard</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) check if either of the
resulting tableaux is a standard tableau, and if so, typecast it
as such</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleHecke</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">RuleHecke</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="kc">None</span><span class="p">);</span><span class="n">p</span>
<span class="go">[[1, 4], [2], [3]]</span>
<span class="gp">sage: </span><span class="n">q</span>
<span class="go">[[(1, 2), (4,)], [(3,)], [(5,)]]</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">SemistandardTableau</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">Tableau</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleHecke.insertion">
<span class="sig-name descname"><span class="pre">insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleHecke.insertion" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert the letter <code class="docutils literal notranslate"><span class="pre">j</span></code> from the second row of the biword
into the row <span class="math notranslate nohighlight">\(r\)</span> of the increasing tableau <span class="math notranslate nohighlight">\(p\)</span> using
Hecke insertion, provided that <span class="math notranslate nohighlight">\(r\)</span> is the <span class="math notranslate nohighlight">\(ir\)</span>-th row
of <span class="math notranslate nohighlight">\(p\)</span>, and provided that there is bumping to be done.</p>
<p>The row <span class="math notranslate nohighlight">\(r\)</span> is modified in place if bumping occurs. The bumped-out
entry, if it exists, is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleHecke</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_right</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span>  <span class="p">[],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span><span class="p">,</span> <span class="n">ir</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">j1</span> <span class="o">=</span> <span class="n">RuleHecke</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">j1</span> <span class="o">==</span> <span class="n">r</span><span class="p">[</span><span class="n">bisect_right</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleHecke.reverse_insertion">
<span class="sig-name descname"><span class="pre">reverse_insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleHecke.reverse_insertion" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse bump the row <code class="docutils literal notranslate"><span class="pre">row</span></code> of the current insertion tableau
<code class="docutils literal notranslate"><span class="pre">p</span></code> with the number <code class="docutils literal notranslate"><span class="pre">x</span></code>, provided that <code class="docutils literal notranslate"><span class="pre">row</span></code> is the
<span class="math notranslate nohighlight">\(i\)</span>-th row of <span class="math notranslate nohighlight">\(p\)</span>.</p>
<p>The row <code class="docutils literal notranslate"><span class="pre">row</span></code> is modified in place. The bumped-out entry
is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleHecke</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_left</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x1</span> <span class="o">=</span> <span class="n">RuleHecke</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x1</span> <span class="o">==</span> <span class="n">r</span><span class="p">[</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleRSK">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RuleRSK</span></span><a class="headerlink" href="#sage.combinat.rsk.RuleRSK" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.rsk.Rule</span></code></a></p>
<p>Rule for the classical Robinson-Schensted-Knuth insertion.</p>
<p>See <a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a> for the definition of this operation.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">RSK</span><span class="p">)</span>
<span class="go">[[[1, 1, 2], [2]], [[1, 2, 2], [2]]]</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">RSK</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 3], [2, 1, 2, 2]]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleRSK.insertion">
<span class="sig-name descname"><span class="pre">insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleRSK.insertion" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert the letter <code class="docutils literal notranslate"><span class="pre">j</span></code> from the second row of the biword
into the row <span class="math notranslate nohighlight">\(r\)</span> using classical Schensted insertion,
if there is bumping to be done.</p>
<p>The row <span class="math notranslate nohighlight">\(r\)</span> is modified in place if bumping occurs. The bumped-out
entry, if it exists, is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleRSK</span>
<span class="gp">sage: </span><span class="n">qr</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">qr</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">j</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleRSK.reverse_insertion">
<span class="sig-name descname"><span class="pre">reverse_insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleRSK.reverse_insertion" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse bump the row <code class="docutils literal notranslate"><span class="pre">row</span></code> of the current insertion tableau
with the number <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>The row <code class="docutils literal notranslate"><span class="pre">row</span></code> is modified in place. The bumped-out entry
is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleRSK</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">RuleRSK</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[2, 3, 4, 4, 8]</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleStar">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RuleStar</span></span><a class="headerlink" href="#sage.combinat.rsk.RuleStar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.rsk.Rule</span></code></a></p>
<p>Rule for <span class="math notranslate nohighlight">\(\star\)</span>-insertion.</p>
<p>The <span class="math notranslate nohighlight">\(\star\)</span>-insertion is similar to the classical RSK algorithm
and is defined in <a class="reference internal" href="../../../references/index.html#mpps2020" id="id17"><span>[MPPS2020]</span></a>. The bottom row of the increasing
Hecke biword is a word in the 0-Hecke monoid that is fully
commutative. When inserting a letter <span class="math notranslate nohighlight">\(x\)</span> into a row <span class="math notranslate nohighlight">\(R\)</span>, there
are three cases:</p>
<ul class="simple">
<li><p>Case 1: If <span class="math notranslate nohighlight">\(R\)</span> is empty or <span class="math notranslate nohighlight">\(x &gt; \max(R)\)</span>, append <span class="math notranslate nohighlight">\(x\)</span> to row <span class="math notranslate nohighlight">\(R\)</span>
and terminate.</p></li>
<li><p>Case 2: Otherwise if <span class="math notranslate nohighlight">\(x\)</span> is not in <span class="math notranslate nohighlight">\(R\)</span>, locate the smallest <span class="math notranslate nohighlight">\(y\)</span> in <span class="math notranslate nohighlight">\(R\)</span>
with <span class="math notranslate nohighlight">\(y &gt; x\)</span>. Bump <span class="math notranslate nohighlight">\(y\)</span> with <span class="math notranslate nohighlight">\(x\)</span> and insert <span class="math notranslate nohighlight">\(y\)</span> into the next row.</p></li>
<li><p>Case 3: Otherwise, if <span class="math notranslate nohighlight">\(x\)</span> is in <span class="math notranslate nohighlight">\(R\)</span>, locate the smallest <span class="math notranslate nohighlight">\(y\)</span> in <span class="math notranslate nohighlight">\(R\)</span> with
<span class="math notranslate nohighlight">\(y \leq x\)</span> and interval <span class="math notranslate nohighlight">\([y,x]\)</span> contained in <span class="math notranslate nohighlight">\(R\)</span>. Row <span class="math notranslate nohighlight">\(R\)</span> remains
unchanged and <span class="math notranslate nohighlight">\(y\)</span> is to be inserted into the next row.</p></li>
</ul>
<p>The <span class="math notranslate nohighlight">\(\star\)</span>-insertion returns a pair consisting a conjugate of a
semistandard tableau and a semistandard tableau. It is a bijection from the
collection of all increasing Hecke biwords whose bottom row is a fully
commutative word to pairs (P, Q) of tableaux of the same shape such that
P is conjugate semistandard, Q is semistandard and the row reading word of
P is fully commutative <a class="reference internal" href="../../../references/index.html#mpps2020" id="id18"><span>[MPPS2020]</span></a>.</p>
<p>EXAMPLES:</p>
<p>As an example of <span class="math notranslate nohighlight">\(\star\)</span>-insertion, we reproduce Example 28 in <a class="reference internal" href="../../../references/index.html#mpps2020" id="id19"><span>[MPPS2020]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleStar</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="go">  1  2  4  1  1  2</span>
<span class="go">  1  4     2  4</span>
<span class="go">  3        4</span>
<span class="gp">sage: </span><span class="n">line1</span><span class="p">,</span><span class="n">line2</span> <span class="o">=</span> <span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">line1</span><span class="p">,</span><span class="n">line2</span>
<span class="go">([1, 1, 2, 2, 4, 4], [1, 3, 2, 4, 2, 4])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;DecreasingHeckeFactorization&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;Star&#39;</span><span class="p">)</span>
<span class="go">(4, 2)()(4, 2)(3, 1)</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.crystals.fully_commutative_stable_grothendieck</span> <span class="kn">import</span> <span class="n">DecreasingHeckeFactorization</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">DecreasingHeckeFactorization</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">RSK</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;Star&#39;</span><span class="p">),</span><span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;Star&#39;</span><span class="p">,</span>
<span class="gp">....: </span>            <span class="n">output</span><span class="o">=</span><span class="s1">&#39;DecreasingHeckeFactorization&#39;</span><span class="p">)</span>
<span class="go">(4, 2)()(4, 2)(3, 1)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;Star&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="go">1  2  4  1  1  2</span>
<span class="go">1  4     2  4</span>
<span class="go">3        4</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;Star&#39;</span><span class="p">)</span>
<span class="go">[[1, 1, 2, 2, 4, 4], [1, 3, 2, 4, 2, 4]]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;DecreasingHeckeFactorization&#39;</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;Star&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">==</span> <span class="n">h</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When <code class="docutils literal notranslate"><span class="pre">output</span></code> is set to <code class="docutils literal notranslate"><span class="pre">'DecreasingHeckeFactorization'</span></code>, the
inverse of <span class="math notranslate nohighlight">\(\star\)</span>-insertion of <span class="math notranslate nohighlight">\((P,Q)\)</span> returns a decreasing
factorization whose number of factors is the maximum entry of <span class="math notranslate nohighlight">\(Q\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.crystals.fully_commutative_stable_grothendieck</span> <span class="kn">import</span> <span class="n">DecreasingHeckeFactorization</span>
<span class="gp">sage: </span><span class="n">h1</span> <span class="o">=</span> <span class="n">DecreasingHeckeFactorization</span><span class="p">([[],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">]]);</span> <span class="n">h1</span>
<span class="go">()(3, 1)(1)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;Star&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
<span class="go">  1  3  1  2</span>
<span class="go">  1     2</span>
<span class="gp">sage: </span><span class="n">h2</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;Star&#39;</span><span class="p">,</span>
<span class="gp">....: </span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;DecreasingHeckeFactorization&#39;</span><span class="p">);</span> <span class="n">h2</span>
<span class="go">(3, 1)(1)</span>
</pre></div>
</div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleStar.backward_rule">
<span class="sig-name descname"><span class="pre">backward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'array'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleStar.backward_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the increasing Hecke biword obtained by applying reverse
<span class="math notranslate nohighlight">\(\star\)</span>-insertion to a pair of tableaux <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">q)</span></code>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code> – two tableaux of the same shape, where <code class="docutils literal notranslate"><span class="pre">p</span></code> is the
conjugate of a semistandard tableau, whose reading word is fully
commutative and <code class="docutils literal notranslate"><span class="pre">q</span></code> is a semistandard tableau.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'array'</span></code>) if <code class="docutils literal notranslate"><span class="pre">q</span></code> is semi-standard:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'array'</span></code> – as a two-line array (i.e. generalized permutation
or biword) that is an increasing Hecke biword</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'DecreasingHeckeFactorization'</span></code> – as a decreasing
factorization in the 0-Hecke monoid</p></li>
</ul>
<p>and if <code class="docutils literal notranslate"><span class="pre">q</span></code> is standard:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'word'</span></code> – as a (possibly non-reduced) word in the 0-Hecke
monoid</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When output is ‘DecreasingHeckeFactorization’, the number of factors
in the output is the largest number in <code class="docutils literal notranslate"><span class="pre">obj1</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleStar</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="go">  1  2  4  1  1  2</span>
<span class="go">  1  4     2  4</span>
<span class="go">  3        4</span>
<span class="gp">sage: </span><span class="n">line1</span><span class="p">,</span><span class="n">line2</span> <span class="o">=</span> <span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span> <span class="n">line1</span><span class="p">,</span><span class="n">line2</span>
<span class="go">([1, 1, 2, 2, 4, 4], [1, 3, 2, 4, 2, 4])</span>
<span class="gp">sage: </span><span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;DecreasingHeckeFactorization&#39;</span><span class="p">)</span>
<span class="go">(4, 2)()(4, 2)(3, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleStar.forward_rule">
<span class="sig-name descname"><span class="pre">forward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_braid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleStar.forward_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pair of tableaux obtained by applying forward insertion
to the increasing Hecke biword <code class="docutils literal notranslate"><span class="pre">[obj1,</span> <span class="pre">obj2]</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – can be one of the following ways to represent a
biword (or, equivalently, an increasing 0-Hecke factorization) that
is fully commutative:</p>
<ul>
<li><p>two lists <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> of equal length, to be
interpreted as the top row and the bottom row of the biword.</p></li>
<li><p>a word <code class="docutils literal notranslate"><span class="pre">obj1</span></code> in an ordered alphabet, to be interpreted as
the bottom row of the biword (in this case, <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>;
the top row of the biword is understood to be <span class="math notranslate nohighlight">\((1,2,\ldots,n)\)</span>
by default).</p></li>
<li><p>a DecreasingHeckeFactorization <code class="docutils literal notranslate"><span class="pre">obj1</span></code>, the whose increasing
Hecke biword will be interpreted as the bottom row; the top row is
understood to be the indices of the factors for each letter in
this biword.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_braid</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) indicator to validate that
input is associated to a fully commutative word in the 0-Hecke monoid,
validation is performed if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>; otherwise, this validation
is ignored.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleStar</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span>
<span class="go">([[1, 3], [2, 3], [2]], [[1, 1], [2, 3], [3]])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span>
<span class="go">([[1, 3], [2, 3], [2]], [[1, 2], [3, 5], [4]])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Star</span><span class="p">);</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span>
<span class="go">([[1, 3], [2, 3], [2]], [[1, 1], [2, 3], [3]])</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.crystals.fully_commutative_stable_grothendieck</span> <span class="kn">import</span> <span class="n">DecreasingHeckeFactorization</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">DecreasingHeckeFactorization</span><span class="p">([[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span><span class="n">q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Star</span><span class="p">);</span> <span class="n">p</span><span class="p">,</span><span class="n">q</span>
<span class="go">([[1, 3], [2, 3], [2]], [[1, 1], [2, 3], [3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleStar.insertion">
<span class="sig-name descname"><span class="pre">insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleStar.insertion" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert the letter <code class="docutils literal notranslate"><span class="pre">b</span></code> from the second row of the biword into the row
<code class="docutils literal notranslate"><span class="pre">r</span></code> using <span class="math notranslate nohighlight">\(\star\)</span>-insertion defined in <a class="reference internal" href="../../../references/index.html#mpps2020" id="id20"><span>[MPPS2020]</span></a>.</p>
<p>The row <span class="math notranslate nohighlight">\(r\)</span> is modified in place if bumping occurs and <span class="math notranslate nohighlight">\(b\)</span> is not in
row <span class="math notranslate nohighlight">\(r\)</span>. The bumped-out entry, if it exists, is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleStar</span>
<span class="gp">sage: </span><span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleStar.reverse_insertion">
<span class="sig-name descname"><span class="pre">reverse_insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleStar.reverse_insertion" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse bump the row <code class="docutils literal notranslate"><span class="pre">r</span></code> of the current insertion tableau <code class="docutils literal notranslate"><span class="pre">p</span></code>
with number <code class="docutils literal notranslate"><span class="pre">x</span></code>, provided that <code class="docutils literal notranslate"><span class="pre">r</span></code> is the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th row of <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<p>The row <code class="docutils literal notranslate"><span class="pre">r</span></code> is modified in place. The bumped-out entry is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleStar</span>
<span class="gp">sage: </span><span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">RuleStar</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleSuperRSK">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">RuleSuperRSK</span></span><a class="headerlink" href="#sage.combinat.rsk.RuleSuperRSK" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.rsk.RuleRSK" title="sage.combinat.rsk.RuleRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.rsk.RuleRSK</span></code></a></p>
<p>Rule for super RSK insertion.</p>
<p>Super RSK is based on <span class="math notranslate nohighlight">\(\epsilon\)</span>-insertion, a combination of
row and column classical RSK insertion.</p>
<p>Super RSK insertion differs from the classical RSK insertion in the
following ways:</p>
<ul class="simple">
<li><p>The input (in terms of biwords) is no longer an arbitrary biword,
but rather a restricted super biword (i.e., a pair of two lists
<span class="math notranslate nohighlight">\([a_1, a_2, \ldots, a_n]\)</span> and <span class="math notranslate nohighlight">\([b_1, b_2, \ldots, b_n]\)</span> that
contains entries with even and odd parity and pairs with mixed
parity entries do not repeat).</p></li>
<li><p>The output still consists of two tableaux <span class="math notranslate nohighlight">\((P, Q)\)</span> of equal
shapes, but rather than both of them being semistandard, now
they are semistandard super tableaux.</p></li>
<li><p>The main difference is in the way bumping works. Instead of having
only row bumping super RSK uses <span class="math notranslate nohighlight">\(\epsilon\)</span>-insertion, a combination
of classical RSK bumping along the rows and a dual RSK like bumping
(i.e. when a number <span class="math notranslate nohighlight">\(k_i\)</span> is inserted into the <span class="math notranslate nohighlight">\(i\)</span>-th row of <span class="math notranslate nohighlight">\(P\)</span>, it
bumps out the first integer greater <strong>or equal to</strong> <span class="math notranslate nohighlight">\(k_i\)</span> in the column)
along the column.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;superRSK&#39;</span><span class="p">)</span>
<span class="go">[[[1]], [[1]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;superRSK&#39;</span><span class="p">)</span>
<span class="go">[[[1, 3]], [[1, 2]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;superRSK&#39;</span><span class="p">)</span>
<span class="go">[[[1, 3], [3&#39;]], [[1, 2], [3]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;superRSK&#39;</span><span class="p">)</span>
<span class="go">[[[1, 3&#39;, 3], [2&#39;]], [[1&#39;, 1, 2&#39;], [2]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="s2">&quot;1p&quot;</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>    <span class="p">[</span><span class="s2">&quot;1p&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;superRSK&#39;</span><span class="p">)</span>
<span class="go">[[[1&#39;, 2, 3&#39;, 3], [1, 3&#39;], [2&#39;], [3&#39;]], [[1&#39;, 2, 3&#39;, 3], [2&#39;, 3&#39;], [2], [3]]]</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">SemistandardSuperTableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;3p&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;2p&#39;</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">SemistandardSuperTableau</span><span class="p">([[</span><span class="s1">&#39;1p&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;2p&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">superRSK</span><span class="p">)</span>
<span class="go">[[1&#39;, 1, 2&#39;, 2], [1, 3, 3&#39;, 2&#39;]]</span>
</pre></div>
</div>
<p>We apply super RSK on Example 5.1 in <a class="reference internal" href="../../../references/index.html#muth2019" id="id21"><span>[Muth2019]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="s2">&quot;1p&quot;</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>          <span class="p">[</span><span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">,</span> <span class="s2">&quot;1p&quot;</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;superRSK&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
<span class="go">([[1&#39;, 2&#39;, 3&#39;, 3], [1, 2, 3&#39;], [3&#39;]], [[1&#39;, 2, 2, 3&#39;], [2&#39;, 3, 3], [3&#39;]])</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">((</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">))</span>
<span class="go">(  1&#39; 2&#39; 3&#39;  3   1&#39;  2  2 3&#39; )</span>
<span class="go">(   1  2 3&#39;      2&#39;  3  3    )</span>
<span class="go">(  3&#39;         ,  3&#39;          )</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">superRSK</span><span class="p">)</span>
<span class="go">[[1&#39;, 2&#39;, 2, 2, 3&#39;, 3&#39;, 3, 3], [3&#39;, 1, 2, 3, 3&#39;, 3&#39;, 2&#39;, 1&#39;]]</span>
</pre></div>
</div>
<p>Example 6.1 in <a class="reference internal" href="../../../references/index.html#muth2019" id="id22"><span>[Muth2019]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="s2">&quot;1p&quot;</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>          <span class="p">[</span><span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">,</span> <span class="s2">&quot;1p&quot;</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;superRSK&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">((</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">))</span>
<span class="go">(  1&#39; 2&#39; 3&#39;  3   1&#39;  2  2 3&#39; )</span>
<span class="go">(   1  2 3&#39;      2&#39;  3  3    )</span>
<span class="go">(  3&#39;         ,  3&#39;          )</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">superRSK</span><span class="p">)</span>
<span class="go">[[1&#39;, 2&#39;, 2, 2, 3&#39;, 3&#39;, 3, 3], [3&#39;, 1, 2, 3, 3&#39;, 3&#39;, 2&#39;, 1&#39;]]</span>

<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="s2">&quot;1p&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>          <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;2p&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;3p&quot;</span><span class="p">,</span> <span class="s2">&quot;1p&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">insertion</span><span class="o">=</span><span class="s1">&#39;superRSK&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">((</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">))</span>
<span class="go">(  1&#39;  2  2 3&#39;   1&#39; 2&#39; 3&#39;  3 )</span>
<span class="go">(  2&#39;  3  3       1  2 3&#39;    )</span>
<span class="go">(  3&#39;         ,  3&#39;          )</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">superRSK</span><span class="p">)</span>
<span class="go">[[1&#39;, 1, 2&#39;, 2, 3&#39;, 3&#39;, 3&#39;, 3], [3, 2&#39;, 3, 2, 3&#39;, 3&#39;, 1&#39;, 2]]</span>
</pre></div>
</div>
<p>Let us now call the inverse correspondence:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">....: </span>           <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">superRSK</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">superRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 2, 2], [2, 1, 2, 3]]</span>
</pre></div>
</div>
<p>When applied to two tableaux with only even parity elements, reverse super
RSK insertion behaves identically to the usual reversel RSK insertion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">RSK</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [1, 4, 5, 3, 2]]</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">SemistandardSuperTableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">SemistandardSuperTableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">superRSK</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [1, 4, 5, 3, 2]]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleSuperRSK.backward_rule">
<span class="sig-name descname"><span class="pre">backward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'array'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleSuperRSK.backward_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the restricted super biword obtained by applying reverse
super RSK insertion to a pair of tableaux <code class="docutils literal notranslate"><span class="pre">(p,</span> <span class="pre">q)</span></code>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code> – two tableaux of the same shape</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'array'</span></code>) if <code class="docutils literal notranslate"><span class="pre">q</span></code> is row-strict:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'array'</span></code> – as a two-line array (i.e. restricted super biword)</p></li>
</ul>
<p>and if <code class="docutils literal notranslate"><span class="pre">q</span></code> is standard, we can have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'word'</span></code> – as a word</p></li>
</ul>
</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleSuperRSK</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">SemistandardSuperTableau</span><span class="p">([[</span><span class="s1">&#39;1p&#39;</span><span class="p">,</span> <span class="s1">&#39;3p&#39;</span><span class="p">,</span> <span class="s1">&#39;4p&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">SemistandardSuperTableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [4&#39;, 3, 3&#39;, 2, 1&#39;]]</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">SemistandardSuperTableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;3p&#39;</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">SemistandardSuperTableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">backward_rule</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">)</span>
<span class="go">[[1, 2, 3], [1, 3, 3&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleSuperRSK.forward_rule">
<span class="sig-name descname"><span class="pre">forward_rule</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_standard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleSuperRSK.forward_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pair of tableaux obtained by applying forward
insertion to the restricted super biword <code class="docutils literal notranslate"><span class="pre">[obj1,</span> <span class="pre">obj2]</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – can be one of the following ways to
represent a generalized permutation (or, equivalently,
biword):</p>
<ul>
<li><p>two lists <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> of equal length,
to be interpreted as the top row and the bottom row of
the biword</p></li>
<li><p>a word <code class="docutils literal notranslate"><span class="pre">obj1</span></code> in an ordered alphabet, to be
interpreted as the bottom row of the biword (in this
case, <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>; the top row of the biword
is understood to be <span class="math notranslate nohighlight">\((1, 2, \ldots, n)\)</span> by default)</p></li>
<li><p>any object <code class="docutils literal notranslate"><span class="pre">obj1</span></code> which has a method <code class="docutils literal notranslate"><span class="pre">_rsk_iter()</span></code>,
as long as this method returns an iterator yielding
pairs of numbers, which then are interperted as top
entries and bottom entries in the biword (in this case,
<code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_standard</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) check if either of
the resulting tableaux is a standard super tableau, and if so,
typecast it as such</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) whether to check
that <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> actually define a valid
restricted super biword</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleSuperRSK</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">forward_rule</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span> <span class="n">p</span>
<span class="go">[[1, 3]]</span>
<span class="gp">sage: </span><span class="n">q</span>
<span class="go">[[1, 2]]</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">SemistandardSuperTableau</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">SemistandardSuperTableau</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleSuperRSK.insertion">
<span class="sig-name descname"><span class="pre">insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleSuperRSK.insertion" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert the letter <code class="docutils literal notranslate"><span class="pre">j</span></code> from the second row of the biword
into the row <code class="docutils literal notranslate"><span class="pre">r</span></code> using dual RSK insertion or classical
Schensted insertion depending on the value of <code class="docutils literal notranslate"><span class="pre">epsilon</span></code>,
if there is bumping to be done.</p>
<p>The row <span class="math notranslate nohighlight">\(r\)</span> is modified in place if bumping occurs. The bumped-out
entry, if it exists, is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleSuperRSK</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_left</span><span class="p">,</span> <span class="n">bisect_right</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">j</span><span class="p">,</span> <span class="n">y_pos</span> <span class="o">=</span> <span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[1, 3, 3, 3, 3]</span>
<span class="gp">sage: </span><span class="n">j</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">y_pos</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">j</span><span class="p">,</span> <span class="n">y_pos</span> <span class="o">=</span> <span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">insertion</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[1, 3, 3, 3, 4]</span>
<span class="gp">sage: </span><span class="n">j</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">y_pos</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleSuperRSK.reverse_insertion">
<span class="sig-name descname"><span class="pre">reverse_insertion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleSuperRSK.reverse_insertion" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse bump the row <code class="docutils literal notranslate"><span class="pre">row</span></code> of the current insertion tableau
with the number <code class="docutils literal notranslate"><span class="pre">x</span></code> using dual RSK insertion or classical
Schensted insertion depending on the value of <span class="math notranslate nohighlight">\(epsilon\)</span>.</p>
<p>The row <code class="docutils literal notranslate"><span class="pre">row</span></code> is modified in place. The bumped-out entry
is returned along with the bumped position.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleSuperRSK</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">bisect</span> <span class="kn">import</span> <span class="n">bisect_left</span><span class="p">,</span> <span class="n">bisect_right</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">j</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[2, 3, 3, 3, 4]</span>
<span class="gp">sage: </span><span class="n">j</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">y</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">j</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[3, 3, 3, 3, 4]</span>
<span class="gp">sage: </span><span class="n">j</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">y</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">j</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">reverse_insertion</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[1, 3, 3, 3, 4]</span>
<span class="gp">sage: </span><span class="n">j</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">y</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.rsk.RuleSuperRSK.to_pairs">
<span class="sig-name descname"><span class="pre">to_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.RuleSuperRSK.to_pairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a valid input for the super RSK algorithm, such as
two <span class="math notranslate nohighlight">\(n\)</span>-tuples <code class="docutils literal notranslate"><span class="pre">obj1</span></code> <span class="math notranslate nohighlight">\(= [a_1, a_2, \ldots, a_n]\)</span>
and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> <span class="math notranslate nohighlight">\(= [b_1, b_2, \ldots, b_n]\)</span> forming a restricted
super biword (i.e., entries with even and odd parity and no
repetition of corresponding pairs with mixed parity entries)
return the array <span class="math notranslate nohighlight">\([(a_1, b_1), (a_2, b_2), \ldots, (a_n, b_n)]\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – anything representing a restricted super biword
(see the doc of <a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK.forward_rule" title="sage.combinat.rsk.RuleSuperRSK.forward_rule"><code class="xref py py-meth docutils literal notranslate"><span class="pre">forward_rule()</span></code></a> for the
encodings accepted)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) whether to check
that <code class="docutils literal notranslate"><span class="pre">obj1</span></code> and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> actually define a valid
restricted super biword</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">RuleSuperRSK</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;1p&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;1p&#39;</span><span class="p">]))</span>
<span class="go">[(2, 1), (1&#39;, 1), (1, 1&#39;)]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;1p&#39;</span><span class="p">,</span> <span class="s1">&#39;2p&#39;</span><span class="p">]))</span>
<span class="go">[(1&#39;, 1), (1, 1&#39;), (2&#39;, 2&#39;)]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">RuleSuperRSK</span><span class="p">()</span><span class="o">.</span><span class="n">to_pairs</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;1p&#39;</span><span class="p">,</span> <span class="s1">&#39;1p&#39;</span><span class="p">]))</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: invalid restricted superbiword</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.rsk.robinson_schensted_knuth">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">robinson_schensted_knuth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj1=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj2=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">insertion=&lt;class</span> <span class="pre">'sage.combinat.rsk.RuleRSK'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_standard=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**options</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.robinson_schensted_knuth" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the Robinson-Schensted-Knuth (RSK) correspondence.</p>
<p>The Robinson-Schensted-Knuth (RSK) correspondence (also known
as the RSK algorithm) is most naturally stated as a bijection
between generalized permutations (also known as two-line arrays,
biwords, …) and pairs of semi-standard Young tableaux <span class="math notranslate nohighlight">\((P, Q)\)</span>
of identical shape. The tableau <span class="math notranslate nohighlight">\(P\)</span> is known as the insertion
tableau, and <span class="math notranslate nohighlight">\(Q\)</span> is known as the recording tableau.</p>
<p>The basic operation is known as row insertion <span class="math notranslate nohighlight">\(P \leftarrow k\)</span>
(where <span class="math notranslate nohighlight">\(P\)</span> is a given semi-standard Young tableau, and <span class="math notranslate nohighlight">\(k\)</span> is an
integer). Row insertion is a recursive algorithm which starts by
setting <span class="math notranslate nohighlight">\(k_0 = k\)</span>, and in its <span class="math notranslate nohighlight">\(i\)</span>-th step inserts the number <span class="math notranslate nohighlight">\(k_i\)</span>
into the <span class="math notranslate nohighlight">\(i\)</span>-th row of <span class="math notranslate nohighlight">\(P\)</span> (we start counting the rows at <span class="math notranslate nohighlight">\(0\)</span>) by
replacing the first integer greater than <span class="math notranslate nohighlight">\(k_i\)</span> in the row by <span class="math notranslate nohighlight">\(k_i\)</span>
and defines <span class="math notranslate nohighlight">\(k_{i+1}\)</span> as the integer that has been replaced. If no
integer greater than <span class="math notranslate nohighlight">\(k_i\)</span> exists in the <span class="math notranslate nohighlight">\(i\)</span>-th row, then <span class="math notranslate nohighlight">\(k_i\)</span> is
simply appended to the row and the algorithm terminates at this point.</p>
<p>A <em>generalized permutation</em> (or <em>biword</em>) is a list
<span class="math notranslate nohighlight">\(((j_0, k_0), (j_1, k_1), \ldots, (j_{\ell-1}, k_{\ell-1}))\)</span>
of pairs such that the letters <span class="math notranslate nohighlight">\(j_0, j_1, \ldots, j_{\ell-1}\)</span>
are weakly increasing (that is,
<span class="math notranslate nohighlight">\(j_0 \leq j_1 \leq \cdots \leq j_{\ell-1}\)</span>), whereas the letters
<span class="math notranslate nohighlight">\(k_i\)</span> satisfy <span class="math notranslate nohighlight">\(k_i \leq k_{i+1}\)</span> whenever <span class="math notranslate nohighlight">\(j_i = j_{i+1}\)</span>.
The <span class="math notranslate nohighlight">\(\ell\)</span>-tuple <span class="math notranslate nohighlight">\((j_0, j_1, \ldots, j_{\ell-1})\)</span> is called the
<em>top line</em> of this generalized permutation,
whereas the <span class="math notranslate nohighlight">\(\ell\)</span>-tuple <span class="math notranslate nohighlight">\((k_0, k_1, \ldots, k_{\ell-1})\)</span> is
called its <em>bottom line</em>.</p>
<p>Now the RSK algorithm, applied to a generalized permutation
<span class="math notranslate nohighlight">\(p = ((j_0, k_0), (j_1, k_1), \ldots, (j_{\ell-1}, k_{\ell-1}))\)</span>
(encoded as a lexicographically sorted list of pairs) starts by
initializing two semi-standard tableaux <span class="math notranslate nohighlight">\(P_0\)</span> and <span class="math notranslate nohighlight">\(Q_0\)</span> as empty
tableaux. For each nonnegative integer <span class="math notranslate nohighlight">\(t\)</span> starting at <span class="math notranslate nohighlight">\(0\)</span>, take
the pair <span class="math notranslate nohighlight">\((j_t, k_t)\)</span> from <span class="math notranslate nohighlight">\(p\)</span> and set
<span class="math notranslate nohighlight">\(P_{t+1} = P_t \leftarrow k_t\)</span>, and define <span class="math notranslate nohighlight">\(Q_{t+1}\)</span> by adding a
new box filled with <span class="math notranslate nohighlight">\(j_t\)</span> to the tableau <span class="math notranslate nohighlight">\(Q_t\)</span> at the same
location the row insertion on <span class="math notranslate nohighlight">\(P_t\)</span> ended (that is to say, adding
a new box with entry <span class="math notranslate nohighlight">\(j_t\)</span> such that <span class="math notranslate nohighlight">\(P_{t+1}\)</span> and <span class="math notranslate nohighlight">\(Q_{t+1}\)</span> have
the same shape). The iterative process stops when <span class="math notranslate nohighlight">\(t\)</span> reaches the
size of <span class="math notranslate nohighlight">\(p\)</span>, and the pair <span class="math notranslate nohighlight">\((P_t, Q_t)\)</span> at this point is the image
of <span class="math notranslate nohighlight">\(p\)</span> under the Robinson-Schensted-Knuth correspondence.</p>
<p>This correspondence has been introduced in <a class="reference internal" href="#knu1970" id="id23"><span>[Knu1970]</span></a>, where it has
been referred to as “Construction A”.</p>
<p>For more information, see Chapter 7 in <a class="reference internal" href="dyck_word.html#sta-ec2" id="id24"><span>[Sta-EC2]</span></a>.</p>
<p>We also note that integer matrices are in bijection with generalized
permutations. Furthermore, we can convert any word <span class="math notranslate nohighlight">\(w\)</span> (and, in
particular, any permutation) to a generalized permutation by
considering the top row to be <span class="math notranslate nohighlight">\((1, 2, \ldots, n)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the
length of <span class="math notranslate nohighlight">\(w\)</span>.</p>
<p>The optional argument <code class="docutils literal notranslate"><span class="pre">insertion</span></code> allows to specify an alternative
insertion procedure to be used instead of the standard
Robinson-Schensted-Knuth insertion.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">obj1,</span> <span class="pre">obj2</span></code> – can be one of the following:</p>
<ul>
<li><p>a word in an ordered alphabet (in this case, <code class="docutils literal notranslate"><span class="pre">obj1</span></code> is said
word, and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p>an integer matrix</p></li>
<li><p>two lists of equal length representing a generalized permutation
(namely, the lists <span class="math notranslate nohighlight">\((j_0, j_1, \ldots, j_{\ell-1})\)</span> and
<span class="math notranslate nohighlight">\((k_0, k_1, \ldots, k_{\ell-1})\)</span> represent the generalized
permutation
<span class="math notranslate nohighlight">\(((j_0, k_0), (j_1, k_1), \ldots, (j_{\ell-1}, k_{\ell-1}))\)</span>)</p></li>
<li><p>any object which has a method <code class="docutils literal notranslate"><span class="pre">_rsk_iter()</span></code> which returns an
iterator over the object represented as generalized permutation or
a pair of lists (in this case, <code class="docutils literal notranslate"><span class="pre">obj1</span></code> is said object,
and <code class="docutils literal notranslate"><span class="pre">obj2</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">insertion</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">RSK.rules.RSK</span></code>) the following types
of insertion are currently supported:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.RSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'RSK'</span></code>) – Robinson-Schensted-Knuth
insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleRSK" title="sage.combinat.rsk.RuleRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.EG</span></code> (or <code class="docutils literal notranslate"><span class="pre">'EG'</span></code>) – Edelman-Greene insertion
(only for reduced words of permutations/elements of a type <span class="math notranslate nohighlight">\(A\)</span>
Coxeter group) (<a class="reference internal" href="#sage.combinat.rsk.RuleEG" title="sage.combinat.rsk.RuleEG"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleEG</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.Hecke</span></code> (or <code class="docutils literal notranslate"><span class="pre">'hecke'</span></code>) – Hecke insertion (only
guaranteed for generalized permutations whose top row is strictly
increasing) (<a class="reference internal" href="#sage.combinat.rsk.RuleHecke" title="sage.combinat.rsk.RuleHecke"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleHecke</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.dualRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'dualRSK'</span></code>) – Dual RSK insertion
(only for strict biwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleDualRSK" title="sage.combinat.rsk.RuleDualRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleDualRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.coRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'coRSK'</span></code>) – CoRSK insertion (only
for strict cobiwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleCoRSK" title="sage.combinat.rsk.RuleCoRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleCoRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.superRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'super'</span></code>) – Super RSK insertion (only for
restricted super biwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK" title="sage.combinat.rsk.RuleSuperRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleSuperRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.Star</span></code> (or <code class="docutils literal notranslate"><span class="pre">'Star'</span></code>) – <span class="math notranslate nohighlight">\(\star\)</span>-insertion (only for
fully commutative words in the 0-Hecke monoid)
(<a class="reference internal" href="#sage.combinat.rsk.RuleStar" title="sage.combinat.rsk.RuleStar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleStar</span></code></a>)</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_standard</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) check if either of the
resulting tableaux is a standard tableau, and if so, typecast it
as such</p></li>
</ul>
<p>For precise information about constraints on the input and output,
as well as the definition of the algorithm (if it is not standard
RSK), see the particular <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rule</span></code></a> class.</p>
<p>EXAMPLES:</p>
<p>If we only input one row, it is understood that the top row
should be <span class="math notranslate nohighlight">\((1, 2, \ldots, n)\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[[[1, 3, 4], [2], [3]], [[1, 2, 4], [3], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">[[[1, 3, 4], [2], [3]], [[1, 2, 4], [3], [5]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">[[[1, 2, 2, 3, 3], [2, 3], [3]], [[1, 2, 3, 6, 8], [4, 7], [5]]]</span>
</pre></div>
</div>
<p>We can provide a generalized permutation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">[[[1, 1, 2], [2]], [[1, 2, 2], [2]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">Word</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">[[[1, 1, 3], [2], [4]], [[1, 1, 4], [3], [4]]]</span>
<span class="gp">sage: </span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">Word</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">]))</span>
<span class="go">[[[1, 2, 7], [2], [6]], [[1, 3, 4], [3], [4]]]</span>
</pre></div>
</div>
<p>We can provide a matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">(</span><span class="n">matrix</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]))</span>
<span class="go">[[[1, 1, 2], [2]], [[1, 2, 2], [2]]]</span>
</pre></div>
</div>
<p>We can also provide something looking like a matrix:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="go">[[[1, 1, 2], [2]], [[1, 2, 2], [2]]]</span>
</pre></div>
</div>
<p>There is also <a class="reference internal" href="#sage.combinat.rsk.RSK_inverse" title="sage.combinat.rsk.RSK_inverse"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK_inverse()</span></code></a> which performs
the inverse of the bijection on a pair of semistandard tableaux. We
note that the inverse function takes 2 separate tableaux as inputs, so
to compose with <a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a>, we need to use the
python <code class="docutils literal notranslate"><span class="pre">*</span></code> on the output:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[[1, 2, 2, 2], [2, 1, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">,</span><span class="n">Q</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
<span class="go">[[1, 2, 2, 2], [2, 1, 1, 2]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.rsk.robinson_schensted_knuth_inverse">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">robinson_schensted_knuth_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output='array'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">insertion=&lt;class</span> <span class="pre">'sage.combinat.rsk.RuleRSK'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.robinson_schensted_knuth_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the generalized permutation corresponding to the pair of
tableaux <span class="math notranslate nohighlight">\((p, q)\)</span> under the inverse of the Robinson-Schensted-Knuth
correspondence.</p>
<p>For more information on the bijection, see <a class="reference internal" href="#sage.combinat.rsk.RSK" title="sage.combinat.rsk.RSK"><code class="xref py py-func docutils literal notranslate"><span class="pre">RSK()</span></code></a>.</p>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">q</span></code> – two semi-standard tableaux of the same shape, or
(in the case when Hecke insertion is used) an increasing tableau and
a set-valued tableau of the same shape (see the note below for the
format of the set-valued tableau)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'array'</span></code>) if <code class="docutils literal notranslate"><span class="pre">q</span></code> is semi-standard:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'array'</span></code> – as a two-line array (i.e. generalized permutation or
biword)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'matrix'</span></code> – as an integer matrix</p></li>
</ul>
<p>and if <code class="docutils literal notranslate"><span class="pre">q</span></code> is standard, we can also have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'word'</span></code> – as a word</p></li>
</ul>
<p>and additionally if <code class="docutils literal notranslate"><span class="pre">p</span></code> is standard, we can also have the output:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'permutation'</span></code> – as a permutation</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">insertion</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">RSK.rules.RSK</span></code>) the insertion algorithm
used in the bijection. Currently the following are supported:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.RSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'RSK'</span></code>) – Robinson-Schensted-Knuth
insertion (<a class="reference internal" href="#sage.combinat.rsk.RuleRSK" title="sage.combinat.rsk.RuleRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.EG</span></code> (or <code class="docutils literal notranslate"><span class="pre">'EG'</span></code>) – Edelman-Greene insertion
(only for reduced words of permutations/elements of a type <span class="math notranslate nohighlight">\(A\)</span>
Coxeter group) (<a class="reference internal" href="#sage.combinat.rsk.RuleEG" title="sage.combinat.rsk.RuleEG"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleEG</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.Hecke</span></code> (or <code class="docutils literal notranslate"><span class="pre">'hecke'</span></code>) – Hecke insertion (only
guaranteed for generalized permutations whose top row is strictly
increasing) (<a class="reference internal" href="#sage.combinat.rsk.RuleHecke" title="sage.combinat.rsk.RuleHecke"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleHecke</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.dualRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'dualRSK'</span></code>) – Dual RSK insertion
(only for strict biwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleDualRSK" title="sage.combinat.rsk.RuleDualRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleDualRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.coRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'coRSK'</span></code>) – CoRSK insertion (only
for strict cobiwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleCoRSK" title="sage.combinat.rsk.RuleCoRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleCoRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.superRSK</span></code> (or <code class="docutils literal notranslate"><span class="pre">'super'</span></code>) – Super RSK insertion (only for
restricted super biwords) (<a class="reference internal" href="#sage.combinat.rsk.RuleSuperRSK" title="sage.combinat.rsk.RuleSuperRSK"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleSuperRSK</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RSK.rules.Star</span></code> (or <code class="docutils literal notranslate"><span class="pre">'Star'</span></code>) – <span class="math notranslate nohighlight">\(\star\)</span>-insertion (only for
fully commutative words in the 0-Hecke monoid)
(<a class="reference internal" href="#sage.combinat.rsk.RuleStar" title="sage.combinat.rsk.RuleStar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RuleStar</span></code></a>)</p></li>
</ul>
</li>
</ul>
<p>For precise information about constraints on the input and
output, see the particular <a class="reference internal" href="#sage.combinat.rsk.Rule" title="sage.combinat.rsk.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rule</span></code></a> class.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the case of Hecke insertion, the input variable <code class="docutils literal notranslate"><span class="pre">q</span></code> should
be a set-valued tableau, encoded as a tableau whose entries are
strictly increasing tuples of positive integers. Each such tuple
encodes the set of its entries.</p>
</div>
<p>EXAMPLES:</p>
<p>If both <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> are standard:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 4, 5], [1, 4, 5, 3, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">)</span>
<span class="go">word: 14532</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">)</span>
<span class="go">[1 0 0 0 0]</span>
<span class="go">[0 0 0 1 0]</span>
<span class="go">[0 0 0 0 1]</span>
<span class="go">[0 0 1 0 0]</span>
<span class="go">[0 1 0 0 0]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">)</span>
<span class="go">[1, 4, 5, 3, 2]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">)</span>
<span class="go">[1, 4, 3, 2, 5]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">)</span>
<span class="go">[1, 2, 5, 4, 3]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;permutation&#39;</span><span class="p">)</span>
<span class="go">[1, 5, 4, 2, 3]</span>
</pre></div>
</div>
<p>If the first tableau is semistandard:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">ret</span> <span class="o">=</span> <span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span> <span class="n">ret</span>
<span class="go">[[1, 2, 3, 4], [1, 3, 2, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s1">&#39;word&#39;</span><span class="p">)</span>
<span class="go">word: 1322</span>
</pre></div>
</div>
<p>In general:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">]]);</span> <span class="n">q</span> <span class="o">=</span> <span class="n">Tableau</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="go">[[1, 2, 3, 3], [2, 1, 2, 2]]</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">)</span>
<span class="go">[0 1]</span>
<span class="go">[1 0]</span>
<span class="go">[0 2]</span>
</pre></div>
</div>
<p>Using Hecke insertion:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">pq</span> <span class="o">=</span> <span class="n">RSK</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Hecke</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RSK_inverse</span><span class="p">(</span><span class="o">*</span><span class="n">pq</span><span class="p">,</span> <span class="n">insertion</span><span class="o">=</span><span class="n">RSK</span><span class="o">.</span><span class="n">rules</span><span class="o">.</span><span class="n">Hecke</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;list&#39;</span><span class="p">)</span>
<span class="go">[5, 4, 3, 1, 4, 2, 5, 5]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The constructor of <code class="docutils literal notranslate"><span class="pre">Tableau</span></code> accepts not only semistandard
tableaux, but also arbitrary lists that are fillings of a
partition diagram. (And such lists are used, e.g., for the
set-valued tableau <code class="docutils literal notranslate"><span class="pre">q</span></code> that is passed to
<code class="docutils literal notranslate"><span class="pre">RSK_inverse(p,</span> <span class="pre">q,</span> <span class="pre">insertion='hecke')</span></code>.)
The user is responsible for ensuring that the tableaux passed to
<code class="docutils literal notranslate"><span class="pre">RSK_inverse</span></code> are of the right types (semistandard, standard,
increasing, set-valued as needed).</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.rsk.to_matrix">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.rsk.</span></span><span class="sig-name descname"><span class="pre">to_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rsk.to_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the integer matrix corresponding to a two-line array.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – the top row of the array</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> – the bottom row of the array</p></li>
</ul>
<p>OUTPUT:</p>
<p>An <span class="math notranslate nohighlight">\(m \times n\)</span>-matrix (where <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(n\)</span> are the maximum entries in
<span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> respectively) whose <span class="math notranslate nohighlight">\((i, j)\)</span>-th entry, for any <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>,
is the number of all positions <span class="math notranslate nohighlight">\(k\)</span> satisfying <span class="math notranslate nohighlight">\(t_k = i\)</span> and <span class="math notranslate nohighlight">\(b_k = j\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rsk</span> <span class="kn">import</span> <span class="n">to_matrix</span>
<span class="gp">sage: </span><span class="n">to_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[0 1 1]</span>
<span class="go">[0 0 0]</span>
<span class="go">[2 0 0]</span>
<span class="go">[0 0 1]</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Robinson-Schensted-Knuth correspondence</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#insertions-currently-available">Insertions currently available</a></li>
<li><a class="reference internal" href="#implementing-your-own-insertion-rule">Implementing your own insertion rule</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="rooted_tree.html"
                          title="previous chapter">Rooted (Unordered) Trees</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="schubert_polynomial.html"
                          title="next chapter">Schubert Polynomials</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/combinat/rsk.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="schubert_polynomial.html" title="Schubert Polynomials"
             >next</a> |</li>
        <li class="right" >
          <a href="rooted_tree.html" title="Rooted (Unordered) Trees"
             >previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="../../../_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../../../../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="../../../index.html">Reference Manual</a> &#187;
      
      <a href="../../index.html">Combinatorics</a> &#187;
    
  </li>

          <li class="nav-item nav-item-1"><a href="../../module_list.html" >Comprehensive Module List</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Robinson-Schensted-Knuth correspondence</a></li> 
      </ul>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2022, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
  </script>
  <script type="text/javascript">
/* detex the document title by removing "\(", "\)", "\", "$" */
document.title = document.title.replace(/\\\(/g, '').replace(/\\\)/g, '').replace(/\\/g, '').replace(/\$/g, '');
  </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>