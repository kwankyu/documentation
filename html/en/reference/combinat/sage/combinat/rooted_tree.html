
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Rooted (Unordered) Trees &#8212; Sage Reference Manual v8.8: Combinatorics</title>
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Robinson-Schensted-Knuth correspondence" href="rsk.html" />
    <link rel="prev" title="Weyl Groups" href="root_system/weyl_group.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="rsk.html" title="Robinson-Schensted-Knuth correspondence"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="root_system/weyl_group.html" title="Weyl Groups"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Combinatorics</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../module_list.html" accesskey="U">Comprehensive Module list</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="rooted-unordered-trees">
<span id="sage-combinat-rooted-tree"></span><h1>Rooted (Unordered) Trees<a class="headerlink" href="#rooted-unordered-trees" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.rooted_tree"></span><p>AUTHORS:</p>
<ul class="simple">
<li>Florent Hivert (2011): initial version</li>
</ul>
<dl class="class">
<dt id="sage.combinat.rooted_tree.LabelledRootedTree">
<em class="property">class </em><code class="descclassname">sage.combinat.rooted_tree.</code><code class="descname">LabelledRootedTree</code><span class="sig-paren">(</span><em>parent</em>, <em>children</em>, <em>label=None</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.LabelledRootedTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="abstract_tree.html#sage.combinat.abstract_tree.AbstractLabelledClonableTree" title="sage.combinat.abstract_tree.AbstractLabelledClonableTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.abstract_tree.AbstractLabelledClonableTree</span></code></a>, <a class="reference internal" href="#sage.combinat.rooted_tree.RootedTree" title="sage.combinat.rooted_tree.RootedTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.rooted_tree.RootedTree</span></code></a></p>
<p>Labelled rooted trees.</p>
<p>A labelled rooted tree is a rooted tree with a label
attached at each node.</p>
<p>More formally:
The <em>labelled rooted trees</em> are an inductive datatype defined
as follows: A labelled rooted tree is a multiset of labelled
rooted trees, endowed with a label (which can be any object,
including <code class="docutils literal notranslate"><span class="pre">None</span></code>). The trees that belong to this multiset
are said to be the <em>children</em> of the tree. (Notice that the
labels of these children may and may not be of the same type
as the label of the tree). A labelled rooted tree which has
no children (so the only information it carries is its label)
is said to be a <em>leaf</em>.</p>
<p>Every labelled rooted tree gives rise to an unlabelled rooted
tree (<a class="reference internal" href="#sage.combinat.rooted_tree.RootedTree" title="sage.combinat.rooted_tree.RootedTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">RootedTree</span></code></a>) by forgetting the labels. (This is
implemented as a conversion.)</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">children</span></code> – a list or tuple or more generally any iterable
of trees or objects convertible to trees</li>
<li><code class="docutils literal notranslate"><span class="pre">label</span></code> – any hashable Sage object (default is <code class="docutils literal notranslate"><span class="pre">None</span></code>)</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">LabelledRootedTree</span><span class="p">([],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">3</span><span class="p">);</span> <span class="n">x</span>
<span class="go">3[]</span>
<span class="gp">sage: </span><span class="n">LabelledRootedTree</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">2[3[], 3[], 3[]]</span>
<span class="gp">sage: </span><span class="n">LabelledRootedTree</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">2[3[], 3[], 3[]]</span>
<span class="gp">sage: </span><span class="n">LabelledRootedTree</span><span class="p">([[],[[],</span> <span class="p">[]]],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">3[None[], None[None[], None[]]]</span>
</pre></div>
</div>
<p>Children are reordered using the value of the <a class="reference internal" href="#sage.combinat.rooted_tree.LabelledRootedTree.sort_key" title="sage.combinat.rooted_tree.LabelledRootedTree.sort_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_key()</span></code></a> method:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">LabelledRootedTree</span><span class="p">([],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">5</span><span class="p">);</span> <span class="n">y</span>
<span class="go">5[]</span>
<span class="gp">sage: </span><span class="n">xyy2</span> <span class="o">=</span> <span class="n">LabelledRootedTree</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">2</span><span class="p">);</span> <span class="n">xyy2</span>
<span class="go">2[3[], 5[], 5[]]</span>
<span class="gp">sage: </span><span class="n">yxy2</span> <span class="o">=</span> <span class="n">LabelledRootedTree</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">2</span><span class="p">);</span> <span class="n">yxy2</span>
<span class="go">2[3[], 5[], 5[]]</span>
<span class="gp">sage: </span><span class="n">xyy2</span> <span class="o">==</span> <span class="n">yxy2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Converting labelled into unlabelled rooted trees by
forgetting the labels, and back (the labels are
initialized as <code class="docutils literal notranslate"><span class="pre">None</span></code>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">yxy2crude</span> <span class="o">=</span> <span class="n">RootedTree</span><span class="p">(</span><span class="n">yxy2</span><span class="p">);</span> <span class="n">yxy2crude</span>
<span class="go">[[], [], []]</span>
<span class="gp">sage: </span><span class="n">LabelledRootedTree</span><span class="p">(</span><span class="n">yxy2crude</span><span class="p">)</span>
<span class="go">None[None[], None[], None[]]</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.rooted_tree.LabelledRootedTree.sort_key">
<code class="descname">sort_key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.LabelledRootedTree.sort_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple of nonnegative integers encoding the labelled
rooted tree <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The first entry of the tuple is a pair consisting of the
number of children of the root and the label of the root. Then
the rest of the tuple is obtained as follows: List
the tuples corresponding to all children (we are regarding the
children themselves as trees). Order this list (not the
tuples!) in lexicographically increasing order, and flatten
it into a single tuple.</p>
<p>This tuple characterizes the labelled rooted tree uniquely, and
can be used to sort the labelled rooted trees provided that the
labels belong to a type which is totally ordered.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The tree <code class="docutils literal notranslate"><span class="pre">self</span></code> must be normalized before calling this
method (see <code class="xref py py-meth docutils literal notranslate"><span class="pre">normalize()</span></code>). This doesn’t matter
unless you are inside the <code class="xref py py-meth docutils literal notranslate"><span class="pre">clone()</span></code> context manager,
because outside of it every rooted tree is already
normalized.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method overrides <a class="reference internal" href="#sage.combinat.rooted_tree.RootedTree.sort_key" title="sage.combinat.rooted_tree.RootedTree.sort_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">RootedTree.sort_key()</span></code></a>
and returns a result different from what the latter
would return, as it wants to encode the whole labelled
tree including its labelling rather than just the
unlabelled tree. Therefore, be careful with using this
method on subclasses of <code class="xref py py-class docutils literal notranslate"><span class="pre">RootedOrderedTree</span></code>;
under some circumstances they could inherit it from
another superclass instead of from <a class="reference internal" href="#sage.combinat.rooted_tree.RootedTree" title="sage.combinat.rooted_tree.RootedTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">RootedTree</span></code></a>,
which would cause the method to forget the labelling.
See the docstrings of <a class="reference internal" href="#sage.combinat.rooted_tree.RootedTree.sort_key" title="sage.combinat.rooted_tree.RootedTree.sort_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">RootedTree.sort_key()</span></code></a> and
<a class="reference internal" href="ordered_tree.html#sage.combinat.ordered_tree.OrderedTree.sort_key" title="sage.combinat.ordered_tree.OrderedTree.sort_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.combinat.ordered_tree.OrderedTree.sort_key()</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">LRT</span> <span class="o">=</span> <span class="n">LabelledRootedTrees</span><span class="p">();</span> <span class="n">LRT</span>
<span class="go">Labelled rooted trees</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">LRT</span><span class="p">([],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">3</span><span class="p">);</span> <span class="n">x</span>
<span class="go">3[]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">sort_key</span><span class="p">()</span>
<span class="go">((0, 3),)</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">LRT</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">2</span><span class="p">);</span> <span class="n">y</span>
<span class="go">2[3[], 3[], 3[]]</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">sort_key</span><span class="p">()</span>
<span class="go">((3, 2), (0, 3), (0, 3), (0, 3))</span>
<span class="gp">sage: </span><span class="n">LRT</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">sort_key</span><span class="p">()</span>
<span class="go">((3, &#39;alpha&#39;), (0, 3), (1, 5), (0, None), (2, 42), (0, 3), (0, 3))</span>
<span class="gp">sage: </span><span class="n">lb</span> <span class="o">=</span> <span class="n">RootedTrees</span><span class="p">()([[],[[],</span> <span class="p">[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">lb</span><span class="o">.</span><span class="n">sort_key</span><span class="p">()</span>
<span class="go">((2, 1), (0, 2), (2, 3), (0, 4), (0, 5))</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.rooted_tree.LabelledRootedTrees">
<em class="property">class </em><code class="descclassname">sage.combinat.rooted_tree.</code><code class="descname">LabelledRootedTrees</code><a class="headerlink" href="#sage.combinat.rooted_tree.LabelledRootedTrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Parents and Elements v8.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></code></a>, <a class="reference external" href="../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Parents and Elements v8.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>This is a parent stub to serve as a factory class for labelled
rooted trees.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">LRT</span> <span class="o">=</span> <span class="n">LabelledRootedTrees</span><span class="p">();</span> <span class="n">LRT</span>
<span class="go">Labelled rooted trees</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">LRT</span><span class="p">([],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">3</span><span class="p">);</span> <span class="n">x</span>
<span class="go">3[]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="n">LRT</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">LRT</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">2</span><span class="p">);</span> <span class="n">y</span>
<span class="go">2[3[], 3[], 3[]]</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="n">LRT</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Add the possibility to restrict the labels to a fixed set.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.combinat.rooted_tree.LabelledRootedTrees_all">
<em class="property">class </em><code class="descclassname">sage.combinat.rooted_tree.</code><code class="descname">LabelledRootedTrees_all</code><span class="sig-paren">(</span><em>category=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.LabelledRootedTrees_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.rooted_tree.LabelledRootedTrees" title="sage.combinat.rooted_tree.LabelledRootedTrees"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.rooted_tree.LabelledRootedTrees</span></code></a></p>
<p>Class of all (unordered) labelled rooted trees.</p>
<p>See <a class="reference internal" href="#sage.combinat.rooted_tree.LabelledRootedTree" title="sage.combinat.rooted_tree.LabelledRootedTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">LabelledRootedTree</span></code></a> for a definition.</p>
<dl class="attribute">
<dt id="sage.combinat.rooted_tree.LabelledRootedTrees_all.Element">
<code class="descname">Element</code><a class="headerlink" href="#sage.combinat.rooted_tree.LabelledRootedTrees_all.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.rooted_tree.LabelledRootedTree" title="sage.combinat.rooted_tree.LabelledRootedTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">LabelledRootedTree</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.rooted_tree.LabelledRootedTrees_all.labelled_trees">
<code class="descname">labelled_trees</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.LabelledRootedTrees_all.labelled_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of labelled trees associated to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">LabelledRootedTrees</span><span class="p">()</span><span class="o">.</span><span class="n">labelled_trees</span><span class="p">()</span>
<span class="go">Labelled rooted trees</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.rooted_tree.LabelledRootedTrees_all.unlabelled_trees">
<code class="descname">unlabelled_trees</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.LabelledRootedTrees_all.unlabelled_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of unlabelled trees associated to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">LabelledRootedTrees</span><span class="p">()</span><span class="o">.</span><span class="n">unlabelled_trees</span><span class="p">()</span>
<span class="go">Rooted trees</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.rooted_tree.RootedTree">
<em class="property">class </em><code class="descclassname">sage.combinat.rooted_tree.</code><code class="descname">RootedTree</code><span class="sig-paren">(</span><em>parent=None</em>, <em>children=[]</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="abstract_tree.html#sage.combinat.abstract_tree.AbstractClonableTree" title="sage.combinat.abstract_tree.AbstractClonableTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.abstract_tree.AbstractClonableTree</span></code></a>, <a class="reference external" href="../../../structure/sage/structure/list_clone.html#sage.structure.list_clone.NormalizedClonableList" title="(in Sage Reference Manual: Parents and Elements v8.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.list_clone.NormalizedClonableList</span></code></a></p>
<p>The class for unordered rooted trees.</p>
<p>The <em>unordered rooted trees</em> are an inductive datatype defined
as follows: An unordered rooted tree is a multiset of
unordered rooted trees. The trees that belong to this
multiset are said to be the <em>children</em> of the tree. The tree
that has no children is called a <em>leaf</em>.</p>
<p>The <em>labelled rooted trees</em> (<a class="reference internal" href="#sage.combinat.rooted_tree.LabelledRootedTree" title="sage.combinat.rooted_tree.LabelledRootedTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">LabelledRootedTree</span></code></a>)
form a subclass of this class; they carry additional data.</p>
<p>One can create a tree from any list (or more generally iterable)
of trees or objects convertible to a tree.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RootedTree</span><span class="p">([])</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">RootedTree</span><span class="p">([[],</span> <span class="p">[[]]])</span>
<span class="go">[[], [[]]]</span>
<span class="gp">sage: </span><span class="n">RootedTree</span><span class="p">([[[]],</span> <span class="p">[]])</span>
<span class="go">[[], [[]]]</span>
<span class="gp">sage: </span><span class="n">O</span> <span class="o">=</span> <span class="n">OrderedTree</span><span class="p">([[[]],</span> <span class="p">[]]);</span> <span class="n">O</span>
<span class="go">[[[]], []]</span>
<span class="gp">sage: </span><span class="n">RootedTree</span><span class="p">(</span><span class="n">O</span><span class="p">)</span>  <span class="c1"># this is O with the ordering forgotten</span>
<span class="go">[[], [[]]]</span>
</pre></div>
</div>
<p>One can also enter any small rooted tree (“small” meaning that
no vertex has more than <span class="math notranslate nohighlight">\(15\)</span> children) by using a simple
numerical encoding of rooted trees, namely, the
<a class="reference internal" href="abstract_tree.html#sage.combinat.abstract_tree.from_hexacode" title="sage.combinat.abstract_tree.from_hexacode"><code class="xref py py-func docutils literal notranslate"><span class="pre">from_hexacode()</span></code></a> function.
(This function actually parametrizes ordered trees, and here
we make it parametrize unordered trees by forgetting the
ordering.)</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.abstract_tree</span> <span class="kn">import</span> <span class="n">from_hexacode</span>
<span class="gp">sage: </span><span class="n">RT</span> <span class="o">=</span> <span class="n">RootedTrees</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">from_hexacode</span><span class="p">(</span><span class="s1">&#39;32001010&#39;</span><span class="p">,</span> <span class="n">RT</span><span class="p">)</span>
<span class="go">[[[]], [[]], [[], []]]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unlike an ordered tree, an (unordered) rooted tree is a
multiset (rather than a list) of children. That is, two
ordered trees which differ from each other by switching
the order of children are equal to each other as (unordered)
rooted trees. Internally, rooted trees are encoded as
<a class="reference external" href="../../../structure/sage/structure/list_clone.html#sage.structure.list_clone.NormalizedClonableList" title="(in Sage Reference Manual: Parents and Elements v8.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.list_clone.NormalizedClonableList</span></code></a>
instances, and instead of storing their children as an
actual multiset, they store their children as a list which
is sorted according to their <a class="reference internal" href="#sage.combinat.rooted_tree.RootedTree.sort_key" title="sage.combinat.rooted_tree.RootedTree.sort_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_key()</span></code></a> value. This
is as good as storing them as multisets, since the
<a class="reference internal" href="#sage.combinat.rooted_tree.RootedTree.sort_key" title="sage.combinat.rooted_tree.RootedTree.sort_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_key()</span></code></a> values are sortable and distinguish
different (unordered) trees. However, if you wish to define
a subclass of <a class="reference internal" href="#sage.combinat.rooted_tree.RootedTree" title="sage.combinat.rooted_tree.RootedTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">RootedTree</span></code></a> which implements rooted
trees with extra structure (say, a class of edge-colored
rooted trees, or a class of rooted trees with a cyclic
order on the list of children), then the inherited
<a class="reference internal" href="#sage.combinat.rooted_tree.RootedTree.sort_key" title="sage.combinat.rooted_tree.RootedTree.sort_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_key()</span></code></a> method will no longer distinguish different
trees (and, as a consequence, equal trees will be regarded
as distinct). Thus, you will have to override the method by
one that does distinguish different trees.</p>
</div>
<dl class="method">
<dt id="sage.combinat.rooted_tree.RootedTree.graft_list">
<code class="descname">graft_list</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTree.graft_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of trees obtained by grafting <code class="docutils literal notranslate"><span class="pre">other</span></code> on <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Here grafting means that one takes the disjoint union of
<code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>, chooses a node of <code class="docutils literal notranslate"><span class="pre">self</span></code>,
and adds the root of <code class="docutils literal notranslate"><span class="pre">other</span></code> to the list of children of
this node. The root of the resulting tree is the root of
<code class="docutils literal notranslate"><span class="pre">self</span></code>. (This can be done for each node of <code class="docutils literal notranslate"><span class="pre">self</span></code>;
this method returns the list of all results.)</p>
<p>This is useful for free pre-Lie algebras.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RT</span> <span class="o">=</span> <span class="n">RootedTree</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">RT</span><span class="p">([])</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">RT</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">graft_list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[[]]]</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">graft_list</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="n">l</span>
<span class="go">[[[], [], []], [[], [[]]], [[], [[]]]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">parent</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span><span class="p">]</span>
<span class="go">[Rooted trees, Rooted trees, Rooted trees]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.rooted_tree.RootedTree.graft_on_root">
<code class="descname">graft_on_root</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTree.graft_on_root" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tree obtained by grafting <code class="docutils literal notranslate"><span class="pre">other</span></code> on the root of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Here grafting means that one takes the disjoint union of
<code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>, and adds the root of <code class="docutils literal notranslate"><span class="pre">other</span></code> to
the list of children of <code class="docutils literal notranslate"><span class="pre">self</span></code>. The root of the resulting
tree is the root of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This is useful for free Nap algebras.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RT</span> <span class="o">=</span> <span class="n">RootedTree</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">RT</span><span class="p">([])</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">RT</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">graft_on_root</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[]]</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">graft_on_root</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[], [], []]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">graft_on_root</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">[[[], []]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.rooted_tree.RootedTree.is_empty">
<code class="descname">is_empty</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTree.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if <code class="docutils literal notranslate"><span class="pre">self</span></code> is the empty tree.</p>
<p>For rooted trees, this always returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is not the same as <code class="docutils literal notranslate"><span class="pre">bool(t)</span></code>, which returns whether
<code class="docutils literal notranslate"><span class="pre">t</span></code> has some child or not.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">RootedTrees</span><span class="p">(</span><span class="mi">4</span><span class="p">)([[],[[]]])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">bool</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">RootedTrees</span><span class="p">(</span><span class="mi">1</span><span class="p">)([])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">bool</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.rooted_tree.RootedTree.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTree.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This function is at the core of the implementation of rooted
(unordered) trees. The underlying structure is provided by
ordered rooted trees. Every rooted tree is represented by a
normalized element in the set of its planar embeddings.</p>
<p>There should be no need to call <code class="docutils literal notranslate"><span class="pre">normalize</span></code> directly as it
is called automatically upon creation and cloning or
modification (by <code class="docutils literal notranslate"><span class="pre">NormalizedClonableList</span></code>).</p>
<p>The normalization has a recursive definition. It means first
that every sub-tree is itself normalized, and also that
sub-trees are sorted. Here the sort is performed according to
the values of the <a class="reference internal" href="#sage.combinat.rooted_tree.RootedTree.sort_key" title="sage.combinat.rooted_tree.RootedTree.sort_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_key()</span></code></a> method.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RT</span> <span class="o">=</span> <span class="n">RootedTree</span>
<span class="gp">sage: </span><span class="n">RT</span><span class="p">([[],[[]]])</span> <span class="o">==</span> <span class="n">RT</span><span class="p">([[[]],[]])</span>  <span class="c1"># indirect doctest</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">rt1</span> <span class="o">=</span> <span class="n">RT</span><span class="p">([[],[[]]])</span>
<span class="gp">sage: </span><span class="n">rt2</span> <span class="o">=</span> <span class="n">RT</span><span class="p">([[[]],[]])</span>
<span class="gp">sage: </span><span class="n">rt1</span> <span class="ow">is</span> <span class="n">rt2</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">rt1</span> <span class="o">==</span> <span class="n">rt2</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">rt1</span><span class="o">.</span><span class="n">_get_list</span><span class="p">()</span> <span class="o">==</span> <span class="n">rt2</span><span class="o">.</span><span class="n">_get_list</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.rooted_tree.RootedTree.single_graft">
<code class="descname">single_graft</code><span class="sig-paren">(</span><em>x</em>, <em>grafting_function</em>, <em>path_prefix=()</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTree.single_graft" title="Permalink to this definition">¶</a></dt>
<dd><p>Graft subtrees of <span class="math notranslate nohighlight">\(x\)</span> on <code class="docutils literal notranslate"><span class="pre">self</span></code> using the given function.</p>
<p>Let <span class="math notranslate nohighlight">\(x_1, x_2, \ldots, x_p\)</span> be the children of the root of
<span class="math notranslate nohighlight">\(x\)</span>. For each <span class="math notranslate nohighlight">\(i\)</span>, the subtree of <span class="math notranslate nohighlight">\(x\)</span> comprising all
descendants of <span class="math notranslate nohighlight">\(x_i\)</span> is joined by a new edge to
the vertex of <code class="docutils literal notranslate"><span class="pre">self</span></code> specified by the <span class="math notranslate nohighlight">\(i\)</span>-th path in the
grafting function (i.e., by the path
<code class="docutils literal notranslate"><span class="pre">grafting_function[i]</span></code>).</p>
<p>The number of vertices of the result is the sum of the numbers
of vertices of <code class="docutils literal notranslate"><span class="pre">self</span></code> and <span class="math notranslate nohighlight">\(x\)</span> minus one, because the root of
<span class="math notranslate nohighlight">\(x\)</span> is not used.</p>
<p>This is used to define the product of the Grossman-Larson algebras.</p>
<p>INPUT:</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\(x\)</span> – a rooted tree</li>
<li><code class="docutils literal notranslate"><span class="pre">grafting_function</span></code> – a list of paths in <code class="docutils literal notranslate"><span class="pre">self</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">path_prefix</span></code> – optional tuple (default <code class="docutils literal notranslate"><span class="pre">()</span></code>)</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">path_prefix</span></code> argument is only used for internal recursion.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">LT</span> <span class="o">=</span> <span class="n">LabelledRootedTrees</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">LT</span><span class="p">([</span><span class="n">LT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">LT</span><span class="p">([</span><span class="n">LT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">single_graft</span><span class="p">(</span><span class="n">x</span><span class="p">,[(</span><span class="mi">0</span><span class="p">,)])</span>
<span class="go">a[b[d[]]]</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">LT</span><span class="p">([</span><span class="n">LT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">),</span><span class="n">LT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;c&#39;</span><span class="p">)],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">LT</span><span class="p">([</span><span class="n">LT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">),</span><span class="n">LT</span><span class="p">([],</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">single_graft</span><span class="p">(</span><span class="n">s</span><span class="p">,[(</span><span class="mi">0</span><span class="p">,),(</span><span class="mi">1</span><span class="p">,)])</span>
<span class="go">a[b[d[]], c[e[]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.rooted_tree.RootedTree.sort_key">
<code class="descname">sort_key</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTree.sort_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple of nonnegative integers encoding the rooted
tree <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The first entry of the tuple is the number of children of the
root. Then the rest of the tuple is obtained as follows: List
the tuples corresponding to all children (we are regarding the
children themselves as trees). Order this list (not the
tuples!) in lexicographically increasing order, and flatten
it into a single tuple.</p>
<p>This tuple characterizes the rooted tree uniquely, and can be
used to sort the rooted trees.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The tree <code class="docutils literal notranslate"><span class="pre">self</span></code> must be normalized before calling this
method (see <a class="reference internal" href="#sage.combinat.rooted_tree.RootedTree.normalize" title="sage.combinat.rooted_tree.RootedTree.normalize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">normalize()</span></code></a>). This doesn’t matter
unless you are inside the <code class="xref py py-meth docutils literal notranslate"><span class="pre">clone()</span></code> context manager,
because outside of it every rooted tree is already
normalized.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">By default, this method does not encode any extra
structure that <code class="docutils literal notranslate"><span class="pre">self</span></code> might have. If you have a subclass
inheriting from <a class="reference internal" href="#sage.combinat.rooted_tree.RootedTree" title="sage.combinat.rooted_tree.RootedTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">RootedTree</span></code></a> which allows for some
extra structure, you need to override <a class="reference internal" href="#sage.combinat.rooted_tree.RootedTree.sort_key" title="sage.combinat.rooted_tree.RootedTree.sort_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_key()</span></code></a> in
order to preserve this structure (for example, the
<a class="reference internal" href="#sage.combinat.rooted_tree.LabelledRootedTree" title="sage.combinat.rooted_tree.LabelledRootedTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">LabelledRootedTree</span></code></a> class does this in
<a class="reference internal" href="#sage.combinat.rooted_tree.LabelledRootedTree.sort_key" title="sage.combinat.rooted_tree.LabelledRootedTree.sort_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LabelledRootedTree.sort_key()</span></code></a>). See the note in the
docstring of
<a class="reference internal" href="ordered_tree.html#sage.combinat.ordered_tree.OrderedTree.sort_key" title="sage.combinat.ordered_tree.OrderedTree.sort_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.combinat.ordered_tree.OrderedTree.sort_key()</span></code></a>
for a pitfall.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RT</span> <span class="o">=</span> <span class="n">RootedTree</span>
<span class="gp">sage: </span><span class="n">RT</span><span class="p">([[],[[]]])</span><span class="o">.</span><span class="n">sort_key</span><span class="p">()</span>
<span class="go">(2, 0, 1, 0)</span>
<span class="gp">sage: </span><span class="n">RT</span><span class="p">([[[]],[]])</span><span class="o">.</span><span class="n">sort_key</span><span class="p">()</span>
<span class="go">(2, 0, 1, 0)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.rooted_tree.RootedTrees">
<em class="property">class </em><code class="descclassname">sage.combinat.rooted_tree.</code><code class="descname">RootedTrees</code><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage Reference Manual: Parents and Elements v8.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></code></a>, <a class="reference external" href="../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Parents and Elements v8.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>Factory class for rooted trees.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">size</span></code> – (optional) an integer</li>
</ul>
<p>OUTPUT:</p>
<p>the set of all rooted trees (of the given size <code class="docutils literal notranslate"><span class="pre">size</span></code> if
specified)</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RootedTrees</span><span class="p">()</span>
<span class="go">Rooted trees</span>

<span class="gp">sage: </span><span class="n">RootedTrees</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Rooted trees with 2 nodes</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.combinat.rooted_tree.RootedTrees_all">
<em class="property">class </em><code class="descclassname">sage.combinat.rooted_tree.</code><code class="descname">RootedTrees_all</code><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTrees_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../sets/sage/sets/disjoint_union_enumerated_sets.html#sage.sets.disjoint_union_enumerated_sets.DisjointUnionEnumeratedSets" title="(in Sage Reference Manual: Sets v8.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.sets.disjoint_union_enumerated_sets.DisjointUnionEnumeratedSets</span></code></a>, <a class="reference internal" href="#sage.combinat.rooted_tree.RootedTrees" title="sage.combinat.rooted_tree.RootedTrees"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.rooted_tree.RootedTrees</span></code></a></p>
<p>Class of all (unordered, unlabelled) rooted trees.</p>
<p>See <a class="reference internal" href="#sage.combinat.rooted_tree.RootedTree" title="sage.combinat.rooted_tree.RootedTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">RootedTree</span></code></a> for a definition.</p>
<dl class="attribute">
<dt id="sage.combinat.rooted_tree.RootedTrees_all.Element">
<code class="descname">Element</code><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTrees_all.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.rooted_tree.RootedTree" title="sage.combinat.rooted_tree.RootedTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">RootedTree</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.rooted_tree.RootedTrees_all.labelled_trees">
<code class="descname">labelled_trees</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTrees_all.labelled_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of labelled trees associated to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RootedTrees</span><span class="p">()</span><span class="o">.</span><span class="n">labelled_trees</span><span class="p">()</span>
<span class="go">Labelled rooted trees</span>
</pre></div>
</div>
<p>As a consequence:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">lb</span> <span class="o">=</span> <span class="n">RootedTrees</span><span class="p">()([[],[[],</span> <span class="p">[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">lb</span>
<span class="go">1[2[], 3[4[], 5[]]]</span>
<span class="gp">sage: </span><span class="n">lb</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;class &#39;sage.combinat.rooted_tree.LabelledRootedTrees_all_with_category.element_class&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">lb</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Labelled rooted trees</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.rooted_tree.RootedTrees_all.leaf">
<code class="descname">leaf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTrees_all.leaf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a leaf tree with <code class="docutils literal notranslate"><span class="pre">self</span></code> as parent.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RootedTrees</span><span class="p">()</span><span class="o">.</span><span class="n">leaf</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.rooted_tree.RootedTrees_all.unlabelled_trees">
<code class="descname">unlabelled_trees</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTrees_all.unlabelled_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of unlabelled trees associated to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RootedTrees</span><span class="p">()</span><span class="o">.</span><span class="n">unlabelled_trees</span><span class="p">()</span>
<span class="go">Rooted trees</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.rooted_tree.RootedTrees_size">
<em class="property">class </em><code class="descclassname">sage.combinat.rooted_tree.</code><code class="descname">RootedTrees_size</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTrees_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.rooted_tree.RootedTrees" title="sage.combinat.rooted_tree.RootedTrees"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.rooted_tree.RootedTrees</span></code></a></p>
<p>The enumerated set of rooted trees with a given number of nodes.</p>
<p>The number of nodes of a rooted tree is defined recursively:
The number of nodes of a rooted tree with <span class="math notranslate nohighlight">\(a\)</span> children is <span class="math notranslate nohighlight">\(a\)</span>
plus the sum of the number of nodes of each of these children.</p>
<dl class="method">
<dt id="sage.combinat.rooted_tree.RootedTrees_size.cardinality">
<code class="descname">cardinality</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTrees_size.cardinality" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cardinality of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RootedTrees</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">RootedTrees</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.rooted_tree.RootedTrees_size.check_element">
<code class="descname">check_element</code><span class="sig-paren">(</span><em>el</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTrees_size.check_element" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that a given tree actually belongs to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This just checks the number of vertices.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RT3</span> <span class="o">=</span> <span class="n">RootedTrees</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RT3</span><span class="p">([[],[]])</span>     <span class="c1"># indirect doctest</span>
<span class="go">[[], []]</span>
<span class="gp">sage: </span><span class="n">RT3</span><span class="p">([[],[],[]])</span>  <span class="c1"># indirect doctest</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: wrong number of nodes</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.rooted_tree.RootedTrees_size.element_class">
<code class="descname">element_class</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.RootedTrees_size.element_class" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.combinat.rooted_tree.number_of_rooted_trees">
<code class="descclassname">sage.combinat.rooted_tree.</code><code class="descname">number_of_rooted_trees</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.rooted_tree.number_of_rooted_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of rooted trees with <span class="math notranslate nohighlight">\(n\)</span> nodes.</p>
<p>Compute the number <span class="math notranslate nohighlight">\(a(n)\)</span> of rooted trees with <span class="math notranslate nohighlight">\(n\)</span> nodes using the
recursive formula (<a class="reference internal" href="#sl000081" id="id1">[SL000081]</a>):</p>
<div class="math notranslate nohighlight">
\[a(n+1) = \frac{1}{n} \sum_{k=1}^{n} \left( \sum_{d|k} d a(d) \right) a(n-k+1)\]</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.rooted_tree</span> <span class="kn">import</span> <span class="n">number_of_rooted_trees</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">number_of_rooted_trees</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[0, 1, 1, 2, 4, 9, 20, 48, 115, 286]</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="sl000081" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[SL000081]</a></td><td>Sloane’s <a class="reference external" href="https://oeis.org/A000081">OEIS sequence A000081</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="root_system/weyl_group.html"
                        title="previous chapter">Weyl Groups</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="rsk.html"
                        title="next chapter">Robinson-Schensted-Knuth correspondence</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/combinat/rooted_tree.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="rsk.html" title="Robinson-Schensted-Knuth correspondence"
             >next</a> |</li>
        <li class="right" >
          <a href="root_system/weyl_group.html" title="Weyl Groups"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Combinatorics</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../module_list.html" >Comprehensive Module list</a> &#187;</li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2019, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>