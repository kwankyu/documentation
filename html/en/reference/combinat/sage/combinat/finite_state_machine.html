
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Finite State Machines, Automata, Transducers &#8212; Sage Reference Manual v8.1: Combinatorics</title>
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '8.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Common Automata and Transducers (Finite State Machines Generators)" href="finite_state_machine_generators.html" />
    <link rel="prev" title="Finite combinatorial classes" href="finite_class.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="finite_state_machine_generators.html" title="Common Automata and Transducers (Finite State Machines Generators)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="finite_class.html" title="Finite combinatorial classes"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Combinatorics</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../module_list.html" accesskey="U">Comprehensive Module list</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="finite-state-machines-automata-transducers">
<span id="sage-combinat-finite-state-machine"></span><h1>Finite State Machines, Automata, Transducers<a class="headerlink" href="#finite-state-machines-automata-transducers" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.finite_state_machine"></span><p>This module adds support for finite state machines, automata and
transducers.</p>
<p>For creating automata and transducers you can use classes</p>
<ul class="simple">
<li><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton" title="sage.combinat.finite_state_machine.Automaton"><code class="xref py py-class docutils literal"><span class="pre">Automaton</span></code></a> and <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer" title="sage.combinat.finite_state_machine.Transducer"><code class="xref py py-class docutils literal"><span class="pre">Transducer</span></code></a>
(or the more general class <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>)</li>
</ul>
<p>or the generators</p>
<ul class="simple">
<li><a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.AutomatonGenerators" title="sage.combinat.finite_state_machine_generators.AutomatonGenerators"><code class="xref py py-class docutils literal"><span class="pre">automata</span></code></a> and
<a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.TransducerGenerators" title="sage.combinat.finite_state_machine_generators.TransducerGenerators"><code class="xref py py-class docutils literal"><span class="pre">transducers</span></code></a></li>
</ul>
<p>which contain <a class="reference internal" href="finite_state_machine_generators.html"><span class="doc">preconstructed and commonly used automata and transducers</span></a>. See also the
<a class="reference internal" href="#finite-state-machine-examples"><span class="std std-ref">examples</span></a> below.</p>
<div class="section" id="contents">
<h2>Contents<a class="headerlink" href="#contents" title="Permalink to this headline">¶</a></h2>
<div class="section" id="finitestatemachine-and-derived-classes-transducer-and-automaton">
<h3><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a> and derived classes <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer" title="sage.combinat.finite_state_machine.Transducer"><code class="xref py py-class docutils literal"><span class="pre">Transducer</span></code></a> and <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton" title="sage.combinat.finite_state_machine.Automaton"><code class="xref py py-class docutils literal"><span class="pre">Automaton</span></code></a><a class="headerlink" href="#finitestatemachine-and-derived-classes-transducer-and-automaton" title="Permalink to this headline">¶</a></h3>
<div class="section" id="accessing-parts-of-a-finite-state-machine">
<h4>Accessing parts of a finite state machine<a class="headerlink" href="#accessing-parts-of-a-finite-state-machine" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.state" title="sage.combinat.finite_state_machine.FiniteStateMachine.state"><code class="xref py py-meth docutils literal"><span class="pre">state()</span></code></a></td>
<td>Get a state by its label</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.states" title="sage.combinat.finite_state_machine.FiniteStateMachine.states"><code class="xref py py-meth docutils literal"><span class="pre">states()</span></code></a></td>
<td>List of states</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_states" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_states"><code class="xref py py-meth docutils literal"><span class="pre">iter_states()</span></code></a></td>
<td>Iterator over the states</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.initial_states" title="sage.combinat.finite_state_machine.FiniteStateMachine.initial_states"><code class="xref py py-meth docutils literal"><span class="pre">initial_states()</span></code></a></td>
<td>List of initial states</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_initial_states" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_initial_states"><code class="xref py py-meth docutils literal"><span class="pre">iter_initial_states()</span></code></a></td>
<td>Iterator over initial states</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.final_states" title="sage.combinat.finite_state_machine.FiniteStateMachine.final_states"><code class="xref py py-meth docutils literal"><span class="pre">final_states()</span></code></a></td>
<td>List of final states</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_final_states" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_final_states"><code class="xref py py-meth docutils literal"><span class="pre">iter_final_states()</span></code></a></td>
<td>Iterator over final states</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.transition" title="sage.combinat.finite_state_machine.FiniteStateMachine.transition"><code class="xref py py-meth docutils literal"><span class="pre">transition()</span></code></a></td>
<td>Get a transition by its states and labels</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.transitions" title="sage.combinat.finite_state_machine.FiniteStateMachine.transitions"><code class="xref py py-meth docutils literal"><span class="pre">transitions()</span></code></a></td>
<td>List of transitions</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_transitions" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_transitions"><code class="xref py py-meth docutils literal"><span class="pre">iter_transitions()</span></code></a></td>
<td>Iterator over the transitions</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.predecessors" title="sage.combinat.finite_state_machine.FiniteStateMachine.predecessors"><code class="xref py py-meth docutils literal"><span class="pre">predecessors()</span></code></a></td>
<td>List of predecessors of a state</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.induced_sub_finite_state_machine" title="sage.combinat.finite_state_machine.FiniteStateMachine.induced_sub_finite_state_machine"><code class="xref py py-meth docutils literal"><span class="pre">induced_sub_finite_state_machine()</span></code></a></td>
<td>Induced sub-machine</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components"><code class="xref py py-meth docutils literal"><span class="pre">accessible_components()</span></code></a></td>
<td>Accessible components</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.coaccessible_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.coaccessible_components"><code class="xref py py-meth docutils literal"><span class="pre">coaccessible_components()</span></code></a></td>
<td>Coaccessible components</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.final_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.final_components"><code class="xref py py-meth docutils literal"><span class="pre">final_components()</span></code></a></td>
<td>Final components (connected components which cannot be left again)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="modified-copies">
<h4>(Modified) Copies<a class="headerlink" href="#modified-copies" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.empty_copy" title="sage.combinat.finite_state_machine.FiniteStateMachine.empty_copy"><code class="xref py py-meth docutils literal"><span class="pre">empty_copy()</span></code></a></td>
<td>Returns an empty deep copy</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.deepcopy" title="sage.combinat.finite_state_machine.FiniteStateMachine.deepcopy"><code class="xref py py-meth docutils literal"><span class="pre">deepcopy()</span></code></a></td>
<td>Returns a deep copy</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.relabeled" title="sage.combinat.finite_state_machine.FiniteStateMachine.relabeled"><code class="xref py py-meth docutils literal"><span class="pre">relabeled()</span></code></a></td>
<td>Returns a relabeled deep copy</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.with_output" title="sage.combinat.finite_state_machine.Automaton.with_output"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.with_output()</span></code></a></td>
<td>Extends an automaton to a transducer</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="manipulation">
<h4>Manipulation<a class="headerlink" href="#manipulation" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_state" title="sage.combinat.finite_state_machine.FiniteStateMachine.add_state"><code class="xref py py-meth docutils literal"><span class="pre">add_state()</span></code></a></td>
<td>Add a state</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_states" title="sage.combinat.finite_state_machine.FiniteStateMachine.add_states"><code class="xref py py-meth docutils literal"><span class="pre">add_states()</span></code></a></td>
<td>Add states</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.delete_state" title="sage.combinat.finite_state_machine.FiniteStateMachine.delete_state"><code class="xref py py-meth docutils literal"><span class="pre">delete_state()</span></code></a></td>
<td>Delete a state</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_transition" title="sage.combinat.finite_state_machine.FiniteStateMachine.add_transition"><code class="xref py py-meth docutils literal"><span class="pre">add_transition()</span></code></a></td>
<td>Add a transition</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_transitions_from_function" title="sage.combinat.finite_state_machine.FiniteStateMachine.add_transitions_from_function"><code class="xref py py-meth docutils literal"><span class="pre">add_transitions_from_function()</span></code></a></td>
<td>Add transitions</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.input_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.input_alphabet"><code class="xref py py-attr docutils literal"><span class="pre">input_alphabet</span></code></a></td>
<td>Input alphabet</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.output_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.output_alphabet"><code class="xref py py-attr docutils literal"><span class="pre">output_alphabet</span></code></a></td>
<td>Output alphabet</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition" title="sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition"><code class="xref py py-attr docutils literal"><span class="pre">on_duplicate_transition</span></code></a></td>
<td>Hook for handling duplicate transitions</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_from_transition_function" title="sage.combinat.finite_state_machine.FiniteStateMachine.add_from_transition_function"><code class="xref py py-meth docutils literal"><span class="pre">add_from_transition_function()</span></code></a></td>
<td>Add transitions by a transition function</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.delete_transition" title="sage.combinat.finite_state_machine.FiniteStateMachine.delete_transition"><code class="xref py py-meth docutils literal"><span class="pre">delete_transition()</span></code></a></td>
<td>Delete a transition</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.remove_epsilon_transitions" title="sage.combinat.finite_state_machine.FiniteStateMachine.remove_epsilon_transitions"><code class="xref py py-meth docutils literal"><span class="pre">remove_epsilon_transitions()</span></code></a></td>
<td>Remove epsilon transitions (not implemented)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.split_transitions" title="sage.combinat.finite_state_machine.FiniteStateMachine.split_transitions"><code class="xref py py-meth docutils literal"><span class="pre">split_transitions()</span></code></a></td>
<td>Split transitions with input words of length <code class="docutils literal"><span class="pre">&gt;</span> <span class="pre">1</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a></td>
<td>Determine input and output alphabets</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_input_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_input_alphabet"><code class="xref py py-meth docutils literal"><span class="pre">determine_input_alphabet()</span></code></a></td>
<td>Determine input alphabet</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_output_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_output_alphabet"><code class="xref py py-meth docutils literal"><span class="pre">determine_output_alphabet()</span></code></a></td>
<td>Determine output alphabet</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out"><code class="xref py py-meth docutils literal"><span class="pre">construct_final_word_out()</span></code></a></td>
<td>Construct final output by implicitly reading trailing letters; cf. <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out"><code class="xref py py-meth docutils literal"><span class="pre">with_final_word_out()</span></code></a></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="properties">
<h4>Properties<a class="headerlink" href="#properties" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_state" title="sage.combinat.finite_state_machine.FiniteStateMachine.has_state"><code class="xref py py-meth docutils literal"><span class="pre">has_state()</span></code></a></td>
<td>Checks for a state</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_initial_state" title="sage.combinat.finite_state_machine.FiniteStateMachine.has_initial_state"><code class="xref py py-meth docutils literal"><span class="pre">has_initial_state()</span></code></a></td>
<td>Checks for an initial state</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_initial_states" title="sage.combinat.finite_state_machine.FiniteStateMachine.has_initial_states"><code class="xref py py-meth docutils literal"><span class="pre">has_initial_states()</span></code></a></td>
<td>Checks for initial states</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_final_state" title="sage.combinat.finite_state_machine.FiniteStateMachine.has_final_state"><code class="xref py py-meth docutils literal"><span class="pre">has_final_state()</span></code></a></td>
<td>Checks for an final state</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_final_states" title="sage.combinat.finite_state_machine.FiniteStateMachine.has_final_states"><code class="xref py py-meth docutils literal"><span class="pre">has_final_states()</span></code></a></td>
<td>Checks for final states</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_transition" title="sage.combinat.finite_state_machine.FiniteStateMachine.has_transition"><code class="xref py py-meth docutils literal"><span class="pre">has_transition()</span></code></a></td>
<td>Checks for a transition</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_deterministic" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_deterministic"><code class="xref py py-meth docutils literal"><span class="pre">is_deterministic()</span></code></a></td>
<td>Checks for a deterministic machine</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_complete" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_complete"><code class="xref py py-meth docutils literal"><span class="pre">is_complete()</span></code></a></td>
<td>Checks for a complete machine</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_connected" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_connected"><code class="xref py py-meth docutils literal"><span class="pre">is_connected()</span></code></a></td>
<td>Checks for a connected machine</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.is_equivalent" title="sage.combinat.finite_state_machine.Automaton.is_equivalent"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.is_equivalent()</span></code></a></td>
<td>Checks for equivalent automata</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_Markov_chain" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_Markov_chain"><code class="xref py py-meth docutils literal"><span class="pre">is_Markov_chain()</span></code></a></td>
<td>Checks for a Markov chain</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_monochromatic" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_monochromatic"><code class="xref py py-meth docutils literal"><span class="pre">is_monochromatic()</span></code></a></td>
<td>Checks whether the colors of all states are equal</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.number_of_words" title="sage.combinat.finite_state_machine.FiniteStateMachine.number_of_words"><code class="xref py py-meth docutils literal"><span class="pre">number_of_words()</span></code></a></td>
<td>Determine the number of successful paths</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.asymptotic_moments" title="sage.combinat.finite_state_machine.FiniteStateMachine.asymptotic_moments"><code class="xref py py-meth docutils literal"><span class="pre">asymptotic_moments()</span></code></a></td>
<td>Main terms of expectation and variance of sums of labels</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.moments_waiting_time" title="sage.combinat.finite_state_machine.FiniteStateMachine.moments_waiting_time"><code class="xref py py-meth docutils literal"><span class="pre">moments_waiting_time()</span></code></a></td>
<td>Moments of the waiting time for first true output</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.epsilon_successors" title="sage.combinat.finite_state_machine.FiniteStateMachine.epsilon_successors"><code class="xref py py-meth docutils literal"><span class="pre">epsilon_successors()</span></code></a></td>
<td>Epsilon successors of a state</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.shannon_parry_markov_chain" title="sage.combinat.finite_state_machine.Automaton.shannon_parry_markov_chain"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.shannon_parry_markov_chain()</span></code></a></td>
<td>Compute Markov chain with Parry measure</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="operations">
<h4>Operations<a class="headerlink" href="#operations" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.disjoint_union" title="sage.combinat.finite_state_machine.FiniteStateMachine.disjoint_union"><code class="xref py py-meth docutils literal"><span class="pre">disjoint_union()</span></code></a></td>
<td>Disjoint union</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.concatenation" title="sage.combinat.finite_state_machine.FiniteStateMachine.concatenation"><code class="xref py py-meth docutils literal"><span class="pre">concatenation()</span></code></a></td>
<td>Concatenation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.kleene_star" title="sage.combinat.finite_state_machine.FiniteStateMachine.kleene_star"><code class="xref py py-meth docutils literal"><span class="pre">kleene_star()</span></code></a></td>
<td>Kleene star</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.complement" title="sage.combinat.finite_state_machine.Automaton.complement"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.complement()</span></code></a></td>
<td>Complement of an automaton</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.intersection" title="sage.combinat.finite_state_machine.Automaton.intersection"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.intersection()</span></code></a></td>
<td>Intersection of automata</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.intersection" title="sage.combinat.finite_state_machine.Transducer.intersection"><code class="xref py py-meth docutils literal"><span class="pre">Transducer.intersection()</span></code></a></td>
<td>Intersection of transducers</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.cartesian_product" title="sage.combinat.finite_state_machine.Transducer.cartesian_product"><code class="xref py py-meth docutils literal"><span class="pre">Transducer.cartesian_product()</span></code></a></td>
<td>Cartesian product of a transducer with another finite state machine</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.product_FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine.product_FiniteStateMachine"><code class="xref py py-meth docutils literal"><span class="pre">product_FiniteStateMachine()</span></code></a></td>
<td>Product of finite state machines</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.composition" title="sage.combinat.finite_state_machine.FiniteStateMachine.composition"><code class="xref py py-meth docutils literal"><span class="pre">composition()</span></code></a></td>
<td>Composition (output of other is input of self)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a></td>
<td>Composition with other finite state machine</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.input_projection" title="sage.combinat.finite_state_machine.FiniteStateMachine.input_projection"><code class="xref py py-meth docutils literal"><span class="pre">input_projection()</span></code></a></td>
<td>Input projection (output is deleted)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.output_projection" title="sage.combinat.finite_state_machine.FiniteStateMachine.output_projection"><code class="xref py py-meth docutils literal"><span class="pre">output_projection()</span></code></a></td>
<td>Output projection (old output is new input)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.projection" title="sage.combinat.finite_state_machine.FiniteStateMachine.projection"><code class="xref py py-meth docutils literal"><span class="pre">projection()</span></code></a></td>
<td>Input or output projection</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.transposition" title="sage.combinat.finite_state_machine.FiniteStateMachine.transposition"><code class="xref py py-meth docutils literal"><span class="pre">transposition()</span></code></a></td>
<td>Transposition (all transitions are reversed)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out"><code class="xref py py-meth docutils literal"><span class="pre">with_final_word_out()</span></code></a></td>
<td>Machine with final output constructed by implicitly reading trailing letters, cf. <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out"><code class="xref py py-meth docutils literal"><span class="pre">construct_final_word_out()</span></code></a> for inplace version</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.determinisation" title="sage.combinat.finite_state_machine.Automaton.determinisation"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.determinisation()</span></code></a></td>
<td>Determinisation of an automaton</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.completion" title="sage.combinat.finite_state_machine.FiniteStateMachine.completion"><code class="xref py py-meth docutils literal"><span class="pre">completion()</span></code></a></td>
<td>Completion of a finite state machine</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">process()</span></code></a></td>
<td>Process input</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a></td>
<td>Process input with shortened output</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></code></a></td>
<td>Process input of an automaton (output differs from general case)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><code class="xref py py-meth docutils literal"><span class="pre">Transducer.process()</span></code></a></td>
<td>Process input of a transducer (output differs from general case)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><code class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></code></a></td>
<td>Return process iterator</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.language" title="sage.combinat.finite_state_machine.FiniteStateMachine.language"><code class="xref py py-meth docutils literal"><span class="pre">language()</span></code></a></td>
<td>Return all possible output words</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.language" title="sage.combinat.finite_state_machine.Automaton.language"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.language()</span></code></a></td>
<td>Return all possible accepted words</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="simplification">
<h4>Simplification<a class="headerlink" href="#simplification" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.prepone_output" title="sage.combinat.finite_state_machine.FiniteStateMachine.prepone_output"><code class="xref py py-meth docutils literal"><span class="pre">prepone_output()</span></code></a></td>
<td>Prepone output where possible</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.equivalence_classes" title="sage.combinat.finite_state_machine.FiniteStateMachine.equivalence_classes"><code class="xref py py-meth docutils literal"><span class="pre">equivalence_classes()</span></code></a></td>
<td>List of equivalent states</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.quotient" title="sage.combinat.finite_state_machine.FiniteStateMachine.quotient"><code class="xref py py-meth docutils literal"><span class="pre">quotient()</span></code></a></td>
<td>Quotient with respect to equivalence classes</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.merged_transitions" title="sage.combinat.finite_state_machine.FiniteStateMachine.merged_transitions"><code class="xref py py-meth docutils literal"><span class="pre">merged_transitions()</span></code></a></td>
<td>Merge transitions while adding input</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.markov_chain_simplification" title="sage.combinat.finite_state_machine.FiniteStateMachine.markov_chain_simplification"><code class="xref py py-meth docutils literal"><span class="pre">markov_chain_simplification()</span></code></a></td>
<td>Simplification of a Markov chain</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.minimization" title="sage.combinat.finite_state_machine.Automaton.minimization"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.minimization()</span></code></a></td>
<td>Minimization of an automaton</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.simplification" title="sage.combinat.finite_state_machine.Transducer.simplification"><code class="xref py py-meth docutils literal"><span class="pre">Transducer.simplification()</span></code></a></td>
<td>Simplification of a transducer</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="conversion">
<h4>Conversion<a class="headerlink" href="#conversion" title="Permalink to this headline">¶</a></h4>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.adjacency_matrix" title="sage.combinat.finite_state_machine.FiniteStateMachine.adjacency_matrix"><code class="xref py py-meth docutils literal"><span class="pre">adjacency_matrix()</span></code></a></td>
<td>(Weighted) adjacency <a class="reference external" href="../../../matrices/sage/matrix/constructor.html#sage.matrix.constructor.MatrixFactory" title="(in Sage Reference Manual: Matrices and Spaces of Matrices v8.1)"><code class="xref py py-class docutils literal"><span class="pre">matrix</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.graph" title="sage.combinat.finite_state_machine.FiniteStateMachine.graph"><code class="xref py py-meth docutils literal"><span class="pre">graph()</span></code></a></td>
<td>Underlying <a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v8.1)"><code class="xref py py-class docutils literal"><span class="pre">DiGraph</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.plot" title="sage.combinat.finite_state_machine.FiniteStateMachine.plot"><code class="xref py py-meth docutils literal"><span class="pre">plot()</span></code></a></td>
<td>Plot</td>
</tr>
</tbody>
</table>
<div class="section" id="latex-output">
<h5>LaTeX output<a class="headerlink" href="#latex-output" title="Permalink to this headline">¶</a></h5>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.latex_options" title="sage.combinat.finite_state_machine.FiniteStateMachine.latex_options"><code class="xref py py-meth docutils literal"><span class="pre">latex_options()</span></code></a></td>
<td>Set options</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.set_coordinates" title="sage.combinat.finite_state_machine.FiniteStateMachine.set_coordinates"><code class="xref py py-meth docutils literal"><span class="pre">set_coordinates()</span></code></a></td>
<td>Set coordinates of the states</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label" title="sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label"><code class="xref py py-meth docutils literal"><span class="pre">default_format_transition_label()</span></code></a></td>
<td>Default formatting of words in transition labels</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_letter_negative" title="sage.combinat.finite_state_machine.FiniteStateMachine.format_letter_negative"><code class="xref py py-meth docutils literal"><span class="pre">format_letter_negative()</span></code></a></td>
<td>Format negative numbers as overlined number</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label_reversed" title="sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label_reversed"><code class="xref py py-meth docutils literal"><span class="pre">format_transition_label_reversed()</span></code></a></td>
<td>Format words in transition labels in reversed order</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#finite-state-machine-latex-output"><span class="std std-ref">LaTeX output</span></a></p>
</div>
</div>
</div>
</div>
<div class="section" id="fsmstate">
<h3><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><code class="xref py py-class docutils literal"><span class="pre">FSMState</span></code></a><a class="headerlink" href="#fsmstate" title="Permalink to this headline">¶</a></h3>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.final_word_out" title="sage.combinat.finite_state_machine.FSMState.final_word_out"><code class="xref py py-attr docutils literal"><span class="pre">final_word_out</span></code></a></td>
<td>Final output of a state</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.is_final" title="sage.combinat.finite_state_machine.FSMState.is_final"><code class="xref py py-attr docutils literal"><span class="pre">is_final</span></code></a></td>
<td>Describes whether a state is final or not</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.is_initial" title="sage.combinat.finite_state_machine.FSMState.is_initial"><code class="xref py py-attr docutils literal"><span class="pre">is_initial</span></code></a></td>
<td>Describes whether a state is initial or not</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.initial_probability" title="sage.combinat.finite_state_machine.FSMState.initial_probability"><code class="xref py py-attr docutils literal"><span class="pre">initial_probability</span></code></a></td>
<td>Probability of starting in this state as part of a Markov chain</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.label" title="sage.combinat.finite_state_machine.FSMState.label"><code class="xref py py-meth docutils literal"><span class="pre">label()</span></code></a></td>
<td>Label of a state</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.relabeled" title="sage.combinat.finite_state_machine.FSMState.relabeled"><code class="xref py py-meth docutils literal"><span class="pre">relabeled()</span></code></a></td>
<td>Returns a relabeled deep copy of a state</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.fully_equal" title="sage.combinat.finite_state_machine.FSMState.fully_equal"><code class="xref py py-meth docutils literal"><span class="pre">fully_equal()</span></code></a></td>
<td>Checks whether two states are fully equal (including all attributes)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="fsmtransition">
<h3><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><code class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></code></a><a class="headerlink" href="#fsmtransition" title="Permalink to this headline">¶</a></h3>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition.from_state" title="sage.combinat.finite_state_machine.FSMTransition.from_state"><code class="xref py py-attr docutils literal"><span class="pre">from_state</span></code></a></td>
<td>State in which transition starts</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition.to_state" title="sage.combinat.finite_state_machine.FSMTransition.to_state"><code class="xref py py-attr docutils literal"><span class="pre">to_state</span></code></a></td>
<td>State in which transition ends</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition.word_in" title="sage.combinat.finite_state_machine.FSMTransition.word_in"><code class="xref py py-attr docutils literal"><span class="pre">word_in</span></code></a></td>
<td>Input word of the transition</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition.word_out" title="sage.combinat.finite_state_machine.FSMTransition.word_out"><code class="xref py py-attr docutils literal"><span class="pre">word_out</span></code></a></td>
<td>Output word of the transition</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition.deepcopy" title="sage.combinat.finite_state_machine.FSMTransition.deepcopy"><code class="xref py py-meth docutils literal"><span class="pre">deepcopy()</span></code></a></td>
<td>Returns a deep copy of the transition</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="fsmprocessiterator">
<h3><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a><a class="headerlink" href="#fsmprocessiterator" title="Permalink to this headline">¶</a></h3>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator.next" title="sage.combinat.finite_state_machine.FSMProcessIterator.next"><code class="xref py py-meth docutils literal"><span class="pre">next()</span></code></a></td>
<td>Makes one step in processing the input tape</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator.preview_word" title="sage.combinat.finite_state_machine.FSMProcessIterator.preview_word"><code class="xref py py-meth docutils literal"><span class="pre">preview_word()</span></code></a></td>
<td>Reads a word from the input tape</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator.result" title="sage.combinat.finite_state_machine.FSMProcessIterator.result"><code class="xref py py-meth docutils literal"><span class="pre">result()</span></code></a></td>
<td>Returns the finished branches during process</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="helper-functions">
<h3>Helper Functions<a class="headerlink" href="#helper-functions" title="Permalink to this headline">¶</a></h3>
<table border="1" class="colwidths-given contentstable docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.equal" title="sage.combinat.finite_state_machine.equal"><code class="xref py py-func docutils literal"><span class="pre">equal()</span></code></a></td>
<td>Checks whether all elements of <code class="docutils literal"><span class="pre">iterator</span></code> are equal</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.full_group_by" title="sage.combinat.finite_state_machine.full_group_by"><code class="xref py py-func docutils literal"><span class="pre">full_group_by()</span></code></a></td>
<td>Group iterable by values of some key</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.startswith" title="sage.combinat.finite_state_machine.startswith"><code class="xref py py-func docutils literal"><span class="pre">startswith()</span></code></a></td>
<td>Determine whether list starts with the given prefix</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMLetterSymbol" title="sage.combinat.finite_state_machine.FSMLetterSymbol"><code class="xref py py-func docutils literal"><span class="pre">FSMLetterSymbol()</span></code></a></td>
<td>Returns a string associated to the input letter</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.FSMWordSymbol" title="sage.combinat.finite_state_machine.FSMWordSymbol"><code class="xref py py-func docutils literal"><span class="pre">FSMWordSymbol()</span></code></a></td>
<td>Returns a string associated to a word</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.is_FSMState" title="sage.combinat.finite_state_machine.is_FSMState"><code class="xref py py-func docutils literal"><span class="pre">is_FSMState()</span></code></a></td>
<td>Tests whether an object inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><code class="xref py py-class docutils literal"><span class="pre">FSMState</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.is_FSMTransition" title="sage.combinat.finite_state_machine.is_FSMTransition"><code class="xref py py-func docutils literal"><span class="pre">is_FSMTransition()</span></code></a></td>
<td>Tests whether an object inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><code class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></code></a></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.is_FiniteStateMachine" title="sage.combinat.finite_state_machine.is_FiniteStateMachine"><code class="xref py py-func docutils literal"><span class="pre">is_FiniteStateMachine()</span></code></a></td>
<td>Tests whether an object inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.duplicate_transition_ignore" title="sage.combinat.finite_state_machine.duplicate_transition_ignore"><code class="xref py py-func docutils literal"><span class="pre">duplicate_transition_ignore()</span></code></a></td>
<td>Default function for handling duplicate transitions</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.duplicate_transition_raise_error" title="sage.combinat.finite_state_machine.duplicate_transition_raise_error"><code class="xref py py-func docutils literal"><span class="pre">duplicate_transition_raise_error()</span></code></a></td>
<td>Raise error when inserting a duplicate transition</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#sage.combinat.finite_state_machine.duplicate_transition_add_input" title="sage.combinat.finite_state_machine.duplicate_transition_add_input"><code class="xref py py-func docutils literal"><span class="pre">duplicate_transition_add_input()</span></code></a></td>
<td>Add input when inserting a duplicate transition</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="examples">
<span id="finite-state-machine-examples"></span><h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>We start with a general <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>. Later there will
be also an <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton" title="sage.combinat.finite_state_machine.Automaton"><code class="xref py py-class docutils literal"><span class="pre">Automaton</span></code></a> and a <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer" title="sage.combinat.finite_state_machine.Transducer"><code class="xref py py-class docutils literal"><span class="pre">Transducer</span></code></a>.</p>
<div class="section" id="a-simple-finite-state-machine">
<h3>A simple finite state machine<a class="headerlink" href="#a-simple-finite-state-machine" title="Permalink to this headline">¶</a></h3>
<p>We can easily create a finite state machine by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fsm</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">fsm</span>
<span class="go">Empty finite state machine</span>
</pre></div>
</div>
<p>By default this is the empty finite state machine, so not very
interesting. Let’s create and add some states and transitions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">day</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="s1">&#39;day&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">night</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="s1">&#39;night&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sunrise</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">night</span><span class="p">,</span> <span class="n">day</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sunset</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">day</span><span class="p">,</span> <span class="n">night</span><span class="p">)</span>
</pre></div>
</div>
<p>Let us look at <code class="docutils literal"><span class="pre">sunset</span></code> more closely:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sunset</span>
<span class="go">Transition from &#39;day&#39; to &#39;night&#39;: -|-</span>
</pre></div>
</div>
<p>Note that could also have created and added the transitions directly
by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="s1">&#39;day&#39;</span><span class="p">,</span> <span class="s1">&#39;night&#39;</span><span class="p">)</span>
<span class="go">Transition from &#39;day&#39; to &#39;night&#39;: -|-</span>
</pre></div>
</div>
<p>This would have had added the states automatically, since they are
present in the transitions.</p>
<p>Anyhow, we got the following finite state machine:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fsm</span>
<span class="go">Finite state machine with 2 states</span>
</pre></div>
</div>
<p>We can also obtain the underlying <a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v8.1)"><code class="xref py py-class docutils literal"><span class="pre">directed</span> <span class="pre">graph</span></code></a> by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 2 vertices</span>
</pre></div>
</div>
<p>To visualize a finite state machine, we can use
<a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.latex" title="(in Sage Reference Manual: Utilities v8.1)"><code class="xref py py-func docutils literal"><span class="pre">latex()</span></code></a> and run the result through LaTeX,
see the section on <a class="reference internal" href="#finite-state-machine-latex-output"><span class="std std-ref">LaTeX output</span></a>
below.</p>
<p>Alternatively, we could have created the finite state machine above
simply by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s1">&#39;night&#39;</span><span class="p">,</span> <span class="s1">&#39;day&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;day&#39;</span><span class="p">,</span> <span class="s1">&#39;night&#39;</span><span class="p">)])</span>
<span class="go">Finite state machine with 2 states</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a> for a lot of possibilities to create
finite state machines.</p>
</div>
<div class="section" id="a-simple-automaton-recognizing-nafs">
<span id="finite-state-machine-recognizing-nafs-example"></span><h3>A simple Automaton (recognizing NAFs)<a class="headerlink" href="#a-simple-automaton-recognizing-nafs" title="Permalink to this headline">¶</a></h3>
<p>We want to build an automaton which recognizes non-adjacent forms
(NAFs), i.e., sequences which have no adjacent non-zeros.
We use <span class="math">\(0\)</span>, <span class="math">\(1\)</span>, and <span class="math">\(-1\)</span> as digits:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">(</span>
<span class="go">....:     {&#39;A&#39;: [(&#39;A&#39;, 0), (&#39;B&#39;, 1), (&#39;B&#39;, -1)], &#39;B&#39;: [(&#39;A&#39;, 0)]})</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">NAF</span>
<span class="go">Automaton with 2 states</span>
</pre></div>
</div>
<p>Of course, we could have specified the initial and final states
directly in the definition of <code class="docutils literal"><span class="pre">NAF</span></code> by <code class="docutils literal"><span class="pre">initial_states=['A']</span></code> and
<code class="docutils literal"><span class="pre">final_states=['A',</span> <span class="pre">'B']</span></code>.</p>
<p>So let’s test the automaton with some input:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NAF</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Alternatively, we could call that by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(True, &#39;B&#39;)</span>
</pre></div>
</div>
<p>which gives additionally the state in which we arrived.</p>
<p>We can also let an automaton act on a <a class="reference internal" href="words/words.html"><span class="doc">word</span></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">Words</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span> <span class="n">W</span>
<span class="go">Finite and infinite words over {-1, 0, 1}</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">W</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]);</span> <span class="n">w</span>
<span class="go">word: 1,0,1,0,-1</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="section" id="recognizing-nafs-via-automata-operations">
<h4>Recognizing NAFs via Automata Operations<a class="headerlink" href="#recognizing-nafs-via-automata-operations" title="Permalink to this headline">¶</a></h4>
<p>Alternatively, we can use automata operations to recognize NAFs; for
simplicity, we only use the input alphabet <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">1]</span></code>. On the one
hand, we can construct such an automaton by forbidding the word
<code class="docutils literal"><span class="pre">11</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">forbidden</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">ContainsWord</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">input_alphabet</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">NAF_negative</span> <span class="o">=</span> <span class="n">forbidden</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">NAF_negative</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">NAF_negative</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>On the other hand, we can write this as a regular expression and
translate that into automata operations:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">zero</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">Word</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">one</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">Word</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">epsilon</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">EmptyWord</span><span class="p">(</span><span class="n">input_alphabet</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">NAF_positive</span> <span class="o">=</span> <span class="p">(</span><span class="n">zero</span> <span class="o">+</span> <span class="n">one</span><span class="o">*</span><span class="n">zero</span><span class="p">)</span><span class="o">.</span><span class="n">kleene_star</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">epsilon</span> <span class="o">+</span> <span class="n">one</span><span class="p">)</span>
</pre></div>
</div>
<p>We check that the two approaches are equivalent:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NAF_negative</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">NAF_positive</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.AutomatonGenerators.ContainsWord" title="sage.combinat.finite_state_machine_generators.AutomatonGenerators.ContainsWord"><code class="xref py py-meth docutils literal"><span class="pre">ContainsWord()</span></code></a>,
<a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.AutomatonGenerators.Word" title="sage.combinat.finite_state_machine_generators.AutomatonGenerators.Word"><code class="xref py py-meth docutils literal"><span class="pre">Word()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.complement" title="sage.combinat.finite_state_machine.Automaton.complement"><code class="xref py py-meth docutils literal"><span class="pre">complement()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.kleene_star" title="sage.combinat.finite_state_machine.FiniteStateMachine.kleene_star"><code class="xref py py-meth docutils literal"><span class="pre">kleene_star()</span></code></a>,
<a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.AutomatonGenerators.EmptyWord" title="sage.combinat.finite_state_machine_generators.AutomatonGenerators.EmptyWord"><code class="xref py py-meth docutils literal"><span class="pre">EmptyWord()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.is_equivalent" title="sage.combinat.finite_state_machine.Automaton.is_equivalent"><code class="xref py py-meth docutils literal"><span class="pre">is_equivalent()</span></code></a>.</p>
</div>
</div>
</div>
<div class="section" id="finite-state-machine-latex-output">
<span id="id1"></span><h3>LaTeX output<a class="headerlink" href="#finite-state-machine-latex-output" title="Permalink to this headline">¶</a></h3>
<p>We can visualize a finite state machine by converting it to LaTeX by
using the usual function <a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.latex" title="(in Sage Reference Manual: Utilities v8.1)"><code class="xref py py-func docutils literal"><span class="pre">latex()</span></code></a>. Within LaTeX,
TikZ is used for typesetting the graphics, see the
<a class="reference external" href="https://en.wikipedia.org/wiki/PGF/TikZ">Wikipedia article PGF/TikZ</a>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">latex</span><span class="p">(</span><span class="n">NAF</span><span class="p">))</span>
<span class="go">\begin{tikzpicture}[auto, initial text=, &gt;=latex]</span>
<span class="go">\node[state, accepting, initial] (v0) at (3.000000, 0.000000) {$\text{\texttt{A}}$};</span>
<span class="go">\node[state, accepting] (v1) at (-3.000000, 0.000000) {$\text{\texttt{B}}$};</span>
<span class="go">\path[-&gt;] (v0) edge[loop above] node {$0$} ();</span>
<span class="go">\path[-&gt;] (v0.185.00) edge node[rotate=360.00, anchor=north] {$1, -1$} (v1.355.00);</span>
<span class="go">\path[-&gt;] (v1.5.00) edge node[rotate=0.00, anchor=south] {$0$} (v0.175.00);</span>
<span class="go">\end{tikzpicture}</span>
</pre></div>
</div>
<p>We can turn this into a graphical representation.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">view</span><span class="p">(</span><span class="n">NAF</span><span class="p">)</span> <span class="c1"># not tested</span>
</pre></div>
</div>
<p>To actually see this, use the live documentation in the Sage notebook
and execute the cells in this and the previous section.</p>
<p>Several options can be set to customize the output, see
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.latex_options" title="sage.combinat.finite_state_machine.FiniteStateMachine.latex_options"><code class="xref py py-meth docutils literal"><span class="pre">latex_options()</span></code></a> for details. In particular,
we use <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_letter_negative" title="sage.combinat.finite_state_machine.FiniteStateMachine.format_letter_negative"><code class="xref py py-meth docutils literal"><span class="pre">format_letter_negative()</span></code></a> to format
<span class="math">\(-1\)</span> as <span class="math">\(\overline{1}\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span>
<span class="go">....:     coordinates={&#39;A&#39;: (0, 0),</span>
<span class="go">....:                  &#39;B&#39;: (6, 0)},</span>
<span class="go">....:     initial_where={&#39;A&#39;: &#39;below&#39;},</span>
<span class="go">....:     format_letter=NAF.format_letter_negative,</span>
<span class="go">....:     format_state_label=lambda x:</span>
<span class="go">....:         r&#39;\mathcal{%s}&#39; % x.label()</span>
<span class="go">....: )</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">latex</span><span class="p">(</span><span class="n">NAF</span><span class="p">))</span>
<span class="go">\begin{tikzpicture}[auto, initial text=, &gt;=latex]</span>
<span class="go">\node[state, accepting, initial, initial where=below] (v0) at (0.000000, 0.000000) {$\mathcal{A}$};</span>
<span class="go">\node[state, accepting] (v1) at (6.000000, 0.000000) {$\mathcal{B}$};</span>
<span class="go">\path[-&gt;] (v0) edge[loop above] node {$0$} ();</span>
<span class="go">\path[-&gt;] (v0.5.00) edge node[rotate=0.00, anchor=south] {$1, \overline{1}$} (v1.175.00);</span>
<span class="go">\path[-&gt;] (v1.185.00) edge node[rotate=360.00, anchor=north] {$0$} (v0.355.00);</span>
<span class="go">\end{tikzpicture}</span>
<span class="gp">sage: </span><span class="n">view</span><span class="p">(</span><span class="n">NAF</span><span class="p">)</span> <span class="c1"># not tested</span>
</pre></div>
</div>
<p>To use the output of <a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.latex" title="(in Sage Reference Manual: Utilities v8.1)"><code class="xref py py-func docutils literal"><span class="pre">latex()</span></code></a> in your own
<span class="math">\(\LaTeX\)</span> file, you have to include</p>
<div class="highlight-latex"><div class="highlight"><pre><span></span><span class="k">\usepackage</span><span class="nb">{</span>tikz<span class="nb">}</span>
<span class="k">\usetikzlibrary</span><span class="nb">{</span>automata<span class="nb">}</span>
</pre></div>
</div>
<p>into the preamble of your file.</p>
</div>
<div class="section" id="a-simple-transducer-binary-inverter">
<h3>A simple transducer (binary inverter)<a class="headerlink" href="#a-simple-transducer-binary-inverter" title="Permalink to this headline">¶</a></h3>
<p>Let’s build a simple transducer, which rewrites a binary word by
iverting each bit:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
</pre></div>
</div>
<p>We can look at the states and transitions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">inverter</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">inverter</span><span class="o">.</span><span class="n">transitions</span><span class="p">():</span>
<span class="go">....:     print(t)</span>
<span class="go">Transition from &#39;A&#39; to &#39;A&#39;: 0|1</span>
<span class="go">Transition from &#39;A&#39; to &#39;A&#39;: 1|0</span>
</pre></div>
</div>
<p>Now we apply a word to it and see what the transducer does:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">inverter</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">True</span></code> means, that we landed in a final state, that state is labeled
<code class="docutils literal"><span class="pre">'A'</span></code>, and we also got an output.</p>
</div>
<div class="section" id="transducers-and-in-finite-words">
<span id="finite-state-machine-division-by-3-example"></span><h3>Transducers and (in)finite Words<a class="headerlink" href="#transducers-and-in-finite-words" title="Permalink to this headline">¶</a></h3>
<p>A transducer can also act on everything iterable, in particular, on
Sage’s <a class="reference internal" href="words/words.html"><span class="doc">words</span></a>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">Words</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span> <span class="n">W</span>
<span class="go">Finite and infinite words over {0, 1}</span>
</pre></div>
</div>
<p>Let us take the inverter from the previous section and feed some
finite word into it:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">W</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span> <span class="n">w</span>
<span class="go">word: 1101</span>
<span class="gp">sage: </span><span class="n">inverter</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go">word: 0010</span>
</pre></div>
</div>
<p>We see that the output is again a word (this is a consequence of
calling <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><code class="xref py py-meth docutils literal"><span class="pre">process()</span></code></a> with <code class="docutils literal"><span class="pre">automatic_output_type</span></code>).</p>
<p>We can even input something infinite like an infinite word:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">tm</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="n">ThueMorseWord</span><span class="p">();</span> <span class="n">tm</span>
<span class="go">word: 0110100110010110100101100110100110010110...</span>
<span class="gp">sage: </span><span class="n">inverter</span><span class="p">(</span><span class="n">tm</span><span class="p">)</span>
<span class="go">word: 1001011001101001011010011001011001101001...</span>
</pre></div>
</div>
</div>
<div class="section" id="a-transducer-which-performs-division-by-in-binary">
<h3>A transducer which performs division by <span class="math">\(3\)</span> in binary<a class="headerlink" href="#a-transducer-which-performs-division-by-in-binary" title="Permalink to this headline">¶</a></h3>
<p>Now we build a transducer, which divides a binary number by <span class="math">\(3\)</span>.
The labels of the states are the remainder of the division.
The transition function is</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">state_from</span><span class="p">,</span> <span class="n">read</span><span class="p">):</span>
<span class="go">....:     if state_from + read &lt;= 1:</span>
<span class="go">....:         state_to = 2*state_from + read</span>
<span class="go">....:         write = 0</span>
<span class="go">....:     else:</span>
<span class="go">....:         state_to = 2*state_from + read - 3</span>
<span class="go">....:         write = 1</span>
<span class="go">....:     return (state_to, write)</span>
</pre></div>
</div>
<p>which assumes reading a binary number from left to right.
We get the transducer with</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">final_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="go">....:                input_alphabet=[0, 1])</span>
</pre></div>
</div>
<p>Let us try to divide <span class="math">\(12\)</span> by <span class="math">\(3\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[0, 1, 0, 0]</span>
</pre></div>
</div>
<p>Now we want to divide <span class="math">\(13\)</span> by <span class="math">\(3\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
</pre></div>
</div>
<p>The raised <code class="docutils literal"><span class="pre">ValueError</span></code>
means <span class="math">\(13\)</span> is not divisible by <span class="math">\(3\)</span>.</p>
</div>
<div class="section" id="gray-code">
<span id="finite-state-machine-gray-code-example"></span><h3>Gray Code<a class="headerlink" href="#gray-code" title="Permalink to this headline">¶</a></h3>
<p>The Gray code is a binary <a class="reference external" href="https://en.wikipedia.org/wiki/Numeral_system">numeral system</a>
where two successive values differ in only one bit, cf. the
<a class="reference external" href="https://en.wikipedia.org/wiki/Gray_code">Wikipedia article Gray_code</a>. The Gray code of an integer <span class="math">\(n\)</span> is obtained by
a bitwise xor between the binary expansion of <span class="math">\(n\)</span> and the binary
expansion of <span class="math">\(\lfloor n/2\rfloor\)</span>; the latter corresponds to a
shift by one position in binary.</p>
<p>The purpose of this example is to construct a transducer converting the
standard binary expansion to the Gray code by translating this
construction into operations with transducers.</p>
<p>For this construction, the least significant digit is at
the left-most position.
Note that it is easier to shift everything to
the right first, i.e., multiply by <span class="math">\(2\)</span> instead of building
<span class="math">\(\lfloor n/2\rfloor\)</span>. Then, we take the input xor with the right
shift of the input and forget the first letter.</p>
<p>We first construct a transducer shifting the binary expansion to the
right. This requires storing the previously read digit in a state.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">shift_right_transition</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">digit</span><span class="p">):</span>
<span class="go">....:     if state == &#39;I&#39;:</span>
<span class="go">....:         return (digit, None)</span>
<span class="go">....:     else:</span>
<span class="go">....:         return (digit, state)</span>
<span class="gp">sage: </span><span class="n">shift_right_transducer</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span>
<span class="go">....:     shift_right_transition,</span>
<span class="go">....:     initial_states=[&#39;I&#39;],</span>
<span class="go">....:     input_alphabet=[0, 1],</span>
<span class="go">....:     final_states=[0])</span>
<span class="gp">sage: </span><span class="n">shift_right_transducer</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;I&#39; to 0: 0|-,</span>
<span class="go"> Transition from &#39;I&#39; to 1: 1|-,</span>
<span class="go"> Transition from 0 to 0: 0|0,</span>
<span class="go"> Transition from 0 to 1: 1|0,</span>
<span class="go"> Transition from 1 to 0: 0|1,</span>
<span class="go"> Transition from 1 to 1: 1|1]</span>
<span class="gp">sage: </span><span class="n">shift_right_transducer</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[0, 1, 1]</span>
<span class="gp">sage: </span><span class="n">shift_right_transducer</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[1, 0]</span>
</pre></div>
</div>
<p>The output of the shifts above look a bit weird (from a right-shift
transducer, we would expect, for example, that <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0]</span></code> was
mapped to <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">0]</span></code>), since we write <code class="docutils literal"><span class="pre">None</span></code> instead of the zero
at the left. Further, note that only <span class="math">\(0\)</span> is listed as a final state
as we have to enforce that a most significant zero is read as the last
input letter in order to flush the last digit:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">shift_right_transducer</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
</pre></div>
</div>
<p>Next, we construct the transducer performing the xor operation. We also
have to take <code class="docutils literal"><span class="pre">None</span></code> into account as our <code class="docutils literal"><span class="pre">shift_right_transducer</span></code>
waits one iteration until it starts writing output. This corresponds
with our intention to forget the first letter.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">xor_transition</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">digits</span><span class="p">):</span>
<span class="go">....:    if digits[0] is None or digits[1] is None:</span>
<span class="go">....:        return (0, None)</span>
<span class="go">....:    else:</span>
<span class="go">....:        return (0, digits[0].__xor__(digits[1]))</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="gp">sage: </span><span class="n">xor_transducer</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span>
<span class="go">....:    xor_transition,</span>
<span class="go">....:    initial_states=[0],</span>
<span class="go">....:    final_states=[0],</span>
<span class="go">....:    input_alphabet=list(product([None, 0, 1], [0, 1])))</span>
<span class="gp">sage: </span><span class="n">xor_transducer</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: (None, 0)|-,</span>
<span class="go"> Transition from 0 to 0: (None, 1)|-,</span>
<span class="go"> Transition from 0 to 0: (0, 0)|0,</span>
<span class="go"> Transition from 0 to 0: (0, 1)|1,</span>
<span class="go"> Transition from 0 to 0: (1, 0)|1,</span>
<span class="go"> Transition from 0 to 0: (1, 1)|0]</span>
<span class="gp">sage: </span><span class="n">xor_transducer</span><span class="p">([(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="go">[0, 1, 1, 0]</span>
<span class="gp">sage: </span><span class="n">xor_transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">)])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
</pre></div>
</div>
<p>The transducer computing the Gray code is then constructed as a
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.cartesian_product" title="sage.combinat.finite_state_machine.Transducer.cartesian_product"><code class="xref py py-meth docutils literal"><span class="pre">Cartesian</span> <span class="pre">product</span></code></a> between the
shifted version and the original input (represented here by the
<code class="docutils literal"><span class="pre">shift_right_transducer</span></code> and the <a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.TransducerGenerators.Identity" title="sage.combinat.finite_state_machine_generators.TransducerGenerators.Identity"><code class="xref py py-meth docutils literal"><span class="pre">identity</span> <span class="pre">transducer</span></code></a>,
respectively). This Cartesian product is then fed into the
<code class="docutils literal"><span class="pre">xor_transducer</span></code> as a <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.composition" title="sage.combinat.finite_state_machine.FiniteStateMachine.composition"><code class="xref py py-meth docutils literal"><span class="pre">composition</span></code></a> of transducers.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">product_transducer</span> <span class="o">=</span> <span class="n">shift_right_transducer</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">transducers</span><span class="o">.</span><span class="n">Identity</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">Gray_transducer</span> <span class="o">=</span> <span class="n">xor_transducer</span><span class="p">(</span><span class="n">product_transducer</span><span class="p">)</span>
</pre></div>
</div>
<p>We use <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out"><code class="xref py py-meth docutils literal"><span class="pre">construct_final_word_out()</span></code></a> to make sure that all output
is written; otherwise, we would have to make sure that a sufficient number of trailing
zeros is read.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Gray_transducer</span><span class="o">.</span><span class="n">construct_final_word_out</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Gray_transducer</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from ((&#39;I&#39;, 0), 0) to ((0, 0), 0): 0|-,</span>
<span class="go"> Transition from ((&#39;I&#39;, 0), 0) to ((1, 0), 0): 1|-,</span>
<span class="go"> Transition from ((0, 0), 0) to ((0, 0), 0): 0|0,</span>
<span class="go"> Transition from ((0, 0), 0) to ((1, 0), 0): 1|1,</span>
<span class="go"> Transition from ((1, 0), 0) to ((0, 0), 0): 0|1,</span>
<span class="go"> Transition from ((1, 0), 0) to ((1, 0), 0): 1|0]</span>
</pre></div>
</div>
<p>There is a <a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.TransducerGenerators.GrayCode" title="sage.combinat.finite_state_machine_generators.TransducerGenerators.GrayCode"><code class="xref py py-meth docutils literal"><span class="pre">prepackaged</span> <span class="pre">transducer</span></code></a>
for Gray code, let’s see whether they agree. We have to use
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.relabeled" title="sage.combinat.finite_state_machine.FiniteStateMachine.relabeled"><code class="xref py py-meth docutils literal"><span class="pre">relabeled()</span></code></a> to relabel our states with
integers.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">constructed</span> <span class="o">=</span> <span class="n">Gray_transducer</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">packaged</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">GrayCode</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">constructed</span> <span class="o">==</span> <span class="n">packaged</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Finally, we check that this indeed computes the Gray code of the first
10 non-negative integers.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">srange</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
<span class="go">....:     Gray_transducer(n.bits())</span>
<span class="go">[]</span>
<span class="go">[1]</span>
<span class="go">[1, 1]</span>
<span class="go">[0, 1]</span>
<span class="go">[0, 1, 1]</span>
<span class="go">[1, 1, 1]</span>
<span class="go">[1, 0, 1]</span>
<span class="go">[0, 0, 1]</span>
<span class="go">[0, 0, 1, 1]</span>
<span class="go">[1, 0, 1, 1]</span>
</pre></div>
</div>
</div>
<div class="section" id="using-the-hook-functions">
<h3>Using the hook-functions<a class="headerlink" href="#using-the-hook-functions" title="Permalink to this headline">¶</a></h3>
<p>Let’s use the <a class="reference internal" href="#finite-state-machine-division-by-3-example"><span class="std std-ref">previous example “division by
3”</span></a> to demonstrate the optional
state and transition parameters <code class="docutils literal"><span class="pre">hook</span></code>.</p>
<p>First, we define what those functions should do. In our case, this is
just saying in which state we are and which transition we take</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">state_hook</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
<span class="go">....:     print(&quot;We are now in State %s.&quot; % (state.label(),))</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMWordSymbol</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">transition_hook</span><span class="p">(</span><span class="n">transition</span><span class="p">,</span> <span class="n">process</span><span class="p">):</span>
<span class="go">....:     print(&quot;Currently we go from %s to %s, &quot;</span>
<span class="go">....:           &quot;reading %s and writing %s.&quot; % (</span>
<span class="go">....:                transition.from_state, transition.to_state,</span>
<span class="go">....:                FSMWordSymbol(transition.word_in),</span>
<span class="go">....:                FSMWordSymbol(transition.word_out)))</span>
</pre></div>
</div>
<p>Now, let’s add these hook-functions to the existing transducer:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">iter_states</span><span class="p">():</span>
<span class="go">....:     s.hook = state_hook</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">iter_transitions</span><span class="p">():</span>
<span class="go">....:     t.hook = transition_hook</span>
</pre></div>
</div>
<p>Rerunning the process again now gives the following output:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">check_epsilon_transitions</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">We are now in State 0.</span>
<span class="go">Currently we go from 0 to 1, reading 1 and writing 0.</span>
<span class="go">We are now in State 1.</span>
<span class="go">Currently we go from 1 to 0, reading 1 and writing 1.</span>
<span class="go">We are now in State 0.</span>
<span class="go">Currently we go from 0 to 0, reading 0 and writing 0.</span>
<span class="go">We are now in State 0.</span>
<span class="go">Currently we go from 0 to 1, reading 1 and writing 0.</span>
<span class="go">We are now in State 1.</span>
<span class="go">(False, 1, [0, 1, 0, 0])</span>
</pre></div>
</div>
<p>The example above just explains the basic idea of using
hook-functions. In the following, we will use those hooks more
seriously.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The hooks of the states are also called while exploring the epsilon
successors of a state (during processing). In the example above, we
used <code class="docutils literal"><span class="pre">check_epsilon_transitions=False</span></code> to avoid this (and also
therefore got a cleaner output).</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The arguments used when calling a hook have changed in
<a class="reference external" href="https://trac.sagemath.org/16538">trac ticket #16538</a> from <code class="docutils literal"><span class="pre">hook(state,</span> <span class="pre">process)</span></code> to
<code class="docutils literal"><span class="pre">hook(process,</span> <span class="pre">state,</span> <span class="pre">output)</span></code>. If you are using
an old-style hook, a deprecation warning is displayed.</p>
</div>
</div>
<div class="section" id="detecting-sequences-with-same-number-of-and">
<h3>Detecting sequences with same number of <span class="math">\(0\)</span> and <span class="math">\(1\)</span><a class="headerlink" href="#detecting-sequences-with-same-number-of-and" title="Permalink to this headline">¶</a></h3>
<p>Suppose we have a binary input and want to accept all sequences with
the same number of <span class="math">\(0\)</span> and <span class="math">\(1\)</span>. This cannot be done with a finite
automaton. Anyhow, we can make usage of the hook functions to extend
our finite automaton by a counter:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span><span class="p">,</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">update_counter</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
<span class="go">....:     l = process.preview_word()</span>
<span class="go">....:     process.fsm.counter += 1 if l == 1 else -1</span>
<span class="go">....:     if process.fsm.counter &gt; 0:</span>
<span class="go">....:         next_state = &#39;positive&#39;</span>
<span class="go">....:     elif process.fsm.counter &lt; 0:</span>
<span class="go">....:         next_state = &#39;negative&#39;</span>
<span class="go">....:     else:</span>
<span class="go">....:         next_state = &#39;zero&#39;</span>
<span class="go">....:     return FSMTransition(state, process.fsm.state(next_state),</span>
<span class="go">....:                          l, process.fsm.counter)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span> <span class="n">hook</span><span class="o">=</span><span class="n">update_counter</span><span class="p">,</span>
<span class="go">....:             is_initial=True, is_final=True))</span>
<span class="go">&#39;zero&#39;</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;positive&#39;</span><span class="p">,</span> <span class="n">hook</span><span class="o">=</span><span class="n">update_counter</span><span class="p">))</span>
<span class="go">&#39;positive&#39;</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;negative&#39;</span><span class="p">,</span> <span class="n">hook</span><span class="o">=</span><span class="n">update_counter</span><span class="p">))</span>
<span class="go">&#39;negative&#39;</span>
</pre></div>
</div>
<p>Now, let’s input some sequence:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">C</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">(False, &#39;positive&#39;, [1, 2, 3, 4, 3, 2])</span>
</pre></div>
</div>
<p>The result is False, since there are four <span class="math">\(1\)</span> but only two <span class="math">\(0\)</span>. We
land in the state <code class="docutils literal"><span class="pre">positive</span></code> and we can also see the values of the
counter in each step.</p>
<p>Let’s try some other examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">C</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">(True, &#39;zero&#39;, [1, 2, 1, 0])</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">C</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">(False, &#39;negative&#39;, [-1, 0, -1, -2])</span>
</pre></div>
</div>
<p>See also methods <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></code></a> and
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><code class="xref py py-meth docutils literal"><span class="pre">Transducer.process()</span></code></a> (or even
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></code></a>), the explanation of the parameter
<code class="docutils literal"><span class="pre">hook</span></code> and the examples in <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><code class="xref py py-class docutils literal"><span class="pre">FSMState</span></code></a> and
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><code class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></code></a>, and the description and examples in
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a> for more information on processing and
hooks.</p>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="hkp2015" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[HKP2015]</a></td><td>Clemens Heuberger, Sara Kropf, and Helmut Prodinger,
<em>Output sum of transducers: Limiting distribution and periodic
fluctuation</em>,
<a class="reference external" href="http://www.combinatorics.org/ojs/index.php/eljc/article/view/v22i2p19">Electron. J. Combin. 22 (2015), #P2.19</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="hkw2015" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[HKW2015]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id6">2</a>, <a class="fn-backref" href="#id9">3</a>, <a class="fn-backref" href="#id10">4</a>, <a class="fn-backref" href="#id11">5</a>, <a class="fn-backref" href="#id12">6</a>, <a class="fn-backref" href="#id13">7</a>, <a class="fn-backref" href="#id14">8</a>, <a class="fn-backref" href="#id16">9</a>)</em> Clemens Heuberger, Sara Kropf and Stephan Wagner,
<em>Variances and Covariances in the Central Limit Theorem for the Output
of a Transducer</em>, European J. Combin. 49 (2015), 167-187,
<a class="reference external" href="https://dx.doi.org/10.1016/j.ejc.2015.03.004">doi:10.1016/j.ejc.2015.03.004</a>.</td></tr>
</tbody>
</table>
<p>AUTHORS:</p>
<ul class="simple">
<li>Daniel Krenn (2012-03-27): initial version</li>
<li>Clemens Heuberger (2012-04-05): initial version</li>
<li>Sara Kropf (2012-04-17): initial version</li>
<li>Clemens Heuberger (2013-08-21): release candidate for Sage patch</li>
<li>Daniel Krenn (2013-08-21): release candidate for Sage patch</li>
<li>Sara Kropf (2013-08-21): release candidate for Sage patch</li>
<li>Clemens Heuberger (2013-09-02): documentation improved</li>
<li>Daniel Krenn (2013-09-13): comments from trac worked in</li>
<li><dl class="first docutils">
<dt>Clemens Heuberger (2013-11-03): output (labels) of determinisation,</dt>
<dd>product, composition, etc. changed (for consistency),
representation of state changed, documentation improved</dd>
</dl>
</li>
<li>Daniel Krenn (2013-11-04): whitespaces in documentation corrected</li>
<li>Clemens Heuberger (2013-11-04): full_group_by added</li>
<li>Daniel Krenn (2013-11-04): next release candidate for Sage patch</li>
<li>Sara Kropf (2013-11-08): fix for adjacency matrix</li>
<li>Clemens Heuberger (2013-11-11): fix for prepone_output</li>
<li><dl class="first docutils">
<dt>Daniel Krenn (2013-11-11): comments from <a class="reference external" href="https://trac.sagemath.org/15078">trac ticket #15078</a> included:</dt>
<dd>docstring of FiniteStateMachine rewritten, Automaton and Transducer
inherited from FiniteStateMachine</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Daniel Krenn (2013-11-25): documentation improved according to</dt>
<dd>comments from <a class="reference external" href="https://trac.sagemath.org/15078">trac ticket #15078</a></dd>
</dl>
</li>
<li>Clemens Heuberger, Daniel Krenn, Sara Kropf (2014-02-21–2014-07-18):
A huge bunch of improvements. Details see
<a class="reference external" href="https://trac.sagemath.org/15841">trac ticket #15841</a>, <a class="reference external" href="https://trac.sagemath.org/15847">trac ticket #15847</a>, <a class="reference external" href="https://trac.sagemath.org/15848">trac ticket #15848</a>, <a class="reference external" href="https://trac.sagemath.org/15849">trac ticket #15849</a>, <a class="reference external" href="https://trac.sagemath.org/15850">trac ticket #15850</a>, <a class="reference external" href="https://trac.sagemath.org/15922">trac ticket #15922</a>, <a class="reference external" href="https://trac.sagemath.org/15923">trac ticket #15923</a>, <a class="reference external" href="https://trac.sagemath.org/15924">trac ticket #15924</a>,
<a class="reference external" href="https://trac.sagemath.org/15925">trac ticket #15925</a>, <a class="reference external" href="https://trac.sagemath.org/15928">trac ticket #15928</a>, <a class="reference external" href="https://trac.sagemath.org/15960">trac ticket #15960</a>, <a class="reference external" href="https://trac.sagemath.org/15961">trac ticket #15961</a>, <a class="reference external" href="https://trac.sagemath.org/15962">trac ticket #15962</a>, <a class="reference external" href="https://trac.sagemath.org/15963">trac ticket #15963</a>, <a class="reference external" href="https://trac.sagemath.org/15975">trac ticket #15975</a>, <a class="reference external" href="https://trac.sagemath.org/16016">trac ticket #16016</a>,
<a class="reference external" href="https://trac.sagemath.org/16024">trac ticket #16024</a>, <a class="reference external" href="https://trac.sagemath.org/16061">trac ticket #16061</a>, <a class="reference external" href="https://trac.sagemath.org/16128">trac ticket #16128</a>, <a class="reference external" href="https://trac.sagemath.org/16132">trac ticket #16132</a>, <a class="reference external" href="https://trac.sagemath.org/16138">trac ticket #16138</a>, <a class="reference external" href="https://trac.sagemath.org/16139">trac ticket #16139</a>, <a class="reference external" href="https://trac.sagemath.org/16140">trac ticket #16140</a>, <a class="reference external" href="https://trac.sagemath.org/16143">trac ticket #16143</a>,
<a class="reference external" href="https://trac.sagemath.org/16144">trac ticket #16144</a>, <a class="reference external" href="https://trac.sagemath.org/16145">trac ticket #16145</a>, <a class="reference external" href="https://trac.sagemath.org/16146">trac ticket #16146</a>, <a class="reference external" href="https://trac.sagemath.org/16191">trac ticket #16191</a>, <a class="reference external" href="https://trac.sagemath.org/16200">trac ticket #16200</a>, <a class="reference external" href="https://trac.sagemath.org/16205">trac ticket #16205</a>, <a class="reference external" href="https://trac.sagemath.org/16206">trac ticket #16206</a>, <a class="reference external" href="https://trac.sagemath.org/16207">trac ticket #16207</a>,
<a class="reference external" href="https://trac.sagemath.org/16229">trac ticket #16229</a>, <a class="reference external" href="https://trac.sagemath.org/16253">trac ticket #16253</a>, <a class="reference external" href="https://trac.sagemath.org/16254">trac ticket #16254</a>, <a class="reference external" href="https://trac.sagemath.org/16255">trac ticket #16255</a>, <a class="reference external" href="https://trac.sagemath.org/16266">trac ticket #16266</a>, <a class="reference external" href="https://trac.sagemath.org/16355">trac ticket #16355</a>, <a class="reference external" href="https://trac.sagemath.org/16357">trac ticket #16357</a>, <a class="reference external" href="https://trac.sagemath.org/16387">trac ticket #16387</a>,
<a class="reference external" href="https://trac.sagemath.org/16425">trac ticket #16425</a>, <a class="reference external" href="https://trac.sagemath.org/16539">trac ticket #16539</a>, <a class="reference external" href="https://trac.sagemath.org/16555">trac ticket #16555</a>, <a class="reference external" href="https://trac.sagemath.org/16557">trac ticket #16557</a>, <a class="reference external" href="https://trac.sagemath.org/16588">trac ticket #16588</a>, <a class="reference external" href="https://trac.sagemath.org/16589">trac ticket #16589</a>, <a class="reference external" href="https://trac.sagemath.org/16666">trac ticket #16666</a>, <a class="reference external" href="https://trac.sagemath.org/16668">trac ticket #16668</a>,
<a class="reference external" href="https://trac.sagemath.org/16674">trac ticket #16674</a>, <a class="reference external" href="https://trac.sagemath.org/16675">trac ticket #16675</a>, <a class="reference external" href="https://trac.sagemath.org/16677">trac ticket #16677</a>.</li>
<li>Daniel Krenn (2015-09-14): cleanup <a class="reference external" href="https://trac.sagemath.org/18227">trac ticket #18227</a></li>
</ul>
<p>ACKNOWLEDGEMENT:</p>
<ul class="simple">
<li>Clemens Heuberger, Daniel Krenn and Sara Kropf are supported by the
Austrian Science Fund (FWF): P 24644-N26.</li>
</ul>
</div>
</div>
<div class="section" id="methods">
<h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="sage.combinat.finite_state_machine.Automaton">
<em class="property">class </em><code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">Automaton</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">sage.combinat.finite_state_machine.FiniteStateMachine</span></code></a></p>
<p>This creates an automaton, which is a finite state machine, whose
transitions have input labels.</p>
<p>An automaton has additional features like creating a deterministic
and a minimized automaton.</p>
<p>See class <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a> for more information.</p>
<p>EXAMPLES:</p>
<p>We can create an automaton recognizing even numbers (given in
binary and read from left to right) in the following way:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                (&#39;Q&#39;, &#39;P&#39;, 1), (&#39;Q&#39;, &#39;Q&#39;, 0)],</span>
<span class="go">....:               initial_states=[&#39;P&#39;], final_states=[&#39;Q&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span>
<span class="go">Automaton with 2 states</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note that the full output of the commands can be obtained by
calling <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><code class="xref py py-meth docutils literal"><span class="pre">process()</span></code></a> and looks like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(False, &#39;P&#39;)</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.cartesian_product">
<code class="descname">cartesian_product</code><span class="sig-paren">(</span><em>other</em>, <em>only_accessible_components=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.cartesian_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new automaton which accepts an input if it is
accepted by both given automata.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">other</span></code> – an automaton</li>
<li><code class="docutils literal"><span class="pre">only_accessible_components</span></code> – If <code class="docutils literal"><span class="pre">True</span></code> (default), then
the result is piped through <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components"><code class="xref py py-meth docutils literal"><span class="pre">accessible_components()</span></code></a>. If no
<code class="docutils literal"><span class="pre">new_input_alphabet</span></code> is given, it is determined by
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>A new automaton which computes the intersection
(see below) of the languages of <code class="docutils literal"><span class="pre">self</span></code> and <code class="docutils literal"><span class="pre">other</span></code>.</p>
<p>The set of states of the new automaton is the Cartesian product of the
set of states of both given automata. There is a transition <span class="math">\(((A, B),
(C, D), a)\)</span> in the new automaton if there are transitions <span class="math">\((A, C, a)\)</span>
and <span class="math">\((B, D, a)\)</span> in the old automata.</p>
<p>The methods <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.intersection" title="sage.combinat.finite_state_machine.Automaton.intersection"><code class="xref py py-meth docutils literal"><span class="pre">intersection()</span></code></a> and
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.cartesian_product" title="sage.combinat.finite_state_machine.Automaton.cartesian_product"><code class="xref py py-meth docutils literal"><span class="pre">cartesian_product()</span></code></a> are the same (for automata).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">aut1</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                   (&#39;2&#39;, &#39;2&#39;, 1),</span>
<span class="go">....:                   (&#39;2&#39;, &#39;2&#39;, 0)],</span>
<span class="go">....:                  initial_states=[&#39;1&#39;],</span>
<span class="go">....:                  final_states=[&#39;2&#39;],</span>
<span class="go">....:                  determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">aut2</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                   (&#39;A&#39;, &#39;B&#39;, 0),</span>
<span class="go">....:                   (&#39;B&#39;, &#39;B&#39;, 0),</span>
<span class="go">....:                   (&#39;B&#39;, &#39;A&#39;, 1)],</span>
<span class="go">....:                  initial_states=[&#39;A&#39;],</span>
<span class="go">....:                  final_states=[&#39;B&#39;],</span>
<span class="go">....:                  determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">res</span> <span class="o">=</span> <span class="n">aut1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">aut2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">aut1</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">aut2</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">res</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">(True, False, False)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">aut1</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">aut2</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">res</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="go">(True, True, True)</span>
<span class="gp">sage: </span><span class="n">res</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;1&#39;, &#39;A&#39;) to (&#39;2&#39;, &#39;A&#39;): 1|-,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;A&#39;) to (&#39;2&#39;, &#39;B&#39;): 0|-,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;A&#39;) to (&#39;2&#39;, &#39;A&#39;): 1|-,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;B&#39;) to (&#39;2&#39;, &#39;B&#39;): 0|-,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;B&#39;) to (&#39;2&#39;, &#39;A&#39;): 1|-]</span>
</pre></div>
</div>
<p>For automata with epsilon-transitions, intersection is not well
defined. But for any finite state machine, epsilon-transitions can be
removed by <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.remove_epsilon_transitions" title="sage.combinat.finite_state_machine.FiniteStateMachine.remove_epsilon_transitions"><code class="xref py py-meth docutils literal"><span class="pre">remove_epsilon_transitions()</span></code></a>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a1</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                 (0, 1, None),</span>
<span class="go">....:                 (1, 1, 1),</span>
<span class="go">....:                 (1, 2, 1)],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[1],</span>
<span class="go">....:                 determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">a2</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[1],</span>
<span class="go">....:                 determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">a1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">An epsilon-transition (with empty input)</span>
<span class="go">was found.</span>
<span class="gp">sage: </span><span class="n">a1</span><span class="o">.</span><span class="n">remove_epsilon_transitions</span><span class="p">()</span>  <span class="c1"># not tested (since not implemented yet)</span>
<span class="gp">sage: </span><span class="n">a1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>  <span class="c1"># not tested</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.complement">
<code class="descname">complement</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.complement" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complement of this automaton.</p>
<p>OUTPUT:</p>
<p>An <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton" title="sage.combinat.finite_state_machine.Automaton"><code class="xref py py-class docutils literal"><span class="pre">Automaton</span></code></a>.</p>
<p>If this automaton recognizes language <span class="math">\(\mathcal{L}\)</span> over an
input alphabet <span class="math">\(\mathcal{A}\)</span>, then the complement recognizes
<span class="math">\(\mathcal{A}\setminus\mathcal{L}\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">Word</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span>
<span class="go">....:  [], [0], [1], [0, 0], [0, 1], [1, 0], [1, 1]</span>
<span class="go">....:  if A(w)]</span>
<span class="go">[[0, 1]]</span>
<span class="gp">sage: </span><span class="n">Ac</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Ac</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|-,</span>
<span class="go"> Transition from 0 to 3: 1|-,</span>
<span class="go"> Transition from 2 to 3: 0|-,</span>
<span class="go"> Transition from 2 to 3: 1|-,</span>
<span class="go"> Transition from 1 to 2: 1|-,</span>
<span class="go"> Transition from 1 to 3: 0|-,</span>
<span class="go"> Transition from 3 to 3: 0|-,</span>
<span class="go"> Transition from 3 to 3: 1|-]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span>
<span class="go">....:  [], [0], [1], [0, 0], [0, 1], [1, 0], [1, 1]</span>
<span class="go">....:  if Ac(w)]</span>
<span class="go">[[], [0], [1], [0, 0], [1, 0], [1, 1]]</span>
</pre></div>
</div>
<p>The automaton must be deterministic:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">Word</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">automata</span><span class="o">.</span><span class="n">Word</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The finite state machine must be deterministic.</span>
<span class="gp">sage: </span><span class="n">Ac</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span>
<span class="go">....:  [], [0], [1], [0, 0], [0, 1], [1, 0], [1, 1]</span>
<span class="go">....:  if Ac(w)]</span>
<span class="go">[[], [0], [1], [0, 0], [1, 0], [1, 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.determinisation">
<code class="descname">determinisation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.determinisation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deterministic automaton which accepts the same input
words as the original one.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A new automaton, which is deterministic.</p>
<p>The labels of the states of the new automaton are frozensets
of states of <code class="docutils literal"><span class="pre">self</span></code>. The color of a new state is the
frozenset of colors of the constituent states of <code class="docutils literal"><span class="pre">self</span></code>.
Therefore, the colors of the constituent states have to be
hashable. However, if all constituent states have color
<code class="docutils literal"><span class="pre">None</span></code>, then the resulting color is <code class="docutils literal"><span class="pre">None</span></code>, too.</p>
<p>The input alphabet must be specified.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">aut</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                 initial_states=[&#39;A&#39;], final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">aut</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from frozenset([&#39;A&#39;])</span>
<span class="go">              to frozenset([&#39;A&#39;]): 0|-,</span>
<span class="go"> Transition from frozenset([&#39;A&#39;])</span>
<span class="go">              to frozenset([&#39;B&#39;]): 1|-,</span>
<span class="go"> Transition from frozenset([&#39;B&#39;])</span>
<span class="go">              to frozenset([]): 0|-,</span>
<span class="go"> Transition from frozenset([&#39;B&#39;])</span>
<span class="go">              to frozenset([&#39;B&#39;]): 1|-,</span>
<span class="go"> Transition from frozenset([])</span>
<span class="go">              to frozenset([]): 0|-,</span>
<span class="go"> Transition from frozenset([])</span>
<span class="go">              to frozenset([]): 1|-]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                (&#39;B&#39;, &#39;C&#39;, 0), (&#39;C&#39;, &#39;C&#39;, 1), (&#39;C&#39;, &#39;C&#39;, 0)],</span>
<span class="go">....:               initial_states=[&#39;A&#39;], final_states=[&#39;C&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[frozenset([&#39;A&#39;]), frozenset([&#39;A&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;A&#39;, &#39;C&#39;]), frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;])]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
<span class="go">....:                (1, 0, -1), (2, 0, -2), (3, 0, -3)],</span>
<span class="go">....:               initial_states=[0], final_states=[0, 1, 2, 3])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span><span class="o">.</span><span class="n">coaccessible_components</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from 0 to 1: 1|-,</span>
<span class="go"> Transition from 1 to 0: -1|-,</span>
<span class="go"> Transition from 1 to 3: 1|-,</span>
<span class="go"> Transition from 3 to 0: -2|-,</span>
<span class="go"> Transition from 3 to 4: 1|-,</span>
<span class="go"> Transition from 4 to 0: -3|-]</span>
</pre></div>
</div>
<p>Note that colors of states have to be hashable:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">unhashable type: &#39;list&#39;</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span>
<span class="go">Automaton with 1 state</span>
</pre></div>
</div>
<p>If the colors of all constituent states are <code class="docutils literal"><span class="pre">None</span></code>,
the resulting color is <code class="docutils literal"><span class="pre">None</span></code>, too (<a class="reference external" href="https://trac.sagemath.org/19199">trac ticket #19199</a>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0],</span>
<span class="go">....:               final_states=[0])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">color</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span><span class="o">.</span><span class="n">iter_states</span><span class="p">()]</span>
<span class="go">[None]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)],</span>
<span class="go">....:      &#39;C&#39;: [], &#39;B&#39;: [(&#39;C&#39;, &#39;b&#39;)]}</span>
<span class="gp">sage: </span><span class="n">auto</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">],</span> <span class="n">final_states</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">auto</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">auto</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;aaab&#39;</span><span class="p">))</span>
<span class="go">[(False, &#39;A&#39;), (True, &#39;C&#39;)]</span>
<span class="gp">sage: </span><span class="n">auto</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]</span>
<span class="gp">sage: </span><span class="n">Ddet</span> <span class="o">=</span> <span class="n">auto</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Ddet</span>
<span class="go">Automaton with 3 states</span>
<span class="gp">sage: </span><span class="n">Ddet</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">Ddet</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from frozenset([&#39;A&#39;]) to frozenset([&#39;A&#39;, &#39;B&#39;]): &#39;a&#39;|-,</span>
<span class="go"> Transition from frozenset([&#39;A&#39;]) to frozenset([&#39;A&#39;]): &#39;b&#39;|-,</span>
<span class="go"> Transition from frozenset([&#39;A&#39;, &#39;B&#39;]) to frozenset([&#39;A&#39;, &#39;B&#39;]): &#39;a&#39;|-,</span>
<span class="go"> Transition from frozenset([&#39;A&#39;, &#39;B&#39;]) to frozenset([&#39;A&#39;, &#39;C&#39;]): &#39;b&#39;|-,</span>
<span class="go"> Transition from frozenset([&#39;A&#39;, &#39;C&#39;]) to frozenset([&#39;A&#39;, &#39;B&#39;]): &#39;a&#39;|-,</span>
<span class="go"> Transition from frozenset([&#39;A&#39;, &#39;C&#39;]) to frozenset([&#39;A&#39;]): &#39;b&#39;|-]</span>
<span class="gp">sage: </span><span class="n">Ddet</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[frozenset([&#39;A&#39;])]</span>
<span class="gp">sage: </span><span class="n">Ddet</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[frozenset([&#39;A&#39;, &#39;C&#39;])]</span>
<span class="gp">sage: </span><span class="n">Ddet</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;aaab&#39;</span><span class="p">))</span>
<span class="go">(True, frozenset([&#39;A&#39;, &#39;C&#39;]))</span>
</pre></div>
</div>
<p>Test that <a class="reference external" href="https://trac.sagemath.org/18992">trac ticket #18992</a> is fixed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[]),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0], final_states=[1])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[frozenset([0, 1])]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[frozenset([0, 1]), frozenset([1])]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from frozenset([0, 1]) to frozenset([1]): 0|-,</span>
<span class="go">Transition from frozenset([1]) to frozenset([1]): 0|-]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">minimization</span><span class="p">()</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: 0|-]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><em>other</em>, <em>only_accessible_components=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new automaton which accepts an input if it is
accepted by both given automata.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">other</span></code> – an automaton</li>
<li><code class="docutils literal"><span class="pre">only_accessible_components</span></code> – If <code class="docutils literal"><span class="pre">True</span></code> (default), then
the result is piped through <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components"><code class="xref py py-meth docutils literal"><span class="pre">accessible_components()</span></code></a>. If no
<code class="docutils literal"><span class="pre">new_input_alphabet</span></code> is given, it is determined by
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>A new automaton which computes the intersection
(see below) of the languages of <code class="docutils literal"><span class="pre">self</span></code> and <code class="docutils literal"><span class="pre">other</span></code>.</p>
<p>The set of states of the new automaton is the Cartesian product of the
set of states of both given automata. There is a transition <span class="math">\(((A, B),
(C, D), a)\)</span> in the new automaton if there are transitions <span class="math">\((A, C, a)\)</span>
and <span class="math">\((B, D, a)\)</span> in the old automata.</p>
<p>The methods <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.intersection" title="sage.combinat.finite_state_machine.Automaton.intersection"><code class="xref py py-meth docutils literal"><span class="pre">intersection()</span></code></a> and
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.cartesian_product" title="sage.combinat.finite_state_machine.Automaton.cartesian_product"><code class="xref py py-meth docutils literal"><span class="pre">cartesian_product()</span></code></a> are the same (for automata).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">aut1</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                   (&#39;2&#39;, &#39;2&#39;, 1),</span>
<span class="go">....:                   (&#39;2&#39;, &#39;2&#39;, 0)],</span>
<span class="go">....:                  initial_states=[&#39;1&#39;],</span>
<span class="go">....:                  final_states=[&#39;2&#39;],</span>
<span class="go">....:                  determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">aut2</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                   (&#39;A&#39;, &#39;B&#39;, 0),</span>
<span class="go">....:                   (&#39;B&#39;, &#39;B&#39;, 0),</span>
<span class="go">....:                   (&#39;B&#39;, &#39;A&#39;, 1)],</span>
<span class="go">....:                  initial_states=[&#39;A&#39;],</span>
<span class="go">....:                  final_states=[&#39;B&#39;],</span>
<span class="go">....:                  determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">res</span> <span class="o">=</span> <span class="n">aut1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">aut2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">aut1</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">aut2</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">res</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">(True, False, False)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">aut1</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">aut2</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">res</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="go">(True, True, True)</span>
<span class="gp">sage: </span><span class="n">res</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;1&#39;, &#39;A&#39;) to (&#39;2&#39;, &#39;A&#39;): 1|-,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;A&#39;) to (&#39;2&#39;, &#39;B&#39;): 0|-,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;A&#39;) to (&#39;2&#39;, &#39;A&#39;): 1|-,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;B&#39;) to (&#39;2&#39;, &#39;B&#39;): 0|-,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;B&#39;) to (&#39;2&#39;, &#39;A&#39;): 1|-]</span>
</pre></div>
</div>
<p>For automata with epsilon-transitions, intersection is not well
defined. But for any finite state machine, epsilon-transitions can be
removed by <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.remove_epsilon_transitions" title="sage.combinat.finite_state_machine.FiniteStateMachine.remove_epsilon_transitions"><code class="xref py py-meth docutils literal"><span class="pre">remove_epsilon_transitions()</span></code></a>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a1</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                 (0, 1, None),</span>
<span class="go">....:                 (1, 1, 1),</span>
<span class="go">....:                 (1, 2, 1)],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[1],</span>
<span class="go">....:                 determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">a2</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[1],</span>
<span class="go">....:                 determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">a1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">An epsilon-transition (with empty input)</span>
<span class="go">was found.</span>
<span class="gp">sage: </span><span class="n">a1</span><span class="o">.</span><span class="n">remove_epsilon_transitions</span><span class="p">()</span>  <span class="c1"># not tested (since not implemented yet)</span>
<span class="gp">sage: </span><span class="n">a1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>  <span class="c1"># not tested</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.is_equivalent">
<code class="descname">is_equivalent</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.is_equivalent" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether two automata are equivalent, i.e., accept the same
language.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">other</span></code> – an <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton" title="sage.combinat.finite_state_machine.Automaton"><code class="xref py py-class docutils literal"><span class="pre">Automaton</span></code></a>.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0],</span>
<span class="go">....:               final_states=[0])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:               initial_states=[&#39;a&#39;],</span>
<span class="go">....:               final_states=[&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">Transition from &#39;b&#39; to &#39;a&#39;: 0|-</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.language">
<code class="descname">language</code><span class="sig-paren">(</span><em>max_length=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.language" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all words accepted by this automaton.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">max_length</span></code> – an integer or <code class="docutils literal"><span class="pre">None</span></code> (default). Only
inputs of length at most <code class="docutils literal"><span class="pre">max_length</span></code> will be
considered. If <code class="docutils literal"><span class="pre">None</span></code>, then this iterates over all
possible words without length restrictions.</li>
<li><code class="docutils literal"><span class="pre">kwargs</span></code> – will be passed on to the <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">process</span>
<span class="pre">iterator</span></code></a>. See <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><code class="xref py py-meth docutils literal"><span class="pre">process()</span></code></a> for a
description.</li>
</ul>
<p>OUTPUT:</p>
<p>An iterator.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">(</span>
<span class="go">....:     {&#39;A&#39;: [(&#39;A&#39;, 0), (&#39;B&#39;, 1), (&#39;B&#39;, -1)],</span>
<span class="go">....:      &#39;B&#39;: [(&#39;A&#39;, 0)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">NAF</span><span class="o">.</span><span class="n">language</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[[],</span>
<span class="go"> [0], [-1], [1],</span>
<span class="go"> [-1, 0], [0, 0], [1, 0], [0, -1], [0, 1],</span>
<span class="go"> [-1, 0, 0], [0, -1, 0], [0, 0, 0], [0, 1, 0], [1, 0, 0],</span>
<span class="go"> [-1, 0, -1], [-1, 0, 1], [0, 0, -1],</span>
<span class="go"> [0, 0, 1], [1, 0, -1], [1, 0, 1]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.language" title="sage.combinat.finite_state_machine.FiniteStateMachine.language"><code class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.language()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><code class="xref py py-meth docutils literal"><span class="pre">process()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.minimization">
<code class="descname">minimization</code><span class="sig-paren">(</span><em>algorithm=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.minimization" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the minimization of the input automaton as a new automaton.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">algorithm</span></code> – Either Moore’s algorithm (by
<code class="docutils literal"><span class="pre">algorithm='Moore'</span></code> or as default for deterministic
automata) or Brzozowski’s algorithm (when
<code class="docutils literal"><span class="pre">algorithm='Brzozowski'</span></code> or when the automaton is not
deterministic) is used.</li>
</ul>
<p>OUTPUT:</p>
<p>A new automaton.</p>
<p>The resulting automaton is deterministic and has a minimal
number of states.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                (&#39;B&#39;, &#39;C&#39;, 0), (&#39;C&#39;, &#39;C&#39;, 1), (&#39;C&#39;, &#39;C&#39;, 0)],</span>
<span class="go">....:               initial_states=[&#39;A&#39;], final_states=[&#39;C&#39;])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">minimization</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Brzozowski&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">transitions</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">states</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[Transition from frozenset([frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;C&#39;, &#39;B&#39;]), frozenset([&#39;A&#39;, &#39;C&#39;])]) to</span>
<span class="go">frozenset([frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]), frozenset([&#39;C&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;A&#39;, &#39;C&#39;]), frozenset([&#39;C&#39;])]): 0|-,</span>
<span class="go">Transition from frozenset([frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;C&#39;, &#39;B&#39;]), frozenset([&#39;A&#39;, &#39;C&#39;])]) to</span>
<span class="go">frozenset([frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]), frozenset([&#39;C&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;A&#39;, &#39;C&#39;])]): 1|-]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">states</span><span class="p">())</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">minimization</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Brzozowski&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">states</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[Transition from frozenset([frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;C&#39;, &#39;B&#39;]), frozenset([&#39;A&#39;, &#39;C&#39;])]) to</span>
<span class="go">frozenset([frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]), frozenset([&#39;C&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;A&#39;, &#39;C&#39;]), frozenset([&#39;C&#39;])]): 0|-,</span>
<span class="go">Transition from frozenset([frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;C&#39;, &#39;B&#39;]), frozenset([&#39;A&#39;, &#39;C&#39;])]) to</span>
<span class="go">frozenset([frozenset([&#39;A&#39;, &#39;C&#39;, &#39;B&#39;]), frozenset([&#39;C&#39;, &#39;B&#39;]),</span>
<span class="go">frozenset([&#39;A&#39;, &#39;C&#39;])]): 1|-]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">states</span><span class="p">())</span>
<span class="go">3</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">aut</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                  (&#39;3&#39;, &#39;2&#39;, &#39;a&#39;), (&#39;2&#39;, &#39;1&#39;, &#39;b&#39;),</span>
<span class="go">....:                  (&#39;3&#39;, &#39;4&#39;, &#39;a&#39;), (&#39;4&#39;, &#39;3&#39;, &#39;b&#39;)],</span>
<span class="go">....:                  initial_states=[&#39;1&#39;], final_states=[&#39;1&#39;])</span>
<span class="gp">sage: </span><span class="nb">min</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">minimization</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Brzozowski&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nb">min</span><span class="o">.</span><span class="n">states</span><span class="p">()),</span> <span class="nb">len</span><span class="p">(</span><span class="n">aut</span><span class="o">.</span><span class="n">states</span><span class="p">())]</span>
<span class="go">[3, 4]</span>
<span class="gp">sage: </span><span class="nb">min</span> <span class="o">=</span> <span class="n">aut</span><span class="o">.</span><span class="n">minimization</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;Moore&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">Minimization via Moore&#39;s Algorithm is only</span>
<span class="go">implemented for deterministic finite state machines</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.process">
<code class="descname">process</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the automaton accepts the input and the state
where the computation stops.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">input_tape</span></code> – the input tape can be a list or an
iterable with entries from the input alphabet. If we are
working with a multi-tape machine (see parameter
<code class="docutils literal"><span class="pre">use_multitape_input</span></code> and notes below), then the tape is a
list or tuple of tracks, each of which can be a list or an
iterable with entries from the input alphabet.</li>
<li><code class="docutils literal"><span class="pre">initial_state</span></code> or <code class="docutils literal"><span class="pre">initial_states</span></code> – the initial
state(s) in which the machine starts. Either specify a
single one with <code class="docutils literal"><span class="pre">initial_state</span></code> or a list of them with
<code class="docutils literal"><span class="pre">initial_states</span></code>. If both are given, <code class="docutils literal"><span class="pre">initial_state</span></code>
will be appended to <code class="docutils literal"><span class="pre">initial_states</span></code>. If neither is
specified, the initial states of the finite state machine
are taken.</li>
<li><code class="docutils literal"><span class="pre">list_of_outputs</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) a boolean or
<code class="docutils literal"><span class="pre">None</span></code>. If <code class="docutils literal"><span class="pre">True</span></code>, then the outputs are given in list form
(even if we have no or only one single output). If
<code class="docutils literal"><span class="pre">False</span></code>, then the result is never a list (an exception is
raised if the result cannot be returned). If
<code class="docutils literal"><span class="pre">list_of_outputs=None</span></code> the method determines automatically
what to do (e.g. if a non-deterministic machine returns more
than one path, then the output is returned in list form).</li>
<li><code class="docutils literal"><span class="pre">only_accepted</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>) a boolean. If set,
then the first argument in the output is guaranteed to be
<code class="docutils literal"><span class="pre">True</span></code> (if the output is a list, then the first argument
of each element will be <code class="docutils literal"><span class="pre">True</span></code>).</li>
<li><code class="docutils literal"><span class="pre">full_output</span></code> – (default: <code class="docutils literal"><span class="pre">True</span></code>) a boolean. If set,
then the full output is given, otherwise only whether the
sequence is accepted or not (the first entry below only).</li>
<li><code class="docutils literal"><span class="pre">always_include_output</span></code> – if set (not by default), always
return a triple containing the (non-existing) output. This
is in order to obtain output compatible with that of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></code></a>. If this parameter is set,
<code class="docutils literal"><span class="pre">full_output</span></code> has no effect.</li>
<li><code class="docutils literal"><span class="pre">format_output</span></code> – a function that translates the written
output (which is in form of a list) to something more
readable. By default (<code class="docutils literal"><span class="pre">None</span></code>) identity is used here.</li>
<li><code class="docutils literal"><span class="pre">check_epsilon_transitions</span></code> – (default: <code class="docutils literal"><span class="pre">True</span></code>) a
boolean. If <code class="docutils literal"><span class="pre">False</span></code>, then epsilon transitions are not
taken into consideration during process.</li>
<li><code class="docutils literal"><span class="pre">write_final_word_out</span></code> – (default: <code class="docutils literal"><span class="pre">True</span></code>) a boolean
specifying whether the final output words should be written
or not.</li>
<li><code class="docutils literal"><span class="pre">use_multitape_input</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>) a
boolean. If <code class="docutils literal"><span class="pre">True</span></code>, then the multi-tape mode of the
process iterator is activated. See also the notes below for
multi-tape machines.</li>
<li><code class="docutils literal"><span class="pre">process_all_prefixes_of_input</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>) a
boolean. If <code class="docutils literal"><span class="pre">True</span></code>, then each prefix of the input word is
processed (instead of processing the whole input word at
once). Consequently, there is an output generated for each
of these prefixes.</li>
<li><code class="docutils literal"><span class="pre">process_iterator_class</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) a class
inherited from <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a>. If <code class="docutils literal"><span class="pre">None</span></code>,
then <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a> is taken. An instance of this
class is created and is used during the processing.</li>
</ul>
<p>OUTPUT:</p>
<p>The full output is a pair (or a list of pairs,
cf. parameter <code class="docutils literal"><span class="pre">list_of_outputs</span></code>), where</p>
<ul class="simple">
<li>the first entry is <code class="docutils literal"><span class="pre">True</span></code> if the input string is accepted and</li>
<li>the second gives the state reached after processing the
input tape (This is a state with label <code class="docutils literal"><span class="pre">None</span></code> if the input
could not be processed, i.e., if at one point no
transition to go on could be found.).</li>
</ul>
<p>If <code class="docutils literal"><span class="pre">full_output</span></code> is <code class="docutils literal"><span class="pre">False</span></code>, then only the first entry
is returned.</p>
<p>If <code class="docutils literal"><span class="pre">always_include_output</span></code> is set, an additional third entry
<code class="docutils literal"><span class="pre">[]</span></code> is included.</p>
<p>Note that in the case the automaton is not
deterministic, all possible paths are taken into account.
You can use <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.determinisation" title="sage.combinat.finite_state_machine.Automaton.determinisation"><code class="xref py py-meth docutils literal"><span class="pre">determinisation()</span></code></a> to get a deterministic
automaton machine.</p>
<p>This function uses an iterator which, in its simplest form, goes
from one state to another in each step. To decide which way to
go, it uses the input words of the outgoing transitions and
compares them to the input tape. More precisely, in each step,
the iterator takes an outgoing transition of the current state,
whose input label equals the input letter of the tape.</p>
<p>If the choice of the outgoing transition is not unique (i.e.,
we have a non-deterministic finite state machine), all
possibilites are followed. This is done by splitting the
process into several branches, one for each of the possible
outgoing transitions.</p>
<p>The process (iteration) stops if all branches are finished,
i.e., for no branch, there is any transition whose input word
coincides with the processed input tape. This can simply
happen when the entire tape was read.</p>
<p>Also see <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> for a
version of <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><code class="xref py py-meth docutils literal"><span class="pre">process()</span></code></a> with shortened output.</p>
<p>Internally this function creates and works with an instance of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a>. This iterator can also be obtained
with <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><code class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></code></a>.</p>
<p>If working with multi-tape finite state machines, all input
words of transitions are words of <span class="math">\(k\)</span>-tuples of letters.
Moreover, the input tape has to consist of <span class="math">\(k\)</span> tracks, i.e.,
be a list or tuple of <span class="math">\(k\)</span> iterators, one for each track.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Working with multi-tape finite state machines is still
experimental and can lead to wrong outputs.</p>
</div>
<p>EXAMPLES:</p>
<p>In the following examples, we construct an automaton which
accepts non-adjacent forms (see also the example on
<a class="reference internal" href="#finite-state-machine-recognizing-nafs-example"><span class="std std-ref">non-adjacent forms</span></a>
in the documentation of the module
<a class="reference internal" href="#"><span class="doc">Finite State Machines, Automata, Transducers</span></a>)
and then test it by feeding it with several binary digit
expansions.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">(</span>
<span class="go">....:     {&#39;_&#39;: [(&#39;_&#39;, 0), (&#39;1&#39;, 1)], &#39;1&#39;: [(&#39;_&#39;, 0)]},</span>
<span class="go">....:     initial_states=[&#39;_&#39;], final_states=[&#39;_&#39;, &#39;1&#39;])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">NAF</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                           [0, 1, 1, 1, 0], [1, 0, 0, 1, 1]]]</span>
<span class="go">[(True, &#39;_&#39;), (True, &#39;1&#39;), (False, None),</span>
<span class="go"> (True, &#39;1&#39;), (False, None), (False, None)]</span>
</pre></div>
</div>
<p>If we just want a condensed output, we use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">NAF</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">....:     for w in [[0], [0, 1], [1, 1], [0, 1, 0, 1],</span>
<span class="go">....:               [0, 1, 1, 1, 0], [1, 0, 0, 1, 1]]]</span>
<span class="go">[True, True, False, True, False, False]</span>
</pre></div>
</div>
<p>It is equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">NAF</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                   [0, 1, 1, 1, 0], [1, 0, 0, 1, 1]]]</span>
<span class="go">[True, True, False, True, False, False]</span>
</pre></div>
</div>
<p>The following example illustrates the difference between
non-existing paths and reaching a non-final state:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(False, None)</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">Transition from &#39;_&#39; to &#39;s&#39;: 2|-</span>
<span class="gp">sage: </span><span class="n">NAF</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(False, &#39;s&#39;)</span>
</pre></div>
</div>
<p>A simple example of a (non-deterministic) multi-tape automaton is the
following: It checks whether the two input tapes have the same number
of ones:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
<span class="go">....:                (&#39;=&#39;, &#39;=&#39;, (None, 0)),</span>
<span class="go">....:                (&#39;=&#39;, &#39;=&#39;, (0, None)),</span>
<span class="go">....:                (&#39;=&#39;, &#39;&lt;&#39;, (None, 1)),</span>
<span class="go">....:                (&#39;&lt;&#39;, &#39;&lt;&#39;, (None, 1)),</span>
<span class="go">....:                (&#39;&lt;&#39;, &#39;&lt;&#39;, (None, 0)),</span>
<span class="go">....:                (&#39;=&#39;, &#39;&gt;&#39;, (1, None)),</span>
<span class="go">....:                (&#39;&gt;&#39;, &#39;&gt;&#39;, (1, None)),</span>
<span class="go">....:                (&#39;&gt;&#39;, &#39;&gt;&#39;, (0, None))],</span>
<span class="go">....:               initial_states=[&#39;=&#39;],</span>
<span class="go">....:               final_states=[&#39;=&#39;])</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">process</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">use_multitape_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, &#39;&gt;&#39;)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">process</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">use_multitape_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, &#39;&lt;&#39;)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">process</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
<span class="go">....:           use_multitape_input=True)</span>
<span class="go">(True, &#39;=&#39;)</span>
</pre></div>
</div>
<p>Alternatively, we can use the following (non-deterministic)
multi-tape automaton for the same check:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
<span class="go">....:                (&#39;=&#39;, &#39;&lt;&#39;, (None, 1)),</span>
<span class="go">....:                (&#39;&lt;&#39;, &#39;&lt;&#39;, (0, None)),</span>
<span class="go">....:                (&#39;&lt;&#39;, &#39;=&#39;, (1, None)),</span>
<span class="go">....:                (&#39;=&#39;, &#39;&gt;&#39;, (1, None)),</span>
<span class="go">....:                (&#39;&gt;&#39;, &#39;&gt;&#39;, (None, 0)),</span>
<span class="go">....:                (&#39;&gt;&#39;, &#39;=&#39;, (None, 1))],</span>
<span class="go">....:               initial_states=[&#39;=&#39;],</span>
<span class="go">....:               final_states=[&#39;=&#39;])</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">process</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">use_multitape_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, &#39;&gt;&#39;)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">process</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">use_multitape_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(False, &#39;&lt;&#39;)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">process</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
<span class="go">....:           use_multitape_input=True)</span>
<span class="go">(True, &#39;=&#39;)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><code class="xref py py-meth docutils literal"><span class="pre">Transducer.process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><code class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.shannon_parry_markov_chain">
<code class="descname">shannon_parry_markov_chain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.shannon_parry_markov_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a time homogeneous Markov chain such that all words of a
given length recognized by the original automaton occur as the
output with the same weight; the transition probabilities
correspond to the Parry measure.</p>
<p>OUTPUT:</p>
<p>A Markov chain. Its input labels are the transition probabilities, the
output labels the labels of the original automaton. In order to obtain
equal weight for all words of the same length, an “exit weight” is
needed. It is stored in the attribute <code class="docutils literal"><span class="pre">color</span></code> of the states of the
Markov chain. The weights of the words of the same length sum up to one
up to an exponentially small error.</p>
<p>The stationary distribution of this Markov chain is
saved as the initial probabilities of the states.</p>
<p>The transition probabilities correspond to the Parry measure
(see <a class="reference internal" href="#s1948" id="id2">[S1948]</a> and <a class="reference internal" href="#p1964" id="id3">[P1964]</a>).</p>
<p>The automaton is assumed to be deterministic, irreducible and
aperiodic. All states must be final.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
<span class="go">....:                  (1, 0, 0)], initial_states=[0],</span>
<span class="go">....:                 final_states=[0, 1])</span>
<span class="gp">sage: </span><span class="n">P_NAF</span> <span class="o">=</span> <span class="n">NAF</span><span class="o">.</span><span class="n">shannon_parry_markov_chain</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P_NAF</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: 1/2|0,</span>
<span class="go"> Transition from 0 to 1: 1/4|1,</span>
<span class="go"> Transition from 0 to 1: 1/4|-1,</span>
<span class="go"> Transition from 1 to 0: 1|0]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">P_NAF</span><span class="o">.</span><span class="n">iter_states</span><span class="p">():</span>
<span class="go">....:     print(s.color)</span>
<span class="go">3/4</span>
<span class="go">3/2</span>
</pre></div>
</div>
<p>The stationary distribution is also computed and saved as the
initial probabilities of the returned Markov chain:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">P_NAF</span><span class="o">.</span><span class="n">states</span><span class="p">():</span>
<span class="go">....:     print(&quot;{} {}&quot;.format(s, s.initial_probability))</span>
<span class="go">0 2/3</span>
<span class="go">1 1/3</span>
</pre></div>
</div>
<p>The automaton is assumed to be deterministic, irreducible and aperiodic:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">shannon_parry_markov_chain</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">Automaton must be strongly connected.</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">shannon_parry_markov_chain</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">Automaton must be deterministic.</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">shannon_parry_markov_chain</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">Automaton must be aperiodic.</span>
</pre></div>
</div>
<p>All states must be final:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">shannon_parry_markov_chain</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">All states must be final.</span>
</pre></div>
</div>
<p>ALGORITHM:</p>
<p>See <a class="reference internal" href="#hkp2015a" id="id4">[HKP2015a]</a>, Lemma 4.1.</p>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="hkp2015a" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[HKP2015a]</a></td><td>Clemens Heuberger, Sara Kropf, and Helmut
Prodinger, <em>Analysis of Carries in Signed Digit Expansions</em>,
<a class="reference external" href="http://arxiv.org/abs/1503.08816">Arxiv 1503.08816</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="p1964" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[P1964]</a></td><td>William Parry, <em>Intrinsic Markov chains</em>, Transactions
of the American Mathematical Society 112, 1964, pp. 55-66.
<a class="reference external" href="https://dx.doi.org/10.1090/S0002-9947-1964-0161372-1">doi:10.1090/S0002-9947-1964-0161372-1</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="s1948" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[S1948]</a></td><td>Claude E. Shannon, <em>A mathematical theory of communication</em>,
The Bell System Technical Journal 27, 1948, 379-423,
<a class="reference external" href="https://dx.doi.org/10.1002/j.1538-7305.1948.tb01338.x">doi:10.1002/j.1538-7305.1948.tb01338.x</a>.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Automaton.with_output">
<code class="descname">with_output</code><span class="sig-paren">(</span><em>word_out_function=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.Automaton.with_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a transducer out of this automaton.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">word_out_function</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) a function. It
transforms a <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><code class="xref py py-class docutils literal"><span class="pre">transition</span></code></a> to the
output word for this transition.</p>
<p>If this is <code class="docutils literal"><span class="pre">None</span></code>, then the output word will be equal to
the input word of each transition.</p>
</li>
</ul>
<p>OUTPUT:</p>
<p>A transducer.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">with_output</span><span class="p">();</span> <span class="n">T</span>
<span class="go">Transducer with 3 states</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: &#39;A&#39;|&#39;A&#39;,</span>
<span class="go"> Transition from 0 to 1: &#39;B&#39;|&#39;B&#39;,</span>
<span class="go"> Transition from 1 to 2: &#39;C&#39;|&#39;C&#39;]</span>
</pre></div>
</div>
<p>This result is in contrast to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Transducer</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: &#39;A&#39;|-,</span>
<span class="go"> Transition from 0 to 1: &#39;B&#39;|-,</span>
<span class="go"> Transition from 1 to 2: &#39;C&#39;|-]</span>
</pre></div>
</div>
<p>where no output labels are created.</p>
<p>Here is another example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T2</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">with_output</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">word_in</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T2</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: &#39;A&#39;|&#39;a&#39;,</span>
<span class="go"> Transition from 0 to 1: &#39;B&#39;|&#39;b&#39;,</span>
<span class="go"> Transition from 1 to 2: &#39;C&#39;|&#39;c&#39;]</span>
</pre></div>
</div>
<p>We can obtain the same result by composing two transducers. As inner
transducer of the composition, we use <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.with_output" title="sage.combinat.finite_state_machine.Automaton.with_output"><code class="xref py py-meth docutils literal"><span class="pre">with_output()</span></code></a>
without the optional argument
<code class="docutils literal"><span class="pre">word_out_function</span></code> (which makes the output of each
transition equal to its input); as outer transducer we use a
<a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.TransducerGenerators.map" title="sage.combinat.finite_state_machine_generators.TransducerGenerators.map"><code class="xref py py-meth docutils literal"><span class="pre">map-transducer</span></code></a>
(for converting to lower case).
This gives</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">with_output</span><span class="p">())</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: &#39;A&#39;|&#39;a&#39;,</span>
<span class="go"> Transition from 0 to 1: &#39;B&#39;|&#39;b&#39;,</span>
<span class="go"> Transition from 1 to 2: &#39;C&#39;|&#39;c&#39;]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.input_projection" title="sage.combinat.finite_state_machine.FiniteStateMachine.input_projection"><code class="xref py py-meth docutils literal"><span class="pre">input_projection()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.output_projection" title="sage.combinat.finite_state_machine.FiniteStateMachine.output_projection"><code class="xref py py-meth docutils literal"><span class="pre">output_projection()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer" title="sage.combinat.finite_state_machine.Transducer"><code class="xref py py-class docutils literal"><span class="pre">Transducer</span></code></a>,
<a class="reference internal" href="finite_state_machine_generators.html#sage.combinat.finite_state_machine_generators.TransducerGenerators.map" title="sage.combinat.finite_state_machine_generators.TransducerGenerators.map"><code class="xref py py-meth docutils literal"><span class="pre">transducers.map()</span></code></a>.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.FSMLetterSymbol">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">FSMLetterSymbol</code><span class="sig-paren">(</span><em>letter</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMLetterSymbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string associated to the input letter.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">letter</span></code> – the input letter or <code class="docutils literal"><span class="pre">None</span></code> (representing the
empty word).</li>
</ul>
<p>OUTPUT:</p>
<p>If <code class="docutils literal"><span class="pre">letter</span></code> is <code class="docutils literal"><span class="pre">None</span></code> the symbol for the empty word
<code class="docutils literal"><span class="pre">FSMEmptyWordSymbol</span></code> is returned, otherwise the string
associated to the letter.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMLetterSymbol</span>
<span class="gp">sage: </span><span class="n">FSMLetterSymbol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">&#39;0&#39;</span>
<span class="gp">sage: </span><span class="n">FSMLetterSymbol</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="go">&#39;-&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator">
<em class="property">class </em><code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">FSMProcessIterator</code><span class="sig-paren">(</span><em>fsm</em>, <em>input_tape=None</em>, <em>initial_state=None</em>, <em>initial_states=[]</em>, <em>use_multitape_input=False</em>, <em>check_epsilon_transitions=True</em>, <em>write_final_word_out=True</em>, <em>format_output=None</em>, <em>process_all_prefixes_of_input=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Parents and Elements v8.1)"><code class="xref py py-class docutils literal"><span class="pre">sage.structure.sage_object.SageObject</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">_abcoll.Iterator</span></code></p>
<p>This class takes an input, feeds it into a finite state machine
(automaton or transducer, in particular), tests whether this was
successful and calculates the written output.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">fsm</span></code> – the finite state machine on which the input should be
processed.</li>
<li><code class="docutils literal"><span class="pre">input_tape</span></code> – the input tape can be a list or an
iterable with entries from the input alphabet. If we are
working with a multi-tape machine (see parameter
<code class="docutils literal"><span class="pre">use_multitape_input</span></code> and notes below), then the tape is a
list or tuple of tracks, each of which can be a list or an
iterable with entries from the input alphabet.</li>
<li><code class="docutils literal"><span class="pre">initial_state</span></code> or <code class="docutils literal"><span class="pre">initial_states</span></code> – the initial
state(s) in which the machine starts. Either specify a
single one with <code class="docutils literal"><span class="pre">initial_state</span></code> or a list of them with
<code class="docutils literal"><span class="pre">initial_states</span></code>. If both are given, <code class="docutils literal"><span class="pre">initial_state</span></code>
will be appended to <code class="docutils literal"><span class="pre">initial_states</span></code>. If neither is
specified, the initial states of the finite state machine
are taken.</li>
<li><code class="docutils literal"><span class="pre">format_output</span></code> – a function that translates the written
output (which is in form of a list) to something more
readable. By default (<code class="docutils literal"><span class="pre">None</span></code>) identity is used here.</li>
<li><code class="docutils literal"><span class="pre">check_epsilon_transitions</span></code> – (default: <code class="docutils literal"><span class="pre">True</span></code>) a
boolean. If <code class="docutils literal"><span class="pre">False</span></code>, then epsilon transitions are not
taken into consideration during process.</li>
<li><code class="docutils literal"><span class="pre">write_final_word_out</span></code> – (default: <code class="docutils literal"><span class="pre">True</span></code>) a boolean
specifying whether the final output words should be written
or not.</li>
<li><code class="docutils literal"><span class="pre">use_multitape_input</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>) a
boolean. If <code class="docutils literal"><span class="pre">True</span></code>, then the multi-tape mode of the
process iterator is activated. See also the notes below for
multi-tape machines.</li>
<li><code class="docutils literal"><span class="pre">process_all_prefixes_of_input</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>) a
boolean. If <code class="docutils literal"><span class="pre">True</span></code>, then each prefix of the input word is
processed (instead of processing the whole input word at
once). Consequently, there is an output generated for each
of these prefixes.</li>
</ul>
<p>OUTPUT:</p>
<p>An iterator.</p>
<p>In its simplest form, it behaves like an iterator which, in
each step, goes from one state to another. To decide which way
to go, it uses the input words of the outgoing transitions and
compares them to the input tape. More precisely, in each step,
the process iterator takes an outgoing transition of the
current state, whose input label equals the input letter of
the tape. The output label of the transition, if present, is
written on the output tape.</p>
<p>If the choice of the outgoing transition is not unique (i.e.,
we have a non-deterministic finite state machine), all
possibilites are followed. This is done by splitting the
process into several branches, one for each of the possible
outgoing transitions.</p>
<p>The process (iteration) stops if all branches are finished,
i.e., for no branch, there is any transition whose input word
coincides with the processed input tape. This can simply
happen when the entire tape was read.
When the process stops, a <code class="docutils literal"><span class="pre">StopIteration</span></code> exception is thrown.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Processing an input tape of length <span class="math">\(n\)</span> usually takes at least <span class="math">\(n+1\)</span>
iterations, since there will be <span class="math">\(n+1\)</span> states visited (in the
case the taken transitions have input words consisting of single
letters).</p>
</div>
<p>An instance of this class is generated when
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></code></a> or
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><code class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.iter_process()</span></code></a> of a finite state machine,
an automaton, or a transducer is invoked.</p>
<p>When working with multi-tape finite state machines, all input
words of transitions are words of <span class="math">\(k\)</span>-tuples of letters.
Moreover, the input tape has to consist of <span class="math">\(k\)</span> tracks, i.e.,
be a list or tuple of <span class="math">\(k\)</span> iterators, one for each track.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Working with multi-tape finite state machines is still
experimental and can lead to wrong outputs.</p>
</div>
<p>EXAMPLES:</p>
<p>The following transducer reads binary words and outputs a word,
where blocks of ones are replaced by just a single one. Further
only words that end with a zero are accepted.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">)],</span>
<span class="go">....:                 &#39;B&#39;: [(&#39;B&#39;, 1, None), (&#39;A&#39;, 0, [1, 0])]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="nb">input</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
<span class="go">(True, &#39;A&#39;, [1, 0, 0, 1, 0, 1, 0])</span>
</pre></div>
</div>
<p>The function <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></code></a> (internally) uses a
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a>. We can do that manually, too, and get full
access to the iteration process:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMProcessIterator</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">FSMProcessIterator</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">input_tape</span><span class="o">=</span><span class="nb">input</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">current</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     print(current)</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;B&#39;</span>
<span class="go">+-- tape at 1, [[]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;B&#39;</span>
<span class="go">+-- tape at 2, [[]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 3, [[1, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 4, [[1, 0, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;B&#39;</span>
<span class="go">+-- tape at 5, [[1, 0, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 6, [[1, 0, 0, 1, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;B&#39;</span>
<span class="go">+-- tape at 7, [[1, 0, 0, 1, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;B&#39;</span>
<span class="go">+-- tape at 8, [[1, 0, 0, 1, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;B&#39;</span>
<span class="go">+-- tape at 9, [[1, 0, 0, 1, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 10, [[1, 0, 0, 1, 0, 1, 0]]</span>
<span class="go">process (0 branches)</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="go">[Branch(accept=True, state=&#39;A&#39;, output=[1, 0, 0, 1, 0, 1, 0])]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                 (1, 2, 1, &#39;c&#39;), (2, 0, 0, &#39;d&#39;),</span>
<span class="go">....:                 (2, 1, None, &#39;d&#39;)],</span>
<span class="go">....:                initial_states=[0], final_states=[2])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
<span class="go">[(False, 1, &#39;abcd&#39;), (True, 2, &#39;abc&#39;)]</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">FSMProcessIterator</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                         format_output=lambda o: &#39;&#39;.join(o))</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">current</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     print(current)</span>
<span class="go">process (2 branches)</span>
<span class="go">+ at state 0</span>
<span class="go">+-- tape at 1, [[&#39;a&#39;]]</span>
<span class="go">+ at state 1</span>
<span class="go">+-- tape at 1, [[&#39;b&#39;]]</span>
<span class="go">process (2 branches)</span>
<span class="go">+ at state 0</span>
<span class="go">+-- tape at 2, [[&#39;a&#39;, &#39;a&#39;]]</span>
<span class="go">+ at state 1</span>
<span class="go">+-- tape at 2, [[&#39;a&#39;, &#39;b&#39;]]</span>
<span class="go">process (2 branches)</span>
<span class="go">+ at state 1</span>
<span class="go">+-- tape at 3, [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]]</span>
<span class="go">+ at state 2</span>
<span class="go">+-- tape at 3, [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]]</span>
<span class="go">process (0 branches)</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="go">[Branch(accept=False, state=1, output=&#39;abcd&#39;),</span>
<span class="go"> Branch(accept=True, state=2, output=&#39;abc&#39;)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><code class="xref py py-meth docutils literal"><span class="pre">Transducer.process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><code class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.iter_process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><code class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.__call__()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator.next" title="sage.combinat.finite_state_machine.FSMProcessIterator.next"><code class="xref py py-meth docutils literal"><span class="pre">next()</span></code></a>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([])</span>
<span class="go">[(False, 0, []), (False, 1, [])]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
<span class="go">....:                initial_states=[0], final_states=[0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">(True, 0, [0, 42])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">write_final_word_out</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">(True, 0, [0])</span>
</pre></div>
</div>
<dl class="class">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.Current">
<em class="property">class </em><code class="descname">Current</code><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.Current" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">dict</span></code></p>
<p>This class stores the branches which have to be processed
during iteration and provides a nicer formatting of them.</p>
<p>This class is derived from <code class="docutils literal"><span class="pre">dict</span></code>. It is returned by the
<code class="docutils literal"><span class="pre">next</span></code>-function during iteration.</p>
<p>EXAMPLES:</p>
<p>In the following example you can see the dict directly and
then the nicer output provided by this class:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMProcessIterator</span>
<span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">FSMProcessIterator</span><span class="p">(</span><span class="n">inverter</span><span class="p">,</span> <span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">current</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     print(dict(current))</span>
<span class="go">....:     print(current)</span>
<span class="go">{((1, 0),): {&#39;A&#39;: Branch(tape_cache=tape at 1, outputs=[[1]])}}</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 1, [[1]]</span>
<span class="go">{((2, 0),): {&#39;A&#39;: Branch(tape_cache=tape at 2, outputs=[[1, 0]])}}</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 2, [[1, 0]]</span>
<span class="go">{}</span>
<span class="go">process (0 branches)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.FinishedBranch">
<em class="property">class </em><code class="descname">FinishedBranch</code><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.FinishedBranch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/functions.html#tuple" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></a></p>
<p>A <a class="reference external" href="https://docs.python.org/library/collections.html#collections.namedtuple" title="(in Python v2.7)"><code class="xref py py-func docutils literal"><span class="pre">named</span> <span class="pre">tuple</span></code></a> representing the
attributes of a branch, once
it is fully processed.</p>
<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.FinishedBranch.accept">
<code class="descname">accept</code><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.FinishedBranch.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.FinishedBranch.output">
<code class="descname">output</code><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.FinishedBranch.output" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.FinishedBranch.state">
<code class="descname">state</code><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.FinishedBranch.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes one step in processing the input tape.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>It returns the current status of the iterator (see below). A
<code class="docutils literal"><span class="pre">StopIteration</span></code> exception is thrown when there is/was
nothing to do (i.e. all branches ended with previous call
of <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator.next" title="sage.combinat.finite_state_machine.FSMProcessIterator.next"><code class="xref py py-meth docutils literal"><span class="pre">next()</span></code></a>).</p>
<p>The current status is a dictionary (encapsulated into an instance of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator.Current" title="sage.combinat.finite_state_machine.FSMProcessIterator.Current"><code class="xref py py-class docutils literal"><span class="pre">Current</span></code></a>).
The keys are positions on
the tape. The value corresponding to such a position is again
a dictionary, where each entry represents a branch of the
process. This dictionary maps the current state of a branch to
a pair consisting of a tape cache and a list of output words,
which were written during reaching this current state.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMProcessIterator</span>
<span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">FSMProcessIterator</span><span class="p">(</span><span class="n">inverter</span><span class="p">,</span> <span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 1, [[1]]</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 2, [[1, 0]]</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">process (0 branches)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><code class="xref py py-meth docutils literal"><span class="pre">Transducer.process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><code class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.iter_process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><code class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.__call__()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">h_old</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">process</span><span class="p">):</span>
<span class="go">....:     print(&quot;{} {}&quot;.format(state, process))</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">hook</span> <span class="o">=</span> <span class="n">h_old</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">doctest:...: DeprecationWarning: The hook of state 0 cannot</span>
<span class="go">be processed: It seems that you are using an old-style hook,</span>
<span class="go">which is deprecated.</span>
<span class="go">See http://trac.sagemath.org/16538 for details.</span>
<span class="go">(False, 0, [1, 1])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">h_new</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
<span class="go">....:     print(&quot;{} {}&quot;.format(state, outputs))</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">hook</span> <span class="o">=</span> <span class="n">h_new</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">check_epsilon_transitions</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">0 [[]]</span>
<span class="go">0 [[1]]</span>
<span class="go">0 [[1, 1]]</span>
<span class="go">(False, 0, [1, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.preview_word">
<code class="descname">preview_word</code><span class="sig-paren">(</span><em>track_number=None</em>, <em>length=1</em>, <em>return_word=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.preview_word" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a word from the input tape.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">track_number</span></code> – an integer or <code class="docutils literal"><span class="pre">None</span></code>. If <code class="docutils literal"><span class="pre">None</span></code>,
then a tuple of words (one from each track) is returned.</li>
<li><code class="docutils literal"><span class="pre">length</span></code> – (default: <code class="docutils literal"><span class="pre">1</span></code>) the length of the word(s).</li>
<li><code class="docutils literal"><span class="pre">return_word</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>) a boolean. If set,
then a word is returned, otherwise a single letter (in which
case <code class="docutils literal"><span class="pre">length</span></code> has to be <code class="docutils literal"><span class="pre">1</span></code>).</li>
</ul>
<p>OUTPUT:</p>
<p>A single letter or a word.</p>
<p>An exception <code class="docutils literal"><span class="pre">StopIteration</span></code> is thrown if the tape (at least
one track) has reached its end.</p>
<p>Typically, this method is called from a hook-function of a
state.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">),</span>
<span class="go">....:                              (&#39;A&#39;, 1, &#39;zero&#39;)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">state_hook</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
<span class="go">....:     print(&quot;We are now in state %s.&quot; % (state.label(),))</span>
<span class="go">....:     print(&quot;Next on the tape is a %s.&quot; % (</span>
<span class="go">....:         process.preview_word(),))</span>
<span class="gp">sage: </span><span class="n">inverter</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hook</span> <span class="o">=</span> <span class="n">state_hook</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span>
<span class="go">....:     input_tape=[0, 1, 1],</span>
<span class="go">....:     check_epsilon_transitions=False)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     pass</span>
<span class="go">We are now in state A.</span>
<span class="go">Next on the tape is a 0.</span>
<span class="go">We are now in state A.</span>
<span class="go">Next on the tape is a 1.</span>
<span class="go">We are now in state A.</span>
<span class="go">Next on the tape is a 1.</span>
<span class="go">We are now in state A.</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="go">[Branch(accept=True, state=&#39;A&#39;, output=[&#39;one&#39;, &#39;zero&#39;, &#39;zero&#39;])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMProcessIterator.result">
<code class="descname">result</code><span class="sig-paren">(</span><em>format_output=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMProcessIterator.result" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the already finished branches during process.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">format_output</span></code> – a function converting the output from
list form to something more readable (default: output the
list directly).</li>
</ul>
<p>OUTPUT:</p>
<p>A list of triples <code class="docutils literal"><span class="pre">(accepted,</span> <span class="pre">state,</span> <span class="pre">output)</span></code>.</p>
<p>See also the parameter <code class="docutils literal"><span class="pre">format_output</span></code> of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;zero&#39;</span><span class="p">)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     pass</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="go">[Branch(accept=True, state=&#39;A&#39;, output=[&#39;one&#39;, &#39;zero&#39;, &#39;zero&#39;])]</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="k">lambda</span> <span class="n">L</span><span class="p">:</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>
<span class="go">[(True, &#39;A&#39;, &#39;one, zero, zero&#39;)]</span>
</pre></div>
</div>
<p>Using both the parameter <code class="docutils literal"><span class="pre">format_output</span></code> of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a> and the parameter <code class="docutils literal"><span class="pre">format_output</span></code>
of <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator.result" title="sage.combinat.finite_state_machine.FSMProcessIterator.result"><code class="xref py py-meth docutils literal"><span class="pre">result()</span></code></a> leads to concatenation of the two
functions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                            format_output=lambda L: &#39;, &#39;.join(L))</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     pass</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="go">[Branch(accept=True, state=&#39;A&#39;, output=&#39;one, zero, zero&#39;)]</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="k">lambda</span> <span class="n">L</span><span class="p">:</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>
<span class="go">[(True, &#39;A&#39;, &#39;o, n, e, ,,  , z, e, r, o, ,,  , z, e, r, o&#39;)]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.finite_state_machine.FSMState">
<em class="property">class </em><code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">FSMState</code><span class="sig-paren">(</span><em>label</em>, <em>word_out=None</em>, <em>is_initial=False</em>, <em>is_final=False</em>, <em>final_word_out=None</em>, <em>initial_probability=None</em>, <em>hook=None</em>, <em>color=None</em>, <em>allow_label_None=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Parents and Elements v8.1)"><code class="xref py py-class docutils literal"><span class="pre">sage.structure.sage_object.SageObject</span></code></a></p>
<p>Class for a state of a finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">label</span></code> – the label of the state.</li>
<li><code class="docutils literal"><span class="pre">word_out</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) a word that is written when
the state is reached.</li>
<li><code class="docutils literal"><span class="pre">is_initial</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>)</li>
<li><code class="docutils literal"><span class="pre">is_final</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>)</li>
<li><code class="docutils literal"><span class="pre">final_word_out</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) a word that is written when
the state is reached as the last state of some input; only for final
states.</li>
<li><code class="docutils literal"><span class="pre">initial_probability</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) The probability of
starting in this state if it is a state of a Markov chain.</li>
<li><code class="docutils literal"><span class="pre">hook</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) A function which is called when
the state is reached during processing input. It takes two input
parameters: the first is the current state (to allow using the same
hook for several states), the second is the current process
iterator object (to have full access to everything; e.g. the
next letter from the input tape can be read in). It can output
the next transition, i.e. the transition to take next. If it
returns <code class="docutils literal"><span class="pre">None</span></code> the process iterator chooses. Moreover, this
function can raise a <code class="docutils literal"><span class="pre">StopIteration</span></code> exception to stop
processing of a finite state machine the input immediately. See
also the example below.</li>
<li><code class="docutils literal"><span class="pre">color</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) In order to distinguish states,
they can be given an arbitrary “color” (an arbitrary object).
This is used in <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.equivalence_classes" title="sage.combinat.finite_state_machine.FiniteStateMachine.equivalence_classes"><code class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.equivalence_classes()</span></code></a>:
states of different colors are never considered to be
equivalent. Note that <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.determinisation" title="sage.combinat.finite_state_machine.Automaton.determinisation"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.determinisation()</span></code></a> requires
that <code class="docutils literal"><span class="pre">color</span></code> is hashable.</li>
<li><code class="docutils literal"><span class="pre">allow_label_None</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>) If <code class="docutils literal"><span class="pre">True</span></code> allows also
<code class="docutils literal"><span class="pre">None</span></code> as label. Note that a state with label <code class="docutils literal"><span class="pre">None</span></code> is used in
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>Returns a state of a finite state machine.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;state 1&#39;</span><span class="p">,</span> <span class="n">word_out</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">is_initial</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span>
<span class="go">&#39;state 1&#39;</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
<span class="go">&#39;state 1&#39;</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;state 2&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">==</span> <span class="n">B</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We can also define a final output word of a final state which is
used if the input of a transducer leads to this state. Such final
output words are used in subsequential transducers.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;state 3&#39;</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">final_word_out</span><span class="o">=</span><span class="s1">&#39;end&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[&#39;end&#39;]</span>
</pre></div>
</div>
<p>The final output word can be a single letter, <code class="docutils literal"><span class="pre">None</span></code> or a list of
letters:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[2]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[2, 3]</span>
</pre></div>
</div>
<p>Only final states can have a final output word which is not
<code class="docutils literal"><span class="pre">None</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">final_word_out</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Only final states can have a final output word,</span>
<span class="go">but state B is not final.</span>
</pre></div>
</div>
<p>Setting the <code class="docutils literal"><span class="pre">final_word_out</span></code> of a final state to <code class="docutils literal"><span class="pre">None</span></code> is the
same as setting it to <code class="docutils literal"><span class="pre">[]</span></code> and is also the default for a final
state:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>It is not allowed to use <code class="docutils literal"><span class="pre">None</span></code> as a label:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">FSMState</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Label None reserved for a special state,</span>
<span class="go">choose another label.</span>
</pre></div>
</div>
<p>This can be overridden by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FSMState</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">allow_label_None</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.determinisation" title="sage.combinat.finite_state_machine.Automaton.determinisation"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.determinisation()</span></code></a> requires that <code class="docutils literal"><span class="pre">color</span></code>
is hashable:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">unhashable type: &#39;list&#39;</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span>
<span class="go">Automaton with 1 state</span>
</pre></div>
</div>
<p>We can use a hook function of a state to stop processing. This is
done by raising a <code class="docutils literal"><span class="pre">StopIteration</span></code> exception. The following code
demonstrates this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                 (2, 3, 9, &#39;c&#39;), (3, 4, 9, &#39;d&#39;)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[4],</span>
<span class="go">....:                input_alphabet=[9])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
<span class="go">....:     raise StopIteration()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">hook</span> <span class="o">=</span> <span class="n">stop</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="go">(False, 3, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMState.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a (shallow) copy of the state.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A new state.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;green&#39;</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">initial_probability</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">fully_equal</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="ow">is</span> <span class="n">B</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_initial</span> <span class="ow">is</span> <span class="n">B</span><span class="o">.</span><span class="n">is_initial</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_final</span> <span class="ow">is</span> <span class="n">B</span><span class="o">.</span><span class="n">is_final</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span> <span class="ow">is</span> <span class="n">B</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">color</span> <span class="ow">is</span> <span class="n">B</span><span class="o">.</span><span class="n">color</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">initial_probability</span> <span class="ow">is</span> <span class="n">B</span><span class="o">.</span><span class="n">initial_probability</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMState.deepcopy">
<code class="descname">deepcopy</code><span class="sig-paren">(</span><em>memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deep copy of the state.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">memo</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) a dictionary storing already
processed elements.</li>
</ul>
<p>OUTPUT:</p>
<p>A new state.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="go">....:              is_final=True, final_word_out=3,</span>
<span class="go">....:              initial_probability=1/3)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span>
<span class="go">(1, 3)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">label</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="n">A</span><span class="o">.</span><span class="n">label</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">color</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">color</span> <span class="ow">is</span> <span class="n">A</span><span class="o">.</span><span class="n">color</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_final</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">is_final</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">is_final</span> <span class="ow">is</span> <span class="n">A</span><span class="o">.</span><span class="n">is_final</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">final_word_out</span> <span class="ow">is</span> <span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">initial_probability</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="n">initial_probability</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">initial_probability</span> <span class="ow">is</span> <span class="n">A</span><span class="o">.</span><span class="n">initial_probability</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMState.final_word_out">
<code class="descname">final_word_out</code><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.final_word_out" title="Permalink to this definition">¶</a></dt>
<dd><p>The final output word of a final state which is written if the
state is reached as the last state of the input of the finite
state machine. For a non-final state, the value is <code class="docutils literal"><span class="pre">None</span></code>.</p>
<p><code class="docutils literal"><span class="pre">final_word_out</span></code> can be a single letter, a list or <code class="docutils literal"><span class="pre">None</span></code>,
but for a final-state, it is always saved as a list.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">final_word_out</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[2]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[3]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[3, 4]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">final_word_out</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A non-final state cannot have a final output word:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Only final states can have a final</span>
<span class="go">output word, but state B is not final.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMState.fully_equal">
<code class="descname">fully_equal</code><span class="sig-paren">(</span><em>left</em>, <em>right</em>, <em>compare_color=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.fully_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether two states are fully equal, i.e., including all
attributes except <code class="docutils literal"><span class="pre">hook</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">left</span></code> – a state.</li>
<li><code class="docutils literal"><span class="pre">right</span></code> – a state.</li>
<li><code class="docutils literal"><span class="pre">compare_color</span></code> – If <code class="docutils literal"><span class="pre">True</span></code> (default) colors are
compared as well, otherwise not.</li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal"><span class="pre">True</span></code> or <code class="docutils literal"><span class="pre">False</span></code>.</p>
<p>Note that usual comparison by <code class="docutils literal"><span class="pre">==</span></code> does only compare the labels.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">is_initial</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">fully_equal</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">==</span> <span class="n">B</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span><span class="p">;</span> <span class="n">A</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;green&#39;</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">fully_equal</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">fully_equal</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">compare_color</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMState.initial_probability">
<code class="descname">initial_probability</code><em class="property"> = None</em><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.initial_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>The probability of starting in this state if it is part of a Markov chain.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;state&#39;</span><span class="p">,</span> <span class="n">initial_probability</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">initial_probability</span>
<span class="go">1/3</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMState.is_final">
<code class="descname">is_final</code><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.is_final" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes whether the state is final or not.</p>
<p><code class="docutils literal"><span class="pre">True</span></code> if the state is final and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">final_word_out</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_final</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">State A cannot be non-final, because it has a</span>
<span class="go">final output word. Only final states can have a final output</span>
<span class="go">word.</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">is_final</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMState.is_initial">
<code class="descname">is_initial</code><em class="property"> = False</em><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.is_initial" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes whether the state is initial.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMState.label">
<code class="descname">label</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.label" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the label of the state.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>The label of the state.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;state&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
<span class="go">&#39;state&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMState.relabeled">
<code class="descname">relabeled</code><span class="sig-paren">(</span><em>label</em>, <em>memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMState.relabeled" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deep copy of the state with a new label.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">label</span></code> – the label of new state.</li>
<li><code class="docutils literal"><span class="pre">memo</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) a dictionary storing already
processed elements.</li>
</ul>
<p>OUTPUT:</p>
<p>A new state.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">relabeled</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="go">&#39;B&#39;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.finite_state_machine.FSMTransition">
<em class="property">class </em><code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">FSMTransition</code><span class="sig-paren">(</span><em>from_state</em>, <em>to_state</em>, <em>word_in=None</em>, <em>word_out=None</em>, <em>hook=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMTransition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Parents and Elements v8.1)"><code class="xref py py-class docutils literal"><span class="pre">sage.structure.sage_object.SageObject</span></code></a></p>
<p>Class for a transition of a finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">from_state</span></code> – state from which transition starts.</li>
<li><code class="docutils literal"><span class="pre">to_state</span></code> – state in which transition ends.</li>
<li><code class="docutils literal"><span class="pre">word_in</span></code> – the input word of the transitions (when the
finite state machine is used as automaton)</li>
<li><code class="docutils literal"><span class="pre">word_out</span></code> – the output word of the transitions (when the
finite state machine is used as transducer)</li>
</ul>
<p>OUTPUT:</p>
<p>A transition of a finite state machine.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span><span class="p">,</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">==</span> <span class="n">S</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">U</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">U</span> <span class="o">==</span> <span class="n">T</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMTransition.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMTransition.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a (shallow) copy of the transition.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A new transition.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">copy</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|-</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FSMTransition.deepcopy">
<code class="descname">deepcopy</code><span class="sig-paren">(</span><em>memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMTransition.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deep copy of the transition.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">memo</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) a dictionary storing already
processed elements.</li>
</ul>
<p>OUTPUT:</p>
<p>A new transition.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">deepcopy</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|-</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMTransition.from_state">
<code class="descname">from_state</code><em class="property"> = None</em><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMTransition.from_state" title="Permalink to this definition">¶</a></dt>
<dd><p>State from which the transition starts. Read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMTransition.to_state">
<code class="descname">to_state</code><em class="property"> = None</em><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMTransition.to_state" title="Permalink to this definition">¶</a></dt>
<dd><p>State in which the transition ends. Read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMTransition.word_in">
<code class="descname">word_in</code><em class="property"> = None</em><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMTransition.word_in" title="Permalink to this definition">¶</a></dt>
<dd><p>Input word of the transition. Read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FSMTransition.word_out">
<code class="descname">word_out</code><em class="property"> = None</em><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMTransition.word_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Output word of the transition. Read-only.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.FSMWordSymbol">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">FSMWordSymbol</code><span class="sig-paren">(</span><em>word</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FSMWordSymbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string of <code class="docutils literal"><span class="pre">word</span></code>. It may returns the symbol of the
empty word <code class="docutils literal"><span class="pre">FSMEmptyWordSymbol</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">word</span></code> – the input word.</li>
</ul>
<p>OUTPUT:</p>
<p>A string of <code class="docutils literal"><span class="pre">word</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMWordSymbol</span>
<span class="gp">sage: </span><span class="n">FSMWordSymbol</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">&#39;0,1,1&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine">
<em class="property">class </em><code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">FiniteStateMachine</code><span class="sig-paren">(</span><em>data=None</em>, <em>initial_states=None</em>, <em>final_states=None</em>, <em>input_alphabet=None</em>, <em>output_alphabet=None</em>, <em>determine_alphabets=None</em>, <em>with_final_word_out=None</em>, <em>store_states_dict=True</em>, <em>on_duplicate_transition=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Parents and Elements v8.1)"><code class="xref py py-class docutils literal"><span class="pre">sage.structure.sage_object.SageObject</span></code></a></p>
<p>Class for a finite state machine.</p>
<p>A finite state machine is a finite set of states connected by
transitions.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">data</span></code> – can be any of the following:</p>
<ol class="arabic simple">
<li>a dictionary of dictionaries (of transitions),</li>
<li>a dictionary of lists (of states or transitions),</li>
<li>a list (of transitions),</li>
<li>a function (transition function),</li>
<li>an other instance of a finite state machine.</li>
</ol>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">initial_states</span></code> and <code class="docutils literal"><span class="pre">final_states</span></code> – the initial and
final states of this machine</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">input_alphabet</span></code> and <code class="docutils literal"><span class="pre">output_alphabet</span></code> – the input and
output alphabets of this machine</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">determine_alphabets</span></code> – If <code class="docutils literal"><span class="pre">True</span></code>, then the function
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a> is called after <code class="docutils literal"><span class="pre">data</span></code> was read and
processed, if <code class="docutils literal"><span class="pre">False</span></code>, then not. If it is <code class="docutils literal"><span class="pre">None</span></code>, then it is
decided during the construction of the finite state machine
whether <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a> should be called.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">with_final_word_out</span></code> – If given (not <code class="docutils literal"><span class="pre">None</span></code>), then the
function <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out"><code class="xref py py-meth docutils literal"><span class="pre">with_final_word_out()</span></code></a> (more precisely, its inplace
pendant <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out"><code class="xref py py-meth docutils literal"><span class="pre">construct_final_word_out()</span></code></a>) is called with input
<code class="docutils literal"><span class="pre">letters=with_final_word_out</span></code> at the end of the creation
process.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">store_states_dict</span></code> – If <code class="docutils literal"><span class="pre">True</span></code>, then additionally the states
are stored in an interal dictionary for speed up.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">on_duplicate_transition</span></code> – A function which is called when a
transition is inserted into <code class="docutils literal"><span class="pre">self</span></code> which already existed (same
<code class="docutils literal"><span class="pre">from_state</span></code>, same <code class="docutils literal"><span class="pre">to_state</span></code>, same <code class="docutils literal"><span class="pre">word_in</span></code>, same <code class="docutils literal"><span class="pre">word_out</span></code>).</p>
<p>This function is assumed to take two arguments, the first being
the already existing transition, the second being the new
transition (as an <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><code class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></code></a>). The function must
return the (possibly modified) original transition.</p>
<p>By default, we have <code class="docutils literal"><span class="pre">on_duplicate_transition=None</span></code>, which is
interpreted as
<code class="docutils literal"><span class="pre">on_duplicate_transition=duplicate_transition_ignore</span></code>, where
<code class="docutils literal"><span class="pre">duplicate_transition_ignore</span></code> is a predefined function
ignoring the occurrence. Other such predefined functions are
<code class="docutils literal"><span class="pre">duplicate_transition_raise_error</span></code> and
<code class="docutils literal"><span class="pre">duplicate_transition_add_input</span></code>.</p>
</li>
</ul>
<p>OUTPUT:</p>
<p>A finite state machine.</p>
<p>The object creation of <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton" title="sage.combinat.finite_state_machine.Automaton"><code class="xref py py-class docutils literal"><span class="pre">Automaton</span></code></a> and <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer" title="sage.combinat.finite_state_machine.Transducer"><code class="xref py py-class docutils literal"><span class="pre">Transducer</span></code></a>
is the same as the one described here (i.e. just replace the word
<code class="docutils literal"><span class="pre">FiniteStateMachine</span></code> by <code class="docutils literal"><span class="pre">Automaton</span></code> or <code class="docutils literal"><span class="pre">Transducer</span></code>).</p>
<p>Each transition of an automaton has an input label. Automata can,
for example, be determinised (see
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.determinisation" title="sage.combinat.finite_state_machine.Automaton.determinisation"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.determinisation()</span></code></a>) and minimized (see
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.minimization" title="sage.combinat.finite_state_machine.Automaton.minimization"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.minimization()</span></code></a>). Each transition of a transducer
has an input and an output label. Transducers can, for example, be
simplified (see <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.simplification" title="sage.combinat.finite_state_machine.Transducer.simplification"><code class="xref py py-meth docutils literal"><span class="pre">Transducer.simplification()</span></code></a>).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span><span class="p">,</span> <span class="n">FSMTransition</span>
</pre></div>
</div>
<p>See documentation for more examples.</p>
<p>We illustrate the different input formats:</p>
<ol class="arabic">
<li><p class="first">The input-data can be a dictionary of dictionaries, where</p>
<ul class="simple">
<li>the keys of the outer dictionary are state-labels (from-states of
transitions),</li>
<li>the keys of the inner dictionaries are state-labels (to-states of
transitions),</li>
<li>the values of the inner dictionaries specify the transition
more precisely.</li>
</ul>
<p>The easiest is to use a tuple consisting of an input and an
output word:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:{</span><span class="s1">&#39;b&#39;</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;c&#39;</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}})</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
<p>Instead of the tuple anything iterable (e.g. a list) can be
used as well.</p>
<p>If you want to use the arguments of <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><code class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></code></a>
directly, you can use a dictionary:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:{</span><span class="s1">&#39;b&#39;</span><span class="p">:{</span><span class="s1">&#39;word_in&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;word_out&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span>
<span class="go">....:                          &#39;c&#39;:{&#39;word_in&#39;:1, &#39;word_out&#39;:1}}})</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
<p>In the case you already have instances of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><code class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></code></a>, it is possible to use them directly:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="n">FSMTransition</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                          &#39;c&#39;:FSMTransition(&#39;a&#39;, &#39;c&#39;, 1, 1)}})</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
</li>
<li><p class="first">The input-data can be a dictionary of lists, where the keys
are states or label of states.</p>
<p>The list-elements can be states:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">({</span><span class="n">a</span><span class="p">:[</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]})</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
<p>Or the list-elements can simply be labels of states:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]})</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
<p>The list-elements can also be transitions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="n">FSMTransition</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                          FSMTransition(&#39;a&#39;, &#39;c&#39;, 1, 1)]})</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
<p>Or they can be tuples of a label, an input word and an output
word specifying a transition:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]})</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
</li>
<li><p class="first">The input-data can be a list, where its elements specify
transitions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">([</span><span class="n">FSMTransition</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                     FSMTransition(&#39;a&#39;, &#39;c&#39;, 1, 1)])</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
<p>It is possible to skip <code class="docutils literal"><span class="pre">FSMTransition</span></code> in the example above:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
<p>The parameters of the transition are given in tuples. Anyhow,
anything iterable (e.g. a list) is possible.</p>
<p>You can also name the parameters of the transition. For this
purpose you take a dictionary:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">([{</span><span class="s1">&#39;from_state&#39;</span><span class="p">:</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;to_state&#39;</span><span class="p">:</span><span class="s1">&#39;b&#39;</span><span class="p">,</span>
<span class="go">....:                      &#39;word_in&#39;:0, &#39;word_out&#39;:1},</span>
<span class="go">....:                     {&#39;from_state&#39;:&#39;a&#39;, &#39;to_state&#39;:&#39;c&#39;,</span>
<span class="go">....:                      &#39;word_in&#39;:1, &#39;word_out&#39;:1}])</span>
<span class="go">Finite state machine with 3 states</span>
</pre></div>
</div>
<p>Other arguments, which <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><code class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></code></a> accepts, can be
added, too.</p>
</li>
<li><p class="first">The input-data can also be function acting as transition
function:</p>
<p>This function has two input arguments:</p>
<ol class="arabic simple">
<li>a label of a state (from which the transition starts),</li>
<li>a letter of the (input-)alphabet (as input-label of the transition).</li>
</ol>
<p>It returns a tuple with the following entries:</p>
<ol class="arabic simple">
<li>a label of a state (to which state the transition goes),</li>
<li>a letter of or a word over the (output-)alphabet (as
output-label of the transition).</li>
</ol>
<p>It may also output a list of such tuples if several
transitions from the from-state and the input letter exist
(this means that the finite state machine is
non-deterministic).</p>
<p>If the transition does not exist, the function should raise a
<code class="docutils literal"><span class="pre">LookupError</span></code> or return an empty list.</p>
<p>When constructing a finite state machine in this way, some
inital states and an input alphabet have to be specified.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">state_from</span><span class="p">,</span> <span class="n">read</span><span class="p">):</span>
<span class="go">....:     if int(state_from) + read &lt;= 2:</span>
<span class="go">....:         state_to = 2*int(state_from)+read</span>
<span class="go">....:         write = 0</span>
<span class="go">....:     else:</span>
<span class="go">....:         state_to = 2*int(state_from) + read - 5</span>
<span class="go">....:         write = 1</span>
<span class="go">....:     return (str(state_to), write)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">input_alphabet</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                        initial_states=[&#39;0&#39;],</span>
<span class="go">....:                        final_states=[&#39;0&#39;])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(True, &#39;0&#39;, [0, 0, 1])</span>
</pre></div>
</div>
</li>
<li><p class="first">The input-data can be an other instance of a finite state machine:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">F</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The other parameters cannot be specified in that case. If you
want to change these, use the attributes
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.is_initial" title="sage.combinat.finite_state_machine.FSMState.is_initial"><code class="xref py py-attr docutils literal"><span class="pre">FSMState.is_initial</span></code></a>, <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState.is_final" title="sage.combinat.finite_state_machine.FSMState.is_final"><code class="xref py py-attr docutils literal"><span class="pre">FSMState.is_final</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.input_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.input_alphabet"><code class="xref py py-attr docutils literal"><span class="pre">input_alphabet</span></code></a>, <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.output_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.output_alphabet"><code class="xref py py-attr docutils literal"><span class="pre">output_alphabet</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition" title="sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition"><code class="xref py py-attr docutils literal"><span class="pre">on_duplicate_transition</span></code></a> and methods
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out"><code class="xref py py-meth docutils literal"><span class="pre">construct_final_word_out()</span></code></a> on the new machine,
respectively.</p>
</li>
</ol>
<p>The following examples demonstrate the use of <code class="docutils literal"><span class="pre">on_duplicate_transition</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;a&#39; to &#39;a&#39;: 1/2|-]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_raise_error</span>
<span class="gp">sage: </span><span class="n">F1</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]],</span>
<span class="go">....:                         on_duplicate_transition=duplicate_transition_raise_error)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Attempting to re-insert transition Transition from &#39;a&#39; to &#39;a&#39;: 1/2|-</span>
</pre></div>
</div>
<p>Use <code class="docutils literal"><span class="pre">duplicate_transition_add_input</span></code> to emulate a Markov chain,
the input labels are considered as transition probabilities:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_add_input</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">]],</span>
<span class="go">....:                        on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;a&#39; to &#39;a&#39;: 1|-]</span>
</pre></div>
</div>
<p>Use <code class="docutils literal"><span class="pre">with_final_word_out</span></code> to construct final output:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0],</span>
<span class="go">....:                with_final_word_out=0)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">iter_final_states</span><span class="p">():</span>
<span class="go">....:     print(&quot;{} {}&quot;.format(s, s.final_word_out))</span>
<span class="go">0 []</span>
<span class="go">1 [0]</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Call either method <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.composition" title="sage.combinat.finite_state_machine.FiniteStateMachine.composition"><code class="xref py py-meth docutils literal"><span class="pre">composition()</span></code></a> or <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">process()</span></code></a>
(with <code class="docutils literal"><span class="pre">full_output=False</span></code>). If the input is not finite
(<code class="docutils literal"><span class="pre">is_finite</span></code> of input is <code class="docutils literal"><span class="pre">False</span></code>), then
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><code class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></code></a> (with <code class="docutils literal"><span class="pre">iterator_type='simple'</span></code>) is
called. Moreover, the flag <code class="docutils literal"><span class="pre">automatic_output_type</span></code> is set
(unless <code class="docutils literal"><span class="pre">format_output</span></code> is specified).
See the documentation of these functions for possible
parameters.</p>
<p>EXAMPLES:</p>
<p>The following code performs a <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.composition" title="sage.combinat.finite_state_machine.FiniteStateMachine.composition"><code class="xref py py-meth docutils literal"><span class="pre">composition()</span></code></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;B&#39;, 0, 0)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;], final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                 (2, 2, 0, 1), (2, 1, 1, 1)],</span>
<span class="go">....:                initial_states=[1], final_states=[1])</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[(&#39;A&#39;, 1), (&#39;B&#39;, 1), (&#39;B&#39;, 2)]</span>
</pre></div>
</div>
<p>An automaton or transducer can also act on an input (an list
or other iterable of letters):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">binary_inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:                              initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">binary_inverter</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[1, 0, 1, 1, 0, 0]</span>
</pre></div>
</div>
<p>We can also let them act on <a class="reference internal" href="words/words.html"><span class="doc">words</span></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">Words</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span> <span class="n">W</span>
<span class="go">Finite and infinite words over {0, 1}</span>
<span class="gp">sage: </span><span class="n">binary_inverter</span><span class="p">(</span><span class="n">W</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">word: 100100</span>
</pre></div>
</div>
<p>Infinite words work as well:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">()</span>
<span class="go">word: 0100101001001010010100100101001001010010...</span>
<span class="gp">sage: </span><span class="n">binary_inverter</span><span class="p">(</span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">())</span>
<span class="go">word: 1011010110110101101011011010110110101101...</span>
</pre></div>
</div>
<p>When only one successful path is found in a non-deterministic
transducer, the result of that path is returned.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0], final_states=[1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[(True, 1, [1]), (False, 2, [2])]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[1]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.composition" title="sage.combinat.finite_state_machine.FiniteStateMachine.composition"><code class="xref py py-meth docutils literal"><span class="pre">composition()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><code class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><code class="xref py py-meth docutils literal"><span class="pre">Transducer.process()</span></code></a>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                         (11, 13, 3, &#39;c&#39;), (11, 14, 4, &#39;d&#39;),</span>
<span class="go">....:                         (12, 13, 3, &#39;e&#39;), (12, 13, 3, &#39;f&#39;),</span>
<span class="go">....:                         (12, 14, 4, &#39;g&#39;), (12, 14, 4, &#39;h&#39;),</span>
<span class="go">....:                         (12, 13, 2, &#39;i&#39;), (12, 14, 2, &#39;j&#39;)],</span>
<span class="go">....:                        initial_states=[11],</span>
<span class="go">....:                        final_states=[13])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="go">....:     return &#39;&#39;.join(o)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">(False, None, None)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">(True, 13, &#39;c&#39;)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">(False, 14, &#39;d&#39;)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Got more than one output, but only allowed to show</span>
<span class="go">one. Change list_of_outputs option.</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[(True, 13, &#39;bi&#39;), (False, 14, &#39;bj&#39;)]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Got more than one output, but only allowed to show</span>
<span class="go">one. Change list_of_outputs option.</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[(True, 13, &#39;be&#39;), (True, 13, &#39;bf&#39;)]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Got more than one output, but only allowed to show</span>
<span class="go">one. Change list_of_outputs option.</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[(False, 14, &#39;bg&#39;), (False, 14, &#39;bh&#39;)]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="go">....:                (11, 13, 3), (11, 14, 4),</span>
<span class="go">....:                (12, 13, 3), (12, 14, 4),</span>
<span class="go">....:                (12, 32, 3), (12, 42, 4),</span>
<span class="go">....:                (12, 13, 2), (12, 14, 2)],</span>
<span class="go">....:               initial_states=[11],</span>
<span class="go">....:               final_states=[13, 32])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="go">....:     return &#39;&#39;.join(o)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[True, False]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[True, True]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[False, False]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                 (11, 13, 3, &#39;c&#39;), (11, 14, 4, &#39;d&#39;),</span>
<span class="go">....:                 (12, 13, 3, &#39;e&#39;), (12, 13, 3, &#39;f&#39;),</span>
<span class="go">....:                 (12, 14, 4, &#39;g&#39;), (12, 14, 4, &#39;h&#39;),</span>
<span class="go">....:                 (12, 13, 2, &#39;i&#39;), (12, 14, 2, &#39;j&#39;)],</span>
<span class="go">....:                initial_states=[11],</span>
<span class="go">....:                final_states=[13])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="go">....:     return &#39;&#39;.join(o)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">&#39;c&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="go">&#39;bi&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[&#39;bi&#39;, None]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span>
<span class="go">....:   list_of_outputs=True, only_accepted=True)</span>
<span class="go">[&#39;bi&#39;]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[(True, 13, &#39;bi&#39;), (False, 14, &#39;bj&#39;)]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Found more than one accepting path.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[&#39;be&#39;, &#39;bf&#39;]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[None, None]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
<span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">inverter</span><span class="p">(</span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">())</span>
<span class="go">word: 1011010110110101101011011010110110101101...</span>
<span class="gp">sage: </span><span class="n">inverter</span><span class="p">(</span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">(),</span> <span class="n">automatic_output_type</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">word: 1011010110110101101011011010110110101101...</span>
<span class="gp">sage: </span><span class="nb">tuple</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">inverter</span><span class="p">(</span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">(),</span>
<span class="go">....:                       automatic_output_type=False), 10))</span>
<span class="go">(1, 0, 1, 1, 0, 1, 0, 1, 1, 0)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">inverter</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:               automatic_output_type=False))</span>
<span class="go">&lt;... &#39;list&#39;&gt;</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">inverter</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:               automatic_output_type=True))</span>
<span class="go">&lt;... &#39;tuple&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components">
<code class="descname">accessible_components</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new finite state machine with the accessible states
of self and all transitions between those states.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A finite state machine with the accessible states of self and
all transitions between those states.</p>
<p>A state is accessible if there is a directed path from an
initial state to the state. If self has no initial states then
a copy of the finite state machine self is returned.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">accessible_components</span><span class="p">()</span>
<span class="go">Automaton with 2 states</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">accessible_components</span><span class="p">()</span>
<span class="go">Automaton with 1 state</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.coaccessible_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.coaccessible_components"><code class="xref py py-meth docutils literal"><span class="pre">coaccessible_components()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.add_from_transition_function">
<code class="descname">add_from_transition_function</code><span class="sig-paren">(</span><em>function</em>, <em>initial_states=None</em>, <em>explore_existing_states=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_from_transition_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a finite state machine from a transition function.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">function</span></code> may return a tuple (new_state, output_word) or a
list of such tuples.</li>
<li><code class="docutils literal"><span class="pre">initial_states</span></code> – If no initial states are given, the
already existing initial states of self are taken.</li>
<li>If <code class="docutils literal"><span class="pre">explore_existing_states</span></code> is True (default), then
already existing states in self (e.g. already given final
states) will also be processed if they are reachable from
the initial states.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">],</span>
<span class="go">....:                        input_alphabet=[0, 1])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
<span class="go">....:     return [(&#39;A&#39;, input), (&#39;B&#39;, 1-input)]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_from_transition_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;A&#39;: 0|0,</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|1,</span>
<span class="go">Transition from &#39;A&#39; to &#39;A&#39;: 1|1,</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 1|0,</span>
<span class="go">Transition from &#39;B&#39; to &#39;A&#39;: 0|0,</span>
<span class="go">Transition from &#39;B&#39; to &#39;B&#39;: 0|1,</span>
<span class="go">Transition from &#39;B&#39; to &#39;A&#39;: 1|1,</span>
<span class="go">Transition from &#39;B&#39; to &#39;B&#39;: 1|0]</span>
</pre></div>
</div>
<p>Initial states can also be given as a parameter:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">input_alphabet</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
<span class="go">....:     return [(&#39;A&#39;, input), (&#39;B&#39;, 1-input)]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_from_transition_function</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;]</span>
</pre></div>
</div>
<p>Already existing states in the finite state machine (the final
states in the example below) are also explored:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="go">....:                        final_states=[1],</span>
<span class="go">....:                        input_alphabet=[0])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">transition_function</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">letter</span><span class="p">):</span>
<span class="go">....:     return(1-state, [])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_from_transition_function</span><span class="p">(</span><span class="n">transition_function</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|-,</span>
<span class="go"> Transition from 1 to 0: 0|-]</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">explore_existing_states=False</span></code>, however, this behavior
is turned off, i.e., already existing states are not
explored:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="go">....:                        final_states=[1],</span>
<span class="go">....:                        input_alphabet=[0])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">transition_function</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">letter</span><span class="p">):</span>
<span class="go">....:     return(1-state, [])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_from_transition_function</span><span class="p">(</span><span class="n">transition_function</span><span class="p">,</span>
<span class="go">....:                                explore_existing_states=False)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|-]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">transition</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">where</span><span class="p">):</span>
<span class="go">....:     return (vector([0, 0]), 1)</span>
<span class="gp">sage: </span><span class="n">Transducer</span><span class="p">(</span><span class="n">transition</span><span class="p">,</span> <span class="n">input_alphabet</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">mutable vectors are unhashable</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.add_state">
<code class="descname">add_state</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a state to the finite state machine and returns the new
state. If the state already exists, that existing state is
returned.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">state</span></code> is either an instance of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><code class="xref py py-class docutils literal"><span class="pre">FSMState</span></code></a> or,
otherwise, a label of a state.</li>
</ul>
<p>OUTPUT:</p>
<p>The new or existing state.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">is_initial</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">&#39;A&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.add_states">
<code class="descname">add_states</code><span class="sig-paren">(</span><em>states</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds several states. See add_state for more information.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">states</span></code> – a list of states or iterator over states.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_states</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;, &#39;B&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.add_transition">
<code class="descname">add_transition</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a transition to the finite state machine and returns the
new transition.</p>
<p>If the transition already exists, the return value of
<code class="docutils literal"><span class="pre">self.on_duplicate_transition</span></code> is returned. See the
documentation of <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>.</p>
<p>INPUT:</p>
<p>The following forms are all accepted:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span><span class="p">,</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">FSMTransition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|1</span>

<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|1</span>

<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">word_in</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">word_out</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|1</span>

<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;word_in&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;word_out&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: {&#39;word_in&#39;: 0, &#39;word_out&#39;: 1}|-</span>

<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">from_state</span><span class="o">=</span><span class="n">A</span><span class="p">,</span> <span class="n">to_state</span><span class="o">=</span><span class="n">B</span><span class="p">,</span>
<span class="go">....:                    word_in=0, word_out=1)</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|1</span>

<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">add_transition</span><span class="p">({</span><span class="s1">&#39;from_state&#39;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="s1">&#39;to_state&#39;</span><span class="p">:</span> <span class="n">B</span><span class="p">,</span>
<span class="go">....:                    &#39;word_in&#39;: 0, &#39;word_out&#39;: 1})</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|1</span>

<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|1</span>

<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">add_transition</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|1</span>
</pre></div>
</div>
<p>If the states <code class="docutils literal"><span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span></code> are not instances of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><code class="xref py py-class docutils literal"><span class="pre">FSMState</span></code></a>, then it is assumed that they are labels of
states.</p>
<p>OUTPUT:</p>
<p>The new transition.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.add_transitions_from_function">
<code class="descname">add_transitions_from_function</code><span class="sig-paren">(</span><em>function</em>, <em>labels_as_input=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.add_transitions_from_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds one or more transitions if <code class="docutils literal"><span class="pre">function(state,</span> <span class="pre">state)</span></code>
says that there are some.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">function</span></code> – a transition function. Given two states
<code class="docutils literal"><span class="pre">from_state</span></code> and <code class="docutils literal"><span class="pre">to_state</span></code> (or their labels if
<code class="docutils literal"><span class="pre">label_as_input</span></code> is true), this function shall return a
tuple <code class="docutils literal"><span class="pre">(word_in,</span> <span class="pre">word_out)</span></code> to add a transition from
<code class="docutils literal"><span class="pre">from_state</span></code> to <code class="docutils literal"><span class="pre">to_state</span></code> with input and output labels
<code class="docutils literal"><span class="pre">word_in</span></code> and <code class="docutils literal"><span class="pre">word_out</span></code>, respectively. If no such
addition is to be added, the transition function shall
return <code class="docutils literal"><span class="pre">None</span></code>. The transition function may also return
a list of such tuples in order to add multiple transitions
between the pair of states.</li>
<li><code class="docutils literal"><span class="pre">label_as_input</span></code> – (default: <code class="docutils literal"><span class="pre">True</span></code>)</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_states</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">):</span>
<span class="go">....:     if state1 == &#39;C&#39;:</span>
<span class="go">....:         return None</span>
<span class="go">....:     return (0, 1)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_transitions_from_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">6</span>
</pre></div>
</div>
<p>Multiple transitions are also possible:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_states</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">):</span>
<span class="go">....:     if state1 != state2:</span>
<span class="go">....:          return [(0, 1), (1, 0)]</span>
<span class="go">....:     else:</span>
<span class="go">....:          return None</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">add_transitions_from_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|1,</span>
<span class="go"> Transition from 0 to 1: 1|0,</span>
<span class="go"> Transition from 1 to 0: 0|1,</span>
<span class="go"> Transition from 1 to 0: 1|0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.adjacency_matrix">
<code class="descname">adjacency_matrix</code><span class="sig-paren">(</span><em>input=None</em>, <em>entry=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.adjacency_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the adjacency matrix of the underlying graph.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">input</span></code> – Only transitions with input label <code class="docutils literal"><span class="pre">input</span></code> are
respected.</li>
<li><code class="docutils literal"><span class="pre">entry</span></code> – The function <code class="docutils literal"><span class="pre">entry</span></code> takes a transition and the
return value is written in the matrix as the entry
<code class="docutils literal"><span class="pre">(transition.from_state,</span> <span class="pre">transition.to_state)</span></code>. The default
value (<code class="docutils literal"><span class="pre">None</span></code>) of entry takes the variable <code class="docutils literal"><span class="pre">x</span></code> to the
power of the sum of the output word of the transition.</li>
</ul>
<p>OUTPUT:</p>
<p>A matrix.</p>
<p>If any label of a state is not an integer, the finite state
machine is relabeled at the beginning.  If there are more than
one transitions between two states, then the different return
values of <code class="docutils literal"><span class="pre">entry</span></code> are added up.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">({</span><span class="mi">0</span><span class="p">:{</span><span class="mi">0</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;a&#39;</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)},</span>
<span class="go">....:                         &#39;a&#39;:{2:(0, 0), 3:(1, 0)},</span>
<span class="go">....:                         2:{0:(1, 1), 4:(0, 0)},</span>
<span class="go">....:                         3:{&#39;a&#39;:(0, 1), 2:(1, 1)},</span>
<span class="go">....:                         4:{4:(1, 1), 3:(0, 1)}},</span>
<span class="go">....:                        initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[1 1 0 0 0]</span>
<span class="go">[0 0 1 1 0]</span>
<span class="go">[x 0 0 0 1]</span>
<span class="go">[0 x x 0 0]</span>
<span class="go">[0 0 0 x x]</span>
</pre></div>
</div>
<p>This is equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">matrix</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[1 1 0 0 0]</span>
<span class="go">[0 0 1 1 0]</span>
<span class="go">[x 0 0 0 1]</span>
<span class="go">[0 x x 0 0]</span>
<span class="go">[0 0 0 x x]</span>
</pre></div>
</div>
<p>It is also possible to use other entries in the adjacency matrix:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">entry</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">transition</span><span class="p">:</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">[1 1 0 0 0]</span>
<span class="go">[0 0 1 1 0]</span>
<span class="go">[1 0 0 0 1]</span>
<span class="go">[0 1 1 0 0]</span>
<span class="go">[0 0 0 1 1]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">entry</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">transition</span><span class="p">:</span>
<span class="go">....:     exp(I*transition.word_out[0]*var(&#39;t&#39;))))</span>
<span class="go">[      0       1       0       0       0]</span>
<span class="go">[      0       0       0       1       0]</span>
<span class="go">[e^(I*t)       0       0       0       0]</span>
<span class="go">[      0       0 e^(I*t)       0       0]</span>
<span class="go">[      0       0       0       0 e^(I*t)]</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                (1, 2, 0),</span>
<span class="go">....:                (2, 0, 1),</span>
<span class="go">....:                (2, 1, 0)],</span>
<span class="go">....:               initial_states=[0],</span>
<span class="go">....:               final_states=[0])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">()</span>
<span class="go">[0 1 0]</span>
<span class="go">[0 0 1]</span>
<span class="go">[1 1 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.asymptotic_moments">
<code class="descname">asymptotic_moments</code><span class="sig-paren">(</span><em>variable=n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.asymptotic_moments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the main terms of expectation and variance of the sum
of output labels and its covariance with the sum of input
labels.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">variable</span></code> – a symbol denoting the length of the input,
by default <span class="math">\(n\)</span>.</li>
</ul>
<p>OUTPUT:</p>
<p>A dictionary consisting of</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">expectation</span></code> – <span class="math">\(e n + \operatorname{Order}(1)\)</span>,</li>
<li><code class="docutils literal"><span class="pre">variance</span></code> – <span class="math">\(v n + \operatorname{Order}(1)\)</span>,</li>
<li><code class="docutils literal"><span class="pre">covariance</span></code> – <span class="math">\(c n + \operatorname{Order}(1)\)</span></li>
</ul>
<p>for suitable constants <span class="math">\(e\)</span>, <span class="math">\(v\)</span> and <span class="math">\(c\)</span>.</p>
<p>Assume that all input and output labels are numbers and that
<code class="docutils literal"><span class="pre">self</span></code> is complete and has only one final component. Assume
further that this final component is aperiodic. Furthermore,
assume that there is exactly one initial state and that all
states are final.</p>
<p>Denote by <span class="math">\(X_n\)</span> the sum of output labels written by the
finite state machine when reading a random input word of
length <span class="math">\(n\)</span> over the input alphabet (assuming
equidistribution).</p>
<p>Then the expectation of <span class="math">\(X_n\)</span> is <span class="math">\(en+O(1)\)</span>, the variance
of <span class="math">\(X_n\)</span> is <span class="math">\(vn+O(1)\)</span> and the covariance of <span class="math">\(X_n\)</span> and
the sum of input labels is <span class="math">\(cn+O(1)\)</span>, cf. <a class="reference internal" href="#hkw2015" id="id5">[HKW2015]</a>,
Theorem 3.9.</p>
<p>In the case of non-integer input or output labels, performance
degrades significantly. For rational input and output labels,
consider rescaling to integers. This limitation comes from the
fact that determinants over polynomial rings can be computed
much more efficiently than over the symbolic ring. In fact, we
compute (parts) of a trivariate generating function where the
input and output labels are exponents of some indeterminates,
see <a class="reference internal" href="#hkw2015" id="id6">[HKW2015]</a>, Theorem 3.9 for details. If those exponents are
integers, we can use a polynomial ring.</p>
<p>EXAMPLES:</p>
<ol class="arabic">
<li><p class="first">A trivial example: write the negative of the input:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[0, -1, -1]</span>
<span class="gp">sage: </span><span class="n">moments</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">-1/2*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;variance&#39;</span><span class="p">]</span>
<span class="go">1/4*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;covariance&#39;</span><span class="p">]</span>
<span class="go">-1/4*n + Order(1)</span>
</pre></div>
</div>
</li>
<li><p class="first">For the case of the Hamming weight of the non-adjacent-form
(NAF) of integers, cf. the <a class="reference external" href="https://en.wikipedia.org/wiki/Non-adjacent_form">Wikipedia article Non-adjacent_form</a>
and the <a class="reference internal" href="#finite-state-machine-recognizing-nafs-example"><span class="std std-ref">example on recognizing NAFs</span></a>, the
following agrees with the results in <a class="reference internal" href="#hp2007" id="id7">[HP2007]</a>.</p>
<p>We first use the transducer to convert the standard binary
expansion to the NAF given in <a class="reference internal" href="#hp2007" id="id8">[HP2007]</a>. We use the parameter
<code class="docutils literal"><span class="pre">with_final_word_out</span></code> such that we do not have to add
sufficiently many trailing zeros:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                   (0, &#39;.1&#39;, 1, None),</span>
<span class="go">....:                   (&#39;.1&#39;, 0, 0, [1, 0]),</span>
<span class="go">....:                   (&#39;.1&#39;, 1, 1, [-1, 0]),</span>
<span class="go">....:                   (1, 1, 1, 0),</span>
<span class="go">....:                   (1, &#39;.1&#39;, 0, None)],</span>
<span class="go">....:                  initial_states=[0],</span>
<span class="go">....:                  final_states=[0],</span>
<span class="go">....:                  with_final_word_out=[0])</span>
</pre></div>
</div>
<p>As an example, we compute the NAF of <span class="math">\(27\)</span> by this
transducer.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">binary_27</span> <span class="o">=</span> <span class="mf">27.</span><span class="n">bits</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">binary_27</span>
<span class="go">[1, 1, 0, 1, 1]</span>
<span class="gp">sage: </span><span class="n">NAF_27</span> <span class="o">=</span> <span class="n">NAF</span><span class="p">(</span><span class="n">binary_27</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">NAF_27</span>
<span class="go">[-1, 0, -1, 0, 0, 1, 0]</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="n">NAF_27</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">27</span>
</pre></div>
</div>
<p>Next, we are only interested in the Hamming weight:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">weight</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
<span class="go">....:     if input is None:</span>
<span class="go">....:         result = 0</span>
<span class="go">....:     else:</span>
<span class="go">....:         result = ZZ(input != 0)</span>
<span class="go">....:     return (0, result)</span>
<span class="gp">sage: </span><span class="n">weight_transducer</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span>
<span class="go">....:                                input_alphabet=[-1, 0, 1],</span>
<span class="go">....:                                initial_states=[0],</span>
<span class="go">....:                                final_states=[0])</span>
<span class="gp">sage: </span><span class="n">NAFweight</span> <span class="o">=</span> <span class="n">weight_transducer</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">NAF</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">NAFweight</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (0, 0) to (0, 0): 0|0,</span>
<span class="go"> Transition from (0, 0) to (&#39;.1&#39;, 0): 1|-,</span>
<span class="go"> Transition from (&#39;.1&#39;, 0) to (0, 0): 0|1,0,</span>
<span class="go"> Transition from (&#39;.1&#39;, 0) to (1, 0): 1|1,0,</span>
<span class="go"> Transition from (1, 0) to (&#39;.1&#39;, 0): 0|-,</span>
<span class="go"> Transition from (1, 0) to (1, 0): 1|0]</span>
<span class="gp">sage: </span><span class="n">NAFweight</span><span class="p">(</span><span class="n">binary_27</span><span class="p">)</span>
<span class="go">[1, 0, 1, 0, 0, 1, 0]</span>
</pre></div>
</div>
<p>Now, we actually compute the asymptotic moments:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">moments</span> <span class="o">=</span> <span class="n">NAFweight</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">1/3*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;variance&#39;</span><span class="p">]</span>
<span class="go">2/27*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;covariance&#39;</span><span class="p">]</span>
<span class="go">Order(1)</span>
</pre></div>
</div>
</li>
<li><p class="first">This is Example 3.16 in <a class="reference internal" href="#hkw2015" id="id9">[HKW2015]</a>, where a transducer with
variable output labels is given. There, the aim was to
choose the output labels of this very simple transducer such
that the input and output sum are asymptotically
independent, i.e., the constant <span class="math">\(c\)</span> vanishes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;a_1, a_2, a_3, a_4&#39;</span><span class="p">)</span>
<span class="go">(a_1, a_2, a_3, a_4)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a_1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a_3</span><span class="p">],</span>
<span class="go">....:                 [1, 0, 0, a_4], [1, 1, 1, a_2]],</span>
<span class="go">....:                initial_states=[0], final_states=[0, 1])</span>
<span class="gp">sage: </span><span class="n">moments</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="go">verbose 0 (...) Non-integer output weights lead to</span>
<span class="go">significant performance degradation.</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">1/4*(a_1 + a_2 + a_3 + a_4)*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;covariance&#39;</span><span class="p">]</span>
<span class="go">-1/4*(a_1 - a_2)*n + Order(1)</span>
</pre></div>
</div>
<p>Therefore, the asymptotic covariance vanishes if and only if
<span class="math">\(a_2=a_1\)</span>.</p>
</li>
<li><p class="first">This is Example 4.3 in <a class="reference internal" href="#hkw2015" id="id10">[HKW2015]</a>, dealing with the
transducer converting the binary expansion of an integer
into Gray code (cf. the <a class="reference external" href="https://en.wikipedia.org/wiki/Gray_code">Wikipedia article Gray_code</a> and the
<a class="reference internal" href="#finite-state-machine-gray-code-example"><span class="std std-ref">example on Gray code</span></a>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">moments</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">GrayCode</span><span class="p">()</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">1/2*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;variance&#39;</span><span class="p">]</span>
<span class="go">1/4*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;covariance&#39;</span><span class="p">]</span>
<span class="go">Order(1)</span>
</pre></div>
</div>
</li>
<li><p class="first">This is the first part of Example 4.4 in <a class="reference internal" href="#hkw2015" id="id11">[HKW2015]</a>,
counting the number of 10 blocks in the standard binary
expansion. The least significant digit is at the left-most
position:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">block10</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">(</span>
<span class="go">....:     [1, 0],</span>
<span class="go">....:     input_alphabet=[0, 1])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">block10</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from () to (): 0|0,</span>
<span class="go"> Transition from () to (1,): 1|0,</span>
<span class="go"> Transition from (1,) to (): 0|1,</span>
<span class="go"> Transition from (1,) to (1,): 1|0]</span>
<span class="gp">sage: </span><span class="n">moments</span> <span class="o">=</span> <span class="n">block10</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">1/4*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;variance&#39;</span><span class="p">]</span>
<span class="go">1/16*n + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;covariance&#39;</span><span class="p">]</span>
<span class="go">Order(1)</span>
</pre></div>
</div>
</li>
<li><p class="first">This is the second part of Example 4.4 in <a class="reference internal" href="#hkw2015" id="id12">[HKW2015]</a>,
counting the number of 11 blocks in the standard binary
expansion. The least significant digit is at the left-most
position:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">block11</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">(</span>
<span class="go">....:     [1, 1],</span>
<span class="go">....:     input_alphabet=[0, 1])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">block11</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from () to (): 0|0,</span>
<span class="go"> Transition from () to (1,): 1|0,</span>
<span class="go"> Transition from (1,) to (): 0|0,</span>
<span class="go"> Transition from (1,) to (1,): 1|1]</span>
<span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>
<span class="go">N</span>
<span class="gp">sage: </span><span class="n">moments</span> <span class="o">=</span> <span class="n">block11</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">1/4*N + Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;variance&#39;</span><span class="p">]</span>
<span class="go">5/16*N + Order(1)</span>
<span class="gp">sage: </span><span class="n">correlation</span> <span class="o">=</span> <span class="p">(</span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;covariance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">coefficient</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span>
<span class="go">....:                (1/2 * sqrt(moments[&#39;variance&#39;].coefficient(N))))</span>
<span class="gp">sage: </span><span class="n">correlation</span>
<span class="go">2/5*sqrt(5)</span>
</pre></div>
</div>
</li>
<li><p class="first">This is Example 4.5 in <a class="reference internal" href="#hkw2015" id="id13">[HKW2015]</a>, counting the number of
01 blocks minus the number of 10 blocks in the standard binary
expansion. The least significant digit is at the left-most
position:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">block01</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">(</span>
<span class="go">....:     [0, 1],</span>
<span class="go">....:     input_alphabet=[0, 1])</span>
<span class="gp">sage: </span><span class="n">product_01x10</span> <span class="o">=</span> <span class="n">block01</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">block10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">block_difference</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])(</span><span class="n">product_01x10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">block_difference</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|-1,</span>
<span class="go"> Transition from 0 to 0: 1|0,</span>
<span class="go"> Transition from 1 to 1: 0|0,</span>
<span class="go"> Transition from 1 to 0: 1|1,</span>
<span class="go"> Transition from 2 to 1: 0|0,</span>
<span class="go"> Transition from 2 to 0: 1|0]</span>
<span class="gp">sage: </span><span class="n">moments</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;expectation&#39;</span><span class="p">]</span>
<span class="go">Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;variance&#39;</span><span class="p">]</span>
<span class="go">Order(1)</span>
<span class="gp">sage: </span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;covariance&#39;</span><span class="p">]</span>
<span class="go">Order(1)</span>
</pre></div>
</div>
</li>
<li><p class="first">The finite state machine must have a unique final component:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (-1, -1, -1, -1), (-1, -1, 1, -1),</span>
<span class="go">....:                 (1, 1, -1, 1), (1, 1, 1, 1)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0, 1, -1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">asymptotic_moments</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">asymptotic_moments is only</span>
<span class="go">implemented for finite state machines with one final</span>
<span class="go">component.</span>
</pre></div>
</div>
<p>In this particular example, the first letter of the input
decides whether we reach the loop at <span class="math">\(-1\)</span> or the loop at
<span class="math">\(1\)</span>. In the first case, we have <span class="math">\(X_n = -n\)</span>, while we have
<span class="math">\(X_n = n\)</span> in the second case. Therefore, the expectation
<span class="math">\(E(X_n)\)</span> of <span class="math">\(X_n\)</span> is <span class="math">\(E(X_n) = 0\)</span>. We get <span class="math">\((X_n-E(X_n))^2 =
n^2\)</span> in all cases, which results in a variance of <span class="math">\(n^2\)</span>.</p>
<p>So this example shows that the variance may be non-linear if
there is more than one final component.</p>
</li>
</ol>
<p>ALGORITHM:</p>
<p>See <a class="reference internal" href="#hkw2015" id="id14">[HKW2015]</a>, Theorem 3.9.</p>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="hp2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[HP2007]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id8">2</a>)</em> Clemens Heuberger and Helmut Prodinger, <em>The Hamming
Weight of the Non-Adjacent-Form under Various Input Statistics</em>,
Periodica Mathematica Hungarica Vol. 55 (1), 2007, pp. 81–96,
<a class="reference external" href="https://dx.doi.org/10.1007/s10998-007-3081-z">doi:10.1007/s10998-007-3081-z</a>.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.coaccessible_components">
<code class="descname">coaccessible_components</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.coaccessible_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sub-machine induced by the coaccessible states of this
finite state machine.</p>
<p>OUTPUT:</p>
<p>A finite state machine of the same type as this finite state
machine.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">ContainsWord</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:     input_alphabet=[0, 1]).complement().minimization().relabeled()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: 0|-,</span>
<span class="go"> Transition from 0 to 0: 1|-,</span>
<span class="go"> Transition from 1 to 1: 0|-,</span>
<span class="go"> Transition from 1 to 2: 1|-,</span>
<span class="go"> Transition from 2 to 1: 0|-,</span>
<span class="go"> Transition from 2 to 0: 1|-]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[1, 2]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">coaccessible_components</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 1 to 1: 0|-,</span>
<span class="go"> Transition from 1 to 2: 1|-,</span>
<span class="go"> Transition from 2 to 1: 0|-]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components"><code class="xref py py-meth docutils literal"><span class="pre">accessible_components()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.induced_sub_finite_state_machine" title="sage.combinat.finite_state_machine.FiniteStateMachine.induced_sub_finite_state_machine"><code class="xref py py-meth docutils literal"><span class="pre">induced_sub_finite_state_machine()</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.completion">
<code class="descname">completion</code><span class="sig-paren">(</span><em>sink=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.completion" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a completion of this finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">sink</span></code> – either an instance of <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><code class="xref py py-class docutils literal"><span class="pre">FSMState</span></code></a> or a label
for the sink (default: <code class="docutils literal"><span class="pre">None</span></code>). If <code class="docutils literal"><span class="pre">None</span></code>, the least
available non-zero integer is used.</li>
</ul>
<p>OUTPUT:</p>
<p>A <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a> of the same type as this finite
state machine.</p>
<p>The resulting finite state machine is a complete version of this
finite state machine.  A finite state machine is considered to
be complete if each transition has an input label of length one
and for each pair <span class="math">\((q, a)\)</span> where <span class="math">\(q\)</span> is a state and <span class="math">\(a\)</span> is an
element of the input alphabet, there is exactly one transition
from <span class="math">\(q\)</span> with input label <span class="math">\(a\)</span>.</p>
<p>If this finite state machine is already complete, a deep copy is
returned. Otherwise, a new non-final state (usually called a
sink) is created and transitions to this sink are introduced as
appropriate.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                         (0, 1, 1, 1),</span>
<span class="go">....:                         (1, 1, 0, 0)])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G1</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">completion</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G1</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: 0|0,</span>
<span class="go"> Transition from 0 to 1: 1|1,</span>
<span class="go"> Transition from 1 to 1: 0|0,</span>
<span class="go"> Transition from 1 to 2: 1|-,</span>
<span class="go"> Transition from 2 to 2: 0|-,</span>
<span class="go"> Transition from 2 to 2: 1|-]</span>
<span class="gp">sage: </span><span class="n">G2</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">completion</span><span class="p">(</span><span class="s1">&#39;Sink&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G2</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G2</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 0: 0|0,</span>
<span class="go"> Transition from 0 to 1: 1|1,</span>
<span class="go"> Transition from 1 to 1: 0|0,</span>
<span class="go"> Transition from 1 to &#39;Sink&#39;: 1|-,</span>
<span class="go"> Transition from &#39;Sink&#39; to &#39;Sink&#39;: 0|-,</span>
<span class="go"> Transition from &#39;Sink&#39; to &#39;Sink&#39;: 1|-]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">completion</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The finite state machine already contains a state</span>
<span class="go">&#39;1&#39;.</span>
</pre></div>
</div>
<p>An input alphabet must be given:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                         (0, 1, 1, 1),</span>
<span class="go">....:                         (1, 1, 0, 0)],</span>
<span class="go">....:                        determine_alphabets=False)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No input alphabet is given. Try calling</span>
<span class="go">determine_alphabets().</span>
</pre></div>
</div>
<p>Non-deterministic machines are not allowed.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">completion</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The finite state machine must be deterministic.</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">completion</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">The finite state machine must be deterministic.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_complete" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_complete"><code class="xref py py-meth docutils literal"><span class="pre">is_complete()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.split_transitions" title="sage.combinat.finite_state_machine.FiniteStateMachine.split_transitions"><code class="xref py py-meth docutils literal"><span class="pre">split_transitions()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_deterministic" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_deterministic"><code class="xref py py-meth docutils literal"><span class="pre">is_deterministic()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.composition">
<code class="descname">composition</code><span class="sig-paren">(</span><em>other</em>, <em>algorithm=None</em>, <em>only_accessible_components=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.composition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new transducer which is the composition of <code class="docutils literal"><span class="pre">self</span></code>
and <code class="docutils literal"><span class="pre">other</span></code>.</p>
<p>INPUT:</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">other</span></code> – a transducer</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">algorithm</span></code> – can be one of the following</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">direct</span></code> – The composition is calculated directly.</p>
<p>There can be arbitrarily many initial and final states,
but the input and output labels must have length <span class="math">\(1\)</span>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The output of <code class="docutils literal"><span class="pre">other</span></code> is fed into <code class="docutils literal"><span class="pre">self</span></code>.</p>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">explorative</span></code> – An explorative algorithm is used.</p>
<p>The input alphabet of self has to be specified.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The output of <code class="docutils literal"><span class="pre">other</span></code> is fed into <code class="docutils literal"><span class="pre">self</span></code>.</p>
</div>
</li>
</ul>
<p>If algorithm is <code class="docutils literal"><span class="pre">None</span></code>, then the algorithm is chosen
automatically (at the moment always <code class="docutils literal"><span class="pre">direct</span></code>, except when
there are output words of <code class="docutils literal"><span class="pre">other</span></code> or input words of <code class="docutils literal"><span class="pre">self</span></code>
of length greater than <span class="math">\(1\)</span>).</p>
</li>
</ul>
<p>OUTPUT:</p>
<p>A new transducer.</p>
<p>The labels of the new finite state machine are pairs of states
of the original finite state machines. The color of a new
state is the tuple of colors of the constituent states.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;, &#39;B&#39;], final_states=[&#39;B&#39;],</span>
<span class="go">....:                determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (2, 2, 1, 1), (2, 2, 0, 0)],</span>
<span class="go">....:                initial_states=[1], final_states=[2],</span>
<span class="go">....:                determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Hd</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[(1, &#39;B&#39;), (1, &#39;A&#39;)]</span>
<span class="gp">sage: </span><span class="n">Hd</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (1, &#39;B&#39;) to (1, &#39;A&#39;): 1|1,</span>
<span class="go"> Transition from (1, &#39;A&#39;) to (2, &#39;B&#39;): 0|0,</span>
<span class="go"> Transition from (2, &#39;B&#39;) to (2, &#39;A&#39;): 0|1,</span>
<span class="go"> Transition from (2, &#39;A&#39;) to (2, &#39;B&#39;): 1|0]</span>
<span class="gp">sage: </span><span class="n">He</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">He</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[(1, &#39;A&#39;), (1, &#39;B&#39;)]</span>
<span class="gp">sage: </span><span class="n">He</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (1, &#39;A&#39;) to (2, &#39;B&#39;): 0|0,</span>
<span class="go"> Transition from (1, &#39;B&#39;) to (1, &#39;A&#39;): 1|1,</span>
<span class="go"> Transition from (2, &#39;B&#39;) to (2, &#39;A&#39;): 0|1,</span>
<span class="go"> Transition from (2, &#39;A&#39;) to (2, &#39;B&#39;): 1|0]</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">==</span> <span class="n">He</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The following example has output of length <span class="math">\(&gt; 1\)</span>, so the
explorative algorithm has to be used (and is selected
automatically).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;B&#39;, 0, 0)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;], final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                 (2, 2, 0, 1), (2, 1, 1, 1)],</span>
<span class="go">....:                initial_states=[1], final_states=[1])</span>
<span class="gp">sage: </span><span class="n">He</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">He</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;A&#39;, 1) to (&#39;B&#39;, 2): 1|0,1,</span>
<span class="go"> Transition from (&#39;B&#39;, 2) to (&#39;B&#39;, 2): 0|1,</span>
<span class="go"> Transition from (&#39;B&#39;, 2) to (&#39;B&#39;, 1): 1|1,</span>
<span class="go"> Transition from (&#39;B&#39;, 1) to (&#39;B&#39;, 1): 0|0,</span>
<span class="go"> Transition from (&#39;B&#39;, 1) to (&#39;B&#39;, 2): 1|0]</span>
<span class="gp">sage: </span><span class="n">Ha</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Ha</span> <span class="o">==</span> <span class="n">He</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Final output words are also considered:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;, &#39;B&#39;],</span>
<span class="go">....:                final_states=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (2, 2, 1, 1), (2, 2, 0, 0)],</span>
<span class="go">....:                initial_states=[1], final_states=[2])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Hd</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[(2, &#39;B&#39;)]</span>
<span class="gp">sage: </span><span class="n">He</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">He</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[(2, &#39;B&#39;)]</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">(2,</span> <span class="pre">'A')</span></code> is not final, as the final output <span class="math">\(0\)</span>
of state <span class="math">\(2\)</span> of <span class="math">\(G\)</span> cannot be processed in state <code class="docutils literal"><span class="pre">'A'</span></code> of
<span class="math">\(F\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">final_word_out</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Hd</span><span class="o">.</span><span class="n">final_states</span><span class="p">()]</span>
<span class="go">[[1, 0]]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">final_word_out</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">He</span><span class="o">.</span><span class="n">final_states</span><span class="p">()]</span>
<span class="go">[[1, 0]]</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">==</span> <span class="n">He</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Here is a non-deterministic example with intermediate output
length <span class="math">\(&gt;1\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">]),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                 (2, 1, 2, &#39;a&#39;), (2, 2, 2, &#39;b&#39;)],</span>
<span class="go">....:                initial_states=[1, 2])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">),</span>
<span class="go">....:                 (&#39;A&#39;, &#39;B&#39;, &#39;a&#39;, &#39;l&#39;),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;B&#39;, &#39;b&#39;, &#39;e&#39;)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (1, &#39;A&#39;) to (1, &#39;A&#39;): 1|&#39;i&#39;,&#39;i&#39;,</span>
<span class="go"> Transition from (1, &#39;A&#39;) to (1, &#39;B&#39;): 1|&#39;i&#39;,&#39;l&#39;,</span>
<span class="go"> Transition from (1, &#39;B&#39;) to (2, &#39;B&#39;): 1|&#39;e&#39;,</span>
<span class="go"> Transition from (2, &#39;A&#39;) to (1, &#39;A&#39;): 2|&#39;i&#39;,</span>
<span class="go"> Transition from (2, &#39;A&#39;) to (1, &#39;B&#39;): 2|&#39;l&#39;,</span>
<span class="go"> Transition from (2, &#39;B&#39;) to (2, &#39;B&#39;): 2|&#39;e&#39;]</span>
</pre></div>
</div>
<p>Be aware that after composition, different transitions may
share the same output label (same python object):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;],</span>
<span class="go">....:                final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">word_out</span> <span class="ow">is</span> <span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">word_out</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)],)</span>
<span class="go">....:                initial_states=[&#39;C&#39;],</span>
<span class="go">....:                final_states=[&#39;C&#39;])</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">transitions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">word_out</span> <span class="ow">is</span> <span class="n">H</span><span class="o">.</span><span class="n">transitions</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">word_out</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="p">(</span>
<span class="go">....:     is_Automaton, is_Transducer)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">is_Transducer</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_Transducer</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;explorative&#39;</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Composition with automaton is not possible.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Composition with automaton is not possible.</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Composition with automaton is not possible.</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Composition with automaton is not possible.</span>
<span class="gp">sage: </span><span class="n">is_Automaton</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">is_Automaton</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;explorative&#39;</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Non-deterministic final output cannot be handeled:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">42</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">42</span><span class="p">)],</span>
<span class="go">....:                initial_states=[&#39;I&#39;],</span>
<span class="go">....:                final_states=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="go">....:                final_states=[0],</span>
<span class="go">....:                input_alphabet=[0])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">H</span><span class="o">.</span><span class="n">final_states</span><span class="p">():</span>
<span class="go">....:     print(&quot;{} {}&quot;.format(s, s.final_word_out))</span>
<span class="go">(0, &#39;I&#39;) [42]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">composition</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">Stopping in state (0, &#39;I&#39;) leads to</span>
<span class="go">non-deterministic final output.</span>
</pre></div>
</div>
<p>Check that the output and input alphabets are set correctly:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                determine_alphabets=False)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)],</span>
<span class="go">....:                initial_states=[2],</span>
<span class="go">....:                determine_alphabets=False)</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Hd</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">Hd</span><span class="o">.</span><span class="n">output_alphabet</span>
<span class="go">([1], [&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">He</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No input alphabet is given. Try calling</span>
<span class="go">determine_alphabets().</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Hd</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">Hd</span><span class="o">.</span><span class="n">output_alphabet</span>
<span class="go">([1], [&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">He</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">He</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">He</span><span class="o">.</span><span class="n">output_alphabet</span>
<span class="go">([1], None)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">output_alphabet</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Hd</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">Hd</span><span class="o">.</span><span class="n">output_alphabet</span>
<span class="go">([1], [&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">He</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">He</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">He</span><span class="o">.</span><span class="n">output_alphabet</span>
<span class="go">([1], [&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">==</span> <span class="n">He</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">sage: </span><span class="n">Hd</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Hd</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">Hd</span><span class="o">.</span><span class="n">output_alphabet</span>
<span class="go">([1], [&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">He</span> <span class="o">=</span> <span class="n">G</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;explorative&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No input alphabet is given. Try calling</span>
<span class="go">determine_alphabets().</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.concatenation">
<code class="descname">concatenation</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.concatenation" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate this finite state machine with another finite
state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">other</span></code> – a <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>A <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a> of the same type as this finite
state machine.</p>
<p>Assume that both finite state machines are automata. If
<span class="math">\(\mathcal{L}_1\)</span> is the language accepted by this automaton and
<span class="math">\(\mathcal{L}_2\)</span> is the language accepted by the other automaton,
then the language accepted by the concatenated automaton is
<span class="math">\(\{ w_1w_2 \mid w_1\in\mathcal{L}_1, w_2\in\mathcal{L}_2\}\)</span> where
<span class="math">\(w_1w_2\)</span> denotes the concatenation of the words <span class="math">\(w_1\)</span> and <span class="math">\(w_2\)</span>.</p>
<p>Assume that both finite state machines are transducers and that
this transducer maps words <span class="math">\(w_1\in\mathcal{L}_1\)</span> to words
<span class="math">\(f_1(w_1)\)</span> and that the other transducer maps words
<span class="math">\(w_2\in\mathcal{L}_2\)</span> to words <span class="math">\(f_2(w_2)\)</span>. Then the concatenated
transducer maps words <span class="math">\(w_1w_2\)</span> with <span class="math">\(w_1\in\mathcal{L}_1\)</span> and
<span class="math">\(w_2\in\mathcal{L}_2\)</span> to <span class="math">\(f_1(w_1)f_2(w_2)\)</span>. Here, <span class="math">\(w_1w_2\)</span> and
<span class="math">\(f_1(w_1)f_2(w_2)\)</span> again denote concatenation of words.</p>
<p>The input alphabet is the union of the input alphabets (if
possible) and <code class="docutils literal"><span class="pre">None</span></code> otherwise. In the latter case, try
calling <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>.</p>
<p>Instead of <code class="docutils literal"><span class="pre">A.concatenation(B)</span></code>, the notation <code class="docutils literal"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">B</span></code> can be
used.</p>
<p>EXAMPLES:</p>
<p>Concatenation of two automata:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">Word</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">Word</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">concatenation</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (0, 0) to (0, 1): 0|-,</span>
<span class="go"> Transition from (0, 1) to (1, 0): -|-,</span>
<span class="go"> Transition from (1, 0) to (1, 1): 1|-]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">w</span>
<span class="go">....:  for w in ([0, 0], [0, 1], [1, 0], [1, 1])</span>
<span class="go">....:  if C(w)]</span>
<span class="go">[[0, 1]]</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="p">(</span>
<span class="go">....:     is_Automaton, is_Transducer)</span>
<span class="gp">sage: </span><span class="n">is_Automaton</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Concatenation of two transducers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">concatenation</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (0, 0) to (0, 1): 0|1,</span>
<span class="go"> Transition from (0, 0) to (0, 1): 1|2,</span>
<span class="go"> Transition from (0, 1) to (1, 0): -|-,</span>
<span class="go"> Transition from (1, 0) to (1, 1): 0|1,</span>
<span class="go"> Transition from (1, 0) to (1, 1): 1|0]</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">w</span><span class="p">,</span> <span class="n">C</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])]</span>
<span class="go">[([0, 0], [1, 1]),</span>
<span class="go"> ([0, 1], [1, 0]),</span>
<span class="go"> ([1, 0], [2, 1]),</span>
<span class="go"> ([1, 1], [2, 0])]</span>
<span class="gp">sage: </span><span class="n">is_Transducer</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Alternative notation as multiplication:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">==</span> <span class="n">A</span> <span class="o">*</span> <span class="n">B</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Final output words are taken into account:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">B</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[1, 2, 3, 4]</span>
</pre></div>
</div>
<p>Handling of the input alphabet:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">input_alphabet</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">determine_alphabets</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])],</span> <span class="n">input_alphabet</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[1, 2]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[[0, 0]]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">D</span><span class="p">)</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.disjoint_union" title="sage.combinat.finite_state_machine.FiniteStateMachine.disjoint_union"><code class="xref py py-meth docutils literal"><span class="pre">disjoint_union()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out">
<code class="descname">construct_final_word_out</code><span class="sig-paren">(</span><em>letters</em>, <em>allow_non_final=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an inplace version of <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out"><code class="xref py py-meth docutils literal"><span class="pre">with_final_word_out()</span></code></a>. See
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out"><code class="xref py py-meth docutils literal"><span class="pre">with_final_word_out()</span></code></a> for documentation and examples.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a (shallow) copy of the finite state machine.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A new finite state machine.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.deepcopy">
<code class="descname">deepcopy</code><span class="sig-paren">(</span><em>memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deep copy of the finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">memo</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) a dictionary storing already
processed elements.</li>
</ul>
<p>OUTPUT:</p>
<p>A new finite state machine.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">deepcopy</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="go">Finite state machine with 1 state</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.default_format_letter">
<code class="descname">default_format_letter</code><span class="sig-paren">(</span><em>x</em>, <em>combine_all=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.default_format_letter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.LatexExpr" title="(in Sage Reference Manual: Utilities v8.1)"><code class="xref py py-class docutils literal"><span class="pre">LatexExpr</span></code></a> built out of the argument <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> – a Sage object</li>
<li><code class="docutils literal"><span class="pre">combine_all</span></code> – boolean (Default: <code class="docutils literal"><span class="pre">False</span></code>) If <code class="docutils literal"><span class="pre">combine_all</span></code>
is <code class="docutils literal"><span class="pre">True</span></code> and the input is a tuple, then it does not return a
tuple and instead returns a string with all the elements separated by
a single space.</li>
</ul>
<p>OUTPUT:</p>
<p>A <a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.LatexExpr" title="(in Sage Reference Manual: Utilities v8.1)"><code class="xref py py-class docutils literal"><span class="pre">LatexExpr</span></code></a> built from <code class="docutils literal"><span class="pre">x</span></code></p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">Integer</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># indirect doctest</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="mi">1</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
<span class="go">\mathrm{False}</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">latex</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">\left[x, 2\right]</span>
</pre></div>
</div>
<p>Check that <a class="reference external" href="https://trac.sagemath.org/11775">trac ticket #11775</a> is fixed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">latex</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">combine_all</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">x 2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label">
<code class="descname">default_format_transition_label</code><span class="sig-paren">(</span><em>word</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Default formatting of words in transition labels for LaTeX output.</p>
<p>INPUT:</p>
<p><code class="docutils literal"><span class="pre">word</span></code> – list of letters</p>
<p>OUTPUT:</p>
<p>String representation of <code class="docutils literal"><span class="pre">word</span></code> suitable to be typeset in
mathematical mode.</p>
<ul class="simple">
<li>For a non-empty word: Concatenation of the letters, piped through
<code class="docutils literal"><span class="pre">self.format_letter</span></code> and separated by blanks.</li>
<li>For an empty word:
<code class="docutils literal"><span class="pre">sage.combinat.finite_state_machine.EmptyWordLaTeX</span></code>.</li>
</ul>
<p>There is also a variant <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label_reversed" title="sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label_reversed"><code class="xref py py-meth docutils literal"><span class="pre">format_transition_label_reversed()</span></code></a>
writing the words in reversed order.</p>
<p>EXAMPLES:</p>
<ol class="arabic">
<li><p class="first">Example of a non-empty word:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">(</span>
<span class="go">....:    [&#39;a&#39;, &#39;alpha&#39;, &#39;a_1&#39;, &#39;0&#39;, 0, (0, 1)]))</span>
<span class="go">\text{\texttt{a}} \text{\texttt{alpha}}</span>
<span class="go">\text{\texttt{a{\char`\_}1}} 0 0 \left(0, 1\right)</span>
</pre></div>
</div>
</li>
<li><p class="first">In the example above, <code class="docutils literal"><span class="pre">'a'</span></code> and <code class="docutils literal"><span class="pre">'alpha'</span></code> should perhaps
be symbols:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;a alpha a_1&#39;</span><span class="p">)</span>
<span class="go">(a, alpha, a_1)</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">a_1</span><span class="p">]))</span>
<span class="go">a \alpha a_{1}</span>
</pre></div>
</div>
</li>
<li><p class="first">Example of an empty word:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">([]))</span>
<span class="go">\varepsilon</span>
</pre></div>
</div>
<p>We can change this by setting
<code class="docutils literal"><span class="pre">sage.combinat.finite_state_machine.EmptyWordLaTeX</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">finite_state_machine</span><span class="o">.</span><span class="n">EmptyWordLaTeX</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">([])</span>
<span class="go">&#39;&#39;</span>
</pre></div>
</div>
<p>Finally, we restore the default value:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">finite_state_machine</span><span class="o">.</span><span class="n">EmptyWordLaTeX</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\varepsilon&#39;</span>
</pre></div>
</div>
</li>
<li><p class="first">This method is the default value for
<code class="docutils literal"><span class="pre">FiniteStateMachine.format_transition_label</span></code>. That can be changed to be
any other function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">custom_format_transition_label</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
<span class="go">....:     return &quot;t&quot;</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">format_transition_label</span><span class="o">=</span><span class="n">custom_format_transition_label</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">latex</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="go">\begin{tikzpicture}[auto, initial text=, &gt;=latex]</span>
<span class="go">\node[state] (v0) at (3.000000, 0.000000) {$0$};</span>
<span class="go">\node[state] (v1) at (-3.000000, 0.000000) {$1$};</span>
<span class="go">\path[-&gt;] (v0) edge node[rotate=360.00, anchor=south] {$t$} (v1);</span>
<span class="go">\end{tikzpicture}</span>
</pre></div>
</div>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.delete_state">
<code class="descname">delete_state</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.delete_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a state and all transitions coming or going to this state.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">s</span></code> – a label of a state or an <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><code class="xref py py-class docutils literal"><span class="pre">FSMState</span></code></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">delete_state</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;B&#39; to &#39;B&#39;: 1|-]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.delete_transition">
<code class="descname">delete_transition</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.delete_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes a transition by removing it from the list of transitions of
the state, where the transition starts.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">t</span></code> – a transition.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">delete_transition</span><span class="p">((</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;B&#39; to &#39;A&#39;: 1|-]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets">
<code class="descname">determine_alphabets</code><span class="sig-paren">(</span><em>reset=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the input and output alphabet according to the
transitions in this finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">reset</span></code> – If reset is <code class="docutils literal"><span class="pre">True</span></code>, then the existing input
and output alphabets are erased, otherwise new letters are
appended to the existing alphabets.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>After this operation the input alphabet and the output
alphabet of this finite state machine are a list of letters.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">At the moment, the letters of the alphabets need to be hashable.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (2, 2, 1, 1), (2, 2, 0, 0)],</span>
<span class="go">....:                final_states=[1],</span>
<span class="go">....:                determine_alphabets=False)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">output_alphabet</span><span class="p">)</span>
<span class="go">(None, None)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">determine_alphabets</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">output_alphabet</span><span class="p">)</span>
<span class="go">([0, 1, 2], [0, 1, 4])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_input_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_input_alphabet"><code class="xref py py-meth docutils literal"><span class="pre">determine_input_alphabet()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_output_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_output_alphabet"><code class="xref py py-meth docutils literal"><span class="pre">determine_output_alphabet()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.determine_input_alphabet">
<code class="descname">determine_input_alphabet</code><span class="sig-paren">(</span><em>reset=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_input_alphabet" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the input alphabet according to the transitions
of this finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">reset</span></code> – a boolean (default: <code class="docutils literal"><span class="pre">True</span></code>). If <code class="docutils literal"><span class="pre">True</span></code>, then
the existing input alphabet is erased, otherwise new letters are
appended to the existing alphabet.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>After this operation the input alphabet of this finite state machine
is a list of letters.</p>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">At the moment, the letters of the alphabet need to be hashable.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (2, 2, 1, 1), (2, 2, 0, 0)],</span>
<span class="go">....:                final_states=[1],</span>
<span class="go">....:                determine_alphabets=False)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">output_alphabet</span><span class="p">)</span>
<span class="go">(None, None)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">determine_input_alphabet</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">output_alphabet</span><span class="p">)</span>
<span class="go">([0, 1, 2], None)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_output_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_output_alphabet"><code class="xref py py-meth docutils literal"><span class="pre">determine_output_alphabet()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.determine_output_alphabet">
<code class="descname">determine_output_alphabet</code><span class="sig-paren">(</span><em>reset=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_output_alphabet" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the output alphabet according to the transitions
of this finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">reset</span></code> – a boolean (default: <code class="docutils literal"><span class="pre">True</span></code>). If <code class="docutils literal"><span class="pre">True</span></code>, then
the existing output alphabet is erased, otherwise new letters are
appended to the existing alphabet.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>After this operation the output alphabet of this finite state machine
is a list of letters.</p>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">At the moment, the letters of the alphabet need to be hashable.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (2, 2, 1, 1), (2, 2, 0, 0)],</span>
<span class="go">....:                final_states=[1],</span>
<span class="go">....:                determine_alphabets=False)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">output_alphabet</span><span class="p">)</span>
<span class="go">(None, None)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">determine_output_alphabet</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">output_alphabet</span><span class="p">)</span>
<span class="go">(None, [0, 1, 4])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_input_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_input_alphabet"><code class="xref py py-meth docutils literal"><span class="pre">determine_input_alphabet()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.digraph">
<code class="descname">digraph</code><span class="sig-paren">(</span><em>edge_labels='words_in_out'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.digraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the graph of the finite state machine with labeled
vertices and labeled edges.</p>
<p>INPUT:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">edge_label</span></code>: (default: <code class="docutils literal"><span class="pre">'words_in_out'</span></code>) can be</dt>
<dd><ul class="first last">
<li><code class="docutils literal"><span class="pre">'words_in_out'</span></code> (labels will be strings <code class="docutils literal"><span class="pre">'i|o'</span></code>)</li>
<li>a function with which takes as input a transition
and outputs (returns) the label</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>OUTPUT:</p>
<p>A <a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v8.1)"><code class="xref py py-class docutils literal"><span class="pre">directed</span> <span class="pre">graph</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">&#39;A&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">Transition from &#39;A&#39; to &#39;A&#39;: 0|1</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 1 vertex</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v8.1)"><code class="xref py py-class docutils literal"><span class="pre">DiGraph</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.disjoint_union">
<code class="descname">disjoint_union</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.disjoint_union" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the disjoint union of this and another finite state
machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">other</span></code> – a <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>A finite state machine of the same type as this finite state
machine.</p>
<p>In general, the disjoint union of two finite state machines is
non-deterministic. In the case of a automata, the language
accepted by the disjoint union is the union of the languages
accepted by the constituent automata. In the case of
transducer, for each successful path in one of the constituent
transducers, there will be one successful path with the same input
and output labels in the disjoint union.</p>
<p>The labels of the states of the disjoint union are pairs <code class="docutils literal"><span class="pre">(i,</span>
<span class="pre">s)</span></code>: for each state <code class="docutils literal"><span class="pre">s</span></code> of this finite state machine, there
is a state <code class="docutils literal"><span class="pre">(0,</span> <span class="pre">s)</span></code> in the disjoint union; for each state
<code class="docutils literal"><span class="pre">s</span></code> of the other finite state machine, there is a state <code class="docutils literal"><span class="pre">(1,</span>
<span class="pre">s)</span></code> in the disjoint union.</p>
<p>The input alphabet is the union of the input alphabets (if
possible) and <code class="docutils literal"><span class="pre">None</span></code> otherwise. In the latter case, try
calling <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>.</p>
<p>The disjoint union can also be written as <code class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">B</span></code> or <code class="docutils literal"><span class="pre">A</span> <span class="pre">|</span> <span class="pre">B</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0],</span>
<span class="go">....:               final_states=[0])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0],</span>
<span class="go">....:               final_states=[0])</span>
<span class="gp">sage: </span><span class="n">B</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">Automaton with 5 states</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (0, 0) to (0, 1): 0|-,</span>
<span class="go"> Transition from (0, 1) to (0, 0): 1|-,</span>
<span class="go"> Transition from (1, 0) to (1, 1): 0|-,</span>
<span class="go"> Transition from (1, 1) to (1, 2): 0|-,</span>
<span class="go"> Transition from (1, 2) to (1, 0): 1|-]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[(0, 0), (1, 0)]</span>
</pre></div>
</div>
<p>Instead of <code class="docutils literal"><span class="pre">.disjoint_union</span></code>, alternative notations are
available:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C1</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">B</span>
<span class="gp">sage: </span><span class="n">C1</span> <span class="o">==</span> <span class="n">C</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C2</span> <span class="o">=</span> <span class="n">A</span> <span class="o">|</span> <span class="n">B</span>
<span class="gp">sage: </span><span class="n">C2</span> <span class="o">==</span> <span class="n">C</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In general, the disjoint union is not deterministic.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">determinisation</span><span class="p">()</span><span class="o">.</span><span class="n">minimization</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:    (1, 7, 0), (1, 0, 1), (2, 6, 0), (2, 0, 1),</span>
<span class="go">....:    (3, 5, 0), (3, 0, 1), (4, 0, 0), (4, 2, 1),</span>
<span class="go">....:    (5, 0, 0), (5, 3, 1), (6, 4, 0), (6, 0, 1),</span>
<span class="go">....:    (7, 4, 0), (7, 3, 1)],</span>
<span class="go">....:    initial_states=[1],</span>
<span class="go">....:    final_states=[1, 2, 3]))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Disjoint union of transducers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T1</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[0])</span>
<span class="gp">sage: </span><span class="n">T2</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[0])</span>
<span class="gp">sage: </span><span class="n">T1</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">T2</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[2]</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">T1</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Found more than one accepting path.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[(True, (1, 0), [2]), (True, (0, 0), [1])]</span>
</pre></div>
</div>
<p>Handling of the input alphabet (see <a class="reference external" href="https://trac.sagemath.org/18989">trac ticket #18989</a>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">input_alphabet</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">determine_alphabets</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])],</span> <span class="n">input_alphabet</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[1, 2]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">D</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[[0, 0]]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">C</span><span class="p">)</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">D</span><span class="p">)</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.intersection" title="sage.combinat.finite_state_machine.Automaton.intersection"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.intersection()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.intersection" title="sage.combinat.finite_state_machine.Transducer.intersection"><code class="xref py py-meth docutils literal"><span class="pre">Transducer.intersection()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.empty_copy">
<code class="descname">empty_copy</code><span class="sig-paren">(</span><em>memo=None</em>, <em>new_class=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.empty_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an empty deep copy of the finite state machine, i.e.,
<code class="docutils literal"><span class="pre">input_alphabet</span></code>, <code class="docutils literal"><span class="pre">output_alphabet</span></code>, <code class="docutils literal"><span class="pre">on_duplicate_transition</span></code>
are preserved, but states and transitions are not.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">memo</span></code> – a dictionary storing already processed elements.</li>
<li><code class="docutils literal"><span class="pre">new_class</span></code> – a class for the copy. By default
(<code class="docutils literal"><span class="pre">None</span></code>), the class of <code class="docutils literal"><span class="pre">self</span></code> is used.</li>
</ul>
<p>OUTPUT:</p>
<p>A new finite state machine.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_raise_error</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span>
<span class="go">....:                        input_alphabet=[0, 1],</span>
<span class="go">....:                        output_alphabet=[2, 3],</span>
<span class="go">....:                        on_duplicate_transition=duplicate_transition_raise_error)</span>
<span class="gp">sage: </span><span class="n">FE</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">empty_copy</span><span class="p">();</span> <span class="n">FE</span>
<span class="go">Empty finite state machine</span>
<span class="gp">sage: </span><span class="n">FE</span><span class="o">.</span><span class="n">input_alphabet</span>
<span class="go">[0, 1]</span>
<span class="gp">sage: </span><span class="n">FE</span><span class="o">.</span><span class="n">output_alphabet</span>
<span class="go">[2, 3]</span>
<span class="gp">sage: </span><span class="n">FE</span><span class="o">.</span><span class="n">on_duplicate_transition</span> <span class="o">==</span> <span class="n">duplicate_transition_raise_error</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.epsilon_successors">
<code class="descname">epsilon_successors</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.epsilon_successors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the dictionary with states reachable from <code class="docutils literal"><span class="pre">state</span></code>
without reading anything from an input tape as keys. The
values are lists of outputs.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">state</span></code> – the state whose epsilon successors should be
determined.</li>
</ul>
<p>OUTPUT:</p>
<p>A dictionary mapping states to a list of output words.</p>
<p>The states in the output are the epsilon successors of
<code class="docutils literal"><span class="pre">state</span></code>. Each word of the list of output words is a word
written when taking a path from <code class="docutils literal"><span class="pre">state</span></code> to the corresponding
state.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">epsilon_successors</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">{1: [[&#39;a&#39;]], 2: [[&#39;a&#39;, &#39;b&#39;]]}</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">epsilon_successors</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">{2: [[&#39;b&#39;]]}</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">epsilon_successors</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">{}</span>
</pre></div>
</div>
<p>If there is a cycle with only epsilon transitions, then this
cycle is only processed once and there is no infinite loop:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">epsilon_successors</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">{0: [[&#39;a&#39;, &#39;b&#39;]], 1: [[&#39;a&#39;]]}</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">epsilon_successors</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">{0: [[&#39;b&#39;]], 1: [[&#39;b&#39;, &#39;a&#39;]]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.equivalence_classes">
<code class="descname">equivalence_classes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.equivalence_classes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of equivalence classes of states.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A list of equivalence classes of states.</p>
<p>Two states <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are equivalent if and only if there is
a bijection <span class="math">\(\varphi\)</span> between paths starting at <span class="math">\(a\)</span> and paths
starting at <span class="math">\(b\)</span> with the following properties: Let <span class="math">\(p_a\)</span> be a
path from <span class="math">\(a\)</span> to <span class="math">\(a'\)</span> and <span class="math">\(p_b\)</span> a path from <span class="math">\(b\)</span> to <span class="math">\(b'\)</span> such
that <span class="math">\(\varphi(p_a)=p_b\)</span>, then</p>
<ul class="simple">
<li><span class="math">\(p_a.\mathit{word}_\mathit{in}=p_b.\mathit{word}_\mathit{in}\)</span>,</li>
<li><span class="math">\(p_a.\mathit{word}_\mathit{out}=p_b.\mathit{word}_\mathit{out}\)</span>,</li>
<li><span class="math">\(a'\)</span> and <span class="math">\(b'\)</span> have the same output label, and</li>
<li><span class="math">\(a'\)</span> and <span class="math">\(b'\)</span> are both final or both non-final and have the
same final output word.</li>
</ul>
<p>The function <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.equivalence_classes" title="sage.combinat.finite_state_machine.FiniteStateMachine.equivalence_classes"><code class="xref py py-meth docutils literal"><span class="pre">equivalence_classes()</span></code></a> returns a list of
the equivalence classes to this equivalence relation.</p>
<p>This is one step of Moore’s minimization algorithm.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.minimization" title="sage.combinat.finite_state_machine.Automaton.minimization"><code class="xref py py-meth docutils literal"><span class="pre">minimization()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fsm</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (&quot;B&quot;, &quot;C&quot;, 0, 0), (&quot;B&quot;, &quot;C&quot;, 1, 1),</span>
<span class="go">....:                           (&quot;C&quot;, &quot;D&quot;, 0, 1), (&quot;C&quot;, &quot;D&quot;, 1, 0),</span>
<span class="go">....:                           (&quot;D&quot;, &quot;A&quot;, 0, 0), (&quot;D&quot;, &quot;A&quot;, 1, 1)])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">equivalence_classes</span><span class="p">())</span>
<span class="go">[[&#39;A&#39;, &#39;C&#39;], [&#39;B&#39;, &#39;D&#39;]]</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">equivalence_classes</span><span class="p">())</span>
<span class="go">[[&#39;A&#39;], [&#39;B&#39;], [&#39;C&#39;], [&#39;D&#39;]]</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">equivalence_classes</span><span class="p">())</span>
<span class="go">[[&#39;A&#39;, &#39;C&#39;], [&#39;B&#39;, &#39;D&#39;]]</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">equivalence_classes</span><span class="p">())</span>
<span class="go">[[&#39;A&#39;], [&#39;B&#39;], [&#39;C&#39;], [&#39;D&#39;]]</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">equivalence_classes</span><span class="p">())</span>
<span class="go">[[&#39;A&#39;, &#39;C&#39;], [&#39;B&#39;, &#39;D&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.final_components">
<code class="descname">final_components</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.final_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the final components of a finite state machine as finite
state machines.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A list of finite state machines, each representing a final
component of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>A final component of a transducer <code class="docutils literal"><span class="pre">T</span></code> is a strongly connected
component <code class="docutils literal"><span class="pre">C</span></code> such that there are no transitions of <code class="docutils literal"><span class="pre">T</span></code>
leaving <code class="docutils literal"><span class="pre">C</span></code>.</p>
<p>The final components are the only parts of a transducer which
influence the main terms of the asymptotic behaviour of the sum
of output labels of a transducer, see <a class="reference internal" href="#hkp2015" id="id15">[HKP2015]</a> and <a class="reference internal" href="#hkw2015" id="id16">[HKW2015]</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                 [&#39;C&#39;, &#39;B&#39;, 0, 1], [&#39;A&#39;, &#39;D&#39;, 1, 0],</span>
<span class="go">....:                 [&#39;D&#39;, &#39;D&#39;, 0, 0], [&#39;D&#39;, &#39;B&#39;, 1, 0],</span>
<span class="go">....:                 [&#39;A&#39;, &#39;E&#39;, 2, 0], [&#39;E&#39;, &#39;E&#39;, 0, 0]])</span>
<span class="gp">sage: </span><span class="n">FC</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">final_components</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">FC</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from &#39;B&#39; to &#39;C&#39;: 0|1,</span>
<span class="go"> Transition from &#39;C&#39; to &#39;B&#39;: 0|1]</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;E&#39; to &#39;E&#39;: 0|0]</span>
</pre></div>
</div>
<p>Another example (cycle of length 2):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">final_components</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">final_components</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|-,</span>
<span class="go"> Transition from 1 to 0: 0|-]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.final_states">
<code class="descname">final_states</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.final_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all final states.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A list of all final states.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">is_initial</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;, &#39;C&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.format_letter">
<code class="descname">format_letter</code><span class="sig-paren">(</span><em>x</em>, <em>combine_all=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_letter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.LatexExpr" title="(in Sage Reference Manual: Utilities v8.1)"><code class="xref py py-class docutils literal"><span class="pre">LatexExpr</span></code></a> built out of the argument <code class="docutils literal"><span class="pre">x</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">x</span></code> – a Sage object</li>
<li><code class="docutils literal"><span class="pre">combine_all</span></code> – boolean (Default: <code class="docutils literal"><span class="pre">False</span></code>) If <code class="docutils literal"><span class="pre">combine_all</span></code>
is <code class="docutils literal"><span class="pre">True</span></code> and the input is a tuple, then it does not return a
tuple and instead returns a string with all the elements separated by
a single space.</li>
</ul>
<p>OUTPUT:</p>
<p>A <a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.LatexExpr" title="(in Sage Reference Manual: Utilities v8.1)"><code class="xref py py-class docutils literal"><span class="pre">LatexExpr</span></code></a> built from <code class="docutils literal"><span class="pre">x</span></code></p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">Integer</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># indirect doctest</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="mi">1</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
<span class="go">\mathrm{False}</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">latex</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">\left[x, 2\right]</span>
</pre></div>
</div>
<p>Check that <a class="reference external" href="https://trac.sagemath.org/11775">trac ticket #11775</a> is fixed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">latex</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">combine_all</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">x 2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.format_letter_negative">
<code class="descname">format_letter_negative</code><span class="sig-paren">(</span><em>letter</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_letter_negative" title="Permalink to this definition">¶</a></dt>
<dd><p>Format negative numbers as overlined numbers, everything
else by standard LaTeX formatting.</p>
<p>INPUT:</p>
<p><code class="docutils literal"><span class="pre">letter</span></code> – anything.</p>
<p>OUTPUT:</p>
<p>Overlined absolute value if letter is a negative integer,
<a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.latex" title="(in Sage Reference Manual: Utilities v8.1)"><code class="xref py py-func docutils literal"><span class="pre">latex(letter)</span></code></a> otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">format_letter_negative</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">]))</span>
<span class="go">[&#39;\\overline{1}&#39;, 0, 1, \text{\texttt{a}}, \mathrm{None}]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">format_letter</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">format_letter_negative</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">latex</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="go">\begin{tikzpicture}[auto, initial text=, &gt;=latex]</span>
<span class="go">\node[state] (v0) at (3.000000, 0.000000) {$0$};</span>
<span class="go">\path[-&gt;] (v0) edge[loop above] node {$\overline{1}$} ();</span>
<span class="go">\end{tikzpicture}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label">
<code class="descname">format_transition_label</code><span class="sig-paren">(</span><em>word</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Default formatting of words in transition labels for LaTeX output.</p>
<p>INPUT:</p>
<p><code class="docutils literal"><span class="pre">word</span></code> – list of letters</p>
<p>OUTPUT:</p>
<p>String representation of <code class="docutils literal"><span class="pre">word</span></code> suitable to be typeset in
mathematical mode.</p>
<ul class="simple">
<li>For a non-empty word: Concatenation of the letters, piped through
<code class="docutils literal"><span class="pre">self.format_letter</span></code> and separated by blanks.</li>
<li>For an empty word:
<code class="docutils literal"><span class="pre">sage.combinat.finite_state_machine.EmptyWordLaTeX</span></code>.</li>
</ul>
<p>There is also a variant <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label_reversed" title="sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label_reversed"><code class="xref py py-meth docutils literal"><span class="pre">format_transition_label_reversed()</span></code></a>
writing the words in reversed order.</p>
<p>EXAMPLES:</p>
<ol class="arabic">
<li><p class="first">Example of a non-empty word:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">(</span>
<span class="go">....:    [&#39;a&#39;, &#39;alpha&#39;, &#39;a_1&#39;, &#39;0&#39;, 0, (0, 1)]))</span>
<span class="go">\text{\texttt{a}} \text{\texttt{alpha}}</span>
<span class="go">\text{\texttt{a{\char`\_}1}} 0 0 \left(0, 1\right)</span>
</pre></div>
</div>
</li>
<li><p class="first">In the example above, <code class="docutils literal"><span class="pre">'a'</span></code> and <code class="docutils literal"><span class="pre">'alpha'</span></code> should perhaps
be symbols:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;a alpha a_1&#39;</span><span class="p">)</span>
<span class="go">(a, alpha, a_1)</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">a_1</span><span class="p">]))</span>
<span class="go">a \alpha a_{1}</span>
</pre></div>
</div>
</li>
<li><p class="first">Example of an empty word:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">([]))</span>
<span class="go">\varepsilon</span>
</pre></div>
</div>
<p>We can change this by setting
<code class="docutils literal"><span class="pre">sage.combinat.finite_state_machine.EmptyWordLaTeX</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">finite_state_machine</span><span class="o">.</span><span class="n">EmptyWordLaTeX</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">default_format_transition_label</span><span class="p">([])</span>
<span class="go">&#39;&#39;</span>
</pre></div>
</div>
<p>Finally, we restore the default value:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">finite_state_machine</span><span class="o">.</span><span class="n">EmptyWordLaTeX</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\varepsilon&#39;</span>
</pre></div>
</div>
</li>
<li><p class="first">This method is the default value for
<code class="docutils literal"><span class="pre">FiniteStateMachine.format_transition_label</span></code>. That can be changed to be
any other function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">custom_format_transition_label</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
<span class="go">....:     return &quot;t&quot;</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">format_transition_label</span><span class="o">=</span><span class="n">custom_format_transition_label</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">latex</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="go">\begin{tikzpicture}[auto, initial text=, &gt;=latex]</span>
<span class="go">\node[state] (v0) at (3.000000, 0.000000) {$0$};</span>
<span class="go">\node[state] (v1) at (-3.000000, 0.000000) {$1$};</span>
<span class="go">\path[-&gt;] (v0) edge node[rotate=360.00, anchor=south] {$t$} (v1);</span>
<span class="go">\end{tikzpicture}</span>
</pre></div>
</div>
</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label_reversed">
<code class="descname">format_transition_label_reversed</code><span class="sig-paren">(</span><em>word</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.format_transition_label_reversed" title="Permalink to this definition">¶</a></dt>
<dd><p>Format words in transition labels in reversed order.</p>
<p>INPUT:</p>
<p><code class="docutils literal"><span class="pre">word</span></code> – list of letters.</p>
<p>OUTPUT:</p>
<p>String representation of <code class="docutils literal"><span class="pre">word</span></code> suitable to be typeset in
mathematical mode, letters are written in reversed order.</p>
<p>This is the reversed version of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label" title="sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label"><code class="xref py py-meth docutils literal"><span class="pre">default_format_transition_label()</span></code></a>.</p>
<p>In digit expansions, digits are frequently processed from the
least significant to the most significant position, but it is
customary to write the least significant digit at the
right-most position. Therefore, the labels have to be
reversed.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">format_transition_label_reversed</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">&#39;3 2 1&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span><span class="n">format_transition_label</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">format_transition_label_reversed</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">latex</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
<span class="go">\begin{tikzpicture}[auto, initial text=, &gt;=latex]</span>
<span class="go">\node[state] (v0) at (3.000000, 0.000000) {$0$};</span>
<span class="go">\path[-&gt;] (v0) edge[loop above] node {$0\mid 3 2 1$} ();</span>
<span class="go">\end{tikzpicture}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.graph">
<code class="descname">graph</code><span class="sig-paren">(</span><em>edge_labels='words_in_out'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the graph of the finite state machine with labeled
vertices and labeled edges.</p>
<p>INPUT:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">edge_label</span></code>: (default: <code class="docutils literal"><span class="pre">'words_in_out'</span></code>) can be</dt>
<dd><ul class="first last">
<li><code class="docutils literal"><span class="pre">'words_in_out'</span></code> (labels will be strings <code class="docutils literal"><span class="pre">'i|o'</span></code>)</li>
<li>a function with which takes as input a transition
and outputs (returns) the label</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>OUTPUT:</p>
<p>A <a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v8.1)"><code class="xref py py-class docutils literal"><span class="pre">directed</span> <span class="pre">graph</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">add_state</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">&#39;A&#39;</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">Transition from &#39;A&#39; to &#39;A&#39;: 0|1</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 1 vertex</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="../../../graphs/sage/graphs/digraph.html#sage.graphs.digraph.DiGraph" title="(in Sage Reference Manual: Graph Theory v8.1)"><code class="xref py py-class docutils literal"><span class="pre">DiGraph</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.has_final_state">
<code class="descname">has_final_state</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_final_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <code class="docutils literal"><span class="pre">state</span></code> is one of the final states of the
finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">state</span></code> can be a <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><code class="xref py py-class docutils literal"><span class="pre">FSMState</span></code></a> or a label.</li>
</ul>
<p>OUTPUT:</p>
<p>True or False.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">(</span><span class="n">final_states</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">has_final_state</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.has_final_states">
<code class="descname">has_final_states</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_final_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the finite state machine has a final state.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>True or False.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">()</span><span class="o">.</span><span class="n">has_final_states</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.has_initial_state">
<code class="descname">has_initial_state</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_initial_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <code class="docutils literal"><span class="pre">state</span></code> is one of the initial states of the
finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">state</span></code> can be a <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><code class="xref py py-class docutils literal"><span class="pre">FSMState</span></code></a> or a label.</li>
</ul>
<p>OUTPUT:</p>
<p>True or False.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">has_initial_state</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.has_initial_states">
<code class="descname">has_initial_states</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_initial_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the finite state machine has an initial state.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>True or False.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">()</span><span class="o">.</span><span class="n">has_initial_states</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.has_state">
<code class="descname">has_state</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <code class="docutils literal"><span class="pre">state</span></code> is one of the states of the finite
state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">state</span></code> can be a <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><code class="xref py py-class docutils literal"><span class="pre">FSMState</span></code></a> or a label of a state.</li>
</ul>
<p>OUTPUT:</p>
<p>True or False.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">()</span><span class="o">.</span><span class="n">has_state</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.has_transition">
<code class="descname">has_transition</code><span class="sig-paren">(</span><em>transition</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.has_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <code class="docutils literal"><span class="pre">transition</span></code> is one of the transitions of
the finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">transition</span></code> has to be a <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><code class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></code></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>True or False.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">()</span><span class="o">.</span><span class="n">has_transition</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">FiniteStateMachine</span><span class="p">()</span><span class="o">.</span><span class="n">has_transition</span><span class="p">((</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Transition is not an instance of FSMTransition.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.induced_sub_finite_state_machine">
<code class="descname">induced_sub_finite_state_machine</code><span class="sig-paren">(</span><em>states</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.induced_sub_finite_state_machine" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sub-finite-state-machine of the finite state machine
induced by the given states.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">states</span></code> – a list (or an iterator) of states (either labels or
instances of <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><code class="xref py py-class docutils literal"><span class="pre">FSMState</span></code></a>) of the sub-finite-state-machine.</li>
</ul>
<p>OUTPUT:</p>
<p>A new finite state machine. It consists (of deep copies) of
the given states and (deep copies) of all transitions of <code class="docutils literal"><span class="pre">self</span></code>
between these states.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (1, 2, 0), (2, 0, 0)])</span>
<span class="gp">sage: </span><span class="n">sub_FSM</span> <span class="o">=</span> <span class="n">FSM</span><span class="o">.</span><span class="n">induced_sub_finite_state_machine</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">sub_FSM</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[0, 1]</span>
<span class="gp">sage: </span><span class="n">sub_FSM</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|-]</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">induced_sub_finite_state_machine</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">3 is not a state of this finite state machine.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.initial_states">
<code class="descname">initial_states</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.initial_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all initial states.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A list of all initial states.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">is_initial</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.input_alphabet">
<code class="descname">input_alphabet</code><em class="property"> = None</em><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.input_alphabet" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of letters representing the input alphabet of the finite
state machine.</p>
<p>It can be set by the parameter <code class="docutils literal"><span class="pre">input_alphabet</span></code> when initializing
a finite state machine, see <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>.</p>
<p>It can also be set by the method <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>, <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.output_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.output_alphabet"><code class="xref py py-attr docutils literal"><span class="pre">output_alphabet</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.input_projection">
<code class="descname">input_projection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.input_projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an automaton where the output of each transition of
self is deleted.</p>
<p>INPUT:</p>
<p>Nothing</p>
<p>OUTPUT:</p>
<p>An automaton.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                         (&#39;B&#39;, &#39;B&#39;, 1, 0)])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">input_projection</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;B&#39;: 0|-,</span>
<span class="go"> Transition from &#39;A&#39; to &#39;A&#39;: 1|-,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;B&#39;: 1|-]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.intersection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.is_Markov_chain">
<code class="descname">is_Markov_chain</code><span class="sig-paren">(</span><em>is_zero=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_Markov_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether <code class="docutils literal"><span class="pre">self</span></code> is a Markov chain where the transition
probabilities are modeled as input labels.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">is_zero</span></code> – by default (<code class="docutils literal"><span class="pre">is_zero=None</span></code>), checking for
zero is simply done by
<a class="reference external" href="../../../structure/sage/structure/element.html#sage.structure.element.Element.is_zero" title="(in Sage Reference Manual: Parents and Elements v8.1)"><code class="xref py py-meth docutils literal"><span class="pre">is_zero()</span></code></a>.  This
parameter can be used to provide a more sophisticated check
for zero, e.g. in the case of symbolic probabilities, see
the examples below.</li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal"><span class="pre">True</span></code> or <code class="docutils literal"><span class="pre">False</span></code>.</p>
<p><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition" title="sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition"><code class="xref py py-attr docutils literal"><span class="pre">on_duplicate_transition</span></code></a> must be
<a class="reference internal" href="#sage.combinat.finite_state_machine.duplicate_transition_add_input" title="sage.combinat.finite_state_machine.duplicate_transition_add_input"><code class="xref py py-func docutils literal"><span class="pre">duplicate_transition_add_input()</span></code></a>, the sum of the input weights
of the transitions leaving a state must add up to 1 and the sum of
initial probabilities must add up to 1 (or all be <code class="docutils literal"><span class="pre">None</span></code>).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_add_input</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                 [1, 0, 1/2, 0], [1, 1, 1/2, 1]],</span>
<span class="go">....:                on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition" title="sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition"><code class="xref py py-attr docutils literal"><span class="pre">on_duplicate_transition</span></code></a> must be
<a class="reference internal" href="#sage.combinat.finite_state_machine.duplicate_transition_add_input" title="sage.combinat.finite_state_machine.duplicate_transition_add_input"><code class="xref py py-func docutils literal"><span class="pre">duplicate_transition_add_input()</span></code></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                 [1, 0, 1/2, 0], [1, 1, 1/2, 1]])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Sum of input labels of the transitions leaving states must be 1:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                 [1, 0, 1/2, 0]],</span>
<span class="go">....:                on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The initial probabilities of all states must be <code class="docutils literal"><span class="pre">None</span></code> or they must
sum up to 1. The initial probabilities of all states have to be set in the latter case:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                 [1, 0, 1, 0]],</span>
<span class="go">....:                on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">initial_probability</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">initial_probability</span> <span class="o">=</span> <span class="mi">7</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">initial_probability</span> <span class="o">=</span> <span class="mi">3</span><span class="o">/</span><span class="mi">4</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If the probabilities are variables in the symbolic ring,
<a class="reference external" href="../../../calculus/sage/symbolic/assumptions.html#sage.symbolic.assumptions.assume" title="(in Sage Reference Manual: Symbolic Calculus v8.1)"><code class="xref py py-func docutils literal"><span class="pre">assume()</span></code></a> will do the trick:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;p q&#39;</span><span class="p">)</span>
<span class="go">(p, q)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">assume</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_zero</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">forget</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">del</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
<p>If the probabilities are variables in some polynomial ring,
the parameter <code class="docutils literal"><span class="pre">is_zero</span></code> can be used:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">is_zero_polynomial</span><span class="p">(</span><span class="n">polynomial</span><span class="p">):</span>
<span class="go">....:     return polynomial in (p + q - 1)*R</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">initial_probability</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">is_Markov_chain</span><span class="p">(</span><span class="n">is_zero_polynomial</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.is_complete">
<code class="descname">is_complete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the finite state machine is complete.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p><code class="docutils literal"><span class="pre">True</span></code> or <code class="docutils literal"><span class="pre">False</span></code>.</p>
<p>A finite state machine is considered to be complete if
each transition has an input label of length one and for each
pair <span class="math">\((q, a)\)</span> where <span class="math">\(q\)</span> is a state and <span class="math">\(a\)</span> is an element of the
input alphabet, there is exactly one transition from <span class="math">\(q\)</span> with
input label <span class="math">\(a\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fsm</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (0, 1, 1, 1),</span>
<span class="go">....:                           (1, 1, 0, 0)],</span>
<span class="go">....:                          determine_alphabets=False)</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No input alphabet is given. Try calling determine_alphabets().</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">input_alphabet</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">Transition from 1 to 1: 1|1</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">Transition from 0 to 0: 1|0</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.is_connected">
<code class="descname">is_connected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.is_deterministic">
<code class="descname">is_deterministic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_deterministic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the finite finite state machine is deterministic.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p><code class="docutils literal"><span class="pre">True</span></code> or <code class="docutils literal"><span class="pre">False</span></code>.</p>
<p>A finite state machine is considered to be deterministic if
each transition has input label of length one and for each
pair <span class="math">\((q,a)\)</span> where <span class="math">\(q\)</span> is a state and <span class="math">\(a\)</span> is an element of the
input alphabet, there is at most one transition from <span class="math">\(q\)</span> with
input label <span class="math">\(a\)</span>. Furthermore, the finite state may not have
more than one initial state.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fsm</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]))</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|-</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]))</span>
<span class="go">Transition from &#39;A&#39; to &#39;C&#39;: 0|-</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[]))</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0,1|-</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Check that <a class="reference external" href="https://trac.sagemath.org/18556">trac ticket #18556</a> is fixed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Automaton</span><span class="p">()</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Automaton</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Automaton</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">is_deterministic</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.is_monochromatic">
<code class="descname">is_monochromatic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_monochromatic" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the colors of all states are equal.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p><code class="docutils literal"><span class="pre">True</span></code> or <code class="docutils literal"><span class="pre">False</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">GrayCode</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">color</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">iter_states</span><span class="p">()]</span>
<span class="go">[None, None, None]</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_monochromatic</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">is_monochromatic</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.iter_final_states">
<code class="descname">iter_final_states</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_final_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator of the final states.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>An iterator over all initial states.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">is_initial</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">iter_final_states</span><span class="p">()]</span>
<span class="go">[&#39;A&#39;, &#39;C&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.iter_initial_states">
<code class="descname">iter_initial_states</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_initial_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator of the initial states.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>An iterator over all initial states.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">is_initial</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">iter_initial_states</span><span class="p">()]</span>
<span class="go">[&#39;A&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process">
<code class="descname">iter_process</code><span class="sig-paren">(</span><em>input_tape=None</em>, <em>initial_state=None</em>, <em>process_iterator_class=None</em>, <em>iterator_type=None</em>, <em>automatic_output_type=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns an iterator for processing the input.
See <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">process()</span></code></a> (which runs this iterator until the end)
for more information.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">iterator_type</span></code> – If <code class="docutils literal"><span class="pre">None</span></code> (default), then
an instance of <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a> is returned. If
this is <code class="docutils literal"><span class="pre">'simple'</span></code> only an iterator over one output is
returned (an exception is raised if this is not the case, i.e.,
if the process has branched).</li>
</ul>
<p>See <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">process()</span></code></a> for a description of the other parameters.</p>
<p>OUTPUT:</p>
<p>An iterator.</p>
<p>EXAMPLES:</p>
<p>We can use <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><code class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></code></a> to deal with infinite words:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:     initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">()</span>
<span class="go">word: 0100101001001010010100100101001001010010...</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span>
<span class="go">....:     words.FibonacciWord(), iterator_type=&#39;simple&#39;)</span>
<span class="gp">sage: </span><span class="n">Words</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])(</span><span class="n">it</span><span class="p">)</span>
<span class="go">word: 1011010110110101101011011010110110101101...</span>
</pre></div>
</div>
<p>This can also be done by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">(),</span>
<span class="go">....:                       iterator_type=&#39;simple&#39;,</span>
<span class="go">....:                       automatic_output_type=True)</span>
<span class="go">word: 1011010110110101101011011010110110101101...</span>
</pre></div>
</div>
<p>or even simpler by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">inverter</span><span class="p">(</span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">())</span>
<span class="go">word: 1011010110110101101011011010110110101101...</span>
</pre></div>
</div>
<p>To see what is going on, we use <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><code class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></code></a> without
arguments:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">words</span><span class="o">.</span><span class="n">FibonacciWord</span><span class="p">())</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">current</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
<span class="go">....:     print(current)</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 1, [[1]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 2, [[1, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 3, [[1, 0, 1]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 4, [[1, 0, 1, 1]]</span>
</pre></div>
</div>
<p>The following show the difference between using the <code class="docutils literal"><span class="pre">'simple'</span></code>-option
and not using it. With this option, we have</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                            iterator_type=&#39;simple&#39;)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
<span class="go">....:     print(&#39;step %s: output %s&#39; % (i, o))</span>
<span class="go">step 0: output 1</span>
<span class="go">step 1: output 0</span>
<span class="go">step 2: output 0</span>
</pre></div>
</div>
<p>So <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><code class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></code></a> is a generator expression which gives
a new output letter in each step (and not more). In many cases
this is sufficient.</p>
<p>Doing the same without the <code class="docutils literal"><span class="pre">'simple'</span></code>-option does not give
the output directly; it has to be extracted first. On the
other hand, additional information is presented:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">inverter</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">current</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
<span class="go">....:     print(current)</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 1, [[1]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 2, [[1, 0]]</span>
<span class="go">process (1 branch)</span>
<span class="go">+ at state &#39;A&#39;</span>
<span class="go">+-- tape at 3, [[1, 0, 0]]</span>
<span class="go">process (0 branches)</span>
<span class="gp">sage: </span><span class="n">it</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="go">[Branch(accept=True, state=&#39;A&#39;, output=[1, 0, 0])]</span>
</pre></div>
</div>
<p>One can see the growing of the output (the list of lists at
the end of each entry).</p>
<p>Even if the transducer has transitions with empty or multiletter
output, the simple iterator returns one new output letter in
each step:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]),</span>
<span class="go">....:                 (0, 0, 1, [1]),</span>
<span class="go">....:                 (0, 0, 2, [2, 2])],</span>
<span class="go">....:                initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">iter_process</span><span class="p">(</span><span class="n">input_tape</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="go">....:                     iterator_type=&#39;simple&#39;)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
<span class="go">....:     print(&#39;step %s: output %s&#39; % (i, o))</span>
<span class="go">step 0: output 1</span>
<span class="go">step 1: output 2</span>
<span class="go">step 2: output 2</span>
<span class="go">step 3: output 1</span>
<span class="go">step 4: output 2</span>
<span class="go">step 5: output 2</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><code class="xref py py-meth docutils literal"><span class="pre">Transducer.process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.iter_states">
<code class="descname">iter_states</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator of the states.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>An iterator of the states of the finite state machine.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">FSM</span><span class="o">.</span><span class="n">iter_states</span><span class="p">()]</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.iter_transitions">
<code class="descname">iter_transitions</code><span class="sig-paren">(</span><em>from_state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_transitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator of all transitions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">from_state</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) If <code class="docutils literal"><span class="pre">from_state</span></code> is
given, then a list of transitions starting there is given.</li>
</ul>
<p>OUTPUT:</p>
<p>An iterator of all transitions.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">t</span><span class="o">.</span><span class="n">from_state</span><span class="o">.</span><span class="n">label</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">to_state</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>
<span class="go">....:     for t in FSM.iter_transitions(&#39;1&#39;)]</span>
<span class="go">[(&#39;1&#39;, &#39;2&#39;)]</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">t</span><span class="o">.</span><span class="n">from_state</span><span class="o">.</span><span class="n">label</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">to_state</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>
<span class="go">....:     for t in FSM.iter_transitions(&#39;2&#39;)]</span>
<span class="go">[(&#39;2&#39;, &#39;2&#39;)]</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">t</span><span class="o">.</span><span class="n">from_state</span><span class="o">.</span><span class="n">label</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">to_state</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>
<span class="go">....:     for t in FSM.iter_transitions()]</span>
<span class="go">[(&#39;1&#39;, &#39;2&#39;), (&#39;2&#39;, &#39;2&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.kleene_star">
<code class="descname">kleene_star</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.kleene_star" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Kleene closure of this finite state machine.</p>
<p>OUTPUT:</p>
<p>A <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a> of the same type as this finite
state machine.</p>
<p>Assume that this finite state machine is an automaton
recognizing the language <span class="math">\(\mathcal{L}\)</span>.  Then the Kleene star
recognizes the language <span class="math">\(\mathcal{L}^*=\{ w_1\ldots w_n \mid
n\ge 0, w_j\in\mathcal{L} \text{ for all } j\}\)</span>.</p>
<p>Assume that this finite state machine is a transducer realizing
a function <span class="math">\(f\)</span> on some alphabet <span class="math">\(\mathcal{L}\)</span>. Then the Kleene
star realizes a function <span class="math">\(g\)</span> on <span class="math">\(\mathcal{L}^*\)</span> with
<span class="math">\(g(w_1\ldots w_n)=f(w_1)\ldots f(w_n)\)</span>.</p>
<p>EXAMPLES:</p>
<p>Kleene star of an automaton:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">automata</span><span class="o">.</span><span class="n">Word</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">kleene_star</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|-,</span>
<span class="go"> Transition from 2 to 0: -|-,</span>
<span class="go"> Transition from 1 to 2: 1|-]</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="p">(</span>
<span class="go">....:     is_Automaton, is_Transducer)</span>
<span class="gp">sage: </span><span class="n">is_Automaton</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">([],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">....:  if B(w)]</span>
<span class="go">[[],</span>
<span class="go"> [0, 1],</span>
<span class="go"> [0, 1, 0, 1]]</span>
</pre></div>
</div>
<p>Kleene star of a transducer:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">kleene_star</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|1,</span>
<span class="go"> Transition from 0 to 1: 1|0,</span>
<span class="go"> Transition from 1 to 0: -|-]</span>
<span class="gp">sage: </span><span class="n">is_Transducer</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">([],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
<span class="go">....:     print(&quot;{} {}&quot;.format(w, S.process(w)))</span>
<span class="go">[]     (True, 0, [])</span>
<span class="go">[0]    [(True, 0, [1]), (True, 1, [1])]</span>
<span class="go">[1]    [(True, 0, [0]), (True, 1, [0])]</span>
<span class="go">[0, 0] [(True, 0, [1, 1]), (True, 1, [1, 1])]</span>
<span class="go">[0, 1] [(True, 0, [1, 0]), (True, 1, [1, 0])]</span>
</pre></div>
</div>
<p>Final output words are taken into account:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">kleene_star</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[(True, 0, [1, 2, 1, 2]), (True, 1, [1, 2, 1, 2])]</span>
</pre></div>
</div>
<p>Final output words may lead to undesirable situations if initial
states and final states coincide:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">final_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([])</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">kleene_star</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">([])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RuntimeError</span>: <span class="n">State 0 is in an epsilon cycle (no input), but</span>
<span class="go">output is written.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.language">
<code class="descname">language</code><span class="sig-paren">(</span><em>max_length=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.language" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all words that can be written by this transducer.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">max_length</span></code> – an integer or <code class="docutils literal"><span class="pre">None</span></code> (default). Only
output words which come from inputs of length at most
<code class="docutils literal"><span class="pre">max_length</span></code> will be considered. If <code class="docutils literal"><span class="pre">None</span></code>, then this
iterates over all possible words without length restrictions.</li>
<li><code class="docutils literal"><span class="pre">kwargs</span></code> – will be passed on to the <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">process</span>
<span class="pre">iterator</span></code></a>. See <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">process()</span></code></a> for a
description.</li>
</ul>
<p>OUTPUT:</p>
<p>An iterator.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
<span class="go">....:                   (0, 0, 0, 0), (0, 1, 1, 0),</span>
<span class="go">....:                   (1, 0, 0, 1), (1, 2, 1, -1),</span>
<span class="go">....:                   (2, 1, 0, 0), (2, 2, 1, 0)],</span>
<span class="go">....:                  initial_states=[&#39;I&#39;], final_states=[0],</span>
<span class="go">....:                  input_alphabet=[0, 1])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">NAF</span><span class="o">.</span><span class="n">language</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
<span class="go">....:        key=lambda o: (ZZ(o, base=2), len(o)))</span>
<span class="go">[[], [0], [0, 0], [0, 0, 0],</span>
<span class="go"> [1], [1, 0], [1, 0, 0],</span>
<span class="go"> [0, 1], [0, 1, 0],</span>
<span class="go"> [-1, 0, 1],</span>
<span class="go"> [0, 0, 1],</span>
<span class="go"> [1, 0, 1]]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">iterator</span> <span class="o">=</span> <span class="n">NAF</span><span class="o">.</span><span class="n">language</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">[0, 0]</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="go">[0, 1]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.language" title="sage.combinat.finite_state_machine.Automaton.language"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.language()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">process()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.latex_options">
<code class="descname">latex_options</code><span class="sig-paren">(</span><em>coordinates=None</em>, <em>format_state_label=None</em>, <em>format_letter=None</em>, <em>format_transition_label=None</em>, <em>loop_where=None</em>, <em>initial_where=None</em>, <em>accepting_style=None</em>, <em>accepting_distance=None</em>, <em>accepting_where=None</em>, <em>accepting_show_empty=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.latex_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Set options for LaTeX output via
<a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.latex" title="(in Sage Reference Manual: Utilities v8.1)"><code class="xref py py-func docutils literal"><span class="pre">latex()</span></code></a> and therefore
<a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.view" title="(in Sage Reference Manual: Utilities v8.1)"><code class="xref py py-func docutils literal"><span class="pre">view()</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">coordinates</span></code> – a dictionary or a function mapping labels
of states to pairs interpreted as coordinates. If no
coordinates are given, states a placed equidistantly on a
circle of radius <span class="math">\(3\)</span>. See also <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.set_coordinates" title="sage.combinat.finite_state_machine.FiniteStateMachine.set_coordinates"><code class="xref py py-meth docutils literal"><span class="pre">set_coordinates()</span></code></a>.</li>
<li><code class="docutils literal"><span class="pre">format_state_label</span></code> – a function mapping labels of
states to a string suitable for typesetting in LaTeX’s
mathematics mode. If not given, <a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.latex" title="(in Sage Reference Manual: Utilities v8.1)"><code class="xref py py-func docutils literal"><span class="pre">latex()</span></code></a>
is used.</li>
<li><code class="docutils literal"><span class="pre">format_letter</span></code> – a function mapping letters of the input
and output alphabets to a string suitable for typesetting in
LaTeX’s mathematics mode. If not given,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label" title="sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label"><code class="xref py py-meth docutils literal"><span class="pre">default_format_transition_label()</span></code></a> uses
<a class="reference external" href="../../../misc/sage/misc/latex.html#sage.misc.latex.latex" title="(in Sage Reference Manual: Utilities v8.1)"><code class="xref py py-func docutils literal"><span class="pre">latex()</span></code></a>.</li>
<li><code class="docutils literal"><span class="pre">format_transition_label</span></code> – a function mapping words over
the input and output alphabets to a string suitable for
typesetting in LaTeX’s mathematics mode. If not given,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label" title="sage.combinat.finite_state_machine.FiniteStateMachine.default_format_transition_label"><code class="xref py py-meth docutils literal"><span class="pre">default_format_transition_label()</span></code></a> is used.</li>
<li><code class="docutils literal"><span class="pre">loop_where</span></code> – a dictionary or a function mapping labels of
initial states to one of <code class="docutils literal"><span class="pre">'above'</span></code>, <code class="docutils literal"><span class="pre">'left'</span></code>, <code class="docutils literal"><span class="pre">'below'</span></code>,
<code class="docutils literal"><span class="pre">'right'</span></code>. If not given, <code class="docutils literal"><span class="pre">'above'</span></code> is used.</li>
<li><code class="docutils literal"><span class="pre">initial_where</span></code> – a dictionary or a function mapping
labels of initial states to one of <code class="docutils literal"><span class="pre">'above'</span></code>, <code class="docutils literal"><span class="pre">'left'</span></code>,
<code class="docutils literal"><span class="pre">'below'</span></code>, <code class="docutils literal"><span class="pre">'right'</span></code>. If not given, TikZ’ default
(currently <code class="docutils literal"><span class="pre">'left'</span></code>) is used.</li>
<li><code class="docutils literal"><span class="pre">accepting_style</span></code> – one of <code class="docutils literal"><span class="pre">'accepting</span> <span class="pre">by</span> <span class="pre">double'</span></code> and
<code class="docutils literal"><span class="pre">'accepting</span> <span class="pre">by</span> <span class="pre">arrow'</span></code>. If not given, <code class="docutils literal"><span class="pre">'accepting</span> <span class="pre">by</span>
<span class="pre">double'</span></code> is used unless there are non-empty final output
words.</li>
<li><code class="docutils literal"><span class="pre">accepting_distance</span></code> – a string giving a LaTeX length
used for the length of the arrow leading from a final state.
If not given, TikZ’ default (currently <code class="docutils literal"><span class="pre">'3ex'</span></code>) is used
unless there are non-empty final output words, in which case
<code class="docutils literal"><span class="pre">'7ex'</span></code> is used.</li>
<li><code class="docutils literal"><span class="pre">accepting_where</span></code> – a dictionary or a function mapping
labels of final states to one of <code class="docutils literal"><span class="pre">'above'</span></code>, <code class="docutils literal"><span class="pre">'left'</span></code>,
<code class="docutils literal"><span class="pre">'below'</span></code>, <code class="docutils literal"><span class="pre">'right'</span></code>. If not given, TikZ’ default
(currently <code class="docutils literal"><span class="pre">'right'</span></code>) is used. If the final state has a
final output word, it is also possible to give an angle
in degrees.</li>
<li><code class="docutils literal"><span class="pre">accepting_show_empty</span></code> – if <code class="docutils literal"><span class="pre">True</span></code> the arrow of an
empty final output word is labeled as well. Note that this
implicitly implies <code class="docutils literal"><span class="pre">accepting_style='accepting</span> <span class="pre">by</span>
<span class="pre">arrow'</span></code>. If not given, the default <code class="docutils literal"><span class="pre">False</span></code> is used.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>As TikZ (cf. the <a class="reference external" href="https://en.wikipedia.org/wiki/PGF/TikZ">Wikipedia article PGF/TikZ</a>) is used to typeset
the graphics, the syntax is oriented on TikZ’ syntax.</p>
<p>This is a convenience function collecting all options for
LaTeX output. All of its functionality can also be achieved by
directly setting the attributes</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">coordinates</span></code>, <code class="docutils literal"><span class="pre">format_label</span></code>, <code class="docutils literal"><span class="pre">loop_where</span></code>,
<code class="docutils literal"><span class="pre">initial_where</span></code>, and <code class="docutils literal"><span class="pre">accepting_where</span></code> of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><code class="xref py py-class docutils literal"><span class="pre">FSMState</span></code></a> (here, <code class="docutils literal"><span class="pre">format_label</span></code> is a callable
without arguments, everything else is a specific value);</li>
<li><code class="docutils literal"><span class="pre">format_label</span></code> of <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><code class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></code></a> (<code class="docutils literal"><span class="pre">format_label</span></code>
is a callable without arguments);</li>
<li><code class="docutils literal"><span class="pre">format_state_label</span></code>, <code class="docutils literal"><span class="pre">format_letter</span></code>,
<code class="docutils literal"><span class="pre">format_transition_label</span></code>, <code class="docutils literal"><span class="pre">accepting_style</span></code>,
<code class="docutils literal"><span class="pre">accepting_distance</span></code>, and <code class="docutils literal"><span class="pre">accepting_show_empty</span></code>
of <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>.</li>
</ul>
<p>This function, however, also (somewhat) checks its input and
serves to collect documentation on all these options.</p>
<p>The function can be called several times, only those arguments
which are not <code class="docutils literal"><span class="pre">None</span></code> are taken into account. By the same
means, it can be combined with directly setting some
attributes as outlined above.</p>
<p>EXAMPLES:</p>
<p>See also the section on <a class="reference internal" href="#finite-state-machine-latex-output"><span class="std std-ref">LaTeX output</span></a>
in the introductory examples of this module.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span><span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
<span class="go">....:     final_states=[0, 3])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">srange</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
<span class="go">....:     T.add_transition(4, j, 0, [0, j])</span>
<span class="go">....:     T.add_transition(j, 4, 0, [0, -j])</span>
<span class="go">....:     T.add_transition(j, j, 0, 0)</span>
<span class="go">Transition from 4 to 0: 0|0,0</span>
<span class="go">Transition from 0 to 4: 0|0,0</span>
<span class="go">Transition from 0 to 0: 0|0</span>
<span class="go">Transition from 4 to 1: 0|0,1</span>
<span class="go">Transition from 1 to 4: 0|0,-1</span>
<span class="go">Transition from 1 to 1: 0|0</span>
<span class="go">Transition from 4 to 2: 0|0,2</span>
<span class="go">Transition from 2 to 4: 0|0,-2</span>
<span class="go">Transition from 2 to 2: 0|0</span>
<span class="go">Transition from 4 to 3: 0|0,3</span>
<span class="go">Transition from 3 to 4: 0|0,-3</span>
<span class="go">Transition from 3 to 3: 0|0</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">Transition from 4 to 4: 0|0</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span>
<span class="go">....:     coordinates={4: (0, 0),</span>
<span class="go">....:                  0: (-6, 3),</span>
<span class="go">....:                  1: (-2, 3),</span>
<span class="go">....:                  2: (2, 3),</span>
<span class="go">....:                  3: (6, 3)},</span>
<span class="go">....:     format_state_label=lambda x: r&#39;\mathbf{%s}&#39; % x,</span>
<span class="go">....:     format_letter=lambda x: r&#39;w_{%s}&#39; % x,</span>
<span class="go">....:     format_transition_label=lambda x:</span>
<span class="go">....:         r&quot;{\scriptstyle %s}&quot; % T.default_format_transition_label(x),</span>
<span class="go">....:     loop_where={4: &#39;below&#39;, 0: &#39;left&#39;, 1: &#39;above&#39;,</span>
<span class="go">....:                 2: &#39;right&#39;, 3:&#39;below&#39;},</span>
<span class="go">....:     initial_where=lambda x: &#39;above&#39;,</span>
<span class="go">....:     accepting_style=&#39;accepting by double&#39;,</span>
<span class="go">....:     accepting_distance=&#39;10ex&#39;,</span>
<span class="go">....:     accepting_where={0: &#39;left&#39;, 3: 45}</span>
<span class="go">....:     )</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">format_label</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="sa">r</span><span class="s1">&#39;\mathcal{I}&#39;</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">\begin{tikzpicture}[auto, initial text=, &gt;=latex]</span>
<span class="go">\node[state, initial, initial where=above] (v0) at (0.000000, 0.000000) {$\mathcal{I}$};</span>
<span class="go">\node[state, accepting, accepting where=left] (v1) at (-6.000000, 3.000000) {$\mathbf{0}$};</span>
<span class="go">\node[state, accepting, accepting where=45] (v2) at (6.000000, 3.000000) {$\mathbf{3}$};</span>
<span class="go">\path[-&gt;] (v2.45.00) edge node[rotate=45.00, anchor=south] {$$ \mid {\scriptstyle w_{0} w_{0}}$} ++(45.00:10ex);</span>
<span class="go">\node[state] (v3) at (-2.000000, 3.000000) {$\mathbf{1}$};</span>
<span class="go">\node[state] (v4) at (2.000000, 3.000000) {$\mathbf{2}$};</span>
<span class="go">\path[-&gt;] (v1) edge[loop left] node[rotate=90, anchor=south] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0}}$} ();</span>
<span class="go">\path[-&gt;] (v1.-21.57) edge node[rotate=-26.57, anchor=south] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0} w_{0}}$} (v0.148.43);</span>
<span class="go">\path[-&gt;] (v3) edge[loop above] node {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0}}$} ();</span>
<span class="go">\path[-&gt;] (v3.-51.31) edge node[rotate=-56.31, anchor=south] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0} w_{-1}}$} (v0.118.69);</span>
<span class="go">\path[-&gt;] (v4) edge[loop right] node[rotate=90, anchor=north] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0}}$} ();</span>
<span class="go">\path[-&gt;] (v4.-118.69) edge node[rotate=56.31, anchor=north] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0} w_{-2}}$} (v0.51.31);</span>
<span class="go">\path[-&gt;] (v2) edge[loop below] node {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0}}$} ();</span>
<span class="go">\path[-&gt;] (v2.-148.43) edge node[rotate=26.57, anchor=north] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0} w_{-3}}$} (v0.21.57);</span>
<span class="go">\path[-&gt;] (v0.158.43) edge node[rotate=333.43, anchor=north] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0} w_{0}}$} (v1.328.43);</span>
<span class="go">\path[-&gt;] (v0.128.69) edge node[rotate=303.69, anchor=north] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0} w_{1}}$} (v3.298.69);</span>
<span class="go">\path[-&gt;] (v0.61.31) edge node[rotate=56.31, anchor=south] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0} w_{2}}$} (v4.231.31);</span>
<span class="go">\path[-&gt;] (v0.31.57) edge node[rotate=26.57, anchor=south] {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0} w_{3}}$} (v2.201.57);</span>
<span class="go">\path[-&gt;] (v0) edge[loop below] node {${\scriptstyle w_{0}}\mid {\scriptstyle w_{0}}$} ();</span>
<span class="go">\end{tikzpicture}</span>
<span class="gp">sage: </span><span class="n">view</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="c1"># not tested</span>
</pre></div>
</div>
<p>To actually see this, use the live documentation in the Sage notebook
and execute the cells.</p>
<p>By changing some of the options, we get the following output:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">latex_options</span><span class="p">(</span>
<span class="go">....:     format_transition_label=T.default_format_transition_label,</span>
<span class="go">....:     accepting_style=&#39;accepting by arrow&#39;,</span>
<span class="go">....:     accepting_show_empty=True</span>
<span class="go">....:     )</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">\begin{tikzpicture}[auto, initial text=, &gt;=latex, accepting text=, accepting/.style=accepting by arrow, accepting distance=10ex]</span>
<span class="go">\node[state, initial, initial where=above] (v0) at (0.000000, 0.000000) {$\mathcal{I}$};</span>
<span class="go">\node[state] (v1) at (-6.000000, 3.000000) {$\mathbf{0}$};</span>
<span class="go">\path[-&gt;] (v1.180.00) edge node[rotate=360.00, anchor=south] {$$ \mid \varepsilon$} ++(180.00:10ex);</span>
<span class="go">\node[state] (v2) at (6.000000, 3.000000) {$\mathbf{3}$};</span>
<span class="go">\path[-&gt;] (v2.45.00) edge node[rotate=45.00, anchor=south] {$$ \mid w_{0} w_{0}$} ++(45.00:10ex);</span>
<span class="go">\node[state] (v3) at (-2.000000, 3.000000) {$\mathbf{1}$};</span>
<span class="go">\node[state] (v4) at (2.000000, 3.000000) {$\mathbf{2}$};</span>
<span class="go">\path[-&gt;] (v1) edge[loop left] node[rotate=90, anchor=south] {$w_{0}\mid w_{0}$} ();</span>
<span class="go">\path[-&gt;] (v1.-21.57) edge node[rotate=-26.57, anchor=south] {$w_{0}\mid w_{0} w_{0}$} (v0.148.43);</span>
<span class="go">\path[-&gt;] (v3) edge[loop above] node {$w_{0}\mid w_{0}$} ();</span>
<span class="go">\path[-&gt;] (v3.-51.31) edge node[rotate=-56.31, anchor=south] {$w_{0}\mid w_{0} w_{-1}$} (v0.118.69);</span>
<span class="go">\path[-&gt;] (v4) edge[loop right] node[rotate=90, anchor=north] {$w_{0}\mid w_{0}$} ();</span>
<span class="go">\path[-&gt;] (v4.-118.69) edge node[rotate=56.31, anchor=north] {$w_{0}\mid w_{0} w_{-2}$} (v0.51.31);</span>
<span class="go">\path[-&gt;] (v2) edge[loop below] node {$w_{0}\mid w_{0}$} ();</span>
<span class="go">\path[-&gt;] (v2.-148.43) edge node[rotate=26.57, anchor=north] {$w_{0}\mid w_{0} w_{-3}$} (v0.21.57);</span>
<span class="go">\path[-&gt;] (v0.158.43) edge node[rotate=333.43, anchor=north] {$w_{0}\mid w_{0} w_{0}$} (v1.328.43);</span>
<span class="go">\path[-&gt;] (v0.128.69) edge node[rotate=303.69, anchor=north] {$w_{0}\mid w_{0} w_{1}$} (v3.298.69);</span>
<span class="go">\path[-&gt;] (v0.61.31) edge node[rotate=56.31, anchor=south] {$w_{0}\mid w_{0} w_{2}$} (v4.231.31);</span>
<span class="go">\path[-&gt;] (v0.31.57) edge node[rotate=26.57, anchor=south] {$w_{0}\mid w_{0} w_{3}$} (v2.201.57);</span>
<span class="go">\path[-&gt;] (v0) edge[loop below] node {$w_{0}\mid w_{0}$} ();</span>
<span class="go">\end{tikzpicture}</span>
<span class="gp">sage: </span><span class="n">view</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="c1"># not tested</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.markov_chain_simplification">
<code class="descname">markov_chain_simplification</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.markov_chain_simplification" title="Permalink to this definition">¶</a></dt>
<dd><p>Consider <code class="docutils literal"><span class="pre">self</span></code> as Markov chain with probabilities as input labels
and simplify it.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>Simplified version of <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_add_input</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="go">....:                 [2, 2, 1/4, 1], [2, -2, 1/4, 1], [-2, -2, 1/4, 1],</span>
<span class="go">....:                 [-2, 2, 1/4, 1], [2, 3, 1/2, 2], [-2, 3, 1/2, 2]],</span>
<span class="go">....:                initial_states=[1],</span>
<span class="go">....:                final_states=[3],</span>
<span class="go">....:                on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">T1</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">markov_chain_simplification</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">T1</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from ((1,),) to ((2, -2),): 1|0,</span>
<span class="go"> Transition from ((2, -2),) to ((2, -2),): 1/2|1,</span>
<span class="go"> Transition from ((2, -2),) to ((3,),): 1/2|2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.merged_transitions">
<code class="descname">merged_transitions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.merged_transitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges transitions which have the same <code class="docutils literal"><span class="pre">from_state</span></code>,
<code class="docutils literal"><span class="pre">to_state</span></code> and <code class="docutils literal"><span class="pre">word_out</span></code> while adding their <code class="docutils literal"><span class="pre">word_in</span></code>.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A finite state machine with merged transitions. If no mergers occur,
return <code class="docutils literal"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_add_input</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                 [2, 2, 1/4, 1], [2, -2, 1/4, 1], [-2, -2, 1/4, 1],</span>
<span class="go">....:                 [-2, 2, 1/4, 1], [2, 3, 1/2, 1], [-2, 3, 1/2, 1]],</span>
<span class="go">....:                on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">T1</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">merged_transitions</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T1</span> <span class="ow">is</span> <span class="n">T</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">T1</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from -2 to -2: 1/4|1,</span>
<span class="go"> Transition from -2 to 2: 1/4|1,</span>
<span class="go"> Transition from -2 to 3: 1/2|1,</span>
<span class="go"> Transition from 1 to 2: 1/4|1,</span>
<span class="go"> Transition from 1 to -2: 3/4|1,</span>
<span class="go"> Transition from 2 to -2: 1/4|1,</span>
<span class="go"> Transition from 2 to 2: 1/4|1,</span>
<span class="go"> Transition from 2 to 3: 1/2|1]</span>
</pre></div>
</div>
<p>Applying the function again does not change the result:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T2</span> <span class="o">=</span> <span class="n">T1</span><span class="o">.</span><span class="n">merged_transitions</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T2</span> <span class="ow">is</span> <span class="n">T1</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.moments_waiting_time">
<code class="descname">moments_waiting_time</code><span class="sig-paren">(</span><em>test=&lt;type 'bool'&gt;</em>, <em>is_zero=None</em>, <em>expectation_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.moments_waiting_time" title="Permalink to this definition">¶</a></dt>
<dd><p>If this finite state machine acts as a Markov chain, return
the expectation and variance of the number of steps until
first writing <code class="docutils literal"><span class="pre">True</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">test</span></code> – (default: <code class="docutils literal"><span class="pre">bool</span></code>) a callable deciding whether
an output label is to be considered <code class="docutils literal"><span class="pre">True</span></code>. By default, the
standard conversion to boolean is used.</li>
<li><code class="docutils literal"><span class="pre">is_zero</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) a callable deciding
whether an expression for a probability is zero. By default,
checking for zero is simply done by
<a class="reference external" href="../../../structure/sage/structure/element.html#sage.structure.element.Element.is_zero" title="(in Sage Reference Manual: Parents and Elements v8.1)"><code class="xref py py-meth docutils literal"><span class="pre">is_zero()</span></code></a>.  This
parameter can be used to provide a more sophisticated check
for zero, e.g. in the case of symbolic probabilities, see
the examples below. This parameter is passed on to
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_Markov_chain" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_Markov_chain"><code class="xref py py-meth docutils literal"><span class="pre">is_Markov_chain()</span></code></a>. This parameter only affects the
input of the Markov chain.</li>
<li><code class="docutils literal"><span class="pre">expectation_only</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>) if set, the
variance is not computed (in order to save time). By default,
the variance is computed.</li>
</ul>
<p>OUTPUT:</p>
<p>A dictionary (if <code class="docutils literal"><span class="pre">expectation_only=False</span></code>) consisting of</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">expectation</span></code>,</li>
<li><code class="docutils literal"><span class="pre">variance</span></code>.</li>
</ul>
<p>Otherwise, just the expectation is returned (no dictionary for
<code class="docutils literal"><span class="pre">expectation_only=True</span></code>).</p>
<p>Expectation and variance of the number of steps until first
writing <code class="docutils literal"><span class="pre">True</span></code> (as determined by the parameter <code class="docutils literal"><span class="pre">test</span></code>).</p>
<p>ALGORITHM:</p>
<p>Relies on a (classical and easy) probabilistic argument,
cf. <a class="reference internal" href="#fgt1992" id="id17">[FGT1992]</a>, Eqns. (6) and (7).</p>
<p>For the variance, see <a class="reference internal" href="#fhp2015" id="id18">[FHP2015]</a>, Section 2.</p>
<p>EXAMPLES:</p>
<ol class="arabic">
<li><p class="first">The simplest example is to wait for the first <span class="math">\(1\)</span> in a
<span class="math">\(0\)</span>-<span class="math">\(1\)</span>-string where both digits appear with probability
<span class="math">\(1/2\)</span>. In fact, the waiting time equals <span class="math">\(k\)</span> if and only if
the string starts with <span class="math">\(0^{k-1}1\)</span>. This event occurs with
probability <span class="math">\(2^{-k}\)</span>. Therefore, the expected waiting time
and the variance are <span class="math">\(\sum_{k\ge 1} k2^{-k}=2\)</span> and
<span class="math">\(\sum_{k\ge 1} (k-2)^2 2^{-k}=2\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="go">k</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="p">),</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">infinity</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">sum</span><span class="p">((</span><span class="n">k</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="p">),</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">infinity</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>We now compute the same expectation and variance by using a
Markov chain:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="p">(</span>
<span class="go">....:     duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span>
<span class="go">....:     [(0, 0, 1/2, 0), (0, 0, 1/2, 1)],</span>
<span class="go">....:     on_duplicate_transition=\</span>
<span class="go">....:         duplicate_transition_add_input,</span>
<span class="go">....:     initial_states=[0],</span>
<span class="go">....:     final_states=[0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">moments_waiting_time</span><span class="p">()</span>
<span class="go">{&#39;expectation&#39;: 2, &#39;variance&#39;: 2}</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">moments_waiting_time</span><span class="p">(</span><span class="n">expectation_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>In the following, we replace the output <code class="docutils literal"><span class="pre">0</span></code> by <code class="docutils literal"><span class="pre">-1</span></code> and
demonstrate the use of the parameter <code class="docutils literal"><span class="pre">test</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">delete_transition</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">add_transition</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">Transition from 0 to 0: 1/2|-1</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">moments_waiting_time</span><span class="p">(</span><span class="n">test</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
<span class="go">{&#39;expectation&#39;: 2, &#39;variance&#39;: 2}</span>
</pre></div>
</div>
</li>
<li><p class="first">Make sure that the transducer is actually a Markov
chain. Although this is checked by the code, unexpected
behaviour may still occur if the transducer looks like a
Markov chain. In the following example, we ‘forget’ to
assign probabilities, but due to a coincidence, all
‘probabilities’ add up to one. Nevertheless, <span class="math">\(0\)</span> is never
written, so the expectation is <span class="math">\(1\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                on_duplicate_transition=\</span>
<span class="go">....:                    duplicate_transition_add_input,</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">moments_waiting_time</span><span class="p">()</span>
<span class="go">{&#39;expectation&#39;: 1, &#39;variance&#39;: 0}</span>
</pre></div>
</div>
</li>
<li><p class="first">If <code class="docutils literal"><span class="pre">True</span></code> is never written, the moments are
<code class="docutils literal"><span class="pre">+Infinity</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                on_duplicate_transition=\</span>
<span class="go">....:                    duplicate_transition_add_input,</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">moments_waiting_time</span><span class="p">()</span>
<span class="go">{&#39;expectation&#39;: +Infinity, &#39;variance&#39;: +Infinity}</span>
</pre></div>
</div>
</li>
<li><p class="first">Let <span class="math">\(h\)</span> and <span class="math">\(r\)</span> be positive integers. We consider random
strings of letters <span class="math">\(1\)</span>, <span class="math">\(\ldots\)</span>, <span class="math">\(r\)</span> where the letter <span class="math">\(j\)</span>
occurs with probability <span class="math">\(p_j\)</span>. Let <span class="math">\(B\)</span> be the random
variable giving the first position of a block of <span class="math">\(h\)</span>
consecutive identical letters. Then</p>
<div class="math">
\[\begin{split}\begin{aligned}
\mathbb{E}(B)&amp;=\frac1{\displaystyle\sum_{i=1}^r
\frac1{p_i^{-1}+\cdots+p_i^{-h}}},\\
\mathbb{V}(B)&amp;=\frac{\displaystyle\sum_{i=1}^r\biggl(
\frac{p_i +p_i^h}{1-p_i^h}
- 2h\frac{ p_i^h(1-p_i)}{(1-p_i^h)^2}\biggr)}
{\displaystyle\biggl(\sum_{i=1}^r
\frac1{p_i^{-1}+\cdots+p_i^{-h}}\biggr)^2}
\end{aligned}\end{split}\]</div>
<p>cf. <a class="reference internal" href="#s1986" id="id19">[S1986]</a>, p. 62, or <a class="reference internal" href="#fhp2015" id="id20">[FHP2015]</a>, Theorem 1. We now
verify this with a transducer approach.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="go">....:     R = PolynomialRing(</span>
<span class="go">....:             QQ,</span>
<span class="go">....:             names=[&#39;p_%d&#39; % j for j in range(r)])</span>
<span class="go">....:     p = R.gens()</span>
<span class="go">....:     def is_zero(polynomial):</span>
<span class="go">....:         return polynomial in (sum(p) - 1) * R</span>
<span class="go">....:     theory_expectation = 1/(sum(1/sum(p[j]^(-i)</span>
<span class="go">....:                     for i in range(1, h+1))</span>
<span class="go">....:                     for j in range(r)))</span>
<span class="go">....:     theory_variance = sum(</span>
<span class="go">....:         (p[i] + p[i]^h)/(1 - p[i]^h)</span>
<span class="go">....:         - 2*h*p[i]^h * (1 - p[i])/(1 - p[i]^h)^2</span>
<span class="go">....:         for i in range(r)</span>
<span class="go">....:         ) * theory_expectation^2</span>
<span class="go">....:     alphabet = list(range(r))</span>
<span class="go">....:     counters = [</span>
<span class="go">....:         transducers.CountSubblockOccurrences([j]*h,</span>
<span class="go">....:                     alphabet)</span>
<span class="go">....:         for j in alphabet]</span>
<span class="go">....:     all_counter = counters[0].cartesian_product(</span>
<span class="go">....:         counters[1:])</span>
<span class="go">....:     adder = transducers.add(input_alphabet=[0, 1],</span>
<span class="go">....:         number_of_operands=r)</span>
<span class="go">....:     probabilities = Transducer(</span>
<span class="go">....:        [(0, 0, p[j], j) for j in alphabet],</span>
<span class="go">....:        initial_states=[0],</span>
<span class="go">....:        final_states=[0],</span>
<span class="go">....:        on_duplicate_transition=\</span>
<span class="go">....:            duplicate_transition_add_input)</span>
<span class="go">....:     chain = adder(all_counter(probabilities))</span>
<span class="go">....:     result = chain.moments_waiting_time(</span>
<span class="go">....:        is_zero=is_zero)</span>
<span class="go">....:     return is_zero((result[&#39;expectation&#39;] -</span>
<span class="go">....:                theory_expectation).numerator()) \</span>
<span class="go">....:            and \</span>
<span class="go">....:            is_zero((result[&#39;variance&#39;] -</span>
<span class="go">....:                 theory_variance).numerator())</span>
<span class="gp">sage: </span><span class="n">test</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p class="first">Consider the alphabet <span class="math">\(\{0, \ldots, r-1\}\)</span>, some <span class="math">\(1\le j\le
r\)</span> and some <span class="math">\(h\ge 1\)</span>.  For some probabilities <span class="math">\(p_0\)</span>,
<span class="math">\(\ldots\)</span>, <span class="math">\(p_{r-1}\)</span>, we consider infinite words where the
letters occur independently with the given probabilities.
The random variable <span class="math">\(B_j\)</span> is the first position <span class="math">\(n\)</span> such
that there exist <span class="math">\(j\)</span> of the <span class="math">\(r\)</span> letters having an <span class="math">\(h\)</span>-run.
The expectation of <span class="math">\(B_j\)</span> is given in <a class="reference internal" href="#fhp2015" id="id21">[FHP2015]</a>, Theorem 2.
Here, we verify this result by using transducers:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="go">....:     R = PolynomialRing(</span>
<span class="go">....:             QQ,</span>
<span class="go">....:             names=[&#39;p_%d&#39; % i for i in range(r)])</span>
<span class="go">....:     p = R.gens()</span>
<span class="go">....:     def is_zero(polynomial):</span>
<span class="go">....:         return polynomial in (sum(p) - 1) * R</span>
<span class="go">....:     alphabet = list(range(r))</span>
<span class="go">....:     counters = [</span>
<span class="go">....:         transducers.Wait([0, 1])(</span>
<span class="go">....:             transducers.CountSubblockOccurrences(</span>
<span class="go">....:                 [i]*h,</span>
<span class="go">....:                 alphabet))</span>
<span class="go">....:         for i in alphabet]</span>
<span class="go">....:     all_counter = counters[0].cartesian_product(</span>
<span class="go">....:         counters[1:])</span>
<span class="go">....:     adder = transducers.add(input_alphabet=[0, 1],</span>
<span class="go">....:         number_of_operands=r)</span>
<span class="go">....:     threshold = transducers.map(</span>
<span class="go">....:         f=lambda x: x &gt;= j,</span>
<span class="go">....:         input_alphabet=srange(r+1))</span>
<span class="go">....:     probabilities = Transducer(</span>
<span class="go">....:         [(0, 0, p[i], i) for i in alphabet],</span>
<span class="go">....:         initial_states=[0],</span>
<span class="go">....:         final_states=[0],</span>
<span class="go">....:         on_duplicate_transition=\</span>
<span class="go">....:             duplicate_transition_add_input)</span>
<span class="go">....:     chain = threshold(adder(all_counter(</span>
<span class="go">....:         probabilities)))</span>
<span class="go">....:     result = chain.moments_waiting_time(</span>
<span class="go">....:         is_zero=is_zero,</span>
<span class="go">....:         expectation_only=True)</span>
<span class="go">....:</span>
<span class="go">....:     R_v = PolynomialRing(</span>
<span class="go">....:             QQ,</span>
<span class="go">....:             names=[&#39;p_%d&#39; % i for i in range(r)])</span>
<span class="go">....:     v = R_v.gens()</span>
<span class="go">....:     S = 1/(1 - sum(v[i]/(1+v[i])</span>
<span class="go">....:                    for i in range(r)))</span>
<span class="go">....:     alpha = [(p[i] - p[i]^h)/(1 - p[i])</span>
<span class="go">....:              for i in range(r)]</span>
<span class="go">....:     gamma = [p[i]/(1 - p[i]) for i in range(r)]</span>
<span class="go">....:     alphabet_set = set(alphabet)</span>
<span class="go">....:     expectation = 0</span>
<span class="go">....:     for q in range(j):</span>
<span class="go">....:         for M in Subsets(alphabet_set, q):</span>
<span class="go">....:             summand = S</span>
<span class="go">....:             for i in M:</span>
<span class="go">....:                 summand = summand.subs(</span>
<span class="go">....:                     {v[i]: gamma[i]}) -\</span>
<span class="go">....:                     summand.subs({v[i]: alpha[i]})</span>
<span class="go">....:             for i in alphabet_set - set(M):</span>
<span class="go">....:                 summand = summand.subs(</span>
<span class="go">....:                     {v[i]: alpha[i]})</span>
<span class="go">....:             expectation += summand</span>
<span class="go">....:     return is_zero((result - expectation).\</span>
<span class="go">....:             numerator())</span>
<span class="gp">sage: </span><span class="n">test</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
</ol>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="fgt1992" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[FGT1992]</a></td><td>Philippe Flajolet, Danièle Gardy, Loÿs Thimonier,
<em>Birthday paradox, coupon collectors, caching algorithms and
self-organizing search</em>, Discrete Appl. Math. 39 (1992),
207–229, <a class="reference external" href="https://dx.doi.org/10.1016/0166-218X(92)90177-C">doi:10.1016/0166-218X(92)90177-C</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="fhp2015" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[FHP2015]</td><td><em>(<a class="fn-backref" href="#id18">1</a>, <a class="fn-backref" href="#id20">2</a>, <a class="fn-backref" href="#id21">3</a>)</em> Uta Freiberg, Clemens Heuberger, Helmut Prodinger,
<em>Application of Smirnov Words to Waiting Time Distributions
of Runs</em>, <a class="reference external" href="http://arxiv.org/abs/1503.08096">Arxiv 1503.08096</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="s1986" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[S1986]</a></td><td>Gábor J. Székely, <em>Paradoxes in Probability Theory
and Mathematical Statistics</em>, D. Reidel Publishing Company.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.number_of_words">
<code class="descname">number_of_words</code><span class="sig-paren">(</span><em>variable=n</em>, <em>base_ring=Algebraic Field</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.number_of_words" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of successful input words of given length.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">variable</span></code> – a symbol denoting the length of the words,
by default <span class="math">\(n\)</span>.</li>
<li><code class="docutils literal"><span class="pre">base_ring</span></code> – Ring (default: <code class="docutils literal"><span class="pre">QQbar</span></code>) in which to
compute the eigenvalues.</li>
</ul>
<p>OUTPUT:</p>
<p>A symbolic expression.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NAFpm</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                    (0, 1, -1), (1, 0, 0)],</span>
<span class="go">....:                   initial_states=[0],</span>
<span class="go">....:                   final_states=[0, 1])</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NAFpm</span><span class="o">.</span><span class="n">number_of_words</span><span class="p">();</span> <span class="n">N</span>
<span class="go">4/3*2^n - 1/3*(-1)^n</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">NAFpm</span><span class="o">.</span><span class="n">language</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
<span class="go">....:     - len(list(NAFpm.language(s-1))) == N.subs(n=s)</span>
<span class="go">....:     for s in srange(1, 6))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>An example with non-rational eigenvalues. By default,
eigenvalues are elements of the
<a class="reference external" href="../../../number_fields/sage/rings/qqbar.html#module-sage.rings.qqbar" title="(in Sage Reference Manual: Algebraic Numbers and Number Fields v8.1)"><code class="xref py py-mod docutils literal"><span class="pre">field</span> <span class="pre">of</span> <span class="pre">algebraic</span> <span class="pre">numbers</span></code></a>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NAFp</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[0, 1])</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NAFp</span><span class="o">.</span><span class="n">number_of_words</span><span class="p">();</span> <span class="n">N</span>
<span class="go">1.170820393249937?*1.618033988749895?^n</span>
<span class="go">- 0.1708203932499369?*(-0.618033988749895?)^n</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">NAFp</span><span class="o">.</span><span class="n">language</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
<span class="go">....:     - len(list(NAFp.language(s-1))) == N.subs(n=s)</span>
<span class="go">....:     for s in srange(1, 6))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We specify a suitable <code class="docutils literal"><span class="pre">base_ring</span></code> to obtain a radical
expression. To do so, we first compute the characteristic
polynomial and then construct a number field generated by its
roots.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">NAFp</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">entry</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">characteristic_polynomial</span><span class="p">()</span>
<span class="go">x^2 - x - 1</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">phi</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="mf">1.6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NAFp</span><span class="o">.</span><span class="n">number_of_words</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">R</span><span class="p">);</span> <span class="n">N</span>
<span class="go">1/2*(1/2*sqrt(5) + 1/2)^n*(3*sqrt(1/5) + 1)</span>
<span class="go">- 1/2*(-1/2*sqrt(5) + 1/2)^n*(3*sqrt(1/5) - 1)</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">NAFp</span><span class="o">.</span><span class="n">language</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
<span class="go">....:     - len(list(NAFp.language(s-1))) == N.subs(n=s)</span>
<span class="go">....:     for s in srange(1, 6))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In this special case, we might also use the constant
<a class="reference external" href="../../../constants/sage/symbolic/constants.html#sage.symbolic.constants.GoldenRatio" title="(in Sage Reference Manual: Constants v8.1)"><code class="xref py py-class docutils literal"><span class="pre">golden_ratio</span></code></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">phi</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">NumberField</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">embedding</span><span class="o">=</span><span class="n">golden_ratio</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NAFp</span><span class="o">.</span><span class="n">number_of_words</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">R</span><span class="p">);</span> <span class="n">N</span>
<span class="go">1/5*(3*golden_ratio + 1)*golden_ratio^n</span>
<span class="go">- 1/5*(3*golden_ratio - 4)*(-golden_ratio + 1)^n</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">NAFp</span><span class="o">.</span><span class="n">language</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
<span class="go">....:     - len(list(NAFp.language(s-1))) == N.subs(n=s)</span>
<span class="go">....:     for s in srange(1, 6))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The adjacency matrix of the following example is a Jordan
matrix of size 3 to the eigenvalue 4:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">J3</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)],</span>
<span class="go">....:     initial_states=[0],</span>
<span class="go">....:     final_states=[0, 1, 2])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="go">....:     for j in range(4):</span>
<span class="go">....:         new_transition = J3.add_transition(i, i, j)</span>
<span class="gp">sage: </span><span class="n">J3</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">entry</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[4 1 0]</span>
<span class="go">[0 4 1]</span>
<span class="go">[0 0 4]</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">J3</span><span class="o">.</span><span class="n">number_of_words</span><span class="p">();</span> <span class="n">N</span>
<span class="go">1/2*4^(n - 2)*(n - 1)*n + 4^(n - 1)*n + 4^n</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">J3</span><span class="o">.</span><span class="n">language</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
<span class="go">....:     - len(list(J3.language(s-1))) == N.subs(n=s)</span>
<span class="go">....:     for s in range(1, 6))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Here is an automaton without cycles, so with eigenvalue <span class="math">\(0\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0],</span>
<span class="go">....:               final_states=list(range(3)))</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">number_of_words</span><span class="p">()</span>
<span class="go">1/2*0^(n - 2)*(n - 1)*n + 0^(n - 1)*n + 0^n</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition">
<code class="descname">on_duplicate_transition</code><span class="sig-paren">(</span><em>old_transition</em>, <em>new_transition</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.on_duplicate_transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Which function to call when a duplicate transition is inserted.</p>
<p>It can be set by the parameter <code class="docutils literal"><span class="pre">on_duplicate_transition</span></code> when
initializing a finite state machine, see
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>, <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.is_Markov_chain" title="sage.combinat.finite_state_machine.FiniteStateMachine.is_Markov_chain"><code class="xref py py-meth docutils literal"><span class="pre">is_Markov_chain()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.markov_chain_simplification" title="sage.combinat.finite_state_machine.FiniteStateMachine.markov_chain_simplification"><code class="xref py py-meth docutils literal"><span class="pre">markov_chain_simplification()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.output_alphabet">
<code class="descname">output_alphabet</code><em class="property"> = None</em><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.output_alphabet" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of letters representing the output alphabet of the finite
state machine.</p>
<p>It can be set by the parameter <code class="docutils literal"><span class="pre">output_alphabet</span></code> when initializing
a finite state machine, see <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>.</p>
<p>It can also be set by the method <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.input_alphabet" title="sage.combinat.finite_state_machine.FiniteStateMachine.input_alphabet"><code class="xref py py-attr docutils literal"><span class="pre">input_alphabet</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.output_projection">
<code class="descname">output_projection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.output_projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a automaton where the input of each transition of self
is deleted and the new input is the original output.</p>
<p>INPUT:</p>
<p>Nothing</p>
<p>OUTPUT:</p>
<p>An automaton.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                         (&#39;B&#39;, &#39;B&#39;, 1, 0)])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">output_projection</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;B&#39;: 1|-,</span>
<span class="go"> Transition from &#39;A&#39; to &#39;A&#39;: 1|-,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;B&#39;: 0|-]</span>
</pre></div>
</div>
<p>Final output words are also considered correctly:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;B&#39;, 1, 0), (&#39;A&#39;, (&#39;final&#39;, 0), 0, 0)],</span>
<span class="go">....:                final_states=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">output_projection</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;, &#39;B&#39;, (&#39;final&#39;, 0), (&#39;final&#39;, 1)]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;B&#39;: 1|-,</span>
<span class="go"> Transition from &#39;A&#39; to &#39;A&#39;: 1|-,</span>
<span class="go"> Transition from &#39;A&#39; to (&#39;final&#39;, 0): 0|-,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;B&#39;: 0|-,</span>
<span class="go"> Transition from &#39;B&#39; to (&#39;final&#39;, 1): 2|-]</span>
<span class="gp">sage: </span><span class="n">J</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;, (&#39;final&#39;, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a graph of the finite state machine with labeled
vertices and labeled edges.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A plot of the graph of the finite state machine.</p>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.predecessors">
<code class="descname">predecessors</code><span class="sig-paren">(</span><em>state</em>, <em>valid_input=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.predecessors" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists all predecessors of a state.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">state</span></code> – the state from which the predecessors should be
listed.</li>
<li><code class="docutils literal"><span class="pre">valid_input</span></code> – If <code class="docutils literal"><span class="pre">valid_input</span></code> is a list, then we
only consider transitions whose input labels are contained
in <code class="docutils literal"><span class="pre">valid_input</span></code>. <code class="docutils literal"><span class="pre">state</span></code> has to be a <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><code class="xref py py-class docutils literal"><span class="pre">FSMState</span></code></a>
(not a label of a state). If input labels of length larger
than <span class="math">\(1\)</span> are used, then <code class="docutils literal"><span class="pre">valid_input</span></code> has to be a list of
lists.</li>
</ul>
<p>OUTPUT:</p>
<p>A list of states.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span>
<span class="go">....:                 (&#39;I&#39;, &#39;C&#39;, &#39;c&#39;, &#39;a&#39;), (&#39;A&#39;, &#39;F&#39;, &#39;b&#39;, &#39;a&#39;),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;F&#39;, [&#39;c&#39;, &#39;b&#39;], &#39;b&#39;), (&#39;C&#39;, &#39;F&#39;, &#39;a&#39;, &#39;c&#39;)],</span>
<span class="go">....:                initial_states=[&#39;I&#39;], final_states=[&#39;F&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">))</span>
<span class="go">[&#39;A&#39;, &#39;I&#39;]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="n">valid_input</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">])</span>
<span class="go">[&#39;F&#39;, &#39;C&#39;, &#39;A&#39;, &#39;I&#39;]</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="n">valid_input</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;a&#39;</span><span class="p">])</span>
<span class="go">[&#39;F&#39;, &#39;C&#39;, &#39;B&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.prepone_output">
<code class="descname">prepone_output</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.prepone_output" title="Permalink to this definition">¶</a></dt>
<dd><p>For all paths, shift the output of the path from one
transition to the earliest possible preceeding transition of
the path.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>Apply the following to each state <span class="math">\(s\)</span> (except initial states) of the
finite state machine as often as possible:</p>
<p>If the letter <span class="math">\(a\)</span> is a prefix of the output label of all transitions from
<span class="math">\(s\)</span> (including the final output of <span class="math">\(s\)</span>), then remove it from all these
labels and append it to all output labels of all transitions leading
to <span class="math">\(s\)</span>.</p>
<p>We assume that the states have no output labels, but final outputs are
allowed.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;B&#39;, 0, 0),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;C&#39;, 1, 0)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;],</span>
<span class="go">....:                final_states=[&#39;C&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">prepone_output</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;B&#39;: 1|1,0,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;B&#39;: 0|0,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;C&#39;: 1|-]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;C&#39;, 1, [1, 1]),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;C&#39;, 0, 1)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;],</span>
<span class="go">....:                final_states=[&#39;C&#39;])</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">prepone_output</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;B&#39;: 0|1,1,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;C&#39;: 1|1,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;C&#39;: 0|-]</span>
</pre></div>
</div>
<p>If initial states are not labeled as such, unexpected results may be
obtained:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">prepone_output</span><span class="p">()</span>
<span class="go">verbose 0 (...: finite_state_machine.py, prepone_output)</span>
<span class="go">All transitions leaving state 0 have an output label with</span>
<span class="go">prefix 0.  However, there is no inbound transition and it</span>
<span class="go">is not an initial state. This routine (possibly called by</span>
<span class="go">simplification) therefore erased this prefix from all</span>
<span class="go">outbound transitions.</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|-]</span>
</pre></div>
</div>
<p>Also the final output of final states can be changed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;C&#39;, 1, [1, 1]),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;C&#39;, 0, 1)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;],</span>
<span class="go">....:                final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">prepone_output</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;B&#39;: 0|1,1,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;C&#39;: 1|1,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;C&#39;: 0|-]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;C&#39;, 1, [1, 1]),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;C&#39;, 0, 1)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;],</span>
<span class="go">....:                final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">prepone_output</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;B&#39;: 0|1,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;C&#39;: 1|1,1,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;C&#39;: 0|1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[0]</span>
</pre></div>
</div>
<p>Output labels do not have to be hashable:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]),</span>
<span class="go">....:                 (1, 0, 0, [vector([0, 0]), 0]),</span>
<span class="go">....:                 (1, 1, 1, [vector([0, 0]), 1]),</span>
<span class="go">....:                 (0, 0, 1, 0)],</span>
<span class="go">....:                 determine_alphabets=False,</span>
<span class="go">....:                 initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">prepone_output</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from 0 to 1: 0|(0, 0),</span>
<span class="go"> Transition from 0 to 0: 1|0,</span>
<span class="go"> Transition from 1 to 0: 0|0,</span>
<span class="go"> Transition from 1 to 1: 1|1,(0, 0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.process">
<code class="descname">process</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the finite state machine accepts the input, the state
where the computation stops and which output is generated.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">input_tape</span></code> – the input tape can be a list or an
iterable with entries from the input alphabet. If we are
working with a multi-tape machine (see parameter
<code class="docutils literal"><span class="pre">use_multitape_input</span></code> and notes below), then the tape is a
list or tuple of tracks, each of which can be a list or an
iterable with entries from the input alphabet.</li>
<li><code class="docutils literal"><span class="pre">initial_state</span></code> or <code class="docutils literal"><span class="pre">initial_states</span></code> – the initial
state(s) in which the machine starts. Either specify a
single one with <code class="docutils literal"><span class="pre">initial_state</span></code> or a list of them with
<code class="docutils literal"><span class="pre">initial_states</span></code>. If both are given, <code class="docutils literal"><span class="pre">initial_state</span></code>
will be appended to <code class="docutils literal"><span class="pre">initial_states</span></code>. If neither is
specified, the initial states of the finite state machine
are taken.</li>
<li><code class="docutils literal"><span class="pre">list_of_outputs</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) a boolean or
<code class="docutils literal"><span class="pre">None</span></code>. If <code class="docutils literal"><span class="pre">True</span></code>, then the outputs are given in list form
(even if we have no or only one single output). If
<code class="docutils literal"><span class="pre">False</span></code>, then the result is never a list (an exception is
raised if the result cannot be returned). If
<code class="docutils literal"><span class="pre">list_of_outputs=None</span></code>, the method determines automatically
what to do (e.g. if a non-deterministic machine returns more
than one path, then the output is returned in list form).</li>
<li><code class="docutils literal"><span class="pre">only_accepted</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>) a boolean. If set,
then the first argument in the output is guaranteed to be
<code class="docutils literal"><span class="pre">True</span></code> (if the output is a list, then the first argument
of each element will be <code class="docutils literal"><span class="pre">True</span></code>).</li>
<li><code class="docutils literal"><span class="pre">always_include_output</span></code> – if set (not by default), always
include the output. This is inconsequential for a
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>, but can be used in derived
classes where the output is suppressed by default,
cf. <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></code></a>.</li>
<li><code class="docutils literal"><span class="pre">format_output</span></code> – a function that translates the written
output (which is in form of a list) to something more
readable. By default (<code class="docutils literal"><span class="pre">None</span></code>) identity is used here.</li>
<li><code class="docutils literal"><span class="pre">check_epsilon_transitions</span></code> – (default: <code class="docutils literal"><span class="pre">True</span></code>) a
boolean. If <code class="docutils literal"><span class="pre">False</span></code>, then epsilon transitions are not
taken into consideration during process.</li>
<li><code class="docutils literal"><span class="pre">write_final_word_out</span></code> – (default: <code class="docutils literal"><span class="pre">True</span></code>) a boolean
specifying whether the final output words should be written
or not.</li>
<li><code class="docutils literal"><span class="pre">use_multitape_input</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>) a
boolean. If <code class="docutils literal"><span class="pre">True</span></code>, then the multi-tape mode of the
process iterator is activated. See also the notes below for
multi-tape machines.</li>
<li><code class="docutils literal"><span class="pre">process_all_prefixes_of_input</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>) a
boolean. If <code class="docutils literal"><span class="pre">True</span></code>, then each prefix of the input word is
processed (instead of processing the whole input word at
once). Consequently, there is an output generated for each
of these prefixes.</li>
<li><code class="docutils literal"><span class="pre">process_iterator_class</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) a class
inherited from <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a>. If <code class="docutils literal"><span class="pre">None</span></code>,
then <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a> is taken. An instance of this
class is created and is used during the processing.</li>
<li><code class="docutils literal"><span class="pre">automatic_output_type</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>) a boolean.
If set and the input has a parent, then the
output will have the same parent. If the input does not have
a parent, then the output will be of the same type as the
input.</li>
</ul>
<p>OUTPUT:</p>
<p>A triple (or a list of triples,
cf. parameter <code class="docutils literal"><span class="pre">list_of_outputs</span></code>), where</p>
<ul class="simple">
<li>the first entry is <code class="docutils literal"><span class="pre">True</span></code> if the input string is accepted,</li>
<li>the second gives the reached state after processing the
input tape (This is a state with label <code class="docutils literal"><span class="pre">None</span></code> if the input
could not be processed, i.e., if at one point no
transition to go on could be found.), and</li>
<li>the third gives a list of the output labels written during
processing (in the case the finite state machine runs as
transducer).</li>
</ul>
<p>Note that in the case the finite state machine is not
deterministic, all possible paths are taken into account.</p>
<p>This function uses an iterator which, in its simplest form, goes
from one state to another in each step. To decide which way to
go, it uses the input words of the outgoing transitions and
compares them to the input tape. More precisely, in each step,
the iterator takes an outgoing transition of the current state,
whose input label equals the input letter of the tape. The
output label of the transition, if present, is written on the
output tape.</p>
<p>If the choice of the outgoing transition is not unique (i.e.,
we have a non-deterministic finite state machine), all
possibilites are followed. This is done by splitting the
process into several branches, one for each of the possible
outgoing transitions.</p>
<p>The process (iteration) stops if all branches are finished,
i.e., for no branch, there is any transition whose input word
coincides with the processed input tape. This can simply
happen when the entire tape was read.</p>
<p>Also see <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> for a version of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">process()</span></code></a> with shortened output.</p>
<p>Internally this function creates and works with an instance of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a>. This iterator can also be obtained
with <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><code class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></code></a>.</p>
<p>If working with multi-tape finite state machines, all input
words of transitions are words of <span class="math">\(k\)</span>-tuples of letters.
Moreover, the input tape has to consist of <span class="math">\(k\)</span> tracks, i.e.,
be a list or tuple of <span class="math">\(k\)</span> iterators, one for each track.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Working with multi-tape finite state machines is still
experimental and can lead to wrong outputs.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">binary_inverter</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:                                      initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">binary_inverter</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(True, &#39;A&#39;, [1, 0, 1, 1, 0, 0])</span>
</pre></div>
</div>
<p>Alternatively, we can invoke this function by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">binary_inverter</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(True, &#39;A&#39;, [1, 0, 1, 1, 0, 0])</span>
</pre></div>
</div>
<p>Below we construct a finite state machine which tests if an input
is a non-adjacent form, i.e., no two neighboring letters are
both nonzero (see also the example on
<a class="reference internal" href="#finite-state-machine-recognizing-nafs-example"><span class="std std-ref">non-adjacent forms</span></a>
in the documentation of the module
<a class="reference internal" href="#"><span class="doc">Finite State Machines, Automata, Transducers</span></a>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">(</span>
<span class="go">....:     {&#39;_&#39;: [(&#39;_&#39;, 0), (1, 1)], 1: [(&#39;_&#39;, 0)]},</span>
<span class="go">....:     initial_states=[&#39;_&#39;], final_states=[&#39;_&#39;, 1])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">NAF</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">w</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                           [0, 1, 1, 1, 0], [1, 0, 0, 1, 1]]]</span>
<span class="go">[True, True, False, True, False, False]</span>
</pre></div>
</div>
<p>Working only with the first component (i.e., returning whether
accepted or not) usually corresponds to using the more
specialized class <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton" title="sage.combinat.finite_state_machine.Automaton"><code class="xref py py-class docutils literal"><span class="pre">Automaton</span></code></a>.</p>
<p>Non-deterministic finite state machines can be handeled as well.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:     initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[(False, 1, [0]), (False, 2, [0])]</span>
</pre></div>
</div>
<p>Here is another non-deterministic finite state machine. Note
that we use <code class="docutils literal"><span class="pre">format_output</span></code> (see
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a>) to convert the written outputs
(all characters) to strings.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                 (0, 1, 1, &#39;c&#39;), (1, 0, [], &#39;d&#39;),</span>
<span class="go">....:                 (1, 1, 1, &#39;e&#39;)],</span>
<span class="go">....:                initial_states=[0], final_states=[0, 1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
<span class="go">(False, None, None)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
<span class="go">[(True, 0, &#39;ad&#39;), (True, 1, &#39;a&#39;)]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
<span class="go">[(True, 0, &#39;cd&#39;), (True, 1, &#39;c&#39;)]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
<span class="go">[(True, 0, &#39;cdcd&#39;), (True, 0, &#39;ced&#39;),</span>
<span class="go"> (True, 1, &#39;cdc&#39;), (True, 1, &#39;ce&#39;)]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
<span class="go">[(True, 0, &#39;adcd&#39;), (True, 0, &#39;aed&#39;),</span>
<span class="go"> (True, 1, &#39;adc&#39;), (True, 1, &#39;ae&#39;), (False, 2, &#39;b&#39;)]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">format_output</span><span class="o">=</span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">o</span><span class="p">),</span>
<span class="go">....:           only_accepted=True)</span>
<span class="go">[(True, 0, &#39;adcd&#39;), (True, 0, &#39;aed&#39;),</span>
<span class="go"> (True, 1, &#39;adc&#39;), (True, 1, &#39;ae&#39;)]</span>
</pre></div>
</div>
<p>A simple example of a multi-tape finite state machine is the
following: It writes the length of the first tape many letters
<code class="docutils literal"><span class="pre">a</span></code> and then the length of the second tape many letters
<code class="docutils literal"><span class="pre">b</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span>
<span class="go">....:                         (0, 1, [], []),</span>
<span class="go">....:                         (1, 1, (None, 1), &#39;b&#39;)],</span>
<span class="go">....:                        initial_states=[0],</span>
<span class="go">....:                        final_states=[1])</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">process</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">use_multitape_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(True, 1, [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><code class="xref py py-meth docutils literal"><span class="pre">Transducer.process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><code class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                        initial_states=[0])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No accepting output was found but according to the</span>
<span class="go">given options, an accepting output should be returned. Change</span>
<span class="go">only_accepted and/or list_of_outputs options.</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">(False, 0, [0])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">(False, 0, [0])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[(False, 0, [0])]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">No accepting output was found but according to the</span>
<span class="go">given options, an accepting output should be returned. Change</span>
<span class="go">only_accepted and/or list_of_outputs options.</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">(False, None, None)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">(False, None, None)</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">only_accepted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">list_of_outputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)],</span>
<span class="go">....:                        initial_states=[0],</span>
<span class="go">....:                        final_states=[1])</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
<span class="go">....:               initial_states=[0],</span>
<span class="go">....:               final_states=[1])</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">(True, 1, [&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">(True, 1)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">(True, 1, [&#39;a&#39;])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(False, 2, [&#39;b&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(False, 2)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(False, 2, [&#39;b&#39;])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">(False, None, None)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">(False, None)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="go">(False, None, None)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.product_FiniteStateMachine">
<code class="descname">product_FiniteStateMachine</code><span class="sig-paren">(</span><em>other</em>, <em>function</em>, <em>new_input_alphabet=None</em>, <em>only_accessible_components=True</em>, <em>final_function=None</em>, <em>new_class=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.product_FiniteStateMachine" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new finite state machine whose states are
<span class="math">\(d\)</span>-tuples of states of the original finite state machines.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">other</span></code> – a finite state machine (for <span class="math">\(d=2\)</span>) or a list
(or iterable) of <span class="math">\(d-1\)</span> finite state machines.</li>
<li><code class="docutils literal"><span class="pre">function</span></code> has to accept <span class="math">\(d\)</span> transitions from <span class="math">\(A_j\)</span> to <span class="math">\(B_j\)</span>
for <span class="math">\(j\in\{1, \ldots, d\}\)</span> and returns a pair <code class="docutils literal"><span class="pre">(word_in,</span> <span class="pre">word_out)</span></code>
which is the label of the transition <span class="math">\(A=(A_1, \ldots, A_d)\)</span> to <span class="math">\(B=(B_1,
\ldots, B_d)\)</span>. If there is no transition from <span class="math">\(A\)</span> to <span class="math">\(B\)</span>,
then <code class="docutils literal"><span class="pre">function</span></code> should raise a <code class="docutils literal"><span class="pre">LookupError</span></code>.</li>
<li><code class="docutils literal"><span class="pre">new_input_alphabet</span></code> (optional) – the new input alphabet
as a list.</li>
<li><code class="docutils literal"><span class="pre">only_accessible_components</span></code> – If <code class="docutils literal"><span class="pre">True</span></code> (default), then
the result is piped through <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components"><code class="xref py py-meth docutils literal"><span class="pre">accessible_components()</span></code></a>. If no
<code class="docutils literal"><span class="pre">new_input_alphabet</span></code> is given, it is determined by
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>.</li>
<li><code class="docutils literal"><span class="pre">final_function</span></code> – A function mapping <span class="math">\(d\)</span> final states of
the original finite state machines to the final output of
the corresponding state in the new finite state machine. By
default, the final output is the empty word if both final
outputs of the constituent states are empty; otherwise, a
<code class="docutils literal"><span class="pre">ValueError</span></code> is raised.</li>
<li><code class="docutils literal"><span class="pre">new_class</span></code> – Class of the new finite state machine. By
default (<code class="docutils literal"><span class="pre">None</span></code>), the class of <code class="docutils literal"><span class="pre">self</span></code> is used.</li>
</ul>
<p>OUTPUT:</p>
<p>A finite state machine whose states are <span class="math">\(d\)</span>-tuples of states of the
original finite state machines. A state is initial or
final if all constituent states are initial or final,
respectively.</p>
<p>The labels of the transitions are defined by <code class="docutils literal"><span class="pre">function</span></code>.</p>
<p>The final output of a final state is determined by calling
<code class="docutils literal"><span class="pre">final_function</span></code> on the constituent states.</p>
<p>The color of a new state is the tuple of colors of the
constituent states of <code class="docutils literal"><span class="pre">self</span></code> and <code class="docutils literal"><span class="pre">other</span></code>. However,
if all constituent states have color <code class="docutils literal"><span class="pre">None</span></code>, then
the state has color <code class="docutils literal"><span class="pre">None</span></code>, too.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span>
<span class="go">....:               initial_states=[&#39;A&#39;], final_states=[&#39;B&#39;],</span>
<span class="go">....:               determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">initial_states</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">final_states</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">addition</span><span class="p">(</span><span class="n">transition1</span><span class="p">,</span> <span class="n">transition2</span><span class="p">):</span>
<span class="go">....:     return (transition1.word_in[0] + transition2.word_in[0],</span>
<span class="go">....:             None)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">addition</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">only_accessible_components</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;A&#39;, 1) to (&#39;B&#39;, 1): 2|-,</span>
<span class="go"> Transition from (&#39;A&#39;, 1) to (&#39;A&#39;, 1): 1|-,</span>
<span class="go"> Transition from (&#39;B&#39;, 1) to (&#39;A&#39;, 1): 3|-]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">color</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">H</span><span class="o">.</span><span class="n">iter_states</span><span class="p">()]</span>
<span class="go">[None, None]</span>
<span class="gp">sage: </span><span class="n">H1</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">addition</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">only_accessible_components</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H1</span><span class="o">.</span><span class="n">states</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">F</span><span class="o">.</span><span class="n">states</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">H1</span><span class="o">.</span><span class="n">states</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">G</span><span class="o">.</span><span class="n">states</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0] )</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0] )</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span>
<span class="go">....:         G, lambda t1,t2: (t1.word_in[0]*t2.word_in[0], None))</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[(0, 0), (1, 0)]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0] )</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0] )</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="n">G</span><span class="p">,</span>
<span class="go">....:                                  lambda t1,t2: (t1.word_in[0]*t2.word_in[0], None),</span>
<span class="go">....:                                  only_accessible_components=False)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[(0, 0), (1, 0), (0, 1), (1, 1)]</span>
</pre></div>
</div>
<p>Also final output words are considered according to the function
<code class="docutils literal"><span class="pre">final_function</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">final_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">minus</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">):</span>
<span class="go">....:     return (t1.word_in[0] - t2.word_in[0],</span>
<span class="go">....:                t1.word_out[0] - t2.word_out[0])</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">minus</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">A final function must be given.</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">plus</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
<span class="go">....:     return s1.final_word_out[0] + s2.final_word_out[0]</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">minus</span><span class="p">,</span>
<span class="go">....:                                  final_function=plus)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">final_states</span><span class="p">()</span>
<span class="go">[(1, 0)]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">final_states</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[2]</span>
</pre></div>
</div>
<p>Products of more than two finite state machines are also possible:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">plus</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span><span class="p">):</span>
<span class="go">....:     if s1.word_in == s2.word_in == s3.word_in:</span>
<span class="go">....:          return (s1.word_in,</span>
<span class="go">....:                  sum(s.word_out[0] for s in (s1, s2, s3)))</span>
<span class="go">....:     else:</span>
<span class="go">....:         raise LookupError</span>
<span class="gp">sage: </span><span class="n">T0</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T1</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T2</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">T0</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">([</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">],</span> <span class="n">plus</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from ((), (), ()) to ((0,), (), ()): 0|0,</span>
<span class="go"> Transition from ((), (), ()) to ((), (1,), ()): 1|0,</span>
<span class="go"> Transition from ((), (), ()) to ((), (), (2,)): 2|0,</span>
<span class="go"> Transition from ((0,), (), ()) to ((0,), (), ()): 0|1,</span>
<span class="go"> Transition from ((0,), (), ()) to ((), (1,), ()): 1|0,</span>
<span class="go"> Transition from ((0,), (), ()) to ((), (), (2,)): 2|0,</span>
<span class="go"> Transition from ((), (1,), ()) to ((0,), (), ()): 0|0,</span>
<span class="go"> Transition from ((), (1,), ()) to ((), (1,), ()): 1|1,</span>
<span class="go"> Transition from ((), (1,), ()) to ((), (), (2,)): 2|0,</span>
<span class="go"> Transition from ((), (), (2,)) to ((0,), (), ()): 0|0,</span>
<span class="go"> Transition from ((), (), (2,)) to ((), (1,), ()): 1|0,</span>
<span class="go"> Transition from ((), (), (2,)) to ((), (), (2,)): 2|1]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">[0, 1, 0, 1, 0, 1, 0, 0, 0, 1]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">other</span></code> can also be an iterable:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">==</span> <span class="n">T0</span><span class="o">.</span><span class="n">product_FiniteStateMachine</span><span class="p">(</span><span class="nb">iter</span><span class="p">([</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">]),</span> <span class="n">plus</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.projection">
<code class="descname">projection</code><span class="sig-paren">(</span><em>what='input'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an Automaton which transition labels are the projection
of the transition labels of the input.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">what</span></code> – (default: <code class="docutils literal"><span class="pre">input</span></code>) either <code class="docutils literal"><span class="pre">input</span></code> or <code class="docutils literal"><span class="pre">output</span></code>.</li>
</ul>
<p>OUTPUT:</p>
<p>An automaton.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                         (&#39;B&#39;, &#39;B&#39;, 1, 0)])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">projection</span><span class="p">(</span><span class="n">what</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;A&#39; to &#39;B&#39;: 1|-,</span>
<span class="go"> Transition from &#39;A&#39; to &#39;A&#39;: 1|-,</span>
<span class="go"> Transition from &#39;B&#39; to &#39;B&#39;: 0|-]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.quotient">
<code class="descname">quotient</code><span class="sig-paren">(</span><em>classes</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.quotient" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the quotient with respect to the equivalence
classes.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">classes</span></code> is a list of equivalence classes of states.</li>
</ul>
<p>OUTPUT:</p>
<p>A finite state machine.</p>
<p>The labels of the new states are tuples of states of the
<code class="docutils literal"><span class="pre">self</span></code>, corresponding to <code class="docutils literal"><span class="pre">classes</span></code>.</p>
<p>Assume that <span class="math">\(c\)</span> is a class, and <span class="math">\(a\)</span> and <span class="math">\(b\)</span> are states in
<span class="math">\(c\)</span>. Then there is a bijection <span class="math">\(\varphi\)</span> between the
transitions from <span class="math">\(a\)</span> and the transitions from <span class="math">\(b\)</span> with the
following properties: if <span class="math">\(\varphi(t_a)=t_b\)</span>, then</p>
<ul class="simple">
<li><span class="math">\(t_a.\mathit{word}_\mathit{in}=t_b.\mathit{word}_\mathit{in}\)</span>,</li>
<li><span class="math">\(t_a.\mathit{word}_\mathit{out}=t_b.\mathit{word}_\mathit{out}\)</span>, and</li>
<li><span class="math">\(t_a\)</span> and <span class="math">\(t_b\)</span> lead to some equivalent states <span class="math">\(a'\)</span> and <span class="math">\(b'\)</span>.</li>
</ul>
<p>Non-initial states may be merged with initial states, the
resulting state is an initial state.</p>
<p>All states in a class must have the same <code class="docutils literal"><span class="pre">is_final</span></code>,
<code class="docutils literal"><span class="pre">final_word_out</span></code> and <code class="docutils literal"><span class="pre">word_out</span></code> values.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fsm</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (&quot;B&quot;, &quot;C&quot;, 0, 0), (&quot;B&quot;, &quot;C&quot;, 1, 1),</span>
<span class="go">....:                           (&quot;C&quot;, &quot;D&quot;, 0, 1), (&quot;C&quot;, &quot;D&quot;, 1, 0),</span>
<span class="go">....:                           (&quot;D&quot;, &quot;A&quot;, 0, 0), (&quot;D&quot;, &quot;A&quot;, 1, 1)])</span>
<span class="gp">sage: </span><span class="n">fsmq</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">quotient</span><span class="p">([[</span><span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">),</span> <span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">)],</span>
<span class="go">....:                      [fsm.state(&quot;B&quot;), fsm.state(&quot;D&quot;)]])</span>
<span class="gp">sage: </span><span class="n">fsmq</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;A&#39;, &#39;C&#39;)</span>
<span class="go">              to (&#39;B&#39;, &#39;D&#39;): 0|1,</span>
<span class="go"> Transition from (&#39;A&#39;, &#39;C&#39;)</span>
<span class="go">              to (&#39;B&#39;, &#39;D&#39;): 1|0,</span>
<span class="go"> Transition from (&#39;B&#39;, &#39;D&#39;)</span>
<span class="go">              to (&#39;A&#39;, &#39;C&#39;): 0|0,</span>
<span class="go"> Transition from (&#39;B&#39;, &#39;D&#39;)</span>
<span class="go">              to (&#39;A&#39;, &#39;C&#39;): 1|1]</span>
<span class="gp">sage: </span><span class="n">fsmq</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|1,</span>
<span class="go"> Transition from 0 to 1: 1|0,</span>
<span class="go"> Transition from 1 to 0: 0|0,</span>
<span class="go"> Transition from 1 to 0: 1|1]</span>
<span class="gp">sage: </span><span class="n">fsmq1</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">quotient</span><span class="p">(</span><span class="n">fsm</span><span class="o">.</span><span class="n">equivalence_classes</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">fsmq1</span> <span class="o">==</span> <span class="n">fsmq</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">fsm</span><span class="o">.</span><span class="n">quotient</span><span class="p">([[</span><span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">),</span> <span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">),</span> <span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">),</span> <span class="n">fsm</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s2">&quot;D&quot;</span><span class="p">)]])</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">AssertionError</span>: <span class="n">Transitions of state &#39;A&#39; and &#39;B&#39; are incompatible.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.relabeled">
<code class="descname">relabeled</code><span class="sig-paren">(</span><em>memo=None</em>, <em>labels=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.relabeled" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deep copy of the finite state machine, but the
states are relabeled.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">memo</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) a dictionary storing already
processed elements.</li>
<li><code class="docutils literal"><span class="pre">labels</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) a dictionary or callable
mapping old labels to new labels. If <code class="docutils literal"><span class="pre">None</span></code>, then the new
labels are integers starting with 0.</li>
</ul>
<p>OUTPUT:</p>
<p>A new finite state machine.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FSM1</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">FSM1</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span>
<span class="gp">sage: </span><span class="n">FSM2</span> <span class="o">=</span> <span class="n">FSM1</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FSM2</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">sage: </span><span class="n">FSM3</span> <span class="o">=</span> <span class="n">FSM1</span><span class="o">.</span><span class="n">relabeled</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="s1">&#39;c&#39;</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">FSM3</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">sage: </span><span class="n">FSM4</span> <span class="o">=</span> <span class="n">FSM2</span><span class="o">.</span><span class="n">relabeled</span><span class="p">(</span><span class="n">labels</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">FSM4</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[0, 2, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.remove_epsilon_transitions">
<code class="descname">remove_epsilon_transitions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.remove_epsilon_transitions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.set_coordinates">
<code class="descname">set_coordinates</code><span class="sig-paren">(</span><em>coordinates</em>, <em>default=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.set_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Set coordinates of the states for the LaTeX representation by
a dictionary or a function mapping labels to coordinates.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">coordinates</span></code> – a dictionary or a function mapping labels
of states to pairs interpreted as coordinates.</li>
<li><code class="docutils literal"><span class="pre">default</span></code> – If <code class="docutils literal"><span class="pre">True</span></code>, then states not given by
<code class="docutils literal"><span class="pre">coordinates</span></code> get a default position on a circle of
radius 3.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">set_coordinates</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coordinates</span>
<span class="go">(0, 0)</span>
</pre></div>
</div>
<p>We can also use a function to determine the coordinates:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">set_coordinates</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">3</span><span class="o">/</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">coordinates</span>
<span class="go">(2, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.split_transitions">
<code class="descname">split_transitions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.split_transitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new transducer, where all transitions in self with input
labels consisting of more than one letter
are replaced by a path of the corresponding length.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A new transducer.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                initial_states=[&#39;A&#39;], final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">split_transitions</span><span class="p">()</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[(&#39;A&#39;, ()), (&#39;B&#39;, ()),</span>
<span class="go"> (&#39;A&#39;, (1,)), (&#39;A&#39;, (1, 2))]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.state">
<code class="descname">state</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the state of the finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">state</span></code> – If <code class="docutils literal"><span class="pre">state</span></code> is not an instance of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><code class="xref py py-class docutils literal"><span class="pre">FSMState</span></code></a>, then it is assumed that it is the label
of a state.</li>
</ul>
<p>OUTPUT:</p>
<p>Returns the state of the finite state machine corresponding to
<code class="docutils literal"><span class="pre">state</span></code>.</p>
<p>If no state is found, then a <code class="docutils literal"><span class="pre">LookupError</span></code> is thrown.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMState</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">FSMState</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">A</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">A</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">LookupError</span>: <span class="n">No state with label xyz found.</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.states">
<code class="descname">states</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the states of the finite state machine.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>The states of the finite state machine as list.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">states</span><span class="p">()</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.transition">
<code class="descname">transition</code><span class="sig-paren">(</span><em>transition</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.transition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the transition of the finite state machine.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">transition</span></code> – If <code class="docutils literal"><span class="pre">transition</span></code> is not an instance of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><code class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></code></a>, then it is assumed that it is a
tuple <code class="docutils literal"><span class="pre">(from_state,</span> <span class="pre">to_state,</span> <span class="pre">word_in,</span> <span class="pre">word_out)</span></code>.</li>
</ul>
<p>OUTPUT:</p>
<p>Returns the transition of the finite state machine
corresponding to <code class="docutils literal"><span class="pre">transition</span></code>.</p>
<p>If no transition is found, then a <code class="docutils literal"><span class="pre">LookupError</span></code> is thrown.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">FSMTransition</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">FiniteStateMachine</span><span class="p">([</span><span class="n">t</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">transition</span><span class="p">((</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">Transition from &#39;A&#39; to &#39;B&#39;: 0|-</span>
<span class="gp">sage: </span><span class="nb">id</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">transition</span><span class="p">((</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.transitions">
<code class="descname">transitions</code><span class="sig-paren">(</span><em>from_state=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.transitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all transitions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">from_state</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) If <code class="docutils literal"><span class="pre">from_state</span></code> is
given, then a list of transitions starting there is given.</li>
</ul>
<p>OUTPUT:</p>
<p>A list of all transitions.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FSM</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">FSM</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from &#39;1&#39; to &#39;2&#39;: 1|-,</span>
<span class="go"> Transition from &#39;2&#39; to &#39;2&#39;: 0|-]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.transposition">
<code class="descname">transposition</code><span class="sig-paren">(</span><em>reverse_output_labels=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.transposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new finite state machine, where all transitions of the
input finite state machine are reversed.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">reverse_output_labels</span></code> – a boolean (default: <code class="docutils literal"><span class="pre">True</span></code>): whether to reverse
output labels.</li>
</ul>
<p>OUTPUT:</p>
<p>A new finite state machine.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">aut</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                 initial_states=[&#39;A&#39;], final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">aut</span><span class="o">.</span><span class="n">transposition</span><span class="p">()</span><span class="o">.</span><span class="n">transitions</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="go">[Transition from &#39;B&#39; to &#39;A&#39;: 0|-]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">aut</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                 initial_states=[&#39;1&#39;], final_states=[&#39;1&#39;, &#39;2&#39;])</span>
<span class="gp">sage: </span><span class="n">aut</span><span class="o">.</span><span class="n">transposition</span><span class="p">()</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])],</span>
<span class="go">....:     initial_states=[0],</span>
<span class="go">....:     final_states=[1])</span>
<span class="gp">sage: </span><span class="n">A</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">transposition</span><span class="p">()([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])],</span>
<span class="go">....:     initial_states=[0],</span>
<span class="go">....:     final_states=[1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[1, 0]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">transposition</span><span class="p">()([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[0, 1]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">transposition</span><span class="p">(</span><span class="n">reverse_output_labels</span><span class="o">=</span><span class="bp">False</span><span class="p">)([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[1, 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out">
<code class="descname">with_final_word_out</code><span class="sig-paren">(</span><em>letters</em>, <em>allow_non_final=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.FiniteStateMachine.with_final_word_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a new finite state machine with final output words
for all states by implicitly reading trailing letters until a
final state is reached.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">letters</span></code> – either an element of the input alphabet or a
list of such elements. This is repeated cyclically when
needed.</li>
<li><code class="docutils literal"><span class="pre">allow_non_final</span></code> – a boolean (default: <code class="docutils literal"><span class="pre">True</span></code>) which
indicates whether we allow that some states may be non-final
in the resulting finite state machine. I.e., if <code class="docutils literal"><span class="pre">False</span></code> then
each state has to have a path to a final state with input
label matching <code class="docutils literal"><span class="pre">letters</span></code>.</li>
</ul>
<p>OUTPUT:</p>
<p>A finite state machine.</p>
<p>The inplace version of this function is
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out" title="sage.combinat.finite_state_machine.FiniteStateMachine.construct_final_word_out"><code class="xref py py-meth docutils literal"><span class="pre">construct_final_word_out()</span></code></a>.</p>
<p>Suppose for the moment a single element <code class="docutils literal"><span class="pre">letter</span></code> as input
for <code class="docutils literal"><span class="pre">letters</span></code>. This is equivalent to <code class="docutils literal"><span class="pre">letters</span> <span class="pre">=</span> <span class="pre">[letter]</span></code>.
We will discuss the general case below.</p>
<p>Let <code class="docutils literal"><span class="pre">word_in</span></code> be a word over the input alphabet and assume
that the original finite state machine transforms <code class="docutils literal"><span class="pre">word_in</span></code> to
<code class="docutils literal"><span class="pre">word_out</span></code> reaching a possibly non-final state <code class="docutils literal"><span class="pre">s</span></code>. Let
further <span class="math">\(k\)</span> be the minimum number of letters <code class="docutils literal"><span class="pre">letter</span></code> such
that there is a path from <code class="docutils literal"><span class="pre">s</span></code> to some final state <code class="docutils literal"><span class="pre">f</span></code> whose
input label consists of <span class="math">\(k\)</span> copies of <code class="docutils literal"><span class="pre">letter</span></code> and whose
output label is <code class="docutils literal"><span class="pre">path_word_out</span></code>. Then the state <code class="docutils literal"><span class="pre">s</span></code> of the
resulting finite state machine is a final state with final
output <code class="docutils literal"><span class="pre">path_word_out</span> <span class="pre">+</span> <span class="pre">f.final_word_out</span></code>. Therefore, the new
finite state machine transforms <code class="docutils literal"><span class="pre">word_in</span></code> to <code class="docutils literal"><span class="pre">word_out</span> <span class="pre">+</span>
<span class="pre">path_word_out</span> <span class="pre">+</span> <span class="pre">f.final_word_out</span></code>.</p>
<p>This is e.g. useful for finite state machines operating on digit
expansions: there, it is sometimes required to read a sufficient
number of trailing zeros (at the most significant positions) in
order to reach a final state and to flush all carries. In this
case, this method constructs an essentially equivalent finite
state machine in the sense that it not longer requires adding
sufficiently many trailing zeros. However, it is the
responsibility of the user to make sure that if adding trailing
zeros to the input anyway, the output is equivalent.</p>
<p>If <code class="docutils literal"><span class="pre">letters</span></code> consists of more than one letter, then it is
assumed that (not necessarily complete) cycles of <code class="docutils literal"><span class="pre">letters</span></code>
are appended as trailing input.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#finite-state-machine-gray-code-example"><span class="std std-ref">example on Gray code</span></a></p>
</div>
<p>EXAMPLES:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">A simple transducer transforming <span class="math">\(00\)</span> blocks to <span class="math">\(01\)</span>
blocks:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">(False, 1, [0, 1, 0])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">(True, 0, [0, 1, 0, 1])</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">iter_final_states</span><span class="p">():</span>
<span class="go">....:     print(&quot;{} {}&quot;.format(f, f.final_word_out))</span>
<span class="go">0 []</span>
<span class="go">1 [1]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">(True, 1, [0, 1, 0, 1])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">(True, 0, [0, 1, 0, 1])</span>
</pre></div>
</div>
</li>
<li><p class="first">A more realistic example: Addition of <span class="math">\(1\)</span> in binary. We
construct a transition function transforming the input
to its binary expansion:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">binary_transition</span><span class="p">(</span><span class="n">carry</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
<span class="go">....:     value = carry + input</span>
<span class="go">....:     if value.mod(2) == 0:</span>
<span class="go">....:         return (value/2, 0)</span>
<span class="go">....:     else:</span>
<span class="go">....:         return ((value-1)/2, 1)</span>
</pre></div>
</div>
<p>Now, we only have to start with a carry of <span class="math">\(1\)</span> to
get the required transducer:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span><span class="n">binary_transition</span><span class="p">,</span>
<span class="go">....:                input_alphabet=[0, 1],</span>
<span class="go">....:                initial_states=[1],</span>
<span class="go">....:                final_states=[0])</span>
</pre></div>
</div>
<p>We test this for the binary expansion of <span class="math">\(7\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(False, 1, [0, 0, 0])</span>
</pre></div>
</div>
<p>The final carry <span class="math">\(1\)</span> has not be flushed yet, we have to add a
trailing zero:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">(True, 0, [0, 0, 0, 1])</span>
</pre></div>
</div>
<p>We check that with this trailing zero, the transducer
performs as advertised:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">ZZ</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">bits</span><span class="p">()</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">....:     for k in srange(16))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>However, most of the time, we produce superfluous trailing
zeros:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span><span class="p">(</span><span class="mf">11.</span><span class="n">bits</span><span class="p">()</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[0, 0, 1, 1, 0]</span>
</pre></div>
</div>
<p>We now use this method:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">iter_final_states</span><span class="p">():</span>
<span class="go">....:     print(&quot;{} {}&quot;.format(f, f.final_word_out))</span>
<span class="go">1 [1]</span>
<span class="go">0 []</span>
</pre></div>
</div>
<p>The same tests as above, but we do not have to pad with
trailing zeros anymore:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(True, 1, [0, 0, 0, 1])</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">ZZ</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">bits</span><span class="p">()),</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">....:     for k in srange(16))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>No more trailing zero in the output:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span><span class="p">(</span><span class="mf">11.</span><span class="n">bits</span><span class="p">())</span>
<span class="go">[0, 0, 1, 1]</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">bits</span><span class="p">())[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
<span class="go">....:     for k in srange(16))</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p class="first">Here is an example, where we allow trailing repeated <span class="math">\(10\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span>
<span class="go">....:                 (1, 2, 1, &#39;b&#39;),</span>
<span class="go">....:                 (2, 0, 0, &#39;c&#39;)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0])</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">iter_final_states</span><span class="p">():</span>
<span class="go">....:     print(str(f) + &#39; &#39; + &#39;&#39;.join(f.final_word_out))</span>
<span class="go">0</span>
<span class="go">1 bc</span>
</pre></div>
</div>
<p>Trying this with trailing repeated <span class="math">\(01\)</span> does not produce
a <code class="docutils literal"><span class="pre">final_word_out</span></code> for state <code class="docutils literal"><span class="pre">1</span></code>, but for state <code class="docutils literal"><span class="pre">2</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">with_final_word_out</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">F</span><span class="o">.</span><span class="n">iter_final_states</span><span class="p">():</span>
<span class="go">....:     print(str(f) + &#39; &#39; + &#39;&#39;.join(f.final_word_out))</span>
<span class="go">0</span>
<span class="go">2 c</span>
</pre></div>
</div>
</li>
<li><p class="first">Here another example with a more-letter trailing input:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span>
<span class="go">....:                 (1, 2, 0, &#39;b&#39;), (1, 2, 1, &#39;b&#39;),</span>
<span class="go">....:                 (2, 3, 0, &#39;c&#39;), (2, 0, 1, &#39;e&#39;),</span>
<span class="go">....:                 (3, 1, 0, &#39;d&#39;), (3, 1, 1, &#39;d&#39;)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[0],</span>
<span class="go">....:                with_final_word_out=[0, 0, 1, 1])</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">iter_final_states</span><span class="p">():</span>
<span class="go">....:     print(str(f) + &#39; &#39; + &#39;&#39;.join(f.final_word_out))</span>
<span class="go">0</span>
<span class="go">1 bcdbcdbe</span>
<span class="go">2 cdbe</span>
<span class="go">3 dbe</span>
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.combinat.finite_state_machine.Transducer">
<em class="property">class </em><code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">Transducer</code><span class="sig-paren">(</span><em>data=None</em>, <em>initial_states=None</em>, <em>final_states=None</em>, <em>input_alphabet=None</em>, <em>output_alphabet=None</em>, <em>determine_alphabets=None</em>, <em>with_final_word_out=None</em>, <em>store_states_dict=True</em>, <em>on_duplicate_transition=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.Transducer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">sage.combinat.finite_state_machine.FiniteStateMachine</span></code></a></p>
<p>This creates a transducer, which is a finite state machine, whose
transitions have input and output labels.</p>
<p>An transducer has additional features like creating a simplified
transducer.</p>
<p>See class <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a> for more information.</p>
<p>EXAMPLES:</p>
<p>We can create a transducer performing the addition of 1 (for
numbers given in binary and read from right to left) in the
following way:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                 (&#39;N&#39;, &#39;N&#39;, 0, 0), (&#39;N&#39;, &#39;N&#39;, 1, 1)],</span>
<span class="go">....:                initial_states=[&#39;C&#39;], final_states=[&#39;N&#39;])</span>
<span class="gp">sage: </span><span class="n">T</span>
<span class="go">Transducer with 2 states</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[0, 0, 1]</span>
<span class="gp">sage: </span><span class="n">ZZ</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="mf">15.</span><span class="n">digits</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">16</span>
</pre></div>
</div>
<p>Note that we have padded the binary input sequence by a <span class="math">\(0\)</span> so
that the transducer can reach its final state.</p>
<dl class="method">
<dt id="sage.combinat.finite_state_machine.Transducer.cartesian_product">
<code class="descname">cartesian_product</code><span class="sig-paren">(</span><em>other</em>, <em>only_accessible_components=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.Transducer.cartesian_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new transducer which can simultaneously process an
input with the machines <code class="docutils literal"><span class="pre">self</span></code> and <code class="docutils literal"><span class="pre">other</span></code> where the
output labels are <span class="math">\(d\)</span>-tuples of the original output labels.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">other</span></code> - a finite state machine (if <span class="math">\(d=2\)</span>) or a list (or
other iterable) of <span class="math">\(d-1\)</span> finite state machines</li>
<li><code class="docutils literal"><span class="pre">only_accessible_components</span></code> – If <code class="docutils literal"><span class="pre">True</span></code> (default), then
the result is piped through <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components"><code class="xref py py-meth docutils literal"><span class="pre">accessible_components()</span></code></a>. If no
<code class="docutils literal"><span class="pre">new_input_alphabet</span></code> is given, it is determined by
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>A transducer which can simultaneously process an input with <code class="docutils literal"><span class="pre">self</span></code>
and the machine(s) in <code class="docutils literal"><span class="pre">other</span></code>.</p>
<p>The set of states of the new transducer is the Cartesian product of
the set of states of <code class="docutils literal"><span class="pre">self</span></code> and <code class="docutils literal"><span class="pre">other</span></code>.</p>
<p>Let <span class="math">\((A_j, B_j, a_j, b_j)\)</span> for <span class="math">\(j\in\{1, \ldots, d\}\)</span> be
transitions in the machines <code class="docutils literal"><span class="pre">self</span></code> and in <code class="docutils literal"><span class="pre">other</span></code>. Then
there is a transition <span class="math">\(((A_1, \ldots, A_d), (B_1, \ldots,
B_d), a, (b_1, \ldots, b_d))\)</span> in the new transducer if <span class="math">\(a_1 =
\cdots = a_d =: a\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">transducer1</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (&#39;A&#39;, &#39;A&#39;, 1, 1)],</span>
<span class="go">....:                          initial_states=[&#39;A&#39;],</span>
<span class="go">....:                          final_states=[&#39;A&#39;],</span>
<span class="go">....:                          determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">transducer2</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]),</span>
<span class="go">....:                           (0, 0, 1, &#39;b&#39;),</span>
<span class="go">....:                           (1, 1, 0, &#39;a&#39;)],</span>
<span class="go">....:                          initial_states=[0],</span>
<span class="go">....:                          final_states=[1],</span>
<span class="go">....:                          determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">transducer1</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">transducer2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span>
<span class="go">Transducer with 2 states</span>
<span class="gp">sage: </span><span class="n">result</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;A&#39;, 0) to (&#39;A&#39;, 1): 0|(0, &#39;b&#39;),(None, &#39;c&#39;),</span>
<span class="go"> Transition from (&#39;A&#39;, 0) to (&#39;A&#39;, 0): 1|(1, &#39;b&#39;),</span>
<span class="go"> Transition from (&#39;A&#39;, 1) to (&#39;A&#39;, 1): 0|(0, &#39;a&#39;)]</span>
<span class="gp">sage: </span><span class="n">result</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[(1, &#39;b&#39;), (0, &#39;b&#39;), (None, &#39;c&#39;),  (0, &#39;a&#39;)]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">transducer1</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">transducer2</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="go">([1, 0, 0], [&#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;])</span>
</pre></div>
</div>
<p>Also final output words are correctly processed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">transducer1</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">final_word_out</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">sage: </span><span class="n">result</span> <span class="o">=</span> <span class="n">transducer1</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">transducer2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">result</span><span class="o">.</span><span class="n">final_states</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">final_word_out</span>
<span class="go">[(2, None)]</span>
</pre></div>
</div>
<p>The following transducer counts the number of 11 blocks minus
the number of 10 blocks over the alphabet <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">1]</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">count_11</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">(</span>
<span class="go">....:     [1, 1],</span>
<span class="go">....:     input_alphabet=[0, 1])</span>
<span class="gp">sage: </span><span class="n">count_10</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">(</span>
<span class="go">....:     [1, 0],</span>
<span class="go">....:     input_alphabet=[0, 1])</span>
<span class="gp">sage: </span><span class="n">count_11x10</span> <span class="o">=</span> <span class="n">count_11</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">count_10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">difference</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])(</span><span class="n">count_11x10</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">initial_states</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from 0 to 1: 0|-1,</span>
<span class="go"> Transition from 0 to 0: 1|1,</span>
<span class="go"> Transition from 1 to 1: 0|0,</span>
<span class="go"> Transition from 1 to 0: 1|0]</span>
<span class="gp">sage: </span><span class="nb">input</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="o">==</span> <span class="n">output</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">other</span></code> is an automaton, then <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.cartesian_product" title="sage.combinat.finite_state_machine.Transducer.cartesian_product"><code class="xref py py-meth docutils literal"><span class="pre">cartesian_product()</span></code></a> returns
<code class="docutils literal"><span class="pre">self</span></code> where the input is restricted to the input accepted by
<code class="docutils literal"><span class="pre">other</span></code>.</p>
<p>For example, if the transducer transforms the standard
binary expansion into the non-adjacent form and the automaton
recognizes the binary expansion without adjacent ones, then the
Cartesian product of these two is a transducer which does not change
the input (except for changing <code class="docutils literal"><span class="pre">a</span></code> to <code class="docutils literal"><span class="pre">(a,</span> <span class="pre">None)</span></code> and ignoring a
leading <span class="math">\(0\)</span>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NAF</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
<span class="go">....:                   (0, 2, 1, None),</span>
<span class="go">....:                   (1, 1, 0, 0),</span>
<span class="go">....:                   (1, 2, 1, 0),</span>
<span class="go">....:                   (2, 1, 0, 1),</span>
<span class="go">....:                   (2, 3, 1, -1),</span>
<span class="go">....:                   (3, 2, 0, 0),</span>
<span class="go">....:                   (3, 3, 1, 0)],</span>
<span class="go">....:                  initial_states=[0],</span>
<span class="go">....:                  final_states=[1],</span>
<span class="go">....:                  determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">aut11</span> <span class="o">=</span> <span class="n">Automaton</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
<span class="go">....:                   initial_states=[0],</span>
<span class="go">....:                   final_states=[0, 1],</span>
<span class="go">....:                   determine_alphabets=True)</span>
<span class="gp">sage: </span><span class="n">res</span> <span class="o">=</span> <span class="n">NAF</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">aut11</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">res</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">[(1, None), (0, None), (0, None), (1, None), (0, None), (1, None)]</span>
</pre></div>
</div>
<p>This is obvious because if the standard binary expansion does not have
adjacent ones, then it is the same as the non-adjacent form.</p>
<p>Be aware that <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.cartesian_product" title="sage.combinat.finite_state_machine.Transducer.cartesian_product"><code class="xref py py-meth docutils literal"><span class="pre">cartesian_product()</span></code></a> is not commutative.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">aut11</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">(</span><span class="n">NAF</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Only an automaton can be intersected with an automaton.</span>
</pre></div>
</div>
<p>The Cartesian product of more than two finite state machines can also
be computed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T0</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T1</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T2</span> <span class="o">=</span> <span class="n">transducers</span><span class="o">.</span><span class="n">CountSubblockOccurrences</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">T0</span><span class="o">.</span><span class="n">cartesian_product</span><span class="p">([</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from ((), (), ()) to ((0,), (), ()): 0|(0, 0, 0),</span>
<span class="go"> Transition from ((), (), ()) to ((), (1,), ()): 1|(0, 0, 0),</span>
<span class="go"> Transition from ((), (), ()) to ((), (), (2,)): 2|(0, 0, 0),</span>
<span class="go"> Transition from ((0,), (), ()) to ((0,), (), ()): 0|(1, 0, 0),</span>
<span class="go"> Transition from ((0,), (), ()) to ((), (1,), ()): 1|(0, 0, 0),</span>
<span class="go"> Transition from ((0,), (), ()) to ((), (), (2,)): 2|(0, 0, 0),</span>
<span class="go"> Transition from ((), (1,), ()) to ((0,), (), ()): 0|(0, 0, 0),</span>
<span class="go"> Transition from ((), (1,), ()) to ((), (1,), ()): 1|(0, 1, 0),</span>
<span class="go"> Transition from ((), (1,), ()) to ((), (), (2,)): 2|(0, 0, 0),</span>
<span class="go"> Transition from ((), (), (2,)) to ((0,), (), ()): 0|(0, 0, 0),</span>
<span class="go"> Transition from ((), (), (2,)) to ((), (1,), ()): 1|(0, 0, 0),</span>
<span class="go"> Transition from ((), (), (2,)) to ((), (), (2,)): 2|(0, 0, 1)]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">[(0, 0, 0),</span>
<span class="go"> (1, 0, 0),</span>
<span class="go"> (0, 0, 0),</span>
<span class="go"> (0, 1, 0),</span>
<span class="go"> (0, 0, 0),</span>
<span class="go"> (0, 0, 1),</span>
<span class="go"> (0, 0, 0),</span>
<span class="go"> (0, 0, 0),</span>
<span class="go"> (0, 0, 0),</span>
<span class="go"> (0, 0, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Transducer.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><em>other</em>, <em>only_accessible_components=True</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.Transducer.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new transducer which accepts an input if it is accepted by
both given finite state machines producing the same output.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">other</span></code> – a transducer</li>
<li><code class="docutils literal"><span class="pre">only_accessible_components</span></code> – If <code class="docutils literal"><span class="pre">True</span></code> (default), then
the result is piped through <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components" title="sage.combinat.finite_state_machine.FiniteStateMachine.accessible_components"><code class="xref py py-meth docutils literal"><span class="pre">accessible_components()</span></code></a>. If no
<code class="docutils literal"><span class="pre">new_input_alphabet</span></code> is given, it is determined by
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets" title="sage.combinat.finite_state_machine.FiniteStateMachine.determine_alphabets"><code class="xref py py-meth docutils literal"><span class="pre">determine_alphabets()</span></code></a>.</li>
</ul>
<p>OUTPUT:</p>
<p>A new transducer which computes the intersection
(see below) of the languages of <code class="docutils literal"><span class="pre">self</span></code> and <code class="docutils literal"><span class="pre">other</span></code>.</p>
<p>The set of states of the transducer is the Cartesian product of the
set of states of both given transducer. There is a transition <span class="math">\(((A,
B), (C, D), a, b)\)</span> in the new transducer if there are
transitions <span class="math">\((A, C, a, b)\)</span> and <span class="math">\((B, D, a, b)\)</span> in the old transducers.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">transducer1</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (&#39;2&#39;, &#39;2&#39;, 1, 0),</span>
<span class="go">....:                           (&#39;2&#39;, &#39;2&#39;, 0, 1)],</span>
<span class="go">....:                          initial_states=[&#39;1&#39;],</span>
<span class="go">....:                          final_states=[&#39;2&#39;])</span>
<span class="gp">sage: </span><span class="n">transducer2</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (&#39;A&#39;, &#39;B&#39;, 0, 0),</span>
<span class="go">....:                           (&#39;B&#39;, &#39;B&#39;, 0, 1),</span>
<span class="go">....:                           (&#39;B&#39;, &#39;A&#39;, 1, 1)],</span>
<span class="go">....:                          initial_states=[&#39;A&#39;],</span>
<span class="go">....:                          final_states=[&#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">res</span> <span class="o">=</span> <span class="n">transducer1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">transducer2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">res</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;1&#39;, &#39;A&#39;) to (&#39;2&#39;, &#39;A&#39;): 1|0,</span>
<span class="go"> Transition from (&#39;2&#39;, &#39;A&#39;) to (&#39;2&#39;, &#39;A&#39;): 1|0]</span>
</pre></div>
</div>
<p>In general, transducers are not closed under intersection. But
for transducer which do not have epsilon-transitions, the
intersection is well defined (cf. <a class="reference internal" href="#bawo2012" id="id22">[BaWo2012]</a>). However, in
the next example the intersection of the two transducers is
not well defined. The intersection of the languages consists
of <span class="math">\((a^n, b^n c^n)\)</span>. This set is not recognizable by a
<em>finite</em> transducer.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                  (0, 1, None, &#39;c&#39;),</span>
<span class="go">....:                  (1, 1, None, &#39;c&#39;)],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[0, 1])</span>
<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span>
<span class="go">....:                  (&#39;A&#39;, &#39;B&#39;, &#39;a&#39;, &#39;c&#39;),</span>
<span class="go">....:                  (&#39;B&#39;, &#39;B&#39;, &#39;a&#39;, &#39;c&#39;)],</span>
<span class="go">....:                 initial_states=[&#39;A&#39;],</span>
<span class="go">....:                 final_states=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="gp">sage: </span><span class="n">t2</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">An epsilon-transition (with empty input or output)</span>
<span class="go">was found.</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<table class="docutils citation" frame="void" id="bawo2012" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id22">[BaWo2012]</a></td><td>Javier Baliosian and Dina Wonsever, <em>Finite State
Transducers</em>, chapter in <em>Handbook of Finite State Based Models and
Applications</em>, edited by Jiacun Wang, Chapman and Hall/CRC, 2012.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Transducer.process">
<code class="descname">process</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.Transducer.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the transducer accepts the input, the state
where the computation stops and which output is generated.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">input_tape</span></code> – the input tape can be a list or an
iterable with entries from the input alphabet. If we are
working with a multi-tape machine (see parameter
<code class="docutils literal"><span class="pre">use_multitape_input</span></code> and notes below), then the tape is a
list or tuple of tracks, each of which can be a list or an
iterable with entries from the input alphabet.</li>
<li><code class="docutils literal"><span class="pre">initial_state</span></code> or <code class="docutils literal"><span class="pre">initial_states</span></code> – the initial
state(s) in which the machine starts. Either specify a
single one with <code class="docutils literal"><span class="pre">initial_state</span></code> or a list of them with
<code class="docutils literal"><span class="pre">initial_states</span></code>. If both are given, <code class="docutils literal"><span class="pre">initial_state</span></code>
will be appended to <code class="docutils literal"><span class="pre">initial_states</span></code>. If neither is
specified, the initial states of the finite state machine
are taken.</li>
<li><code class="docutils literal"><span class="pre">list_of_outputs</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) a boolean or
<code class="docutils literal"><span class="pre">None</span></code>. If <code class="docutils literal"><span class="pre">True</span></code>, then the outputs are given in list form
(even if we have no or only one single output). If
<code class="docutils literal"><span class="pre">False</span></code>, then the result is never a list (an exception is
raised if the result cannot be returned). If
<code class="docutils literal"><span class="pre">list_of_outputs=None</span></code> the method determines automatically
what to do (e.g. if a non-deterministic machine returns more
than one path, then the output is returned in list form).</li>
<li><code class="docutils literal"><span class="pre">only_accepted</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>) a boolean. If set,
then the first argument in the output is guaranteed to be
<code class="docutils literal"><span class="pre">True</span></code> (if the output is a list, then the first argument
of each element will be <code class="docutils literal"><span class="pre">True</span></code>).</li>
<li><code class="docutils literal"><span class="pre">full_output</span></code> – (default: <code class="docutils literal"><span class="pre">True</span></code>) a boolean. If set,
then the full output is given, otherwise only the generated
output (the third entry below only). If the input is not
accepted, a <code class="docutils literal"><span class="pre">ValueError</span></code> is raised.</li>
<li><code class="docutils literal"><span class="pre">always_include_output</span></code> – if set (not by default), always
include the output. This is inconsequential for a
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer" title="sage.combinat.finite_state_machine.Transducer"><code class="xref py py-class docutils literal"><span class="pre">Transducer</span></code></a>, but can be used in other classes
derived from <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a> where the output is
suppressed by default, cf. <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></code></a>.</li>
<li><code class="docutils literal"><span class="pre">format_output</span></code> – a function that translates the written
output (which is in form of a list) to something more
readable. By default (<code class="docutils literal"><span class="pre">None</span></code>) identity is used here.</li>
<li><code class="docutils literal"><span class="pre">check_epsilon_transitions</span></code> – (default: <code class="docutils literal"><span class="pre">True</span></code>) a
boolean. If <code class="docutils literal"><span class="pre">False</span></code>, then epsilon transitions are not
taken into consideration during process.</li>
<li><code class="docutils literal"><span class="pre">write_final_word_out</span></code> – (default: <code class="docutils literal"><span class="pre">True</span></code>) a boolean
specifying whether the final output words should be written
or not.</li>
<li><code class="docutils literal"><span class="pre">use_multitape_input</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>) a
boolean. If <code class="docutils literal"><span class="pre">True</span></code>, then the multi-tape mode of the
process iterator is activated. See also the notes below for
multi-tape machines.</li>
<li><code class="docutils literal"><span class="pre">process_all_prefixes_of_input</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>) a
boolean. If <code class="docutils literal"><span class="pre">True</span></code>, then each prefix of the input word is
processed (instead of processing the whole input word at
once). Consequently, there is an output generated for each
of these prefixes.</li>
<li><code class="docutils literal"><span class="pre">process_iterator_class</span></code> – (default: <code class="docutils literal"><span class="pre">None</span></code>) a class
inherited from <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a>. If <code class="docutils literal"><span class="pre">None</span></code>,
then <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a> is taken. An instance of this
class is created and is used during the processing.</li>
<li><code class="docutils literal"><span class="pre">automatic_output_type</span></code> – (default: <code class="docutils literal"><span class="pre">False</span></code>) a boolean
If set and the input has a parent, then the
output will have the same parent. If the input does not have
a parent, then the output will be of the same type as the
input.</li>
</ul>
<p>OUTPUT:</p>
<p>The full output is a triple (or a list of triples,
cf. parameter <code class="docutils literal"><span class="pre">list_of_outputs</span></code>), where</p>
<ul class="simple">
<li>the first entry is <code class="docutils literal"><span class="pre">True</span></code> if the input string is accepted,</li>
<li>the second gives the reached state after processing the
input tape (This is a state with label <code class="docutils literal"><span class="pre">None</span></code> if the input
could not be processed, i.e., if at one point no
transition to go on could be found.), and</li>
<li>the third gives a list of the output labels written during
processing.</li>
</ul>
<p>If <code class="docutils literal"><span class="pre">full_output</span></code> is <code class="docutils literal"><span class="pre">False</span></code>, then only the third entry
is returned.</p>
<p>Note that in the case the transducer is not
deterministic, all possible paths are taken into account.</p>
<p>This function uses an iterator which, in its simplest form, goes
from one state to another in each step. To decide which way to
go, it uses the input words of the outgoing transitions and
compares them to the input tape. More precisely, in each step,
the iterator takes an outgoing transition of the current state,
whose input label equals the input letter of the tape. The
output label of the transition, if present, is written on the
output tape.</p>
<p>If the choice of the outgoing transition is not unique (i.e.,
we have a non-deterministic finite state machine), all
possibilites are followed. This is done by splitting the
process into several branches, one for each of the possible
outgoing transitions.</p>
<p>The process (iteration) stops if all branches are finished,
i.e., for no branch, there is any transition whose input word
coincides with the processed input tape. This can simply
happen when the entire tape was read.</p>
<p>Also see <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> for a version of
<a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer.process" title="sage.combinat.finite_state_machine.Transducer.process"><code class="xref py py-meth docutils literal"><span class="pre">process()</span></code></a> with shortened output.</p>
<p>Internally this function creates and works with an instance of
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a>. This iterator can also be obtained
with <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><code class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></code></a>.</p>
<p>If working with multi-tape finite state machines, all input
words of transitions are words of <span class="math">\(k\)</span>-tuples of letters.
Moreover, the input tape has to consist of <span class="math">\(k\)</span> tracks, i.e.,
be a list or tuple of <span class="math">\(k\)</span> iterators, one for each track.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Working with multi-tape finite state machines is still
experimental and can lead to wrong outputs.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">binary_inverter</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]},</span>
<span class="go">....:                              initial_states=[&#39;A&#39;], final_states=[&#39;A&#39;])</span>
<span class="gp">sage: </span><span class="n">binary_inverter</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(True, &#39;A&#39;, [1, 0, 1, 1, 0, 0])</span>
</pre></div>
</div>
<p>If we are only interested in the output, we can also use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">binary_inverter</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">[1, 0, 1, 1, 0, 0]</span>
</pre></div>
</div>
<p>This can also be used with words as input:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">Words</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span> <span class="n">W</span>
<span class="go">Finite and infinite words over {0, 1}</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">W</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]);</span> <span class="n">w</span>
<span class="go">word: 010011</span>
<span class="gp">sage: </span><span class="n">binary_inverter</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="go">word: 101100</span>
</pre></div>
</div>
<p>In this case it is automatically determined that the output is
a word. The call above is equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">binary_inverter</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">w</span><span class="p">,</span>
<span class="go">....:                         full_output=False,</span>
<span class="go">....:                         list_of_outputs=False,</span>
<span class="go">....:                         automatic_output_type=True)</span>
<span class="go">word: 101100</span>
</pre></div>
</div>
<p>The following transducer transforms <span class="math">\(0^n 1\)</span> to <span class="math">\(1^n 2\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_final</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>We can see the different possibilites of the output by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="go">....:                         [0], [0, 0], [2, 0], [0, 1, 2]]]</span>
<span class="go">[(True, 1, [2]), (True, 1, [1, 2]),</span>
<span class="go"> (True, 1, [1, 1, 2]), (False, None, None),</span>
<span class="go"> (False, 0, [1]), (False, 0, [1, 1]),</span>
<span class="go"> (False, None, None), (False, None, None)]</span>
</pre></div>
</div>
<p>If we just want a condensed output, we use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">....:      for w in [[1], [0, 1], [0, 0, 1]]]</span>
<span class="go">[[2], [1, 2], [1, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">full_output</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">full_output</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
</pre></div>
</div>
<p>It is equivalent to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">T</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]]</span>
<span class="go">[[2], [1, 2], [1, 1, 2]]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
<span class="gp">sage: </span><span class="n">T</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Invalid input sequence.</span>
</pre></div>
</div>
<p>A cycle with empty input and empty output is correctly processed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0], final_states=[1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([])</span>
<span class="go">[(False, 0, []), (True, 1, [])]</span>
<span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[(False, 0, [&#39;r&#39;]), (True, 1, [&#39;r&#39;])]</span>
</pre></div>
</div>
<p>If there is a cycle with empty input but non-empty output, the
possible outputs would be an infinite set:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)],</span>
<span class="go">....:                initial_states=[0], final_states=[1])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RuntimeError</span>: <span class="n">State 0 is in an epsilon cycle (no input),</span>
<span class="go">but output is written.</span>
</pre></div>
</div>
<p>But if this cycle with empty input and non-empty output is not
reached, the correct output is produced:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_initial</span> <span class="o">=</span> <span class="bp">False</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([])</span>
<span class="go">(False, -1, [])</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">RuntimeError</span>: <span class="n">State 0 is in an epsilon cycle (no input),</span>
<span class="go">but output is written.</span>
</pre></div>
</div>
<p>If we set <code class="docutils literal"><span class="pre">check_epsilon_transitions=False</span></code>, then no
transitions with empty input are considered
anymore. Thus cycles with empty input are no problem anymore:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">process</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">check_epsilon_transitions</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">(False, 0, [&#39;r&#39;])</span>
</pre></div>
</div>
<p>A simple example of a multi-tape transducer is the
following: It writes the length of the first tape many letters <code class="docutils literal"><span class="pre">a</span></code>
and then the length of the second tape many letters <code class="docutils literal"><span class="pre">b</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span>
<span class="go">....:                 (0, 1, [], []),</span>
<span class="go">....:                 (1, 1, (None, 1), &#39;b&#39;)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[1])</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">process</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">use_multitape_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(True, 1, [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.process" title="sage.combinat.finite_state_machine.FiniteStateMachine.process"><code class="xref py py-meth docutils literal"><span class="pre">FiniteStateMachine.process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton.process" title="sage.combinat.finite_state_machine.Automaton.process"><code class="xref py py-meth docutils literal"><span class="pre">Automaton.process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.iter_process" title="sage.combinat.finite_state_machine.FiniteStateMachine.iter_process"><code class="xref py py-meth docutils literal"><span class="pre">iter_process()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.__call__" title="sage.combinat.finite_state_machine.FiniteStateMachine.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a>,
<a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.combinat.finite_state_machine.Transducer.simplification">
<code class="descname">simplification</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.Transducer.simplification" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a simplified transducer.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>A new transducer.</p>
<p>This function simplifies a transducer by Moore’s algorithm,
first moving common output labels of transitions leaving a
state to output labels of transitions entering the state
(cf. <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine.prepone_output" title="sage.combinat.finite_state_machine.FiniteStateMachine.prepone_output"><code class="xref py py-meth docutils literal"><span class="pre">prepone_output()</span></code></a>).</p>
<p>The resulting transducer implements the same function as the
original transducer.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fsm</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                           (&quot;B&quot;, &quot;C&quot;, 0, 0), (&quot;B&quot;, &quot;C&quot;, 1, 1),</span>
<span class="go">....:                           (&quot;C&quot;, &quot;D&quot;, 0, 1), (&quot;C&quot;, &quot;D&quot;, 1, 0),</span>
<span class="go">....:                           (&quot;D&quot;, &quot;A&quot;, 0, 0), (&quot;D&quot;, &quot;A&quot;, 1, 1)])</span>
<span class="gp">sage: </span><span class="n">fsms</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">fsms</span>
<span class="go">Transducer with 2 states</span>
<span class="gp">sage: </span><span class="n">fsms</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;A&#39;, &#39;C&#39;)</span>
<span class="go">              to (&#39;B&#39;, &#39;D&#39;): 0|1,</span>
<span class="go"> Transition from (&#39;A&#39;, &#39;C&#39;)</span>
<span class="go">              to (&#39;B&#39;, &#39;D&#39;): 1|0,</span>
<span class="go"> Transition from (&#39;B&#39;, &#39;D&#39;)</span>
<span class="go">              to (&#39;A&#39;, &#39;C&#39;): 0|0,</span>
<span class="go"> Transition from (&#39;B&#39;, &#39;D&#39;)</span>
<span class="go">              to (&#39;A&#39;, &#39;C&#39;): 1|1]</span>
<span class="gp">sage: </span><span class="n">fsms</span><span class="o">.</span><span class="n">relabeled</span><span class="p">()</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from 0 to 1: 0|1,</span>
<span class="go"> Transition from 0 to 1: 1|0,</span>
<span class="go"> Transition from 1 to 0: 0|0,</span>
<span class="go"> Transition from 1 to 0: 1|1]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">fsm</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                   (&quot;A&quot;, &quot;B&quot;, 1, 1),</span>
<span class="go">....:                   (&quot;A&quot;, &quot;C&quot;, 1, -1),</span>
<span class="go">....:                   (&quot;B&quot;, &quot;A&quot;, 2, 0),</span>
<span class="go">....:                   (&quot;C&quot;, &quot;A&quot;, 2, 0)])</span>
<span class="gp">sage: </span><span class="n">fsm_simplified</span> <span class="o">=</span> <span class="n">fsm</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">fsm_simplified</span>
<span class="go">Transducer with 2 states</span>
<span class="gp">sage: </span><span class="n">fsm_simplified</span><span class="o">.</span><span class="n">transitions</span><span class="p">()</span>
<span class="go">[Transition from (&#39;A&#39;,) to (&#39;A&#39;,): 0|0,</span>
<span class="go"> Transition from (&#39;A&#39;,) to (&#39;B&#39;, &#39;C&#39;): 1|1,0,</span>
<span class="go"> Transition from (&#39;A&#39;,) to (&#39;B&#39;, &#39;C&#39;): 1|-1,0,</span>
<span class="go"> Transition from (&#39;B&#39;, &#39;C&#39;) to (&#39;A&#39;,): 2|-]</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_add_input</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">([(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="go">....:                 (&#39;A&#39;, &#39;B&#39;, 1/4, 1),</span>
<span class="go">....:                 (&#39;A&#39;, &#39;C&#39;, 1/4, 1),</span>
<span class="go">....:                 (&#39;B&#39;, &#39;A&#39;, 1, 0),</span>
<span class="go">....:                 (&#39;C&#39;, &#39;A&#39;, 1, 0)],</span>
<span class="go">....:                initial_states=[0],</span>
<span class="go">....:                final_states=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;],</span>
<span class="go">....:                on_duplicate_transition=duplicate_transition_add_input)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from (&#39;A&#39;,) to (&#39;A&#39;,): 1/2|0,</span>
<span class="go"> Transition from (&#39;A&#39;,) to (&#39;B&#39;, &#39;C&#39;): 1/2|1,</span>
<span class="go"> Transition from (&#39;B&#39;, &#39;C&#39;) to (&#39;A&#39;,): 1|0]</span>
</pre></div>
</div>
<p>Illustrating the use of colors in order to avoid identification of states:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">Transducer</span><span class="p">(</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
<span class="go">....:                  [1,0,0,0], [1,1,1,1]],</span>
<span class="go">....:                 initial_states=[0],</span>
<span class="go">....:                 final_states=[0,1])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from (0, 1) to (0, 1): 0|0,</span>
<span class="go"> Transition from (0, 1) to (0, 1): 1|1]</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">simplification</span><span class="p">()</span><span class="o">.</span><span class="n">transitions</span><span class="p">())</span>
<span class="go">[Transition from (0,) to (0,): 0|0,</span>
<span class="go"> Transition from (0,) to (1,): 1|1,</span>
<span class="go"> Transition from (1,) to (0,): 0|0,</span>
<span class="go"> Transition from (1,) to (1,): 1|1]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.duplicate_transition_add_input">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">duplicate_transition_add_input</code><span class="sig-paren">(</span><em>old_transition</em>, <em>new_transition</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.duplicate_transition_add_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternative function for handling duplicate transitions in finite
state machines. This implementation adds the input label of the
new transition to the input label of the old transition.  This is
intended for the case where a Markov chain is modelled by a finite
state machine using the input labels as transition probabilities.</p>
<p>See the documentation of the <code class="docutils literal"><span class="pre">on_duplicate_transition</span></code> parameter
of <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">old_transition</span></code> – A transition in a finite state machine.</li>
<li><code class="docutils literal"><span class="pre">new_transition</span></code> – A transition, identical to <code class="docutils literal"><span class="pre">old_transition</span></code>,
which is to be inserted into the finite state machine.</li>
</ul>
<p>OUTPUT:</p>
<p>A transition whose input weight is the sum of the input
weights of <code class="docutils literal"><span class="pre">old_transition</span></code> and <code class="docutils literal"><span class="pre">new_transition</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_add_input</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">duplicate_transition_add_input</span><span class="p">(</span><span class="n">FSMTransition</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
<span class="go">....:                                FSMTransition(&#39;a&#39;, &#39;a&#39;, 1/2))</span>
<span class="go">Transition from &#39;a&#39; to &#39;a&#39;: 1|-</span>
</pre></div>
</div>
<p>Input labels must be lists of length 1:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">duplicate_transition_add_input</span><span class="p">(</span><span class="n">FSMTransition</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
<span class="go">....:                                FSMTransition(&#39;a&#39;, &#39;a&#39;, [1, 1]))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">Trying to use duplicate_transition_add_input on</span>
<span class="go">&quot;Transition from &#39;a&#39; to &#39;a&#39;: 1,1|-&quot; and</span>
<span class="go">&quot;Transition from &#39;a&#39; to &#39;a&#39;: 1,1|-&quot;,</span>
<span class="go">but input words are assumed to be lists of length 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.duplicate_transition_ignore">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">duplicate_transition_ignore</code><span class="sig-paren">(</span><em>old_transition</em>, <em>new_transition</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.duplicate_transition_ignore" title="Permalink to this definition">¶</a></dt>
<dd><p>Default function for handling duplicate transitions in finite
state machines. This implementation ignores the occurrence.</p>
<p>See the documentation of the <code class="docutils literal"><span class="pre">on_duplicate_transition</span></code> parameter
of <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">old_transition</span></code> – A transition in a finite state machine.</li>
<li><code class="docutils literal"><span class="pre">new_transition</span></code> – A transition, identical to <code class="docutils literal"><span class="pre">old_transition</span></code>,
which is to be inserted into the finite state machine.</li>
</ul>
<p>OUTPUT:</p>
<p>The same transition, unchanged.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_ignore</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">duplicate_transition_ignore</span><span class="p">(</span><span class="n">FSMTransition</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                             FSMTransition(0, 0, 1))</span>
<span class="go">Transition from 0 to 0: 1|-</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.duplicate_transition_raise_error">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">duplicate_transition_raise_error</code><span class="sig-paren">(</span><em>old_transition</em>, <em>new_transition</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.duplicate_transition_raise_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternative function for handling duplicate transitions in finite
state machines. This implementation raises a <code class="docutils literal"><span class="pre">ValueError</span></code>.</p>
<p>See the documentation of the <code class="docutils literal"><span class="pre">on_duplicate_transition</span></code> parameter
of <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">old_transition</span></code> – A transition in a finite state machine.</li>
<li><code class="docutils literal"><span class="pre">new_transition</span></code> – A transition, identical to <code class="docutils literal"><span class="pre">old_transition</span></code>,
which is to be inserted into the finite state machine.</li>
</ul>
<p>OUTPUT:</p>
<p>Nothing. A <code class="docutils literal"><span class="pre">ValueError</span></code> is raised.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">duplicate_transition_raise_error</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">FSMTransition</span>
<span class="gp">sage: </span><span class="n">duplicate_transition_raise_error</span><span class="p">(</span><span class="n">FSMTransition</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="go">....:                                  FSMTransition(0, 0, 1))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Attempting to re-insert transition Transition from 0 to 0: 1|-</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.equal">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">equal</code><span class="sig-paren">(</span><em>iterator</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether all elements of <code class="docutils literal"><span class="pre">iterator</span></code> are equal.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">iterator</span></code> – an iterator of the elements to check</li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal"><span class="pre">True</span></code> or <code class="docutils literal"><span class="pre">False</span></code>.</p>
<p>This implements <a class="reference external" href="http://stackoverflow.com/a/3844832/1052778">http://stackoverflow.com/a/3844832/1052778</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">equal</span>
<span class="gp">sage: </span><span class="n">equal</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">equal</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">equal</span><span class="p">([])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">equal</span><span class="p">(</span><span class="nb">iter</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can test other properties of the elements than the elements
themselves. In the following example, we check whether all tuples
have the same lengths:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">equal</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">equal</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.full_group_by">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">full_group_by</code><span class="sig-paren">(</span><em>l</em>, <em>key=&lt;function &lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.full_group_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Group iterable <code class="docutils literal"><span class="pre">l</span></code> by values of <code class="docutils literal"><span class="pre">key</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li>iterable <code class="docutils literal"><span class="pre">l</span></code></li>
<li>key function <code class="docutils literal"><span class="pre">key</span></code></li>
</ul>
<p>OUTPUT:</p>
<p>A list of pairs <code class="docutils literal"><span class="pre">(k,</span> <span class="pre">elements)</span></code> such that <code class="docutils literal"><span class="pre">key(e)=k</span></code> for all
<code class="docutils literal"><span class="pre">e</span></code> in <code class="docutils literal"><span class="pre">elements</span></code>.</p>
<p>This is similar to <code class="docutils literal"><span class="pre">itertools.groupby</span></code> except that lists are
returned instead of iterables and no prior sorting is required.</p>
<p>We do not require</p>
<ul class="simple">
<li>that the keys are sortable (in contrast to the
approach via <code class="docutils literal"><span class="pre">sorted</span></code> and <code class="docutils literal"><span class="pre">itertools.groupby</span></code>) and</li>
<li>that the keys are hashable (in contrast to the
implementation proposed in <a class="reference external" href="http://stackoverflow.com/a/15250161">http://stackoverflow.com/a/15250161</a>).</li>
</ul>
<p>However, it is required</p>
<ul class="simple">
<li>that distinct keys have distinct <code class="docutils literal"><span class="pre">str</span></code>-representations.</li>
</ul>
<p>The implementation is inspired by
<a class="reference external" href="http://stackoverflow.com/a/15250161">http://stackoverflow.com/a/15250161</a>, but non-hashable keys are
allowed.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">full_group_by</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="n">full_group_by</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[(2/x, [0, 2]), (1/x, [1])]</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">groupby</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">elements</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="go">....:                            key=lambda i:t[i]),</span>
<span class="go">....:                            key=lambda i:t[i]):</span>
<span class="go">....:     print(&quot;{} {}&quot;.format(k, list(elements)))</span>
<span class="go">2/x [0]</span>
<span class="go">1/x [1]</span>
<span class="go">2/x [2]</span>
</pre></div>
</div>
<p>Note that the behavior is different from <code class="docutils literal"><span class="pre">itertools.groupby</span></code>
because neither <span class="math">\(1/x&lt;2/x\)</span> nor <span class="math">\(2/x&lt;1/x\)</span> does hold.</p>
<p>Here, the result <code class="docutils literal"><span class="pre">r</span></code> has been sorted in order to guarantee a
consistent order for the doctest suite.</p>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.is_Automaton">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">is_Automaton</code><span class="sig-paren">(</span><em>FSM</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.is_Automaton" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether or not <code class="docutils literal"><span class="pre">FSM</span></code> inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.Automaton" title="sage.combinat.finite_state_machine.Automaton"><code class="xref py py-class docutils literal"><span class="pre">Automaton</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.is_FSMProcessIterator">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">is_FSMProcessIterator</code><span class="sig-paren">(</span><em>PI</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.is_FSMProcessIterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether or not <code class="docutils literal"><span class="pre">PI</span></code> inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMProcessIterator" title="sage.combinat.finite_state_machine.FSMProcessIterator"><code class="xref py py-class docutils literal"><span class="pre">FSMProcessIterator</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.is_FSMState">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">is_FSMState</code><span class="sig-paren">(</span><em>S</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.is_FSMState" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether or not <code class="docutils literal"><span class="pre">S</span></code> inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMState" title="sage.combinat.finite_state_machine.FSMState"><code class="xref py py-class docutils literal"><span class="pre">FSMState</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.is_FSMTransition">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">is_FSMTransition</code><span class="sig-paren">(</span><em>T</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.is_FSMTransition" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether or not <code class="docutils literal"><span class="pre">T</span></code> inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.FSMTransition" title="sage.combinat.finite_state_machine.FSMTransition"><code class="xref py py-class docutils literal"><span class="pre">FSMTransition</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.is_FiniteStateMachine">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">is_FiniteStateMachine</code><span class="sig-paren">(</span><em>FSM</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.is_FiniteStateMachine" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether or not <code class="docutils literal"><span class="pre">FSM</span></code> inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.FiniteStateMachine" title="sage.combinat.finite_state_machine.FiniteStateMachine"><code class="xref py py-class docutils literal"><span class="pre">FiniteStateMachine</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.is_Transducer">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">is_Transducer</code><span class="sig-paren">(</span><em>FSM</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.is_Transducer" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests whether or not <code class="docutils literal"><span class="pre">FSM</span></code> inherits from <a class="reference internal" href="#sage.combinat.finite_state_machine.Transducer" title="sage.combinat.finite_state_machine.Transducer"><code class="xref py py-class docutils literal"><span class="pre">Transducer</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.setup_latex_preamble">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">setup_latex_preamble</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.setup_latex_preamble" title="Permalink to this definition">¶</a></dt>
<dd><p>This function adds the package <code class="docutils literal"><span class="pre">tikz</span></code> with support for automata
to the preamble of Latex so that the finite state machines can be
drawn nicely.</p>
<p>INPUT:</p>
<p>Nothing.</p>
<p>OUTPUT:</p>
<p>Nothing.</p>
<p>See the section on <a class="reference internal" href="#finite-state-machine-latex-output"><span class="std std-ref">LaTeX output</span></a>
in the introductory examples of this module.</p>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.startswith">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">startswith</code><span class="sig-paren">(</span><em>list</em>, <em>prefix</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.startswith" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether list starts with the given prefix.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">list</span></code> – list</li>
<li><code class="docutils literal"><span class="pre">prefix</span></code> – list representing the prefix</li>
</ul>
<p>OUTPUT:</p>
<p><code class="docutils literal"><span class="pre">True</span></code> or <code class="docutils literal"><span class="pre">False</span></code>.</p>
<p>Similar to <a class="reference external" href="https://docs.python.org/library/stdtypes.html#str.startswith" title="(in Python v2.7)"><code class="xref py py-meth docutils literal"><span class="pre">str.startswith()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="n">startswith</span>
<span class="gp">sage: </span><span class="n">startswith</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">startswith</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">startswith</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.tupleofwords_to_wordoftuples">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">tupleofwords_to_wordoftuples</code><span class="sig-paren">(</span><em>tupleofwords</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.tupleofwords_to_wordoftuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Transposes a tuple of words over the alphabet to a word of tuples.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">tupleofwords</span></code> – a tuple of a list of letters.</li>
</ul>
<p>OUTPUT:</p>
<p>A list of tuples.</p>
<p>Missing letters in the words are padded with the letter <code class="docutils literal"><span class="pre">None</span></code>
(from the empty word).</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="p">(</span>
<span class="go">....:     tupleofwords_to_wordoftuples)</span>
<span class="gp">sage: </span><span class="n">tupleofwords_to_wordoftuples</span><span class="p">(</span>
<span class="go">....:     ([1, 2], [3, 4, 5, 6], [7]))</span>
<span class="go">[(1, 3, 7), (2, 4, None), (None, 5, None), (None, 6, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.combinat.finite_state_machine.wordoftuples_to_tupleofwords">
<code class="descclassname">sage.combinat.finite_state_machine.</code><code class="descname">wordoftuples_to_tupleofwords</code><span class="sig-paren">(</span><em>wordoftuples</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.finite_state_machine.wordoftuples_to_tupleofwords" title="Permalink to this definition">¶</a></dt>
<dd><p>Transposes a word of tuples to a tuple of words over the alphabet.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">wordoftuples</span></code> – a list of tuples of letters.</li>
</ul>
<p>OUTPUT:</p>
<p>A tuple of lists.</p>
<p>Letters <code class="docutils literal"><span class="pre">None</span></code> (empty word) are removed from each word in the output.</p>
<p>EXAMPLES:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.finite_state_machine</span> <span class="kn">import</span> <span class="p">(</span>
<span class="go">....:     wordoftuples_to_tupleofwords)</span>
<span class="gp">sage: </span><span class="n">wordoftuples_to_tupleofwords</span><span class="p">(</span>
<span class="go">....:     [(1, 2), (1, None), (1, None), (1, 2), (None, 2)])</span>
<span class="go">([1, 1, 1, 1], [2, 2, 2])</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference internal" href="#">Finite State Machines, Automata, Transducers</a><ul>
<li><a class="reference internal" href="#contents">Contents</a><ul>
<li><a class="reference internal" href="#finitestatemachine-and-derived-classes-transducer-and-automaton"><code class="docutils literal"><span class="pre">FiniteStateMachine</span></code> and derived classes <code class="docutils literal"><span class="pre">Transducer</span></code> and <code class="docutils literal"><span class="pre">Automaton</span></code></a><ul>
<li><a class="reference internal" href="#accessing-parts-of-a-finite-state-machine">Accessing parts of a finite state machine</a></li>
<li><a class="reference internal" href="#modified-copies">(Modified) Copies</a></li>
<li><a class="reference internal" href="#manipulation">Manipulation</a></li>
<li><a class="reference internal" href="#properties">Properties</a></li>
<li><a class="reference internal" href="#operations">Operations</a></li>
<li><a class="reference internal" href="#simplification">Simplification</a></li>
<li><a class="reference internal" href="#conversion">Conversion</a><ul>
<li><a class="reference internal" href="#latex-output">LaTeX output</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#fsmstate"><code class="docutils literal"><span class="pre">FSMState</span></code></a></li>
<li><a class="reference internal" href="#fsmtransition"><code class="docutils literal"><span class="pre">FSMTransition</span></code></a></li>
<li><a class="reference internal" href="#fsmprocessiterator"><code class="docutils literal"><span class="pre">FSMProcessIterator</span></code></a></li>
<li><a class="reference internal" href="#helper-functions">Helper Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#a-simple-finite-state-machine">A simple finite state machine</a></li>
<li><a class="reference internal" href="#a-simple-automaton-recognizing-nafs">A simple Automaton (recognizing NAFs)</a><ul>
<li><a class="reference internal" href="#recognizing-nafs-via-automata-operations">Recognizing NAFs via Automata Operations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#finite-state-machine-latex-output">LaTeX output</a></li>
<li><a class="reference internal" href="#a-simple-transducer-binary-inverter">A simple transducer (binary inverter)</a></li>
<li><a class="reference internal" href="#transducers-and-in-finite-words">Transducers and (in)finite Words</a></li>
<li><a class="reference internal" href="#a-transducer-which-performs-division-by-in-binary">A transducer which performs division by <span class="math">\(3\)</span> in binary</a></li>
<li><a class="reference internal" href="#gray-code">Gray Code</a></li>
<li><a class="reference internal" href="#using-the-hook-functions">Using the hook-functions</a></li>
<li><a class="reference internal" href="#detecting-sequences-with-same-number-of-and">Detecting sequences with same number of <span class="math">\(0\)</span> and <span class="math">\(1\)</span></a></li>
</ul>
</li>
<li><a class="reference internal" href="#methods">Methods</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="finite_class.html"
                                  title="previous chapter">Finite combinatorial classes</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="finite_state_machine_generators.html"
                                  title="next chapter">Common Automata and Transducers (Finite State Machines Generators)</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/sage/combinat/finite_state_machine.rst.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../../../search.html" method="get">
                <input type="text" name="q" size="18" />
               <!-- The shading of the "Go" button should be consistent -->
               <!-- with the colour of the header and footer. See the file -->
               <!-- doc/common/themes/sage/theme.conf for colours used by -->
               <!-- the Sage theme. -->
                <input type="submit" style="background-color: #B8B9F6" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="finite_state_machine_generators.html" title="Common Automata and Transducers (Finite State Machines Generators)"
             >next</a> |</li>
        <li class="right" >
          <a href="finite_class.html" title="Finite combinatorial classes"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Combinatorics</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../module_list.html" >Comprehensive Module list</a> &#187;</li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2017, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>