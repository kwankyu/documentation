
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Binary Trees &#8212; Sage 9.5 Reference Manual: Combinatorics</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sage.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <script data-url_root="../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script async="async" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Blob Algebras" href="blob_algebra.html" />
    <link rel="prev" title="Binary Recurrence Sequences" href="binary_recurrence_sequences.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="blob_algebra.html" title="Blob Algebras"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="binary_recurrence_sequences.html" title="Binary Recurrence Sequences"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.5 Reference Manual: Combinatorics</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../module_list.html" accesskey="U">Comprehensive Module List</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Binary Trees</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="binary-trees">
<span id="sage-combinat-binary-tree"></span><h1>Binary Trees<a class="headerlink" href="#binary-trees" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.binary_tree"></span><p>This module deals with binary trees as mathematical (in particular immutable)
objects.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you need the data-structure for example to represent sets or hash
tables with AVL trees, you should have a look at <code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.misc.sagex_ds</span></code>.</p>
</div>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Florent Hivert (2010-2011): initial implementation.</p></li>
<li><p>Adrien Boussicault (2015): Hook statistics.</p></li>
</ul>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.combinat.binary_tree.</span></span><span class="sig-name descname"><span class="pre">BinaryTree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">children</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="abstract_tree.html#sage.combinat.abstract_tree.AbstractClonableTree" title="sage.combinat.abstract_tree.AbstractClonableTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.abstract_tree.AbstractClonableTree</span></code></a>, <a class="reference external" href="../../../structure/sage/structure/list_clone.html#sage.structure.list_clone.ClonableArray" title="(in Sage 9.5 Reference Manual: Parents and Elements v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.list_clone.ClonableArray</span></code></a></p>
<p>Binary trees.</p>
<p>Binary trees here mean ordered (a.k.a. plane) finite binary
trees, where “ordered” means that the children of each node are
ordered.</p>
<p>Binary trees contain nodes and leaves, where each node has two
children while each leaf has no children. The number of leaves
of a binary tree always equals the number of nodes plus <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">children</span></code> – <code class="docutils literal notranslate"><span class="pre">None</span></code> (default) or a list, tuple or iterable of
length <span class="math notranslate nohighlight">\(2\)</span> of binary trees or convertible objects. This corresponds
to the standard recursive definition of a binary tree as either a
leaf or a pair of binary trees. Syntactic sugar allows leaving out
all but the outermost calls of the <code class="docutils literal notranslate"><span class="pre">BinaryTree()</span></code> constructor, so
that, e. g., <code class="docutils literal notranslate"><span class="pre">BinaryTree([BinaryTree(None),BinaryTree(None)])</span></code> can
be shortened to <code class="docutils literal notranslate"><span class="pre">BinaryTree([None,None])</span></code>. It is also allowed to
abbreviate <code class="docutils literal notranslate"><span class="pre">[None,</span> <span class="pre">None]</span></code> by <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) whether check for binary should be
performed or not.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span>
<span class="go">[., .]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="go">[., .]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="p">[]])</span>
<span class="go">[., [., .]]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span> <span class="kc">None</span><span class="p">])</span>
<span class="go">[[., .], .]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">(</span><span class="s2">&quot;[[], .]&quot;</span><span class="p">)</span>
<span class="go">[[., .], .]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])])</span>
<span class="go">[., [., .]]</span>

<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span> <span class="kc">None</span><span class="p">,</span> <span class="p">[]])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: this is not a binary tree</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.as_ordered_tree">
<span class="sig-name descname"><span class="pre">as_ordered_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">with_leaves</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.as_ordered_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the same tree seen as an ordered tree. By default, leaves
are transformed into actual nodes, but this can be avoided by
setting the optional variable <code class="docutils literal notranslate"><span class="pre">with_leaves</span></code> to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([]);</span> <span class="n">bt</span>
<span class="go">[., .]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">as_ordered_tree</span><span class="p">()</span>
<span class="go">[[], []]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">as_ordered_tree</span><span class="p">(</span><span class="n">with_leaves</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">();</span> <span class="n">bt</span>
<span class="go">1[., .]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">as_ordered_tree</span><span class="p">()</span>
<span class="go">1[None[], None[]]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">as_ordered_tree</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">1[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.canonical_labelling">
<span class="sig-name descname"><span class="pre">canonical_labelling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.canonical_labelling" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a labelled version of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The canonical labelling of a binary tree is a certain labelling of the
nodes (not the leaves) of the tree.
The actual canonical labelling is currently unspecified. However, it
is guaranteed to have labels in <span class="math notranslate nohighlight">\(1...n\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of
nodes of the tree. Moreover, two (unlabelled) trees compare as equal if
and only if their canonical labelled trees compare as equal.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="go">1[., .]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="kc">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="go">5[2[1[., .], 4[3[., .], .]], 7[6[., .], 8[., .]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.canopee">
<span class="sig-name descname"><span class="pre">canopee</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.canopee" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the canopee of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The <em>canopee</em> of a non-empty binary tree <span class="math notranslate nohighlight">\(T\)</span> with <span class="math notranslate nohighlight">\(n\)</span> internal nodes is
the list <span class="math notranslate nohighlight">\(l\)</span> of <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(1\)</span> of length <span class="math notranslate nohighlight">\(n-1\)</span> obtained by going along the
leaves of <span class="math notranslate nohighlight">\(T\)</span> from left to right except the two extremal ones, writing
<span class="math notranslate nohighlight">\(0\)</span> if the leaf is a right leaf and <span class="math notranslate nohighlight">\(1\)</span> if the leaf is a left leaf.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">canopee</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="p">[]])</span><span class="o">.</span><span class="n">canopee</span><span class="p">()</span>
<span class="go">[1]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">canopee</span><span class="p">()</span>
<span class="go">[0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[]])</span><span class="o">.</span><span class="n">canopee</span><span class="p">()</span>
<span class="go">[0, 1]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="kc">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span><span class="o">.</span><span class="n">canopee</span><span class="p">()</span>
<span class="go">[0, 1, 0, 0, 1, 0, 1]</span>
</pre></div>
</div>
<p>The number of pairs <span class="math notranslate nohighlight">\((t_1, t_2)\)</span> of binary trees of size <span class="math notranslate nohighlight">\(n\)</span> such that
the canopee of <span class="math notranslate nohighlight">\(t_1\)</span> is the complementary of the canopee of <span class="math notranslate nohighlight">\(t_2\)</span> is
also the number of Baxter permutations (see <a class="reference internal" href="../../../references/index.html#dg1994" id="id1"><span>[DG1994]</span></a>, see
also <a class="reference external" href="https://oeis.org/A001181">OEIS sequence A001181</a>). We check this in small cases:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="nb">len</span><span class="p">([(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">....: </span>      <span class="k">if</span> <span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">u</span><span class="o">.</span><span class="n">canopee</span><span class="p">()]</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">canopee</span><span class="p">()])</span>
<span class="gp">....: </span>   <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
<span class="go">[1, 2, 6, 22]</span>
</pre></div>
</div>
<p>Here is a less trivial implementation of this:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.finite_set_map_cy</span> <span class="kn">import</span> <span class="n">fibers</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.misc.all</span> <span class="kn">import</span> <span class="n">attrcall</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">baxter</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">f</span> <span class="o">=</span> <span class="n">fibers</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">canopee</span><span class="p">()),</span>
<span class="gp">....: </span>                  <span class="n">BinaryTrees</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)])</span>
<span class="gp">....: </span>               <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">baxter</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)]</span>
<span class="go">[1, 2, 6, 22, 92, 422]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.check">
<span class="sig-name descname"><span class="pre">check</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that <code class="docutils literal notranslate"><span class="pre">self</span></code> is a binary tree.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[]])</span>     <span class="c1"># indirect doctest</span>
<span class="go">[[., .], [., .]]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[],</span> <span class="p">[]])</span> <span class="c1"># indirect doctest</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: this is not a binary tree</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[]])</span>         <span class="c1"># indirect doctest</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: this is not a binary tree</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.comb">
<span class="sig-name descname"><span class="pre">comb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'left'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.comb" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the comb of a tree.</p>
<p>There are two combs in a binary tree: a left comb and a right comb.</p>
<p>Consider all the vertices of the leftmost (resp. rightmost) branch of
the root. The left (resp. right) comb is the list of right (resp. left)
subtrees of each of these vertices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">side</span></code> – (default: ‘left’) set to ‘left’ to obtain a left
comb, and to ‘right’ to obtain a right comb.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of binary trees.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.over_decomposition" title="sage.combinat.binary_tree.BinaryTree.over_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">over_decomposition()</span></code></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.under_decomposition" title="sage.combinat.binary_tree.BinaryTree.under_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">under_decomposition()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span> <span class="s1">&#39;.&#39;</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">BT</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">),</span> <span class="n">BT</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">)]</span>
<span class="go">[[], []]</span>
<span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span> <span class="s1">&#39;[.,.]&#39;</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">BT</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">),</span> <span class="n">BT</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">)]</span>
<span class="go">[[], []]</span>
<span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span> <span class="s1">&#39;[[[.,.], .], [.,.]]&#39;</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">BT</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
<span class="go">[., .]</span>
<span class="gp">sage: </span><span class="n">BT</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">[.]</span>
<span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span> <span class="s1">&#39;[[[[., [., .]], .], [[., .], [[[., .], [., .]], [., .]]]], [., [[[., .], [[[., .], [., .]], .]], .]]]&#39;</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">BT</span><span class="p">)</span>
<span class="go">        ________o________</span>
<span class="go">       /                 \</span>
<span class="go">    __o__                 o</span>
<span class="go">   /     \                 \</span>
<span class="go">  o     __o___              o</span>
<span class="go"> /     /      \            /</span>
<span class="go">o     o       _o_       __o__</span>
<span class="go"> \           /   \     /     \</span>
<span class="go">  o         o     o   o       o</span>
<span class="go">           / \               /</span>
<span class="go">          o   o             o</span>
<span class="go">                           / \</span>
<span class="go">                          o   o</span>
<span class="gp">sage: </span><span class="n">BT</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
<span class="go">[[[., .], [[[., .], [., .]], [., .]]], ., [., .]]</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">BT</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">))</span>
<span class="go">[   __o___     , , o ]</span>
<span class="go">[  /      \          ]</span>
<span class="go">[ o       _o_        ]</span>
<span class="go">[        /   \       ]</span>
<span class="go">[       o     o      ]</span>
<span class="go">[      / \           ]</span>
<span class="go">[     o   o          ]</span>
<span class="gp">sage: </span><span class="n">BT</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">[., [[., .], [[[., .], [., .]], .]]]</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">BT</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">))</span>
<span class="go">[ ,   __o__   ]</span>
<span class="go">[    /     \  ]</span>
<span class="go">[   o       o ]</span>
<span class="go">[          /  ]</span>
<span class="go">[         o   ]</span>
<span class="go">[        / \  ]</span>
<span class="go">[       o   o ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.dendriform_shuffle">
<span class="sig-name descname"><span class="pre">dendriform_shuffle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.dendriform_shuffle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of terms in the dendriform product.</p>
<p>This is the list of all binary trees that can be obtained by
identifying the rightmost path in <code class="docutils literal notranslate"><span class="pre">self</span></code> and the leftmost
path in <code class="docutils literal notranslate"><span class="pre">other</span></code>. Every term corresponds to a shuffle of the
vertices on the rightmost path in <code class="docutils literal notranslate"><span class="pre">self</span></code> and the vertices on
the leftmost path in <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">u</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([])</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">g</span><span class="p">,</span> <span class="n">u</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">g</span><span class="p">])</span>

<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">dendriform_shuffle</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
<span class="go">[[[., .], .], [., [., .]]]</span>

<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">dendriform_shuffle</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
<span class="go">[[[[[., .], .], .], .], [[[., .], [., .]], .],</span>
<span class="go">[[., .], [[., .], .]]]</span>

<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">dendriform_shuffle</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
<span class="go">[[[[., .], .], [., .]], [[., .], [., [., .]]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.graph">
<span class="sig-name descname"><span class="pre">graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">with_leaves</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert <code class="docutils literal notranslate"><span class="pre">self</span></code> to a digraph.</p>
<p>By default, this graph contains both nodes and leaves, hence
is never empty. To obtain a graph which contains only the
nodes, the <code class="docutils literal notranslate"><span class="pre">with_leaves</span></code> optional keyword variable has to be
set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>The resulting digraph is endowed with a combinatorial embedding,
in order to be displayed correctly.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">with_leaves</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) a Boolean, determining
whether the resulting graph will be formed from the leaves
and the nodes of <code class="docutils literal notranslate"><span class="pre">self</span></code> (if <code class="docutils literal notranslate"><span class="pre">True</span></code>), or only from the
nodes of <code class="docutils literal notranslate"><span class="pre">self</span></code> (if <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Digraph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Digraph on 2 vertices</span>

<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[[],</span> <span class="kc">None</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Digraph on 9 vertices</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 4, None), (1, 2, None), (1, 3, None), (4, 5, None), (4, 8, None), (5, 6, None), (5, 7, None)]</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Digraph on 4 vertices</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 2, None), (2, 3, None)]</span>

<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Digraph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Digraph on 0 vertices</span>

<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Digraph on 3 vertices</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Digraph on 1 vertex</span>

<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[[],</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Digraph on 5 vertices</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[(0, 1, None), (0, 2, None), (2, 3, None), (2, 4, None)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.hook_number">
<span class="sig-name descname"><span class="pre">hook_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.hook_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of hooks.</p>
<p>Recalling that a branch is a path from a vertex of the tree to a leaf,
the leftmost (resp. rightmost) branch of a vertex <span class="math notranslate nohighlight">\(v\)</span> is the branch from
<span class="math notranslate nohighlight">\(v\)</span> made only of left (resp. right) edges.</p>
<p>The hook of a vertex <span class="math notranslate nohighlight">\(v\)</span> is a set of vertices formed by the
union of <span class="math notranslate nohighlight">\({v}\)</span>, and the vertices of its leftmost and rightmost branches.</p>
<p>There is a unique way to partition the set of vertices in hooks.
The number of hooks in such a partition is the hook number of the tree.</p>
<p>We can obtain this partition recursively by extracting the root’s hook
and iterating the processus on each tree of the remaining forest.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span> <span class="s1">&#39;.&#39;</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">BT</span><span class="o">.</span><span class="n">hook_number</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span> <span class="s1">&#39;[.,.]&#39;</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">BT</span><span class="o">.</span><span class="n">hook_number</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span> <span class="s1">&#39;[[[.,.], .], [.,.]]&#39;</span> <span class="p">);</span> <span class="n">ascii_art</span><span class="p">(</span><span class="n">BT</span><span class="p">)</span>
<span class="go">    o</span>
<span class="go">   / \</span>
<span class="go">  o   o</span>
<span class="go"> /</span>
<span class="go">o</span>
<span class="gp">sage: </span><span class="n">BT</span><span class="o">.</span><span class="n">hook_number</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span> <span class="s1">&#39;[[[[., [., .]], .], [[., .], [[[., .], [., .]], [., .]]]], [., [[[., .], [[[., .], [., .]], .]], .]]]&#39;</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">BT</span><span class="p">)</span>
<span class="go">        ________o________</span>
<span class="go">       /                 \</span>
<span class="go">    __o__                 o</span>
<span class="go">   /     \                 \</span>
<span class="go">  o     __o___              o</span>
<span class="go"> /     /      \            /</span>
<span class="go">o     o       _o_       __o__</span>
<span class="go"> \           /   \     /     \</span>
<span class="go">  o         o     o   o       o</span>
<span class="go">           / \               /</span>
<span class="go">          o   o             o</span>
<span class="go">                           / \</span>
<span class="go">                          o   o</span>
<span class="gp">sage: </span><span class="n">BT</span><span class="o">.</span><span class="n">hook_number</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.in_order_traversal">
<span class="sig-name descname"><span class="pre">in_order_traversal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node_action</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_action</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.in_order_traversal" title="Permalink to this definition">¶</a></dt>
<dd><p>Explore the binary tree <code class="docutils literal notranslate"><span class="pre">self</span></code> using the depth-first infix-order
traversal algorithm, executing the <code class="docutils literal notranslate"><span class="pre">node_action</span></code> function
whenever traversing a node and executing the <code class="docutils literal notranslate"><span class="pre">leaf_action</span></code>
function whenever traversing a leaf.</p>
<p>In more detail, what this method does to a tree <span class="math notranslate nohighlight">\(T\)</span> is the
following:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">if the root of `T` is a node:</span>
<span class="go">    apply in_order_traversal to the left subtree of `T`</span>
<span class="go">        (with the same node_action and leaf_action);</span>
<span class="go">    apply node_action to the root of `T`;</span>
<span class="go">    apply in_order_traversal to the right subtree of `T`</span>
<span class="go">        (with the same node_action and leaf_action);</span>
<span class="go">else:</span>
<span class="go">    apply leaf_action to the root of `T`.</span>
</pre></div>
</div>
<p>For example on the following binary tree <span class="math notranslate nohighlight">\(T\)</span>, where we denote
leaves by <span class="math notranslate nohighlight">\(a, b, c, \ldots\)</span> and nodes by <span class="math notranslate nohighlight">\(1, 2, 3, \ldots\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|     ____3____          |</span>
<span class="go">|    /         \         |</span>
<span class="go">|   1          __7__     |</span>
<span class="go">|  / \        /     \    |</span>
<span class="go">| a   2      _5_     8   |</span>
<span class="go">|    / \    /   \   / \  |</span>
<span class="go">|   b   c  4     6 h   i |</span>
<span class="go">|         / \   / \      |</span>
<span class="go">|        d   e f   g     |</span>
</pre></div>
</div>
<p>this method first applies <code class="docutils literal notranslate"><span class="pre">leaf_action</span></code> to <span class="math notranslate nohighlight">\(a\)</span>, then applies
<code class="docutils literal notranslate"><span class="pre">node_action</span></code> to <span class="math notranslate nohighlight">\(1\)</span>, then <code class="docutils literal notranslate"><span class="pre">leaf_action</span></code> to <span class="math notranslate nohighlight">\(b\)</span>, then
<code class="docutils literal notranslate"><span class="pre">node_action</span></code> to <span class="math notranslate nohighlight">\(2\)</span>, etc., with the vertices being traversed
in the order <span class="math notranslate nohighlight">\(a,1,b,2,c,3,d,4,e,5,f,6,g,7,h,8,i\)</span>.</p>
<p>See <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.in_order_traversal_iter" title="sage.combinat.binary_tree.BinaryTree.in_order_traversal_iter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">in_order_traversal_iter()</span></code></a> for a version of this
algorithm which only iterates through the vertices rather than
applying any function to them.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">node_action</span></code> – (optional) a function which takes a node in input
and does something during the exploration</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">leaf_action</span></code> – (optional) a function which takes a leaf in input
and does something during the exploration</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.in_order_traversal_iter">
<span class="sig-name descname"><span class="pre">in_order_traversal_iter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.in_order_traversal_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>The depth-first infix-order traversal iterator for the binary
tree <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This method iters each vertex (node and leaf alike) of the given
binary tree following the depth-first infix order traversal
algorithm.</p>
<p>The <em>depth-first infix order traversal algorithm</em> iterates
through a binary tree as follows:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">iterate through the left subtree (by the depth-first infix</span>
<span class="go">    order traversal algorithm);</span>
<span class="go">yield the root;</span>
<span class="go">iterate through the right subtree (by the depth-first infix</span>
<span class="go">    order traversal algorithm).</span>
</pre></div>
</div>
<p>For example on the following binary tree <span class="math notranslate nohighlight">\(T\)</span>, where we denote
leaves by <span class="math notranslate nohighlight">\(a, b, c, \ldots\)</span> and nodes by <span class="math notranslate nohighlight">\(1, 2, 3, \ldots\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|     ____3____          |</span>
<span class="go">|    /         \         |</span>
<span class="go">|   1          __7__     |</span>
<span class="go">|  / \        /     \    |</span>
<span class="go">| a   2      _5_     8   |</span>
<span class="go">|    / \    /   \   / \  |</span>
<span class="go">|   b   c  4     6 h   i |</span>
<span class="go">|         / \   / \      |</span>
<span class="go">|        d   e f   g     |</span>
</pre></div>
</div>
<p>the depth-first infix-order traversal algorithm iterates through
the vertices of <span class="math notranslate nohighlight">\(T\)</span> in the following order:
<span class="math notranslate nohighlight">\(a,1,b,2,c,3,d,4,e,5,f,6,g,7,h,8,i\)</span>.</p>
<p>See <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.in_order_traversal" title="sage.combinat.binary_tree.BinaryTree.in_order_traversal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">in_order_traversal()</span></code></a> for a version of this algorithm
which not only iterates through, but actually does something at
the vertices of tree.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.is_complete">
<span class="sig-name descname"><span class="pre">is_complete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.is_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">self</span></code> is complete, else return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>In a nutshell, a complete binary tree is a perfect binary tree
except possibly in the last level, with all nodes in the last
level “flush to the left”.</p>
<p>In more detail:
A complete binary tree (also called binary heap) is a binary tree in
which every level, except possibly the last one (the deepest), is
completely filled. At depth <span class="math notranslate nohighlight">\(n\)</span>, all nodes must be as far left as
possible.</p>
<p>For example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|         ___o___   |</span>
<span class="go">|        /       \  |</span>
<span class="go">|     __o__       o |</span>
<span class="go">|    /     \        |</span>
<span class="go">|   o       o       |</span>
<span class="go">|  / \     / \      |</span>
<span class="go">| o   o   o   o     |</span>
</pre></div>
</div>
<p>is not complete but the following ones are:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|     __o__          _o_            ___o___     |</span>
<span class="go">|    /     \        /   \          /       \    |</span>
<span class="go">|   o       o      o     o      __o__       o   |</span>
<span class="go">|  / \     / \    / \          /     \     / \  |</span>
<span class="go">| o   o   o   o, o   o    ,   o       o   o   o |</span>
<span class="go">|                            / \     /          |</span>
<span class="go">|                           o   o   o           |</span>
</pre></div>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">lst</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="p">[</span><span class="n">bt</span> <span class="k">for</span> <span class="n">bt</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="n">bt</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span> <span class="n">ascii_art</span><span class="p">(</span><span class="n">lst</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="c1"># long time</span>
<span class="go">[  ]</span>
<span class="go">[ o ]</span>
<span class="go">[   o ]</span>
<span class="go">[  /  ]</span>
<span class="go">[ o   ]</span>
<span class="go">[   o   ]</span>
<span class="go">[  / \  ]</span>
<span class="go">[ o   o ]</span>
<span class="go">[     o   ]</span>
<span class="go">[    / \  ]</span>
<span class="go">[   o   o ]</span>
<span class="go">[  /      ]</span>
<span class="go">[ o       ]</span>
<span class="go">[     _o_   ]</span>
<span class="go">[    /   \  ]</span>
<span class="go">[   o     o ]</span>
<span class="go">[  / \      ]</span>
<span class="go">[ o   o     ]</span>
<span class="go">[     __o__   ]</span>
<span class="go">[    /     \  ]</span>
<span class="go">[   o       o ]</span>
<span class="go">[  / \     /  ]</span>
<span class="go">[ o   o   o   ]</span>
<span class="go">[     __o__     ]</span>
<span class="go">[    /     \    ]</span>
<span class="go">[   o       o   ]</span>
<span class="go">[  / \     / \  ]</span>
<span class="go">[ o   o   o   o ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.is_empty">
<span class="sig-name descname"><span class="pre">is_empty</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.is_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <code class="docutils literal notranslate"><span class="pre">self</span></code> is empty.</p>
<p>The notion of emptiness employed here is the one which defines
a binary tree to be empty if its root is a leaf. There is
precisely one empty binary tree.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">is_empty</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.is_full">
<span class="sig-name descname"><span class="pre">is_full</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.is_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">self</span></code> is full, else return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>A full binary tree is a tree in which every node either has two
child nodes or has two child leaves.</p>
<p>This is also known as <em>proper binary tree</em> or <em>2-tree</em> or <em>strictly
binary tree</em>.</p>
<p>For example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|       __o__   |</span>
<span class="go">|      /     \  |</span>
<span class="go">|     o       o |</span>
<span class="go">|    / \        |</span>
<span class="go">|   o   o       |</span>
<span class="go">|  /     \      |</span>
<span class="go">| o       o     |</span>
</pre></div>
</div>
<p>is not full but the next one is:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|         ___o___   |</span>
<span class="go">|        /       \  |</span>
<span class="go">|     __o__       o |</span>
<span class="go">|    /     \        |</span>
<span class="go">|   o       o       |</span>
<span class="go">|  / \     / \      |</span>
<span class="go">| o   o   o   o     |</span>
</pre></div>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[[[],</span><span class="kc">None</span><span class="p">],[</span><span class="kc">None</span><span class="p">,[]]],</span> <span class="p">[]])</span><span class="o">.</span><span class="n">is_full</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[[[],[]],[[],[]]],</span> <span class="p">[]])</span><span class="o">.</span><span class="n">is_full</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">([</span><span class="n">bt</span> <span class="k">for</span> <span class="n">bt</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">bt</span><span class="o">.</span><span class="n">is_full</span><span class="p">()])</span>
<span class="go">[   _o_    ,     _o_   ]</span>
<span class="go">[  /   \        /   \  ]</span>
<span class="go">[ o     o      o     o ]</span>
<span class="go">[      / \    / \      ]</span>
<span class="go">[     o   o  o   o     ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.is_perfect">
<span class="sig-name descname"><span class="pre">is_perfect</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.is_perfect" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">self</span></code> is perfect, else return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>A perfect binary tree is a full tree in which all leaves are at the
same depth.</p>
<p>For example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|         ___o___   |</span>
<span class="go">|        /       \  |</span>
<span class="go">|     __o__       o |</span>
<span class="go">|    /     \        |</span>
<span class="go">|   o       o       |</span>
<span class="go">|  / \     / \      |</span>
<span class="go">| o   o   o   o     |</span>
</pre></div>
</div>
<p>is not perfect but the next one is:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|     __o__     |</span>
<span class="go">|    /     \    |</span>
<span class="go">|   o       o   |</span>
<span class="go">|  / \     / \  |</span>
<span class="go">| o   o   o   o |</span>
</pre></div>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">lst</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="p">[</span><span class="n">bt</span> <span class="k">for</span> <span class="n">bt</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="n">bt</span><span class="o">.</span><span class="n">is_perfect</span><span class="p">()]</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span> <span class="n">ascii_art</span><span class="p">(</span><span class="n">lst</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="c1"># long time</span>
<span class="go">[  ]</span>
<span class="go">[ o ]</span>
<span class="go">[  ]</span>
<span class="go">[   o   ]</span>
<span class="go">[  / \  ]</span>
<span class="go">[ o   o ]</span>
<span class="go">[  ]</span>
<span class="go">[  ]</span>
<span class="go">[  ]</span>
<span class="go">[     __o__     ]</span>
<span class="go">[    /     \    ]</span>
<span class="go">[   o       o   ]</span>
<span class="go">[  / \     / \  ]</span>
<span class="go">[ o   o   o   o ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.left_border_symmetry">
<span class="sig-name descname"><span class="pre">left_border_symmetry</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.left_border_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tree where a symmetry has been applied recursively on
all left borders. If a tree is made of three trees <span class="math notranslate nohighlight">\([T_1, T_2,
T_3]\)</span> on its left border, it becomes <span class="math notranslate nohighlight">\([T_3', T_2', T_1']\)</span> where
same symmetry has been applied to <span class="math notranslate nohighlight">\(T_1, T_2, T_3\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">left_border_symmetry</span><span class="p">()</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">left_border_symmetry</span><span class="p">()</span>
<span class="go">[., .]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,[]],</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">left_border_symmetry</span><span class="p">()</span>
<span class="go">[[., .], [., .]]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,[</span><span class="kc">None</span><span class="p">,[]]],</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">left_border_symmetry</span><span class="p">()</span>
<span class="go">[[., .], [., [., .]]]</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,[</span><span class="kc">None</span><span class="p">,[]]],</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bt</span>
<span class="go">4[1[., 2[., 3[., .]]], .]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">left_border_symmetry</span><span class="p">()</span>
<span class="go">1[4[., .], 2[., 3[., .]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.left_children_node_number">
<span class="sig-name descname"><span class="pre">left_children_node_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'left'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.left_children_node_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of nodes which are left children in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Every node (except the root) is either the left child or the
right child of its parent node. The total number of nodes
is <span class="math notranslate nohighlight">\(1\)</span> plus the number of left-children nodes plus the number of
right-children nodes.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">direction</span></code> – either <code class="docutils literal notranslate"><span class="pre">'left'</span></code> (default) or <code class="docutils literal notranslate"><span class="pre">'right'</span></code> ; if
set to <code class="docutils literal notranslate"><span class="pre">'right'</span></code>, instead count nodes that are right children</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,[[],[]]],[</span><span class="kc">None</span><span class="p">,[[],</span><span class="kc">None</span><span class="p">]]])</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">bt</span><span class="p">)</span>
<span class="go">  __o__</span>
<span class="go"> /     \</span>
<span class="go">o       o</span>
<span class="go"> \       \</span>
<span class="go">  o       o</span>
<span class="go"> / \     /</span>
<span class="go">o   o   o</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">left_children_node_number</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">left_children_node_number</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">4</span>

<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span><span class="mi">5</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">bt</span><span class="o">.</span><span class="n">left_children_node_number</span><span class="p">()</span>
<span class="gp">....: </span>           <span class="o">+</span> <span class="n">bt</span><span class="o">.</span><span class="n">left_children_node_number</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">bt</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.left_right_symmetry">
<span class="sig-name descname"><span class="pre">left_right_symmetry</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.left_right_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the left-right symmetrized tree of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">left_right_symmetry</span><span class="p">()</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">left_right_symmetry</span><span class="p">()</span>
<span class="go">[., .]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">left_right_symmetry</span><span class="p">()</span>
<span class="go">[., [., .]]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,</span> <span class="p">[]],</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">left_right_symmetry</span><span class="p">()</span>
<span class="go">[., [[., .], .]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.left_rotate">
<span class="sig-name descname"><span class="pre">left_rotate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.left_rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of left rotation applied to the binary
tree <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Left rotation on binary trees is defined as follows:
Let <span class="math notranslate nohighlight">\(T\)</span> be a binary tree such that the right child of the
root of <span class="math notranslate nohighlight">\(T\)</span> is a node. Let <span class="math notranslate nohighlight">\(A\)</span> be the left
child of the root of <span class="math notranslate nohighlight">\(T\)</span>, and let <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(C\)</span> be the
left and right children of the right child of the root
of <span class="math notranslate nohighlight">\(T\)</span>. (Keep in mind that nodes of trees are identified
with the subtrees consisting of their descendants.)
Then, the left rotation of <span class="math notranslate nohighlight">\(T\)</span> is the binary tree in
which the right child of the root is <span class="math notranslate nohighlight">\(C\)</span>, whereas
the left child of the root is a node whose left and right
children are <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>. In pictures:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|   *                        *   |</span>
<span class="go">|  / \                      / \  |</span>
<span class="go">| A   *  -left-rotate-&gt;    *   C |</span>
<span class="go">|    / \                  / \    |</span>
<span class="go">|   B   C                A   B   |</span>
</pre></div>
</div>
<p>where asterisks signify a single node each (but <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span>
and <span class="math notranslate nohighlight">\(C\)</span> might be empty).</p>
<p>For example,</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|   _o_                        o |</span>
<span class="go">|  /   \                      /  |</span>
<span class="go">| o     o  -left-rotate-&gt;    o   |</span>
<span class="go">|      /                    / \  |</span>
<span class="go">|     o                    o   o |</span>
<span class="go">&lt;BLANKLINE&gt;</span>
<span class="go">|       __o__                            o |</span>
<span class="go">|      /     \                          /  |</span>
<span class="go">|     o       o  -left-rotate-&gt;        o   |</span>
<span class="go">|    / \                              /    |</span>
<span class="go">|   o   o                            o     |</span>
<span class="go">|  /     \                          / \    |</span>
<span class="go">| o       o                        o   o   |</span>
<span class="go">|                                 /     \  |</span>
<span class="go">|                                o       o |</span>
</pre></div>
</div>
<p>Left rotation is the inverse operation to right rotation
(<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.right_rotate" title="sage.combinat.binary_tree.BinaryTree.right_rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">right_rotate()</span></code></a>).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.right_rotate" title="sage.combinat.binary_tree.BinaryTree.right_rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">right_rotate()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[[],</span><span class="kc">None</span><span class="p">]]);</span> <span class="n">ascii_art</span><span class="p">([</span><span class="n">b</span><span class="p">])</span>
<span class="go">[   _o_   ]</span>
<span class="go">[  /   \  ]</span>
<span class="go">[ o     o ]</span>
<span class="go">[      /  ]</span>
<span class="go">[     o   ]</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">left_rotate</span><span class="p">()])</span>
<span class="go">[     o ]</span>
<span class="go">[    /  ]</span>
<span class="go">[   o   ]</span>
<span class="go">[  / \  ]</span>
<span class="go">[ o   o ]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">left_rotate</span><span class="p">()</span><span class="o">.</span><span class="n">right_rotate</span><span class="p">()</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.make_leaf">
<span class="sig-name descname"><span class="pre">make_leaf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.make_leaf" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <code class="docutils literal notranslate"><span class="pre">self</span></code> so that it becomes a leaf (i. e., an empty tree).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">self</span></code> must be in a mutable state.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.make_node" title="sage.combinat.binary_tree.BinaryTree.make_node"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_node</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">make_leaf</span><span class="p">()</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: object is immutable; please change a copy instead.</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">t</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t1</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="n">t1</span><span class="o">.</span><span class="n">make_leaf</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span><span class="p">,</span> <span class="n">t1</span>
<span class="go">([., .], .)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.make_node">
<span class="sig-name descname"><span class="pre">make_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">child_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[None,</span> <span class="pre">None]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.make_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify <code class="docutils literal notranslate"><span class="pre">self</span></code> so that it becomes a node with children <code class="docutils literal notranslate"><span class="pre">child_list</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">child_list</span></code> – a pair of binary trees (or objects convertible to)</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">self</span></code> must be in a mutable state.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.make_leaf" title="sage.combinat.binary_tree.BinaryTree.make_leaf"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_leaf</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">make_node</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: object is immutable; please change a copy instead.</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">t</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t1</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="n">t1</span><span class="o">.</span><span class="n">make_node</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t</span><span class="p">,</span> <span class="n">t1</span>
<span class="go">(., [., .])</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">t</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="n">t</span><span class="o">.</span><span class="n">make_node</span><span class="p">([</span><span class="n">BinaryTree</span><span class="p">(),</span> <span class="n">BinaryTree</span><span class="p">(),</span> <span class="n">BinaryTree</span><span class="p">([])])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the list must have length 2</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">t1</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t2</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="n">t2</span><span class="o">.</span><span class="n">make_node</span><span class="p">([</span><span class="n">t1</span><span class="p">,</span> <span class="n">t1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="k">with</span> <span class="n">t2</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">as</span> <span class="n">t3</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="n">t3</span><span class="o">.</span><span class="n">make_node</span><span class="p">([</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span>
<span class="go">([., .], [[., .], [., .]], [[., .], [[., .], [., .]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.over">
<span class="sig-name descname"><span class="pre">over</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.over" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">self</span></code> over <code class="docutils literal notranslate"><span class="pre">bt</span></code>, where “over” is the <code class="docutils literal notranslate"><span class="pre">over</span></code>
(<span class="math notranslate nohighlight">\(/\)</span>) operation.</p>
<p>If <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(T'\)</span> are two binary trees, then <span class="math notranslate nohighlight">\(T\)</span> over <span class="math notranslate nohighlight">\(T'\)</span>
(written <span class="math notranslate nohighlight">\(T / T'\)</span>) is defined as the tree obtained by grafting
<span class="math notranslate nohighlight">\(T'\)</span> on the rightmost leaf of <span class="math notranslate nohighlight">\(T\)</span>. More precisely, <span class="math notranslate nohighlight">\(T / T'\)</span> is
defined by identifying the root of the <span class="math notranslate nohighlight">\(T'\)</span> with the rightmost
leaf of <span class="math notranslate nohighlight">\(T\)</span>. See section 4.5 of <a class="reference internal" href="../../../references/index.html#hnt2005" id="id2"><span>[HNT2005]</span></a>.</p>
<p>If <span class="math notranslate nohighlight">\(T\)</span> is empty, then <span class="math notranslate nohighlight">\(T / T' = T'\)</span>.</p>
<p>The definition of this “over” operation goes back to
Loday-Ronco <a class="reference internal" href="../../../references/index.html#lr0102066" id="id3"><span>[LR0102066]</span></a> (Definition 2.2), but it is
denoted by <span class="math notranslate nohighlight">\(\backslash\)</span> and called the “under” operation there.
In fact, trees in sage have their root at the top, contrary to
the trees in <a class="reference internal" href="../../../references/index.html#lr0102066" id="id4"><span>[LR0102066]</span></a> which are growing upwards. For
this reason, the names of the over and under operations are
swapped, in order to keep a graphical meaning.
(Our notation follows that of section 4.5 of <a class="reference internal" href="../../../references/index.html#hnt2005" id="id5"><span>[HNT2005]</span></a>.)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.under" title="sage.combinat.binary_tree.BinaryTree.under"><code class="xref py py-meth docutils literal notranslate"><span class="pre">under()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<p>Showing only the nodes of a binary tree, here is an
example for the over operation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|   o       __o__       _o_         |</span>
<span class="go">|  / \  /  /     \  =  /   \        |</span>
<span class="go">| o   o   o       o   o     o       |</span>
<span class="go">|          \     /           \      |</span>
<span class="go">|           o   o           __o__   |</span>
<span class="go">|                          /     \  |</span>
<span class="go">|                         o       o |</span>
<span class="go">|                          \     /  |</span>
<span class="go">|                           o   o   |</span>
</pre></div>
</div>
<p>A Sage example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">b1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[[],[]]])</span>
<span class="gp">sage: </span><span class="n">b2</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,</span> <span class="p">[]],[]])</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">((</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b1</span><span class="o">/</span><span class="n">b2</span><span class="p">))</span>
<span class="go">(   _o_    ,   _o_  ,   _o_           )</span>
<span class="go">(  /   \      /   \    /   \          )</span>
<span class="go">( o     o    o     o  o     o_        )</span>
<span class="go">(      / \    \            /  \       )</span>
<span class="go">(     o   o    o          o    o      )</span>
<span class="go">(                               \     )</span>
<span class="go">(                               _o_   )</span>
<span class="go">(                              /   \  )</span>
<span class="go">(                             o     o )</span>
<span class="go">(                              \      )</span>
<span class="go">(                               o     )</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.over_decomposition">
<span class="sig-name descname"><span class="pre">over_decomposition</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.over_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique maximal decomposition as an over product.</p>
<p>This means that the tree is cut along all edges of its rightmost path.</p>
<p>Beware that the factors are ordered starting from the root.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.comb" title="sage.combinat.binary_tree.BinaryTree.comb"><code class="xref py py-meth docutils literal notranslate"><span class="pre">comb()</span></code></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.under_decomposition" title="sage.combinat.binary_tree.BinaryTree.under_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">under_decomposition()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([])</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">g</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[., [., .]]</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">under</span><span class="p">(</span><span class="n">g</span><span class="p">);</span> <span class="n">l</span>
<span class="go">[[., .], .]</span>
<span class="gp">sage: </span><span class="n">r</span><span class="o">.</span><span class="n">over_decomposition</span><span class="p">()</span>
<span class="go">[[., .], [., .]]</span>
<span class="gp">sage: </span><span class="n">l</span><span class="o">.</span><span class="n">over_decomposition</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span><span class="n">l</span><span class="p">]</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go"> o</span>
<span class="go">                _o_</span>
<span class="go"> /               o     o</span>
<span class="go">     /                 o   o</span>
<span class="go">                               o</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">over_decomposition</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span><span class="n">g</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">g</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.prune">
<span class="sig-name descname"><span class="pre">prune</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the binary tree obtained by deleting each leaf of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The operation of pruning is the left inverse of attaching as
many leaves as possible to each node of a binary tree.
That is to say, for all binary trees <code class="docutils literal notranslate"><span class="pre">bt</span></code>, we have:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">bt == bt.to_full().prune()</span>
</pre></div>
</div>
<p>However, it is only a right inverse if and only if <code class="docutils literal notranslate"><span class="pre">bt</span></code>
is a full binary tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">bt == bt.prune().to_full()</span>
</pre></div>
</div>
<p>OUTPUT:</p>
<p>A binary tree.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.to_full" title="sage.combinat.binary_tree.BinaryTree.to_full"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_full()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[</span><span class="kc">None</span><span class="p">,</span> <span class="p">[]],</span> <span class="p">[[],</span> <span class="p">[]]],</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">bt</span><span class="p">)</span>
<span class="go">      o</span>
<span class="go">     /</span>
<span class="go">  __o__</span>
<span class="go"> /     \</span>
<span class="go">o       o</span>
<span class="go"> \     / \</span>
<span class="go">  o   o   o</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">bt</span><span class="o">.</span><span class="n">prune</span><span class="p">())</span>
<span class="go">    o</span>
<span class="go">   /</span>
<span class="go">  o</span>
<span class="go"> / \</span>
<span class="go">o   o</span>
</pre></div>
</div>
<p>We check the relationship with <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.to_full" title="sage.combinat.binary_tree.BinaryTree.to_full"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_full()</span></code></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="p">[]],</span> <span class="p">[]]],</span> <span class="p">[[],[]]])</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">==</span> <span class="n">bt</span><span class="o">.</span><span class="n">to_full</span><span class="p">()</span><span class="o">.</span><span class="n">prune</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">==</span> <span class="n">bt</span><span class="o">.</span><span class="n">prune</span><span class="p">()</span><span class="o">.</span><span class="n">to_full</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[]],</span> <span class="p">[[],</span> <span class="p">[[[],</span> <span class="p">[]],</span> <span class="p">[]]]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">is_full</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">==</span> <span class="n">bt</span><span class="o">.</span><span class="n">prune</span><span class="p">()</span><span class="o">.</span><span class="n">to_full</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Pruning the empty tree is again the empty tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">prune</span><span class="p">()</span>
<span class="go">.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.q_hook_length_fraction">
<span class="sig-name descname"><span class="pre">q_hook_length_fraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.q_hook_length_fraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the <code class="docutils literal notranslate"><span class="pre">q</span></code>-hook length fraction of the binary tree <code class="docutils literal notranslate"><span class="pre">self</span></code>,
with an additional “q-factor” if desired.</p>
<p>If <span class="math notranslate nohighlight">\(T\)</span> is a (plane) binary tree and <span class="math notranslate nohighlight">\(q\)</span> is a polynomial
indeterminate over some ring, then the <span class="math notranslate nohighlight">\(q\)</span>-hook length fraction
<span class="math notranslate nohighlight">\(h_{q} (T)\)</span> of <span class="math notranslate nohighlight">\(T\)</span> is defined by</p>
<div class="math notranslate nohighlight">
\[h_{q} (T)
= \frac{[\lvert T \rvert]_q!}{\prod_{t \in T}
[\lvert T_t \rvert]_q},\]</div>
<p>where the product ranges over all nodes <span class="math notranslate nohighlight">\(t\)</span> of <span class="math notranslate nohighlight">\(T\)</span>, where <span class="math notranslate nohighlight">\(T_t\)</span>
denotes the subtree of <span class="math notranslate nohighlight">\(T\)</span> consisting of <span class="math notranslate nohighlight">\(t\)</span> and its all
descendants, and where for every tree <span class="math notranslate nohighlight">\(S\)</span>, we denote by
<span class="math notranslate nohighlight">\(\lvert S \rvert\)</span> the number of nodes of <span class="math notranslate nohighlight">\(S\)</span>. While this
definition only shows that <span class="math notranslate nohighlight">\(h_{q} (T)\)</span> is a rational function
in <span class="math notranslate nohighlight">\(T\)</span>, it is in fact easy to show that <span class="math notranslate nohighlight">\(h_{q} (T)\)</span> is
actually a polynomial in <span class="math notranslate nohighlight">\(T\)</span>, and thus makes sense when any
element of a commutative ring is substituted for <span class="math notranslate nohighlight">\(q\)</span>.
This can also be explicitly seen from the following recursive
formula for <span class="math notranslate nohighlight">\(h_{q} (T)\)</span>:</p>
<div class="math notranslate nohighlight">
\[h_{q} (T)
= \binom{ \lvert T \rvert - 1 }{ \lvert T_1 \rvert }_q
h_{q} (T_1) h_{q} (T_2),\]</div>
<p>where <span class="math notranslate nohighlight">\(T\)</span> is any nonempty binary tree, and <span class="math notranslate nohighlight">\(T_1\)</span> and <span class="math notranslate nohighlight">\(T_2\)</span> are
the two child trees of the root of <span class="math notranslate nohighlight">\(T\)</span>, and where
<span class="math notranslate nohighlight">\(\binom{a}{b}_q\)</span> denotes a <span class="math notranslate nohighlight">\(q\)</span>-binomial coefficient.</p>
<p>A variation of the <span class="math notranslate nohighlight">\(q\)</span>-hook length fraction is the following
“<span class="math notranslate nohighlight">\(q\)</span>-hook length fraction with <span class="math notranslate nohighlight">\(q\)</span>-factor”:</p>
<div class="math notranslate nohighlight">
\[f_{q} (T)
= h_{q} (T) \cdot
\prod_{t \in T} q^{\lvert T_{\mathrm{right}(t)} \rvert},\]</div>
<p>where for every node <span class="math notranslate nohighlight">\(t\)</span>, we denote by <span class="math notranslate nohighlight">\(\mathrm{right}(t)\)</span> the
right child of <span class="math notranslate nohighlight">\(t\)</span>.
This <span class="math notranslate nohighlight">\(f_{q} (T)\)</span> differs from <span class="math notranslate nohighlight">\(h_{q} (T)\)</span> only in a
multiplicative factor, which is a power of <span class="math notranslate nohighlight">\(q\)</span>.</p>
<p>When <span class="math notranslate nohighlight">\(q = 1\)</span>, both <span class="math notranslate nohighlight">\(f_{q} (T)\)</span> and <span class="math notranslate nohighlight">\(h_{q} (T)\)</span> equal the number
of permutations whose binary search tree (see <a class="reference internal" href="../../../references/index.html#hnt2005" id="id6"><span>[HNT2005]</span></a> for the
definition) is <span class="math notranslate nohighlight">\(T\)</span> (after dropping the labels). For example,
there are <span class="math notranslate nohighlight">\(20\)</span> permutations which give a binary tree of the
following shape:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|     __o__   |</span>
<span class="go">|    /     \  |</span>
<span class="go">|   o       o |</span>
<span class="go">|  / \     /  |</span>
<span class="go">| o   o   o   |</span>
</pre></div>
</div>
<p>by the binary search insertion algorithm, in accordance with
the fact that this tree satisfies <span class="math notranslate nohighlight">\(f_{1} (T) = 20\)</span>.</p>
<p>When <span class="math notranslate nohighlight">\(q\)</span> is considered as a polynomial indeterminate,
<span class="math notranslate nohighlight">\(f_{q} (T)\)</span> is the generating function for all permutations
whose binary search tree is <span class="math notranslate nohighlight">\(T\)</span> (after dropping the labels)
with respect to the number of inversions (i. e., the Coxeter
length) of the permutations.</p>
<p>Objects similar to <span class="math notranslate nohighlight">\(h_{q} (T)\)</span> also make sense for general
ordered forests (rather than just binary trees), see e. g.
<a class="reference internal" href="../../../references/index.html#bw1988" id="id7"><span>[BW1988]</span></a>, Theorem 9.1.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> – a ring element which is to be substituted as <span class="math notranslate nohighlight">\(q\)</span>
into the <span class="math notranslate nohighlight">\(q\)</span>-hook length fraction (by default, this is
set to be the indeterminate <span class="math notranslate nohighlight">\(q\)</span> in the polynomial ring
<span class="math notranslate nohighlight">\(\ZZ[q]\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q_factor</span></code> – a Boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) which
determines whether to compute <span class="math notranslate nohighlight">\(h_{q} (T)\)</span> or to
compute <span class="math notranslate nohighlight">\(f_{q} (T)\)</span> (namely, <span class="math notranslate nohighlight">\(h_{q} (T)\)</span> is obtained when
<code class="docutils literal notranslate"><span class="pre">q_factor</span> <span class="pre">==</span> <span class="pre">False</span></code>, and <span class="math notranslate nohighlight">\(f_{q} (T)\)</span> is obtained when
<code class="docutils literal notranslate"><span class="pre">q_factor</span> <span class="pre">==</span> <span class="pre">True</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Let us start with a simple example. Actually, let us start
with the easiest possible example – the binary tree with
only one vertex (which is a leaf):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">(</span><span class="n">q_factor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Nothing different for a tree with one node and two leaves:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([]);</span> <span class="n">b</span>
<span class="go">[., .]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">(</span><span class="n">q_factor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Let us get to a more interesting tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],[]],[[],</span><span class="kc">None</span><span class="p">]]);</span> <span class="n">b</span>
<span class="go">[[[., .], [., .]], [[., .], .]]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">()(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">20</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">()</span>
<span class="go">q^7 + 2*q^6 + 3*q^5 + 4*q^4 + 4*q^3 + 3*q^2 + 2*q + 1</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">(</span><span class="n">q_factor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">q^10 + 2*q^9 + 3*q^8 + 4*q^7 + 4*q^6 + 3*q^5 + 2*q^4 + q^3</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">465</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">q_factor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">3720</span>
<span class="gp">sage: </span><span class="n">q</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="s1">&#39;q&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">q^14 + 2*q^12 + 3*q^10 + 4*q^8 + 4*q^6 + 3*q^4 + 2*q^2 + 1</span>
</pre></div>
</div>
<p>Let us check the fact that <span class="math notranslate nohighlight">\(f_{q} (T)\)</span> is the generating function
for all permutations whose binary search tree is <span class="math notranslate nohighlight">\(T\)</span> (after
dropping the labels) with respect to the number of inversions of
the permutations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">q_hook_length_fraction_2</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">P</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">ZZ</span><span class="p">,</span> <span class="s1">&#39;q&#39;</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="n">q</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">res</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">sylvester_class</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">res</span> <span class="o">+=</span> <span class="n">q</span> <span class="o">**</span> <span class="n">Permutation</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">length</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">res</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_genfun</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span> <span class="n">q_hook_length_fraction_2</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="gp">....: </span>                <span class="o">==</span> <span class="n">T</span><span class="o">.</span><span class="n">q_hook_length_fraction</span><span class="p">(</span><span class="n">q_factor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">....: </span>                <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">test_genfun</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.right_rotate">
<span class="sig-name descname"><span class="pre">right_rotate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.right_rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of right rotation applied to the binary
tree <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Right rotation on binary trees is defined as follows:
Let <span class="math notranslate nohighlight">\(T\)</span> be a binary tree such that the left child of the
root of <span class="math notranslate nohighlight">\(T\)</span> is a node. Let <span class="math notranslate nohighlight">\(C\)</span> be the right
child of the root of <span class="math notranslate nohighlight">\(T\)</span>, and let <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> be the
left and right children of the left child of the root
of <span class="math notranslate nohighlight">\(T\)</span>. (Keep in mind that nodes of trees are identified
with the subtrees consisting of their descendants.)
Then, the right rotation of <span class="math notranslate nohighlight">\(T\)</span> is the binary tree in
which the left child of the root is <span class="math notranslate nohighlight">\(A\)</span>, whereas
the right child of the root is a node whose left and right
children are <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(C\)</span>. In pictures:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|     *                      *     |</span>
<span class="go">|    / \                    / \    |</span>
<span class="go">|   *   C -right-rotate-&gt;  A   *   |</span>
<span class="go">|  / \                        / \  |</span>
<span class="go">| A   B                      B   C |</span>
</pre></div>
</div>
<p>where asterisks signify a single node each (but <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span>
and <span class="math notranslate nohighlight">\(C\)</span> might be empty).</p>
<p>For example,</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|     o                     _o_   |</span>
<span class="go">|    /                     /   \  |</span>
<span class="go">|   o    -right-rotate-&gt;  o     o |</span>
<span class="go">|  / \                         /  |</span>
<span class="go">| o   o                       o   |</span>
<span class="go">&lt;BLANKLINE&gt;</span>
<span class="go">|       __o__                         _o__      |</span>
<span class="go">|      /     \                       /    \     |</span>
<span class="go">|     o       o  -right-rotate-&gt;    o     _o_   |</span>
<span class="go">|    / \                           /     /   \  |</span>
<span class="go">|   o   o                         o     o     o |</span>
<span class="go">|  /     \                               \      |</span>
<span class="go">| o       o                               o     |</span>
</pre></div>
</div>
<p>Right rotation is the inverse operation to left rotation
(<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.left_rotate" title="sage.combinat.binary_tree.BinaryTree.left_rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">left_rotate()</span></code></a>).</p>
<p>The right rotation operation introduced here is the one defined
in Definition 2.1 of <a class="reference internal" href="../../../references/index.html#cp2012" id="id8"><span>[CP2012]</span></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.left_rotate" title="sage.combinat.binary_tree.BinaryTree.left_rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">left_rotate()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],[]],</span> <span class="kc">None</span><span class="p">]);</span> <span class="n">ascii_art</span><span class="p">([</span><span class="n">b</span><span class="p">])</span>
<span class="go">[     o ]</span>
<span class="go">[    /  ]</span>
<span class="go">[   o   ]</span>
<span class="go">[  / \  ]</span>
<span class="go">[ o   o ]</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">right_rotate</span><span class="p">()])</span>
<span class="go">[   _o_   ]</span>
<span class="go">[  /   \  ]</span>
<span class="go">[ o     o ]</span>
<span class="go">[      /  ]</span>
<span class="go">[     o   ]</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[[],</span><span class="kc">None</span><span class="p">],[</span><span class="kc">None</span><span class="p">,[]]],</span> <span class="p">[]]);</span> <span class="n">ascii_art</span><span class="p">([</span><span class="n">b</span><span class="p">])</span>
<span class="go">[       __o__   ]</span>
<span class="go">[      /     \  ]</span>
<span class="go">[     o       o ]</span>
<span class="go">[    / \        ]</span>
<span class="go">[   o   o       ]</span>
<span class="go">[  /     \      ]</span>
<span class="go">[ o       o     ]</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">right_rotate</span><span class="p">()])</span>
<span class="go">[     _o__      ]</span>
<span class="go">[    /    \     ]</span>
<span class="go">[   o     _o_   ]</span>
<span class="go">[  /     /   \  ]</span>
<span class="go">[ o     o     o ]</span>
<span class="go">[        \      ]</span>
<span class="go">[         o     ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.show">
<span class="sig-name descname"><span class="pre">show</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">with_leaves</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the binary tree <code class="docutils literal notranslate"><span class="pre">show</span></code>, with or without leaves depending
on the Boolean keyword variable <code class="docutils literal notranslate"><span class="pre">with_leaves</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>For a labelled binary tree, the labels shown in the
picture are not (in general) the ones given by the
labelling!</p>
<p>Use <code class="xref py py-meth docutils literal notranslate"><span class="pre">_latex_()</span></code>, <code class="docutils literal notranslate"><span class="pre">view</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">_ascii_art_()</span></code> or <code class="docutils literal notranslate"><span class="pre">pretty_print</span></code> for more
faithful representations of the data of the tree.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.single_edge_cut_shapes">
<span class="sig-name descname"><span class="pre">single_edge_cut_shapes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.single_edge_cut_shapes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of possible single-edge cut shapes for the binary tree.</p>
<p>This is used in <a class="reference internal" href="interval_posets.html#sage.combinat.interval_posets.TamariIntervalPoset.is_new" title="sage.combinat.interval_posets.TamariIntervalPoset.is_new"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.combinat.interval_posets.TamariIntervalPoset.is_new()</span></code></a>.</p>
<p>OUTPUT:</p>
<p>a list of triples <span class="math notranslate nohighlight">\((m, i, n)\)</span> of integers</p>
<p>This is a list running over all inner edges (i.e., edges
joining two non-leaf vertices) of the binary tree. The removal
of each inner edge defines two binary trees (connected
components), the root-tree and the sub-tree. Thus, to every
inner edge, we can assign three positive integers:
<span class="math notranslate nohighlight">\(m\)</span> is the node number of the root-tree <span class="math notranslate nohighlight">\(R\)</span>, and <span class="math notranslate nohighlight">\(n\)</span> is
the node number of the sub-tree <span class="math notranslate nohighlight">\(S\)</span>. The integer <span class="math notranslate nohighlight">\(i\)</span> is the
index of the leaf of <span class="math notranslate nohighlight">\(R\)</span> on which <span class="math notranslate nohighlight">\(S\)</span> is grafted to obtain the
original tree. The leaves of <span class="math notranslate nohighlight">\(R\)</span> are numbered starting from
<span class="math notranslate nohighlight">\(1\)</span> (from left to right), hence <span class="math notranslate nohighlight">\(1 \leq i \leq m+1\)</span>.</p>
<p>In fact, each of <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(n\)</span> determines the other, as the
total node number of <span class="math notranslate nohighlight">\(R\)</span> and <span class="math notranslate nohighlight">\(S\)</span> is the node number of
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">single_edge_cut_shapes</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">BT</span><span class="p">]</span>
<span class="go">[[(2, 3, 1), (1, 2, 2)],</span>
<span class="go">[(2, 2, 1), (1, 2, 2)],</span>
<span class="go">[(2, 1, 1), (2, 3, 1)],</span>
<span class="go">[(2, 2, 1), (1, 1, 2)],</span>
<span class="go">[(2, 1, 1), (1, 1, 2)]]</span>

<span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">single_edge_cut_shapes</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">BT</span><span class="p">]</span>
<span class="go">[[(1, 2, 1)], [(1, 1, 1)]]</span>

<span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">single_edge_cut_shapes</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">BT</span><span class="p">]</span>
<span class="go">[[]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.sylvester_class">
<span class="sig-name descname"><span class="pre">sylvester_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_to_right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.sylvester_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the sylvester class corresponding to the binary tree
<code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The sylvester class of a tree <span class="math notranslate nohighlight">\(T\)</span> is the set of permutations
<span class="math notranslate nohighlight">\(\sigma\)</span> whose right-to-left binary search tree (a notion defined
in <a class="reference internal" href="../../../references/index.html#hnt2005" id="id9"><span>[HNT2005]</span></a>, Definition 7) is <span class="math notranslate nohighlight">\(T\)</span> after forgetting the labels.
This is an equivalence class of the sylvester congruence (the
congruence on words which holds two words <span class="math notranslate nohighlight">\(uacvbw\)</span> and <span class="math notranslate nohighlight">\(ucavbw\)</span>
congruent whenever <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span>, <span class="math notranslate nohighlight">\(c\)</span> are letters satisfying
<span class="math notranslate nohighlight">\(a \leq b &lt; c\)</span>, and extends by transitivity) on the symmetric
group.</p>
<p>For example the following tree’s sylvester class consists of the
permutations <span class="math notranslate nohighlight">\((1,3,2)\)</span> and <span class="math notranslate nohighlight">\((3,1,2)\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">[   o   ]</span>
<span class="go">[  / \  ]</span>
<span class="go">[ o   o ]</span>
</pre></div>
</div>
<p>(only the nodes are drawn here).</p>
<p>The right-to-left binary search tree of a word is constructed by
an RSK-like insertion algorithm which proceeds as follows: Start
with an empty labelled binary tree, and read the word from right
to left. Each time a letter is read from the word, insert this
letter in the existing tree using binary search tree insertion
(<a class="reference internal" href="#sage.combinat.binary_tree.LabelledBinaryTree.binary_search_insert" title="sage.combinat.binary_tree.LabelledBinaryTree.binary_search_insert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">binary_search_insert()</span></code></a>).
This is what the
<a class="reference internal" href="permutation.html#sage.combinat.permutation.Permutation.binary_search_tree" title="sage.combinat.permutation.Permutation.binary_search_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">binary_search_tree()</span></code></a>
method computes if it is given the keyword
<code class="docutils literal notranslate"><span class="pre">left_to_right=False</span></code>.</p>
<p>Here are two more descriptions of the sylvester class of a binary
search tree:</p>
<ul class="simple">
<li><p>The sylvester class of a binary search tree <span class="math notranslate nohighlight">\(T\)</span> is the set of
all linear extensions of the poset corresponding to <span class="math notranslate nohighlight">\(T\)</span> (that
is, of the poset whose Hasse diagram is <span class="math notranslate nohighlight">\(T\)</span>, with the root on
top), provided that the nodes of <span class="math notranslate nohighlight">\(T\)</span> are labelled with
<span class="math notranslate nohighlight">\(1, 2, \ldots, n\)</span> in a binary-search-tree way (i.e., every left
descendant of a node has a label smaller than that of the node,
and every right descendant of a node has a label higher than
that of the node).</p></li>
<li><p>The sylvester class of a binary search tree <span class="math notranslate nohighlight">\(T\)</span> (with vertex
labels <span class="math notranslate nohighlight">\(1, 2, \ldots, n\)</span>) is the interval <span class="math notranslate nohighlight">\([u, v]\)</span> in the right
permutohedron order
(<a class="reference internal" href="permutation.html#sage.combinat.permutation.Permutation.permutohedron_lequal" title="sage.combinat.permutation.Permutation.permutohedron_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">permutohedron_lequal()</span></code></a>),
where <span class="math notranslate nohighlight">\(u\)</span> is the 312-avoiding permutation corresponding to <span class="math notranslate nohighlight">\(T\)</span>
(<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.to_312_avoiding_permutation" title="sage.combinat.binary_tree.BinaryTree.to_312_avoiding_permutation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_312_avoiding_permutation()</span></code></a>), and where <span class="math notranslate nohighlight">\(v\)</span> is the
132-avoiding permutation corresponding to <span class="math notranslate nohighlight">\(T\)</span>
(<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.to_132_avoiding_permutation" title="sage.combinat.binary_tree.BinaryTree.to_132_avoiding_permutation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_132_avoiding_permutation()</span></code></a>).</p></li>
</ul>
<p>If the optional keyword variable <code class="docutils literal notranslate"><span class="pre">left_to_right</span></code> is set to
<code class="docutils literal notranslate"><span class="pre">True</span></code>, then the <em>left</em> sylvester class of <code class="docutils literal notranslate"><span class="pre">self</span></code> is
returned instead. This is the set of permutations <span class="math notranslate nohighlight">\(\sigma\)</span> whose
left-to-right binary search tree (that is, the result of the
<a class="reference internal" href="permutation.html#sage.combinat.permutation.Permutation.binary_search_tree" title="sage.combinat.permutation.Permutation.binary_search_tree"><code class="xref py py-meth docutils literal notranslate"><span class="pre">binary_search_tree()</span></code></a>
with <code class="docutils literal notranslate"><span class="pre">left_to_right</span></code> set to <code class="docutils literal notranslate"><span class="pre">True</span></code>) is <code class="docutils literal notranslate"><span class="pre">self</span></code>. It is an
equivalence class of the left sylvester congruence.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method yields the elements of the sylvester class as
raw lists, not as permutations!</p>
</div>
<p>EXAMPLES:</p>
<p>Verifying the claim that the right-to-left binary search trees of
the permutations in the sylvester class of a tree <span class="math notranslate nohighlight">\(t\)</span> all equal
<span class="math notranslate nohighlight">\(t\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_bst_of_sc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">left_to_right</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">sylvester_class</span><span class="p">(</span><span class="n">left_to_right</span><span class="o">=</span><span class="n">left_to_right</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="n">p_per</span> <span class="o">=</span> <span class="n">Permutation</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">....: </span>            <span class="n">tree</span> <span class="o">=</span> <span class="n">p_per</span><span class="o">.</span><span class="n">binary_search_tree</span><span class="p">(</span><span class="n">left_to_right</span><span class="o">=</span><span class="n">left_to_right</span><span class="p">)</span>
<span class="gp">....: </span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
<span class="gp">....: </span>                <span class="k">return</span> <span class="kc">False</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="kc">True</span>
<span class="gp">sage: </span><span class="n">test_bst_of_sc</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_bst_of_sc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>   <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The same with the left-to-right version of binary search:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">test_bst_of_sc</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_bst_of_sc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>   <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Checking that the sylvester class is the set of linear extensions
of the poset of the tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span><span class="n">sylvester_class</span><span class="p">())</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span><span class="n">to_poset</span><span class="p">()</span><span class="o">.</span><span class="n">linear_extensions</span><span class="p">())</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.tamari_greater">
<span class="sig-name descname"><span class="pre">tamari_greater</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_greater" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of all trees greater or equal to <code class="docutils literal notranslate"><span class="pre">self</span></code> in the Tamari
order.</p>
<p>This is the order filter of the Tamari order generated by <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>See <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_lequal()</span></code></a> for the definition of the Tamari poset.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_smaller" title="sage.combinat.binary_tree.BinaryTree.tamari_smaller"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_smaller()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<p>For example, the tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|     __o__   |</span>
<span class="go">|    /     \  |</span>
<span class="go">|   o       o |</span>
<span class="go">|  / \     /  |</span>
<span class="go">| o   o   o   |</span>
</pre></div>
</div>
<p>has these trees greater or equal to it:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|o          , o        , o        , o        ,  o       ,   o      ,|</span>
<span class="go">| \            \          \          \           \           \      |</span>
<span class="go">|  o            o          o           o         _o_        __o__   |</span>
<span class="go">|   \            \          \           \       /   \      /     \  |</span>
<span class="go">|    o            o          o          _o_    o     o    o       o |</span>
<span class="go">|     \            \        / \        /   \    \     \    \     /  |</span>
<span class="go">|      o            o      o   o      o     o    o     o    o   o   |</span>
<span class="go">|       \            \          \          /                        |</span>
<span class="go">|        o            o          o        o                         |</span>
<span class="go">|         \          /                                              |</span>
<span class="go">|          o        o                                               |</span>
<span class="go">&lt;BLANKLINE&gt;</span>
<span class="go">|   o        ,   o      ,   _o_      ,   _o__     ,   __o__    ,   ___o___  ,|</span>
<span class="go">|  / \          / \        /   \        /    \       /     \      /       \  |</span>
<span class="go">| o   o        o   o      o     o      o     _o_    o       o    o         o |</span>
<span class="go">|      \            \          / \          /   \    \       \    \       /  |</span>
<span class="go">|       o            o        o   o        o     o    o       o    o     o   |</span>
<span class="go">|        \            \            \            /      \            \        |</span>
<span class="go">|         o            o            o          o        o            o       |</span>
<span class="go">|          \          /                                                      |</span>
<span class="go">|           o        o                                                       |</span>
<span class="go">&lt;BLANKLINE&gt;</span>
<span class="go">|     _o_    ,     __o__  |</span>
<span class="go">|    /   \        /     \ |</span>
<span class="go">|   o     o      o       o|</span>
<span class="go">|  / \     \    / \     / |</span>
<span class="go">| o   o     o  o   o   o  |</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.tamari_interval">
<span class="sig-name descname"><span class="pre">tamari_interval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Tamari interval between <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> as a
<a class="reference internal" href="interval_posets.html#sage.combinat.interval_posets.TamariIntervalPoset" title="sage.combinat.interval_posets.TamariIntervalPoset"><code class="xref py py-class docutils literal notranslate"><span class="pre">TamariIntervalPoset</span></code></a>.</p>
<p>A “Tamari interval” is an interval in the Tamari poset.
See <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_lequal()</span></code></a> for the definition of the Tamari poset.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> – a binary tree greater or equal to <code class="docutils literal notranslate"><span class="pre">self</span></code>
in the Tamari order</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,</span> <span class="p">[[],</span> <span class="kc">None</span><span class="p">]],</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">ip</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">tamari_interval</span><span class="p">(</span><span class="n">BinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="p">[[</span><span class="kc">None</span><span class="p">,</span> <span class="p">[]],</span> <span class="kc">None</span><span class="p">]]));</span> <span class="n">ip</span>
<span class="go">The Tamari interval of size 4 induced by relations [(2, 4), (3, 4), (3, 1), (2, 1)]</span>
<span class="gp">sage: </span><span class="n">ip</span><span class="o">.</span><span class="n">lower_binary_tree</span><span class="p">()</span>
<span class="go">[[., [[., .], .]], .]</span>
<span class="gp">sage: </span><span class="n">ip</span><span class="o">.</span><span class="n">upper_binary_tree</span><span class="p">()</span>
<span class="go">[., [[., [., .]], .]]</span>
<span class="gp">sage: </span><span class="n">ip</span><span class="o">.</span><span class="n">interval_cardinality</span><span class="p">()</span>
<span class="go">4</span>
<span class="gp">sage: </span><span class="n">ip</span><span class="o">.</span><span class="n">number_of_tamari_inversions</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">ip</span><span class="o">.</span><span class="n">binary_trees</span><span class="p">())</span>
<span class="go">[[., [[., [., .]], .]],</span>
<span class="go"> [[., [., [., .]]], .],</span>
<span class="go"> [., [[[., .], .], .]],</span>
<span class="go"> [[., [[., .], .]], .]]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">tamari_interval</span><span class="p">(</span><span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,[]],[]]))</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the two binary trees are not comparable on the Tamari lattice</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.tamari_join">
<span class="sig-name descname"><span class="pre">tamari_join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_join" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the join of the binary trees <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>
(of equal size) in the <span class="math notranslate nohighlight">\(n\)</span>-th Tamari poset (where <span class="math notranslate nohighlight">\(n\)</span> is
the size of these trees).</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Tamari poset (defined in <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_lequal()</span></code></a>)
is known to be a lattice, and the map from the <span class="math notranslate nohighlight">\(n\)</span>-th
symmetric group <span class="math notranslate nohighlight">\(S_n\)</span> to the <span class="math notranslate nohighlight">\(n\)</span>-th Tamari poset defined
by sending every permutation <span class="math notranslate nohighlight">\(p \in S_n\)</span> to the binary
search tree of <span class="math notranslate nohighlight">\(p\)</span> (more precisely, to
<code class="docutils literal notranslate"><span class="pre">p.binary_search_tree_shape()</span></code>) is a lattice
homomorphism. (See Theorem 6.2 in <a class="reference internal" href="../../../references/index.html#rea2004" id="id10"><span>[Rea2004]</span></a>.)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_lequal()</span></code></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_meet" title="sage.combinat.binary_tree.BinaryTree.tamari_meet"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_meet()</span></code></a>.</p>
</div>
<p>AUTHORS:</p>
<p>Viviane Pons and Darij Grinberg, 18 June 2014;
Frédéric Chapoton, 9 January 2018.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="p">[[],</span> <span class="kc">None</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,</span> <span class="p">[]],</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="kc">None</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">e</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">b1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="p">[[[],</span> <span class="kc">None</span><span class="p">],</span> <span class="kc">None</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">b2</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">b1</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">b2</span><span class="p">)</span>
<span class="go">[., [[., .], [., .]]]</span>
<span class="gp">sage: </span><span class="n">b3</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[[],</span> <span class="kc">None</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">b1</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">b3</span><span class="p">)</span>
<span class="go">[., [., [[., .], .]]]</span>
<span class="gp">sage: </span><span class="n">b2</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">b3</span><span class="p">)</span>
<span class="go">[[., .], [., [., .]]]</span>
</pre></div>
</div>
<p>The universal property of the meet operation is
satisfied:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_uni_join</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">j</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">tamari_lequal</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="kc">False</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">q</span><span class="o">.</span><span class="n">tamari_lequal</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="kc">False</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">tamari_greater</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">tamari_lequal</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">j</span><span class="o">.</span><span class="n">tamari_lequal</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="kc">False</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="kc">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">test_uni_join</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">();</span> <span class="n">q</span> <span class="o">=</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">();</span> <span class="n">test_uni_join</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Border cases:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([])</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_join</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">[., .]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.tamari_lequal">
<span class="sig-name descname"><span class="pre">tamari_lequal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">self</span></code> is less or equal to another binary
tree <code class="docutils literal notranslate"><span class="pre">t2</span></code> (of the same size as <code class="docutils literal notranslate"><span class="pre">self</span></code>) in the Tamari order.</p>
<p>The Tamari order on binary trees of size <span class="math notranslate nohighlight">\(n\)</span> is the partial order
on the set of all binary trees of size <span class="math notranslate nohighlight">\(n\)</span> generated by the
following requirement:  If a binary tree <span class="math notranslate nohighlight">\(T'\)</span> is obtained by
right rotation (see <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.right_rotate" title="sage.combinat.binary_tree.BinaryTree.right_rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">right_rotate()</span></code></a>) from a binary tree <span class="math notranslate nohighlight">\(T\)</span>,
then <span class="math notranslate nohighlight">\(T &lt; T'\)</span>.
This not only is a well-defined partial order, but actually is
a lattice structure on the set of binary trees of size <span class="math notranslate nohighlight">\(n\)</span>, and
is a quotient of the weak order on the <span class="math notranslate nohighlight">\(n\)</span>-th symmetric group
(also known as the right permutohedron order, see
<a class="reference internal" href="permutation.html#sage.combinat.permutation.Permutation.permutohedron_lequal" title="sage.combinat.permutation.Permutation.permutohedron_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">permutohedron_lequal()</span></code></a>).
See <a class="reference internal" href="../../../references/index.html#cp2012" id="id11"><span>[CP2012]</span></a>. The set of binary trees of size <span class="math notranslate nohighlight">\(n\)</span> equipped with
the Tamari order is called the <span class="math notranslate nohighlight">\(n\)</span>-th Tamari poset.</p>
<p>The Tamari order can equivalently be defined as follows:</p>
<p>If <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(S\)</span> are two binary trees of size <span class="math notranslate nohighlight">\(n\)</span>, then the
following four statements are equivalent:</p>
<ul class="simple">
<li><p>We have <span class="math notranslate nohighlight">\(T \leq S\)</span> in the Tamari order.</p></li>
<li><p>There exist elements <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(s\)</span> of the Sylvester classes
(<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.sylvester_class" title="sage.combinat.binary_tree.BinaryTree.sylvester_class"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sylvester_class()</span></code></a>) of <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(S\)</span>, respectively,
such that <span class="math notranslate nohighlight">\(t \leq s\)</span> in the weak order on the symmetric
group.</p></li>
<li><p>The 132-avoiding permutation corresponding to <span class="math notranslate nohighlight">\(T\)</span> (see
<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.to_132_avoiding_permutation" title="sage.combinat.binary_tree.BinaryTree.to_132_avoiding_permutation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_132_avoiding_permutation()</span></code></a>) is <span class="math notranslate nohighlight">\(\leq\)</span> to the
132-avoiding permutation corresponding to <span class="math notranslate nohighlight">\(S\)</span> in the weak
order on the symmetric group.</p></li>
<li><p>The 312-avoiding permutation corresponding to <span class="math notranslate nohighlight">\(T\)</span> (see
<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.to_312_avoiding_permutation" title="sage.combinat.binary_tree.BinaryTree.to_312_avoiding_permutation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_312_avoiding_permutation()</span></code></a>) is <span class="math notranslate nohighlight">\(\leq\)</span> to the
312-avoiding permutation corresponding to <span class="math notranslate nohighlight">\(S\)</span> in the weak
order on the symmetric group.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_smaller" title="sage.combinat.binary_tree.BinaryTree.tamari_smaller"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_smaller()</span></code></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_greater" title="sage.combinat.binary_tree.BinaryTree.tamari_greater"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_greater()</span></code></a>,
<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_pred" title="sage.combinat.binary_tree.BinaryTree.tamari_pred"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_pred()</span></code></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_succ" title="sage.combinat.binary_tree.BinaryTree.tamari_succ"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_succ()</span></code></a>,
<a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_interval" title="sage.combinat.binary_tree.BinaryTree.tamari_interval"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_interval()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<p>This tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|       o    |</span>
<span class="go">|      / \   |</span>
<span class="go">|     o   o  |</span>
<span class="go">|    /       |</span>
<span class="go">|   o        |</span>
<span class="go">|  / \       |</span>
<span class="go">| o   o      |</span>
</pre></div>
</div>
<p>is Tamari-<span class="math notranslate nohighlight">\(\leq\)</span> to the following tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|     _o_     |</span>
<span class="go">|    /   \    |</span>
<span class="go">|   o     o   |</span>
<span class="go">|  / \     \  |</span>
<span class="go">| o   o     o |</span>
</pre></div>
</div>
<p>Checking this:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[[],</span> <span class="p">[]],</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],[]],[</span><span class="kc">None</span><span class="p">,[]]])</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_lequal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.tamari_meet">
<span class="sig-name descname"><span class="pre">tamari_meet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'right'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_meet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the meet of the binary trees <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>
(of equal size) in the <span class="math notranslate nohighlight">\(n\)</span>-th Tamari poset (where <span class="math notranslate nohighlight">\(n\)</span> is
the size of these trees).</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Tamari poset (defined in <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_lequal()</span></code></a>)
is known to be a lattice, and the map from the <span class="math notranslate nohighlight">\(n\)</span>-th
symmetric group <span class="math notranslate nohighlight">\(S_n\)</span> to the <span class="math notranslate nohighlight">\(n\)</span>-th Tamari poset defined
by sending every permutation <span class="math notranslate nohighlight">\(p \in S_n\)</span> to the binary
search tree of <span class="math notranslate nohighlight">\(p\)</span> (more precisely, to
<code class="docutils literal notranslate"><span class="pre">p.binary_search_tree_shape()</span></code>) is a lattice
homomorphism. (See Theorem 6.2 in <a class="reference internal" href="../../../references/index.html#rea2004" id="id12"><span>[Rea2004]</span></a>.)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_lequal()</span></code></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_join" title="sage.combinat.binary_tree.BinaryTree.tamari_join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_join()</span></code></a>.</p>
</div>
<p>AUTHORS:</p>
<p>Viviane Pons and Darij Grinberg, 18 June 2014.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="p">[[],</span> <span class="kc">None</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">c</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,</span> <span class="p">[]],</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">d</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="kc">None</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">c</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">c</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">c</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">d</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">d</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">d</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">d</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">e</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">b1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="p">[[[],</span> <span class="kc">None</span><span class="p">],</span> <span class="kc">None</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">b2</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="kc">None</span><span class="p">],</span> <span class="p">[]])</span>
<span class="gp">sage: </span><span class="n">b1</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">b2</span><span class="p">)</span>
<span class="go">[[[[., .], .], .], .]</span>
<span class="gp">sage: </span><span class="n">b3</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],</span> <span class="p">[[],</span> <span class="kc">None</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">b1</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">b3</span><span class="p">)</span>
<span class="go">[[[[., .], .], .], .]</span>
<span class="gp">sage: </span><span class="n">b2</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">b3</span><span class="p">)</span>
<span class="go">[[[[., .], .], .], .]</span>
</pre></div>
</div>
<p>The universal property of the meet operation is
satisfied:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_uni_meet</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">tamari_lequal</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="kc">False</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">tamari_lequal</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="kc">False</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">tamari_smaller</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">tamari_lequal</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">tamari_lequal</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="kc">False</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="kc">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">test_uni_meet</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">();</span> <span class="n">q</span> <span class="o">=</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">();</span> <span class="n">test_uni_meet</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Border cases:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([])</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">tamari_meet</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">[., .]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.tamari_pred">
<span class="sig-name descname"><span class="pre">tamari_pred</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_pred" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the list of predecessors of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the Tamari poset.</p>
<p>This list is computed by performing all left rotates possible on
its nodes.</p>
<p>See <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_lequal()</span></code></a> for the definition of the Tamari poset.</p>
<p>EXAMPLES:</p>
<p>For this tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|     __o__   |</span>
<span class="go">|    /     \  |</span>
<span class="go">|   o       o |</span>
<span class="go">|  / \     /  |</span>
<span class="go">| o   o   o   |</span>
</pre></div>
</div>
<p>the list is:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|        o ,       _o_   |</span>
<span class="go">|       /         /   \  |</span>
<span class="go">|     _o_        o     o |</span>
<span class="go">|    /   \      /     /  |</span>
<span class="go">|   o     o    o     o   |</span>
<span class="go">|  / \        /          |</span>
<span class="go">| o   o      o           |</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.tamari_smaller">
<span class="sig-name descname"><span class="pre">tamari_smaller</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_smaller" title="Permalink to this definition">¶</a></dt>
<dd><p>The list of all trees smaller or equal to <code class="docutils literal notranslate"><span class="pre">self</span></code> in the Tamari
order.</p>
<p>This is the order ideal of the Tamari order generated by <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>See <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_lequal()</span></code></a> for the definition of the Tamari poset.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_greater" title="sage.combinat.binary_tree.BinaryTree.tamari_greater"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_greater()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<p>The tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|     __o__   |</span>
<span class="go">|    /     \  |</span>
<span class="go">|   o       o |</span>
<span class="go">|  / \     /  |</span>
<span class="go">| o   o   o   |</span>
</pre></div>
</div>
<p>has these trees smaller or equal to it:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|    __o__  ,       _o_  ,        o ,         o,         o,           o |</span>
<span class="go">|   /     \        /   \         /           /          /            /  |</span>
<span class="go">|  o       o      o     o      _o_          o          o            o   |</span>
<span class="go">| / \     /      /     /      /   \        / \        /            /    |</span>
<span class="go">|o   o   o      o     o      o     o      o   o      o            o     |</span>
<span class="go">|              /            / \          /          /            /      |</span>
<span class="go">|             o            o   o        o          o            o       |</span>
<span class="go">|                                      /          / \          /        |</span>
<span class="go">|                                     o          o   o        o         |</span>
<span class="go">|                                                            /          |</span>
<span class="go">|                                                           o           |</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.tamari_sorting_tuple">
<span class="sig-name descname"><span class="pre">tamari_sorting_tuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_sorting_tuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Tamari sorting tuple of <code class="docutils literal notranslate"><span class="pre">self</span></code> and the
size of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This is a pair <span class="math notranslate nohighlight">\((w, n)\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the number of
nodes of <code class="docutils literal notranslate"><span class="pre">self</span></code>, and <span class="math notranslate nohighlight">\(w\)</span> is an <span class="math notranslate nohighlight">\(n\)</span>-tuple whose
<span class="math notranslate nohighlight">\(i\)</span>-th entry is the number of all nodes among the
descendants of the right child of the <span class="math notranslate nohighlight">\(i\)</span>-th node
of <code class="docutils literal notranslate"><span class="pre">self</span></code>. Here, the nodes of <code class="docutils literal notranslate"><span class="pre">self</span></code> are numbered
from left to right.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">reverse</span></code> – boolean (default <code class="docutils literal notranslate"><span class="pre">False</span></code>) if <code class="docutils literal notranslate"><span class="pre">True</span></code>,
return instead the result for the left-right symmetric of the
binary tree</p></li>
</ul>
<p>OUTPUT:</p>
<p>a pair <span class="math notranslate nohighlight">\((w, n)\)</span>, where <span class="math notranslate nohighlight">\(w\)</span> is a tuple of integers,
and <span class="math notranslate nohighlight">\(n\)</span> the size</p>
<p>Two binary trees of the same size are comparable in
the Tamari order if and only if the associated tuples
<span class="math notranslate nohighlight">\(w\)</span> are componentwise comparable.
(This is essentially the Theorem in <a class="reference internal" href="../../../references/index.html#ht1972" id="id13"><span>[HT1972]</span></a>.)
This is used in <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_lequal()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">tamari_sorting_tuple</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="go">[((2, 1, 0), 3),</span>
<span class="go"> ((2, 0, 0), 3),</span>
<span class="go"> ((0, 1, 0), 3),</span>
<span class="go"> ((1, 0, 0), 3),</span>
<span class="go"> ((0, 0, 0), 3)]</span>

<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">u</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">left_right_symmetry</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">tamari_sorting_tuple</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="n">u</span><span class="o">.</span><span class="n">tamari_sorting_tuple</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>REFERENCES:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../../../references/index.html#ht1972" id="id14"><span>[HT1972]</span></a></p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.tamari_succ">
<span class="sig-name descname"><span class="pre">tamari_succ</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.tamari_succ" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the list of successors of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the Tamari poset.</p>
<p>This is the list of all trees obtained by a right rotate of
one of its nodes.</p>
<p>See <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_lequal" title="sage.combinat.binary_tree.BinaryTree.tamari_lequal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_lequal()</span></code></a> for the definition of the Tamari poset.</p>
<p>EXAMPLES:</p>
<p>The list of successors of:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|     __o__   |</span>
<span class="go">|    /     \  |</span>
<span class="go">|   o       o |</span>
<span class="go">|  / \     /  |</span>
<span class="go">| o   o   o   |</span>
</pre></div>
</div>
<p>is:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|   _o__     ,   ___o___  ,     _o_     |</span>
<span class="go">|  /    \       /       \      /   \    |</span>
<span class="go">| o     _o_    o         o    o     o   |</span>
<span class="go">|      /   \    \       /    / \     \  |</span>
<span class="go">|     o     o    o     o    o   o     o |</span>
<span class="go">|          /      \                     |</span>
<span class="go">|         o        o                    |</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.to_132_avoiding_permutation">
<span class="sig-name descname"><span class="pre">to_132_avoiding_permutation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_132_avoiding_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 132-avoiding permutation corresponding to the binary tree.</p>
<p>The linear extensions of a binary tree form an interval of the weak
order called the sylvester class of the tree. This permutation is
the maximal element of this sylvester class.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_132_avoiding_permutation</span><span class="p">()</span>
<span class="go">[3, 1, 2]</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="kc">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_132_avoiding_permutation</span><span class="p">()</span>
<span class="go">[8, 6, 7, 3, 4, 1, 2, 5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.to_312_avoiding_permutation">
<span class="sig-name descname"><span class="pre">to_312_avoiding_permutation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_312_avoiding_permutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 312-avoiding permutation corresponding to the binary tree.</p>
<p>The linear extensions of a binary tree form an interval of the weak
order called the sylvester class of the tree. This permutation is
the minimal element of this sylvester class.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_312_avoiding_permutation</span><span class="p">()</span>
<span class="go">[1, 3, 2]</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="kc">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_312_avoiding_permutation</span><span class="p">()</span>
<span class="go">[1, 3, 4, 2, 6, 8, 7, 5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.to_dyck_word">
<span class="sig-name descname"><span class="pre">to_dyck_word</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">usemap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'1L0R'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_dyck_word" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Dyck word associated with <code class="docutils literal notranslate"><span class="pre">self</span></code> using the given map.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">usemap</span></code> – a string, either <code class="docutils literal notranslate"><span class="pre">1L0R</span></code>, <code class="docutils literal notranslate"><span class="pre">1R0L</span></code>, <code class="docutils literal notranslate"><span class="pre">L1R0</span></code>, <code class="docutils literal notranslate"><span class="pre">R1L0</span></code></p></li>
</ul>
<p>The bijection is defined recursively as follows:</p>
<ul class="simple">
<li><p>a leaf is associated to the empty Dyck Word</p></li>
<li><p>a tree with children <span class="math notranslate nohighlight">\(l,r\)</span> is associated with the Dyck word
described by <code class="docutils literal notranslate"><span class="pre">usemap</span></code> where <span class="math notranslate nohighlight">\(L\)</span> and <span class="math notranslate nohighlight">\(R\)</span> are respectively the
Dyck words associated with the trees <span class="math notranslate nohighlight">\(l\)</span> and <span class="math notranslate nohighlight">\(r\)</span>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">()</span>
<span class="go">[1, 0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="kc">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">()</span>
<span class="go">[1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,[]],</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">()</span>
<span class="go">[1, 1, 0, 1, 0, 0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,[]],</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">(</span><span class="s2">&quot;1R0L&quot;</span><span class="p">)</span>
<span class="go">[1, 0, 1, 1, 0, 0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,[]],</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">(</span><span class="s2">&quot;L1R0&quot;</span><span class="p">)</span>
<span class="go">[1, 1, 0, 0, 1, 0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,[]],</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">(</span><span class="s2">&quot;R1L0&quot;</span><span class="p">)</span>
<span class="go">[1, 1, 0, 1, 0, 0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,[]],</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">to_dyck_word</span><span class="p">(</span><span class="s2">&quot;R10L&quot;</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: R10L is not a correct map</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.to_dyck_word_tamari">
<span class="sig-name descname"><span class="pre">to_dyck_word_tamari</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_dyck_word_tamari" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Dyck word associated with <code class="docutils literal notranslate"><span class="pre">self</span></code> in consistency with
the Tamari order on Dyck words and binary trees.</p>
<p>The bijection is defined recursively as follows:</p>
<ul class="simple">
<li><p>a leaf is associated with an empty Dyck word;</p></li>
<li><p>a tree with children <span class="math notranslate nohighlight">\(l,r\)</span> is associated with the Dyck word
<span class="math notranslate nohighlight">\(T(l) 1 T(r) 0\)</span>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">()</span><span class="o">.</span><span class="n">to_dyck_word_tamari</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([])</span><span class="o">.</span><span class="n">to_dyck_word_tamari</span><span class="p">()</span>
<span class="go">[1, 0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,[]],</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">to_dyck_word_tamari</span><span class="p">()</span>
<span class="go">[1, 1, 0, 0, 1, 0]</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="kc">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span><span class="o">.</span><span class="n">to_dyck_word_tamari</span><span class="p">()</span>
<span class="go">[1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.to_full">
<span class="sig-name descname"><span class="pre">to_full</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full binary tree constructed from <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(T\)</span> be a binary tree with <span class="math notranslate nohighlight">\(n\)</span> nodes. We construct a full
binary tree <span class="math notranslate nohighlight">\(F\)</span> from <span class="math notranslate nohighlight">\(T\)</span> by attaching a leaf to each node of
<span class="math notranslate nohighlight">\(T\)</span> which does not have 2 children. The resulting tree will
have <span class="math notranslate nohighlight">\(2n + 1\)</span> nodes.</p>
<p>OUTPUT:</p>
<p>A full binary tree. See <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.is_full" title="sage.combinat.binary_tree.BinaryTree.is_full"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_full()</span></code></a> for the definition of full.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.prune" title="sage.combinat.binary_tree.BinaryTree.prune"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prune()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[</span><span class="kc">None</span><span class="p">,[]],</span><span class="kc">None</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_full</span><span class="p">()</span><span class="o">.</span><span class="n">is_full</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">bt</span><span class="p">)</span>
<span class="go">  o</span>
<span class="go"> /</span>
<span class="go">o</span>
<span class="go"> \</span>
<span class="go">  o</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">bt</span><span class="o">.</span><span class="n">to_full</span><span class="p">())</span>
<span class="go">     __o___</span>
<span class="go">    /      \</span>
<span class="go">  _o_       o</span>
<span class="go"> /   \</span>
<span class="go">o     o</span>
<span class="go">     / \</span>
<span class="go">    o   o</span>

<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">bt</span><span class="p">)</span>
<span class="go">  o</span>
<span class="go"> / \</span>
<span class="go">o   o</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">bt</span><span class="o">.</span><span class="n">to_full</span><span class="p">())</span>
<span class="go">    __o__</span>
<span class="go">   /     \</span>
<span class="go">  o       o</span>
<span class="go"> / \     / \</span>
<span class="go">o   o   o   o</span>

<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">to_full</span><span class="p">()</span>
<span class="go">[., .]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.to_ordered_tree_left_branch">
<span class="sig-name descname"><span class="pre">to_ordered_tree_left_branch</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_ordered_tree_left_branch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ordered tree of size <span class="math notranslate nohighlight">\(n+1\)</span> by the following recursive rule:</p>
<ul class="simple">
<li><p>if <span class="math notranslate nohighlight">\(x\)</span> is the left child of <span class="math notranslate nohighlight">\(y\)</span>, <span class="math notranslate nohighlight">\(x\)</span> becomes the left brother
of <span class="math notranslate nohighlight">\(y\)</span></p></li>
<li><p>if <span class="math notranslate nohighlight">\(x\)</span> is the right child of <span class="math notranslate nohighlight">\(y\)</span>, <span class="math notranslate nohighlight">\(x\)</span> becomes the last child
of <span class="math notranslate nohighlight">\(y\)</span></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_ordered_tree_left_branch</span><span class="p">()</span>
<span class="go">[[], [[]]]</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="kc">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_ordered_tree_left_branch</span><span class="p">()</span>
<span class="go">[[], [[], []], [[], [[]]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.to_ordered_tree_right_branch">
<span class="sig-name descname"><span class="pre">to_ordered_tree_right_branch</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_ordered_tree_right_branch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ordered tree of size <span class="math notranslate nohighlight">\(n+1\)</span> by the following recursive rule:</p>
<ul class="simple">
<li><p>if <span class="math notranslate nohighlight">\(x\)</span> is the right child of <span class="math notranslate nohighlight">\(y\)</span>, <span class="math notranslate nohighlight">\(x\)</span> becomes the right brother
of <span class="math notranslate nohighlight">\(y\)</span></p></li>
<li><p>if <span class="math notranslate nohighlight">\(x\)</span> is the left child of <span class="math notranslate nohighlight">\(y\)</span>, <span class="math notranslate nohighlight">\(x\)</span> becomes the first child
of <span class="math notranslate nohighlight">\(y\)</span></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_ordered_tree_right_branch</span><span class="p">()</span>
<span class="go">[[[]], []]</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[[],</span> <span class="p">[[],</span> <span class="kc">None</span><span class="p">]],</span> <span class="p">[[],</span> <span class="p">[]]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_ordered_tree_right_branch</span><span class="p">()</span>
<span class="go">[[[[]], [[]]], [[]], []]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.to_poset">
<span class="sig-name descname"><span class="pre">to_poset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">with_leaves</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_to_leaf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_poset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the poset obtained by interpreting the tree as a Hasse
diagram.</p>
<p>The default orientation is from leaves to root but you can
pass <code class="docutils literal notranslate"><span class="pre">root_to_leaf=True</span></code> to obtain the inverse orientation.</p>
<p>Leaves are ignored by default, but one can set <code class="docutils literal notranslate"><span class="pre">with_leaves</span></code> to
<code class="docutils literal notranslate"><span class="pre">True</span></code> to obtain the poset of the complete tree.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">with_leaves</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) a Boolean, determining
whether the resulting poset will be formed from the leaves
and the nodes of <code class="docutils literal notranslate"><span class="pre">self</span></code> (if <code class="docutils literal notranslate"><span class="pre">True</span></code>), or only from the
nodes of <code class="docutils literal notranslate"><span class="pre">self</span></code> (if <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">root_to_leaf</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) a Boolean,
determining whether the poset orientation should be from root
to leaves (if <code class="docutils literal notranslate"><span class="pre">True</span></code>) or from leaves to root (if <code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_poset</span><span class="p">()</span>
<span class="go">Finite poset containing 1 elements</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_poset</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Finite poset containing 3 elements</span>
<span class="gp">sage: </span><span class="n">P1</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">to_poset</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">maximal_elements</span><span class="p">())</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P1</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">())</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([])</span>
<span class="gp">sage: </span><span class="n">P2</span> <span class="o">=</span> <span class="n">bt</span><span class="o">.</span><span class="n">to_poset</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">root_to_leaf</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P2</span><span class="o">.</span><span class="n">maximal_elements</span><span class="p">())</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">P2</span><span class="o">.</span><span class="n">minimal_elements</span><span class="p">())</span>
<span class="go">1</span>
</pre></div>
</div>
<p>If the tree is labelled, we use its labelling to label the poset.
Otherwise, we use the poset canonical labelling:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[</span><span class="kc">None</span><span class="p">,[]]])</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bt</span>
<span class="go">2[1[., .], 3[., 4[., .]]]</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_poset</span><span class="p">()</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[4, 3], [3, 2], [1, 2]]</span>
</pre></div>
</div>
<p>Let us check that the empty binary tree is correctly handled:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_poset</span><span class="p">()</span>
<span class="go">Finite poset containing 0 elements</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_poset</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Finite poset containing 1 elements</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.to_tilting">
<span class="sig-name descname"><span class="pre">to_tilting</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_tilting" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a binary tree into a tilting object.</p>
<p>Let <span class="math notranslate nohighlight">\(t\)</span> be a binary tree with <span class="math notranslate nohighlight">\(n\)</span> nodes. There exists a unique
depiction of <span class="math notranslate nohighlight">\(t\)</span> (above the diagonal) such that all leaves are
regularly distributed on the diagonal line from <span class="math notranslate nohighlight">\((0,0)\)</span> to
<span class="math notranslate nohighlight">\((n,n)\)</span> and all edges are either horizontal or vertical. This
method provides the coordinates of this depiction, with the
root as the top-left vertex.</p>
<p>OUTPUT:</p>
<p>a list of pairs of integers.</p>
<p>Every vertex of the binary tree is mapped to a pair of
integers. The conventions are the following. The root has
coordinates <span class="math notranslate nohighlight">\((0, n)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the node number.
If a vertex is the left (right) son of
another vertex, they share the first (second) coordinate.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">to_tilting</span><span class="p">()</span>
<span class="go">[(0, 1)]</span>

<span class="gp">sage: </span><span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">to_tilting</span><span class="p">())</span>
<span class="go">[(1, 2), (0, 2)]</span>
<span class="go">[(0, 1), (0, 2)]</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.abstract_tree</span> <span class="kn">import</span> <span class="n">from_hexacode</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">from_hexacode</span><span class="p">(</span><span class="s1">&#39;2020222002000&#39;</span><span class="p">,</span> <span class="n">BinaryTrees</span><span class="p">())</span>
<span class="gp">sage: </span><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">to_tilting</span><span class="p">())</span>
<span class="go">[(0, 1), (2, 3), (4, 5), (6, 7), (4, 7), (8, 9), (10, 11),</span>
<span class="go">(8, 11), (4, 11), (12, 13), (4, 13), (2, 13), (0, 13)]</span>

<span class="gp">sage: </span><span class="n">t2</span> <span class="o">=</span> <span class="n">DyckWord</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_binary_tree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">to_tilting</span><span class="p">())</span> <span class="o">==</span> <span class="n">t2</span><span class="o">.</span><span class="n">node_number</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.to_undirected_graph">
<span class="sig-name descname"><span class="pre">to_undirected_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">with_leaves</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.to_undirected_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the undirected graph obtained from the tree nodes and edges.</p>
<p>Leaves are ignored by default, but one can set <code class="docutils literal notranslate"><span class="pre">with_leaves</span></code> to
<code class="docutils literal notranslate"><span class="pre">True</span></code> to obtain the graph of the complete tree.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">with_leaves</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) a Boolean, determining
whether the resulting graph will be formed from the leaves
and the nodes of <code class="docutils literal notranslate"><span class="pre">self</span></code> (if <code class="docutils literal notranslate"><span class="pre">True</span></code>), or only from the
nodes of <code class="docutils literal notranslate"><span class="pre">self</span></code> (if <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">()</span>
<span class="go">Graph on 1 vertex</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Graph on 3 vertices</span>

<span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">()</span>
<span class="go">Graph on 0 vertices</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">(</span><span class="n">with_leaves</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Graph on 1 vertex</span>
</pre></div>
</div>
<p>If the tree is labelled, we use its labelling to label the graph.
Otherwise, we use the graph canonical labelling which means that
two different trees can have the same graph.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">bt</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[</span><span class="kc">None</span><span class="p">,[]]])</span>
<span class="gp">sage: </span><span class="n">bt</span><span class="o">.</span><span class="n">canonical_labelling</span><span class="p">()</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">()</span> <span class="o">==</span> <span class="n">bt</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">BinaryTree</span><span class="p">([[],[]])</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">()</span> <span class="o">==</span> <span class="n">BinaryTree</span><span class="p">([[[],</span><span class="kc">None</span><span class="p">],</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">to_undirected_graph</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.twisting_number">
<span class="sig-name descname"><span class="pre">twisting_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.twisting_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a pair (number of maximal left branches, number of maximal right
branches).</p>
<p>Recalling that a branch of a vertex <span class="math notranslate nohighlight">\(v\)</span> is a path from a vertex of the
tree to a leaf, a left (resp. right) branch is a branch made only of
left (resp. right) edges. The length of a branch is the number of edges
composing it. A left (resp. right) branch is maximal if it is not
included in a strictly longer left (resp. right) branch.</p>
<p>OUTPUT:</p>
<p>A list of two integers</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span> <span class="s1">&#39;.&#39;</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">BT</span><span class="o">.</span><span class="n">twisting_number</span><span class="p">()</span>
<span class="go">[0, 0]</span>
<span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span> <span class="s1">&#39;[.,.]&#39;</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">BT</span><span class="o">.</span><span class="n">twisting_number</span><span class="p">()</span>
<span class="go">[0, 0]</span>
<span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span> <span class="s1">&#39;[[[.,.], .], [.,.]]&#39;</span> <span class="p">);</span> <span class="n">ascii_art</span><span class="p">(</span><span class="n">BT</span><span class="p">)</span>
<span class="go">    o</span>
<span class="go">   / \</span>
<span class="go">  o   o</span>
<span class="go"> /</span>
<span class="go">o</span>
<span class="gp">sage: </span><span class="n">BT</span><span class="o">.</span><span class="n">twisting_number</span><span class="p">()</span>
<span class="go">[1, 1]</span>
<span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span> <span class="s1">&#39;[[[[., [., .]], .], [[., .], [[[., .], [., .]], [., .]]]], [., [[[., .], [[[., .], [., .]], .]], .]]]&#39;</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">BT</span><span class="p">)</span>
<span class="go">        ________o________</span>
<span class="go">       /                 \</span>
<span class="go">    __o__                 o</span>
<span class="go">   /     \                 \</span>
<span class="go">  o     __o___              o</span>
<span class="go"> /     /      \            /</span>
<span class="go">o     o       _o_       __o__</span>
<span class="go"> \           /   \     /     \</span>
<span class="go">  o         o     o   o       o</span>
<span class="go">           / \               /</span>
<span class="go">          o   o             o</span>
<span class="go">                           / \</span>
<span class="go">                          o   o</span>
<span class="gp">sage: </span><span class="n">BT</span><span class="o">.</span><span class="n">twisting_number</span><span class="p">()</span>
<span class="go">[5, 6]</span>
<span class="gp">sage: </span><span class="n">BT</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">(</span> <span class="s1">&#39;[.,[[[.,.],.],.]]&#39;</span> <span class="p">);</span> <span class="n">ascii_art</span><span class="p">(</span><span class="n">BT</span><span class="p">)</span>
<span class="go">  o</span>
<span class="go">   \</span>
<span class="go">    o</span>
<span class="go">   /</span>
<span class="go">  o</span>
<span class="go"> /</span>
<span class="go">o</span>
<span class="gp">sage: </span><span class="n">BT</span><span class="o">.</span><span class="n">twisting_number</span><span class="p">()</span>
<span class="go">[1, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.under">
<span class="sig-name descname"><span class="pre">under</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.under" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">self</span></code> under <code class="docutils literal notranslate"><span class="pre">bt</span></code>, where “under” is the <code class="docutils literal notranslate"><span class="pre">under</span></code>
(<span class="math notranslate nohighlight">\(\backslash\)</span>) operation.</p>
<p>If <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(T'\)</span> are two binary trees, then <span class="math notranslate nohighlight">\(T\)</span> under <span class="math notranslate nohighlight">\(T'\)</span>
(written <span class="math notranslate nohighlight">\(T \backslash T'\)</span>) is defined as the tree obtained
by grafting <span class="math notranslate nohighlight">\(T\)</span> on the leftmost leaf of <span class="math notranslate nohighlight">\(T'\)</span>. More precisely,
<span class="math notranslate nohighlight">\(T \backslash T'\)</span> is defined by identifying the root of <span class="math notranslate nohighlight">\(T\)</span>
with the leftmost leaf of <span class="math notranslate nohighlight">\(T'\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(T'\)</span> is empty, then <span class="math notranslate nohighlight">\(T \backslash T' = T\)</span>.</p>
<p>The definition of this “under” operation goes back to
Loday-Ronco <a class="reference internal" href="../../../references/index.html#lr0102066" id="id15"><span>[LR0102066]</span></a> (Definition 2.2), but it is
denoted by <span class="math notranslate nohighlight">\(/\)</span> and called the “over” operation there. In fact,
trees in sage have their root at the top, contrary to the trees
in <a class="reference internal" href="../../../references/index.html#lr0102066" id="id16"><span>[LR0102066]</span></a> which are growing upwards. For this reason,
the names of the over and under operations are swapped, in
order to keep a graphical meaning.
(Our notation follows that of section 4.5 of <a class="reference internal" href="../../../references/index.html#hnt2005" id="id17"><span>[HNT2005]</span></a>.)</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.over" title="sage.combinat.binary_tree.BinaryTree.over"><code class="xref py py-meth docutils literal notranslate"><span class="pre">over()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<p>Showing only the nodes of a binary tree, here is an
example for the under operation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">b1</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([[],[]])</span>
<span class="gp">sage: </span><span class="n">b2</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,[]])</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">((</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b1</span> \ <span class="n">b2</span><span class="p">))</span>
<span class="go">(   o  , o  ,     _o_   )</span>
<span class="go">(  / \    \      /   \  )</span>
<span class="go">( o   o    o    o     o )</span>
<span class="go">(              / \      )</span>
<span class="go">(             o   o     )</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTree.under_decomposition">
<span class="sig-name descname"><span class="pre">under_decomposition</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTree.under_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique maximal decomposition as an under product.</p>
<p>This means that the tree is cut along all edges of its leftmost path.</p>
<p>Beware that the factors are ordered starting from the root.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.comb" title="sage.combinat.binary_tree.BinaryTree.comb"><code class="xref py py-meth docutils literal notranslate"><span class="pre">comb()</span></code></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.over_decomposition" title="sage.combinat.binary_tree.BinaryTree.over_decomposition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">over_decomposition()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">BinaryTree</span><span class="p">([])</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">g</span><span class="p">);</span> <span class="n">r</span>
<span class="go">[., [., .]]</span>
<span class="gp">sage: </span><span class="n">l</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">under</span><span class="p">(</span><span class="n">g</span><span class="p">);</span> <span class="n">l</span>
<span class="go">[[., .], .]</span>
<span class="gp">sage: </span><span class="n">l</span><span class="o">.</span><span class="n">under_decomposition</span><span class="p">()</span>
<span class="go">[[., .], [., .]]</span>
<span class="gp">sage: </span><span class="n">r</span><span class="o">.</span><span class="n">under_decomposition</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span><span class="n">r</span><span class="p">]</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">under</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">under</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">under</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ascii_art</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">      o</span>
<span class="go">     /</span>
<span class="go">    o</span>
<span class="go">   / \</span>
<span class="go">  o   o</span>
<span class="go"> /</span>
<span class="go">o</span>
<span class="go"> \</span>
<span class="go">  o</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">under_decomposition</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span><span class="n">g</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">r</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTrees">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.combinat.binary_tree.</span></span><span class="sig-name descname"><span class="pre">BinaryTrees</span></span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage 9.5 Reference Manual: Parents and Elements v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></code></a>, <a class="reference external" href="../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage 9.5 Reference Manual: Parents and Elements v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>Factory for binary trees.</p>
<p>A binary tree is a tree with at most 2 children. The binary
trees considered here are also ordered (a.k.a. planar), that is
to say, their children are ordered.</p>
<p>A full binary tree is a binary tree with no nodes with 1 child.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code> – (optional) an integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">full</span></code> – (optional) a boolean</p></li>
</ul>
<p>OUTPUT:</p>
<p>The set of all (full if <code class="docutils literal notranslate"><span class="pre">full=True</span></code>) binary trees (of the given
<code class="docutils literal notranslate"><span class="pre">size</span></code> if specified).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree" title="sage.combinat.binary_tree.BinaryTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryTree</span></code></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.is_full" title="sage.combinat.binary_tree.BinaryTree.is_full"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BinaryTree.is_full()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">()</span>
<span class="go">Binary trees</span>

<span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Binary trees of size 2</span>

<span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">(</span><span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Full binary trees</span>

<span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Full binary trees of size 3</span>

<span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: n must be 0 or odd</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a factory class whose constructor returns instances of
subclasses.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The fact that BinaryTrees is a class instead of a simple callable
is an implementation detail. It could be changed in the future
and one should not rely on it.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTrees.leaf">
<span class="sig-name descname"><span class="pre">leaf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees.leaf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a leaf tree with <code class="docutils literal notranslate"><span class="pre">self</span></code> as parent.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">()</span><span class="o">.</span><span class="n">leaf</span><span class="p">()</span>
<span class="go">.</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTrees_all">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.combinat.binary_tree.</span></span><span class="sig-name descname"><span class="pre">BinaryTrees_all</span></span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../sets/sage/sets/disjoint_union_enumerated_sets.html#sage.sets.disjoint_union_enumerated_sets.DisjointUnionEnumeratedSets" title="(in Sage 9.5 Reference Manual: Sets v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.sets.disjoint_union_enumerated_sets.DisjointUnionEnumeratedSets</span></code></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTrees" title="sage.combinat.binary_tree.BinaryTrees"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.binary_tree.BinaryTrees</span></code></a></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTrees_all.Element">
<span class="sig-name descname"><span class="pre">Element</span></span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees_all.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree" title="sage.combinat.binary_tree.BinaryTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryTree</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTrees_all.labelled_trees">
<span class="sig-name descname"><span class="pre">labelled_trees</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees_all.labelled_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of labelled trees associated to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">()</span><span class="o">.</span><span class="n">labelled_trees</span><span class="p">()</span>
<span class="go">Labelled binary trees</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTrees_all.unlabelled_trees">
<span class="sig-name descname"><span class="pre">unlabelled_trees</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees_all.unlabelled_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of unlabelled trees associated to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">()</span><span class="o">.</span><span class="n">unlabelled_trees</span><span class="p">()</span>
<span class="go">Binary trees</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTrees_size">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.combinat.binary_tree.</span></span><span class="sig-name descname"><span class="pre">BinaryTrees_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTrees" title="sage.combinat.binary_tree.BinaryTrees"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.binary_tree.BinaryTrees</span></code></a></p>
<p>The enumerated sets of binary trees of given size.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTrees_size.cardinality">
<span class="sig-name descname"><span class="pre">cardinality</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees_size.cardinality" title="Permalink to this definition">¶</a></dt>
<dd><p>The cardinality of <code class="docutils literal notranslate"><span class="pre">self</span></code></p>
<p>This is a Catalan number.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.BinaryTrees_size.random_element">
<span class="sig-name descname"><span class="pre">random_element</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.BinaryTrees_size.random_element" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random <code class="docutils literal notranslate"><span class="pre">BinaryTree</span></code> with uniform probability.</p>
<p>This method generates a random <code class="docutils literal notranslate"><span class="pre">DyckWord</span></code> and then uses a
bijection between Dyck words and binary trees.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span> <span class="c1"># random</span>
<span class="go">[., [., [., [., [., .]]]]]</span>
<span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="go">[., .]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.FullBinaryTrees_all">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.combinat.binary_tree.</span></span><span class="sig-name descname"><span class="pre">FullBinaryTrees_all</span></span><a class="headerlink" href="#sage.combinat.binary_tree.FullBinaryTrees_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../sets/sage/sets/disjoint_union_enumerated_sets.html#sage.sets.disjoint_union_enumerated_sets.DisjointUnionEnumeratedSets" title="(in Sage 9.5 Reference Manual: Sets v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.sets.disjoint_union_enumerated_sets.DisjointUnionEnumeratedSets</span></code></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTrees" title="sage.combinat.binary_tree.BinaryTrees"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.binary_tree.BinaryTrees</span></code></a></p>
<p>All full binary trees.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.FullBinaryTrees_size">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.combinat.binary_tree.</span></span><span class="sig-name descname"><span class="pre">FullBinaryTrees_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.FullBinaryTrees_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTrees" title="sage.combinat.binary_tree.BinaryTrees"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.binary_tree.BinaryTrees</span></code></a></p>
<p>Full binary trees of a fixed size (number of nodes).</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.FullBinaryTrees_size.cardinality">
<span class="sig-name descname"><span class="pre">cardinality</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.FullBinaryTrees_size.cardinality" title="Permalink to this definition">¶</a></dt>
<dd><p>The cardinality of <code class="docutils literal notranslate"><span class="pre">self</span></code></p>
<p>This is a Catalan number.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.FullBinaryTrees_size.random_element">
<span class="sig-name descname"><span class="pre">random_element</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.FullBinaryTrees_size.random_element" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a random <code class="docutils literal notranslate"><span class="pre">FullBinaryTree</span></code> with uniform probability.</p>
<p>This method generates a random <code class="docutils literal notranslate"><span class="pre">DyckWord</span></code> of size <span class="math notranslate nohighlight">\((s-1) / 2\)</span>,
where <span class="math notranslate nohighlight">\(s\)</span> is the size of <code class="docutils literal notranslate"><span class="pre">self</span></code>, which uses a bijection between
Dyck words and binary trees to get a binary tree, and convert it
to a full binary tree.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span> <span class="c1"># random</span>
<span class="go">[[], [[], []]]</span>
<span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="go">[., .]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.LabelledBinaryTree">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.combinat.binary_tree.</span></span><span class="sig-name descname"><span class="pre">LabelledBinaryTree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">children</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="abstract_tree.html#sage.combinat.abstract_tree.AbstractLabelledClonableTree" title="sage.combinat.abstract_tree.AbstractLabelledClonableTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.abstract_tree.AbstractLabelledClonableTree</span></code></a>, <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree" title="sage.combinat.binary_tree.BinaryTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.binary_tree.BinaryTree</span></code></a></p>
<p>Labelled binary trees.</p>
<p>A labelled binary tree is a binary tree (see <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree" title="sage.combinat.binary_tree.BinaryTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryTree</span></code></a> for
the meaning of this) with a label assigned to each node.
The labels need not be integers, nor are they required to be distinct.
<code class="docutils literal notranslate"><span class="pre">None</span></code> can be used as a label.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>While it is possible to assign values to leaves (not just nodes)
using this class, these labels are disregarded by various
methods such as
<a class="reference internal" href="abstract_tree.html#sage.combinat.abstract_tree.AbstractLabelledTree.labels" title="sage.combinat.abstract_tree.AbstractLabelledTree.labels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">labels()</span></code></a>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">map_labels()</span></code>,
and (ironically)
<a class="reference internal" href="abstract_tree.html#sage.combinat.abstract_tree.AbstractLabelledTree.leaf_labels" title="sage.combinat.abstract_tree.AbstractLabelledTree.leaf_labels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">leaf_labels()</span></code></a>.</p>
</div>
<p>INPUT:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">children</span></code> – <code class="docutils literal notranslate"><span class="pre">None</span></code> (default) or a list, tuple or iterable of
length <span class="math notranslate nohighlight">\(2\)</span> of labelled binary trees or convertible objects. This
corresponds to the standard recursive definition of a labelled
binary tree as being either a leaf, or a pair of:</p>
<ul class="simple">
<li><p>a pair of labelled binary trees,</p></li>
<li><p>and a label.</p></li>
</ul>
<p>(The label is specified in the keyword variable <code class="docutils literal notranslate"><span class="pre">label</span></code>; see
below.)</p>
<p>Syntactic sugar allows leaving out all but the outermost calls
of the <code class="docutils literal notranslate"><span class="pre">LabelledBinaryTree()</span></code> constructor, so that, e. g.,
<code class="docutils literal notranslate"><span class="pre">LabelledBinaryTree([LabelledBinaryTree(None),LabelledBinaryTree(None)])</span></code>
can be shortened to <code class="docutils literal notranslate"><span class="pre">LabelledBinaryTree([None,None])</span></code>. However,
using this shorthand, it is impossible to label any vertex of
the tree other than the root (because there is no way to pass a
<code class="docutils literal notranslate"><span class="pre">label</span></code> variable without calling <code class="docutils literal notranslate"><span class="pre">LabelledBinaryTree</span></code>
explicitly).</p>
<p>It is also allowed to abbreviate <code class="docutils literal notranslate"><span class="pre">[None,</span> <span class="pre">None]</span></code> by <code class="docutils literal notranslate"><span class="pre">[]</span></code> if
one does not want to label the leaves (which one should not do
anyway!).</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">label</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>) the label to be put on the root
of this tree.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) whether checks should be
performed or not.</p></li>
</ul>
<div class="admonition-todo admonition" id="id18">
<p class="admonition-title">Todo</p>
<p>It is currently not possible to use <code class="docutils literal notranslate"><span class="pre">LabelledBinaryTree()</span></code>
as a shorthand for <code class="docutils literal notranslate"><span class="pre">LabelledBinaryTree(None)</span></code> (in analogy to
similar syntax in the <code class="docutils literal notranslate"><span class="pre">BinaryTree</span></code> class).</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;ae&quot;</span><span class="p">)</span>    <span class="c1"># not well supported</span>
<span class="go">&#39;ae&#39;</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([])</span>
<span class="go">None[., .]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([],</span> <span class="n">label</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>    <span class="c1"># not well supported</span>
<span class="go">3[., .]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="go">None[., .]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">5[., .]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="p">[]])</span>
<span class="go">None[., None[., .]]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="p">[]],</span> <span class="n">label</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">4[., None[., .]]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([[],</span> <span class="kc">None</span><span class="p">])</span>
<span class="go">None[None[., .], .]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">(</span><span class="s2">&quot;[[], .]&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">False[None[., .], .]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="n">LabelledBinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="mi">4</span><span class="p">)],</span> <span class="n">label</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3[., 4[., .]]</span>
<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="n">BinaryTree</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])],</span> <span class="n">label</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3[., None[., .]]</span>

<span class="gp">sage: </span><span class="n">LabelledBinaryTree</span><span class="p">([[],</span> <span class="kc">None</span><span class="p">,</span> <span class="p">[]])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: this is not a binary tree</span>

<span class="gp">sage: </span><span class="n">LBT</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span>
<span class="gp">sage: </span><span class="n">t1</span> <span class="o">=</span> <span class="n">LBT</span><span class="p">([[</span><span class="n">LBT</span><span class="p">([],</span> <span class="n">label</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="kc">None</span><span class="p">],</span> <span class="kc">None</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="mi">4</span><span class="p">);</span> <span class="n">t1</span>
<span class="go">4[None[2[., .], .], .]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.LabelledBinaryTree.binary_search_insert">
<span class="sig-name descname"><span class="pre">binary_search_insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">letter</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTree.binary_search_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of inserting a letter <code class="docutils literal notranslate"><span class="pre">letter</span></code> into the
right strict binary search tree <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">letter</span></code> – any object comparable with the labels of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<p>The right strict binary search tree <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">letter</span></code>
inserted into it according to the binary search insertion
algorithm.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">self</span></code> is supposed to be a binary search tree.
This is not being checked!</p>
</div>
<p>A right strict binary search tree is defined to be a labelled
binary tree such that for each node <span class="math notranslate nohighlight">\(n\)</span> with label <span class="math notranslate nohighlight">\(x\)</span>,
every descendant of the left child of <span class="math notranslate nohighlight">\(n\)</span> has a label <span class="math notranslate nohighlight">\(\leq x\)</span>,
and every descendant of the right child of <span class="math notranslate nohighlight">\(n\)</span> has a label
<span class="math notranslate nohighlight">\(&gt; x\)</span>. (Here, only nodes count as descendants, and every node
counts as its own descendant too.) Leaves are assumed to have
no labels.</p>
<p>Given a right strict binary search tree <span class="math notranslate nohighlight">\(t\)</span> and a letter <span class="math notranslate nohighlight">\(i\)</span>,
the result of inserting <span class="math notranslate nohighlight">\(i\)</span> into <span class="math notranslate nohighlight">\(t\)</span> (denoted <span class="math notranslate nohighlight">\(Ins(i, t)\)</span> in
the following) is defined recursively as follows:</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(t\)</span> is empty, then <span class="math notranslate nohighlight">\(Ins(i, t)\)</span> is the tree with one node
only, and this node is labelled with <span class="math notranslate nohighlight">\(i\)</span>.</p></li>
<li><p>Otherwise, let <span class="math notranslate nohighlight">\(j\)</span> be the label of the root of <span class="math notranslate nohighlight">\(t\)</span>. If
<span class="math notranslate nohighlight">\(i &gt; j\)</span>, then <span class="math notranslate nohighlight">\(Ins(i, t)\)</span> is obtained by replacing the
right child of <span class="math notranslate nohighlight">\(t\)</span> by <span class="math notranslate nohighlight">\(Ins(i, r)\)</span> in <span class="math notranslate nohighlight">\(t\)</span>, where <span class="math notranslate nohighlight">\(r\)</span> denotes
the right child of <span class="math notranslate nohighlight">\(t\)</span>. If <span class="math notranslate nohighlight">\(i \leq j\)</span>, then <span class="math notranslate nohighlight">\(Ins(i, t)\)</span> is
obtained by replacing the left child of <span class="math notranslate nohighlight">\(t\)</span> by <span class="math notranslate nohighlight">\(Ins(i, l)\)</span>
in <span class="math notranslate nohighlight">\(t\)</span>, where <span class="math notranslate nohighlight">\(l\)</span> denotes the left child of <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
</ul>
<p>See, for example, <a class="reference internal" href="../../../references/index.html#hnt2005" id="id19"><span>[HNT2005]</span></a> for properties of this algorithm.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If <span class="math notranslate nohighlight">\(t\)</span> is nonempty, then inserting <span class="math notranslate nohighlight">\(i\)</span> into <span class="math notranslate nohighlight">\(t\)</span> does not
change the root label of <span class="math notranslate nohighlight">\(t\)</span>. Hence, as opposed to
algorithms like Robinson-Schensted-Knuth, binary
search tree insertion involves no bumping.</p>
</div>
<p>EXAMPLES:</p>
<p>The example from Fig. 2 of <a class="reference internal" href="../../../references/index.html#hnt2005" id="id20"><span>[HNT2005]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">LBT</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">LBT</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[., .]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[., d[., .]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[., d[., e[., .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[a[., .], d[., e[., .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[a[., b[., .]], d[., e[., .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[a[., b[., .]], d[d[., .], e[., .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[a[a[., .], b[., .]], d[d[., .], e[., .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[a[a[., .], b[., .]], d[d[c[., .], .], e[., .]]]</span>
</pre></div>
</div>
<p>Other examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">LBT</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span>
<span class="gp">sage: </span><span class="n">LBT</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3[., .]</span>
<span class="gp">sage: </span><span class="n">LBT</span><span class="p">([],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1[., 3[., .]]</span>
<span class="gp">sage: </span><span class="n">LBT</span><span class="p">([],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3[1[., .], .]</span>
<span class="gp">sage: </span><span class="n">res</span> <span class="o">=</span> <span class="n">LBT</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]:</span>
<span class="gp">....: </span>    <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">binary_search_insert</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">res</span>
<span class="go">3[1[., 2[., .]], 5[4[., .], 6[., .]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.LabelledBinaryTree.heap_insert">
<span class="sig-name descname"><span class="pre">heap_insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTree.heap_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of inserting a letter <code class="docutils literal notranslate"><span class="pre">l</span></code> into the binary
heap (tree) <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>A binary heap is a labelled complete binary tree such that for
each node, the label at the node is greater or equal to the
label of each of its child nodes. (More precisely, this is
called a max-heap.)</p>
<p>For example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|     _7_   |</span>
<span class="go">|    /   \  |</span>
<span class="go">|   5     6 |</span>
<span class="go">|  / \      |</span>
<span class="go">| 3   4     |</span>
</pre></div>
</div>
<p>is a binary heap.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Binary_heap#Insert">Wikipedia article Binary_heap#Insert</a> for a description of how to
insert a letter into a binary heap. The result is another binary
heap.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">letter</span></code> – any object comparable with the labels of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">self</span></code> is assumed to be a binary heap (tree). No check is
performed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.LabelledBinaryTree.left_rotate">
<span class="sig-name descname"><span class="pre">left_rotate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTree.left_rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of left rotation applied to the labelled
binary tree <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Left rotation on labelled binary trees is defined as
follows: Let <span class="math notranslate nohighlight">\(T\)</span> be a labelled binary tree such that the
right child of the root of <span class="math notranslate nohighlight">\(T\)</span> is a node. Let
<span class="math notranslate nohighlight">\(A\)</span> be the left child of the root of <span class="math notranslate nohighlight">\(T\)</span>, and let <span class="math notranslate nohighlight">\(B\)</span>
and <span class="math notranslate nohighlight">\(C\)</span> be the left and right children of the right child
of the root of <span class="math notranslate nohighlight">\(T\)</span>. (Keep in mind that nodes of trees are
identified with the subtrees consisting of their
descendants.) Furthermore, let <span class="math notranslate nohighlight">\(x\)</span> be the label at the
root of <span class="math notranslate nohighlight">\(T\)</span>, and <span class="math notranslate nohighlight">\(y\)</span> be the label at the right child of the
root of <span class="math notranslate nohighlight">\(T\)</span>.
Then, the left rotation of <span class="math notranslate nohighlight">\(T\)</span> is the labelled binary tree
in which the root is labelled <span class="math notranslate nohighlight">\(y\)</span>, the right child of the
root is <span class="math notranslate nohighlight">\(C\)</span>, whereas the left child of the root is a node
labelled <span class="math notranslate nohighlight">\(x\)</span> whose left and right children are <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>.
In pictures:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|     y                    x     |</span>
<span class="go">|    / \                  / \    |</span>
<span class="go">|   x   C &lt;-left-rotate- A   y   |</span>
<span class="go">|  / \                      / \  |</span>
<span class="go">| A   B                    B   C |</span>
</pre></div>
</div>
<p>Left rotation is the inverse operation to right rotation
(<a class="reference internal" href="#sage.combinat.binary_tree.LabelledBinaryTree.right_rotate" title="sage.combinat.binary_tree.LabelledBinaryTree.right_rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">right_rotate()</span></code></a>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.LabelledBinaryTree.right_rotate">
<span class="sig-name descname"><span class="pre">right_rotate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTree.right_rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of right rotation applied to the labelled
binary tree <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Right rotation on labelled binary trees is defined as
follows: Let <span class="math notranslate nohighlight">\(T\)</span> be a labelled binary tree such that the
left child of the root of <span class="math notranslate nohighlight">\(T\)</span> is a node. Let
<span class="math notranslate nohighlight">\(C\)</span> be the right child of the root of <span class="math notranslate nohighlight">\(T\)</span>, and let <span class="math notranslate nohighlight">\(A\)</span>
and <span class="math notranslate nohighlight">\(B\)</span> be the left and right children of the left child
of the root of <span class="math notranslate nohighlight">\(T\)</span>. (Keep in mind that nodes of trees are
identified with the subtrees consisting of their
descendants.) Furthermore, let <span class="math notranslate nohighlight">\(y\)</span> be the label at the
root of <span class="math notranslate nohighlight">\(T\)</span>, and <span class="math notranslate nohighlight">\(x\)</span> be the label at the left child of the
root of <span class="math notranslate nohighlight">\(T\)</span>.
Then, the right rotation of <span class="math notranslate nohighlight">\(T\)</span> is the labelled binary
tree in which the root is labelled <span class="math notranslate nohighlight">\(x\)</span>, the left child of
the root is <span class="math notranslate nohighlight">\(A\)</span>, whereas the right child of the root is a
node labelled <span class="math notranslate nohighlight">\(y\)</span> whose left and right children are <span class="math notranslate nohighlight">\(B\)</span>
and <span class="math notranslate nohighlight">\(C\)</span>. In pictures:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">|     y                      x     |</span>
<span class="go">|    / \                    / \    |</span>
<span class="go">|   x   C -right-rotate-&gt;  A   y   |</span>
<span class="go">|  / \                        / \  |</span>
<span class="go">| A   B                      B   C |</span>
</pre></div>
</div>
<p>Right rotation is the inverse operation to left rotation
(<a class="reference internal" href="#sage.combinat.binary_tree.LabelledBinaryTree.left_rotate" title="sage.combinat.binary_tree.LabelledBinaryTree.left_rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">left_rotate()</span></code></a>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.LabelledBinaryTree.semistandard_insert">
<span class="sig-name descname"><span class="pre">semistandard_insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">letter</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTree.semistandard_insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of inserting a letter <code class="docutils literal notranslate"><span class="pre">letter</span></code> into the
semistandard tree <code class="docutils literal notranslate"><span class="pre">self</span></code> using the bumping algorithm.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">letter</span></code> – any object comparable with the labels of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<p>The semistandard tree <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">letter</span></code> inserted into it
according to the bumping algorithm.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">self</span></code> is supposed to be a semistandard tree.
This is not being checked!</p>
</div>
<p>A semistandard tree is defined to be a labelled binary tree
such that for each node <span class="math notranslate nohighlight">\(n\)</span> with label <span class="math notranslate nohighlight">\(x\)</span>, every descendant of
the left child of <span class="math notranslate nohighlight">\(n\)</span> has a label <span class="math notranslate nohighlight">\(&gt; x\)</span>, and every descendant
of the right child of <span class="math notranslate nohighlight">\(n\)</span> has a label <span class="math notranslate nohighlight">\(\geq x\)</span>. (Here, only
nodes count as descendants, and every node counts as its own
descendant too.) Leaves are assumed to have no labels.</p>
<p>Given a semistandard tree <span class="math notranslate nohighlight">\(t\)</span> and a letter <span class="math notranslate nohighlight">\(i\)</span>, the result of
inserting <span class="math notranslate nohighlight">\(i\)</span> into <span class="math notranslate nohighlight">\(t\)</span> (denoted <span class="math notranslate nohighlight">\(Ins(i, t)\)</span> in the following)
is defined recursively as follows:</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(t\)</span> is empty, then <span class="math notranslate nohighlight">\(Ins(i, t)\)</span> is the tree with one node
only, and this node is labelled with <span class="math notranslate nohighlight">\(i\)</span>.</p></li>
<li><p>Otherwise, let <span class="math notranslate nohighlight">\(j\)</span> be the label of the root of <span class="math notranslate nohighlight">\(t\)</span>. If
<span class="math notranslate nohighlight">\(i \geq j\)</span>, then <span class="math notranslate nohighlight">\(Ins(i, t)\)</span> is obtained by replacing the
right child of <span class="math notranslate nohighlight">\(t\)</span> by <span class="math notranslate nohighlight">\(Ins(i, r)\)</span> in <span class="math notranslate nohighlight">\(t\)</span>, where <span class="math notranslate nohighlight">\(r\)</span> denotes
the right child of <span class="math notranslate nohighlight">\(t\)</span>. If <span class="math notranslate nohighlight">\(i &lt; j\)</span>, then <span class="math notranslate nohighlight">\(Ins(i, t)\)</span> is
obtained by replacing the label at the root of <span class="math notranslate nohighlight">\(t\)</span> by <span class="math notranslate nohighlight">\(i\)</span>,
and replacing the left child of <span class="math notranslate nohighlight">\(t\)</span> by <span class="math notranslate nohighlight">\(Ins(j, l)\)</span>
in <span class="math notranslate nohighlight">\(t\)</span>, where <span class="math notranslate nohighlight">\(l\)</span> denotes the left child of <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
</ul>
<p>This algorithm is similar to the Robinson-Schensted-Knuth
insertion algorithm for semistandard Young tableaux.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Darij Grinberg (10 Nov 2013).</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">LBT</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">LBT</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">.</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[., .]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[., d[., .]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">b[., d[., e[., .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">a[b[., .], d[., e[., .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">a[b[., .], b[d[., .], e[., .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">a[b[., .], b[d[., .], d[e[., .], .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">a[b[., .], a[b[d[., .], .], d[e[., .], .]]]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">);</span> <span class="n">x</span>
<span class="go">a[b[., .], a[b[d[., .], .], c[d[e[., .], .], .]]]</span>
</pre></div>
</div>
<p>Other examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">LBT</span> <span class="o">=</span> <span class="n">LabelledBinaryTree</span>
<span class="gp">sage: </span><span class="n">LBT</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3[., .]</span>
<span class="gp">sage: </span><span class="n">LBT</span><span class="p">([],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1[., 3[., .]]</span>
<span class="gp">sage: </span><span class="n">LBT</span><span class="p">([],</span> <span class="n">label</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1[3[., .], .]</span>
<span class="gp">sage: </span><span class="n">res</span> <span class="o">=</span> <span class="n">LBT</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]:</span>
<span class="gp">....: </span>    <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">semistandard_insert</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">res</span>
<span class="go">1[3[., .], 2[5[., .], 4[., 6[., .]]]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.LabelledBinaryTrees">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.combinat.binary_tree.</span></span><span class="sig-name descname"><span class="pre">LabelledBinaryTrees</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">category</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ordered_tree.html#sage.combinat.ordered_tree.LabelledOrderedTrees" title="sage.combinat.ordered_tree.LabelledOrderedTrees"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.ordered_tree.LabelledOrderedTrees</span></code></a></p>
<p>This is a parent stub to serve as a factory class for trees with various
labels constraints.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.LabelledBinaryTrees.Element">
<span class="sig-name descname"><span class="pre">Element</span></span><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTrees.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.binary_tree.LabelledBinaryTree" title="sage.combinat.binary_tree.LabelledBinaryTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">LabelledBinaryTree</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.LabelledBinaryTrees.labelled_trees">
<span class="sig-name descname"><span class="pre">labelled_trees</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTrees.labelled_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of labelled trees associated to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">LabelledBinaryTrees</span><span class="p">()</span><span class="o">.</span><span class="n">labelled_trees</span><span class="p">()</span>
<span class="go">Labelled binary trees</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.LabelledBinaryTrees.unlabelled_trees">
<span class="sig-name descname"><span class="pre">unlabelled_trees</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.LabelledBinaryTrees.unlabelled_trees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of unlabelled trees associated to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">LabelledBinaryTrees</span><span class="p">()</span><span class="o">.</span><span class="n">unlabelled_trees</span><span class="p">()</span>
<span class="go">Binary trees</span>
</pre></div>
</div>
<p>This is used to compute the shape:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">LabelledBinaryTrees</span><span class="p">()</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">();</span> <span class="n">t</span>
<span class="go">[[[., .], [., .]], [[., .], [., .]]]</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Binary trees</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.binary_search_tree_shape">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.binary_tree.</span></span><span class="sig-name descname"><span class="pre">binary_search_tree_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left_to_right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.binary_search_tree_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Direct computation of the binary search tree shape of a list of integers.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">w</span></code> – a list of integers</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">left_to_right</span></code> – boolean (default <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
</ul>
<p>OUTPUT: a non labelled binary tree</p>
<p>This is used under the same name as a method for permutations.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.binary_tree</span> <span class="kn">import</span> <span class="n">binary_search_tree_shape</span>
<span class="gp">sage: </span><span class="n">binary_search_tree_shape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[., [[[., .], .], .]]</span>
<span class="gp">sage: </span><span class="n">binary_search_tree_shape</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[[., [[., .], .]], .]</span>
</pre></div>
</div>
<p>By passing the option <code class="docutils literal notranslate"><span class="pre">left_to_right=False</span></code> one can have
the insertion going from right to left:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">binary_search_tree_shape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">[[., .], [., [., .]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sage.combinat.binary_tree.from_tamari_sorting_tuple">
<span class="sig-prename descclassname"><span class="pre">sage.combinat.binary_tree.</span></span><span class="sig-name descname"><span class="pre">from_tamari_sorting_tuple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.binary_tree.from_tamari_sorting_tuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a binary tree from its Tamari-sorting tuple.</p>
<p>See <a class="reference internal" href="#sage.combinat.binary_tree.BinaryTree.tamari_sorting_tuple" title="sage.combinat.binary_tree.BinaryTree.tamari_sorting_tuple"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tamari_sorting_tuple()</span></code></a></p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">key</span></code> – a tuple of integers</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.binary_tree</span> <span class="kn">import</span> <span class="n">from_tamari_sorting_tuple</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">BinaryTrees</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span><span class="o">.</span><span class="n">random_element</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">from_tamari_sorting_tuple</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">tamari_sorting_tuple</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">t</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="binary_recurrence_sequences.html"
                        title="previous chapter">Binary Recurrence Sequences</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="blob_algebra.html"
                        title="next chapter">Blob Algebras</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/combinat/binary_tree.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="blob_algebra.html" title="Blob Algebras"
             >next</a> |</li>
        <li class="right" >
          <a href="binary_recurrence_sequences.html" title="Binary Recurrence Sequences"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.5 Reference Manual: Combinatorics</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../module_list.html" >Comprehensive Module List</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Binary Trees</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2022, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>