
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="viewport" content="width=600, initial-scale=1">
    <title>Fully commutative elements of Coxeter groups &#8212; Sage 9.3 Reference Manual: Combinatorics</title>
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script async="async" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Finite State Machines, Automata, Transducers" href="finite_state_machine.html" />
    <link rel="prev" title="Brent Yorgey’s fast algorithm for integer vector (multiset) partitions." href="fast_vector_partitions.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="finite_state_machine.html" title="Finite State Machines, Automata, Transducers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="fast_vector_partitions.html" title="Brent Yorgey’s fast algorithm for integer vector (multiset) partitions."
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.3 Reference Manual: Combinatorics</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../module_list.html" accesskey="U">Comprehensive Module list</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Fully commutative elements of Coxeter groups</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="fully-commutative-elements-of-coxeter-groups">
<span id="sage-combinat-fully-commutative-elements"></span><h1>Fully commutative elements of Coxeter groups<a class="headerlink" href="#fully-commutative-elements-of-coxeter-groups" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.fully_commutative_elements"></span><p>An element <span class="math notranslate nohighlight">\(w\)</span> in a Coxeter system (W,S) is fully commutative (FC) if
every two reduced words of w can be related by a sequence of only
commutation relations, i.e., relations of the form <span class="math notranslate nohighlight">\(st=ts\)</span> where <span class="math notranslate nohighlight">\(s,t\)</span> are
commuting generators in <span class="math notranslate nohighlight">\(S\)</span>. See <a class="reference internal" href="../../../references/index.html#ste1996" id="id1"><span>[Ste1996]</span></a>.</p>
<p>Authors:</p>
<ul class="simple">
<li><p>Chase Meadors, Tianyuan Xu (2020): Initial version</p></li>
</ul>
<div class="section" id="acknowledgements">
<h2>Acknowledgements<a class="headerlink" href="#acknowledgements" title="Permalink to this headline">¶</a></h2>
<p>A draft of this code was written during an REU project at University of
Colorado Boulder. We thank Rachel Castro, Joel Courtney, Thomas Magnuson and
Natalie Schoenhals for their contribution to the project and the code.</p>
<dl class="py class">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElement">
<em class="property">class </em><code class="sig-prename descclassname">sage.combinat.fully_commutative_elements.</code><code class="sig-name descname">FullyCommutativeElement</code><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/list_clone.html#sage.structure.list_clone.NormalizedClonableList" title="(in Sage 9.3 Reference Manual: Parents and Elements v9.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.list_clone.NormalizedClonableList</span></code></a></p>
<p>A fully commutative (FC) element in a Coxeter system.</p>
<p>An element <span class="math notranslate nohighlight">\(w\)</span> in a Coxeter system (W,S) is fully commutative (FC) if every
two reduced word of w can be related by a sequence of only commutation
relations, i.e., relations of the form <span class="math notranslate nohighlight">\(st=ts\)</span> where <span class="math notranslate nohighlight">\(s,t\)</span> are commuting
generators in <span class="math notranslate nohighlight">\(S\)</span>.</p>
<p>Every FC element has a canonical reduced word called its Cartier–Foata
form. See <a class="reference internal" href="../../../references/index.html#gre2006" id="id2"><span>[Gre2006]</span></a>. We will normalize each FC element to this form.</p>
<dl class="py method">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElement.check">
<code class="sig-name descname">check</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement.check" title="Permalink to this definition">¶</a></dt>
<dd><p>Called automatically when an element is created.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="c1"># indirect doctest</span>
<span class="go">[1, 2]</span>
<span class="gp">sage: </span><span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="c1"># indirect doctest</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the input is not a reduced word of a fully commutative element</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElement.coset_decomposition">
<code class="sig-name descname">coset_decomposition</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">side</span><span class="o">=</span><span class="default_value">'left'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement.coset_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coset decomposition of <code class="docutils literal notranslate"><span class="pre">self</span></code> with respect to the parabolic
subgroup generated by <code class="docutils literal notranslate"><span class="pre">J</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">J</span></code> – subset of the generating set <span class="math notranslate nohighlight">\(S\)</span> of the Coxeter system</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">side</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'left'</span></code>); if the value is set to
‘right’, then the function returns the tuple <span class="math notranslate nohighlight">\((w'^J, w'_J)\)</span> from the
coset decomposition <span class="math notranslate nohighlight">\(w = w'^J \cdot w'_J\)</span> of <span class="math notranslate nohighlight">\(w\)</span> with respect to <span class="math notranslate nohighlight">\(J\)</span></p></li>
</ul>
<p>OUTPUT:</p>
<p>The tuple of elements <span class="math notranslate nohighlight">\((w_J, w^J)\)</span> such that <span class="math notranslate nohighlight">\(w=w_J \cdot w^J\)</span>, <span class="math notranslate nohighlight">\(w_J\)</span> is
generated by the elements in <span class="math notranslate nohighlight">\(J\)</span>, and <span class="math notranslate nohighlight">\(w^J\)</span> has no left descent from
<span class="math notranslate nohighlight">\(J\)</span>. This tuple is unique and satisfies the equation <span class="math notranslate nohighlight">\(\ell(w) =
\ell(w_J) + \ell(w^J)\)</span>, where <span class="math notranslate nohighlight">\(\ell\)</span> denotes Coxeter length, by general
theory; see Proposition 2.4.4 of <a class="reference internal" href="../../../references/index.html#bb2005" id="id3"><span>[BB2005]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FC</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">coset_decomposition</span><span class="p">({</span><span class="mi">1</span><span class="p">})</span>
<span class="go">([1], [6, 2, 5, 4, 6, 5])</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">coset_decomposition</span><span class="p">({</span><span class="mi">1</span><span class="p">},</span> <span class="n">side</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">([1, 6, 2, 5, 4, 6, 5], [])</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">coset_decomposition</span><span class="p">({</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">})</span>
<span class="go">([6, 5, 6], [1, 2, 4, 5])</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">coset_decomposition</span><span class="p">({</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">([1, 6, 2, 5, 4], [6, 5])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The factor <span class="math notranslate nohighlight">\(w_J\)</span> of the coset decomposition <span class="math notranslate nohighlight">\(w = w_J \cdot
w^J\)</span> can be obtained by greedily “pulling left descents of <span class="math notranslate nohighlight">\(w\)</span> that
are in <span class="math notranslate nohighlight">\(J\)</span> to the left”; see the proof of <a class="reference internal" href="../../../references/index.html#bb2005" id="id4"><span>[BB2005]</span></a>. This greedy
algorithm works for all elements in Coxeter group, but it becomes
especially simple for FC elements because descents are easier to
find for FC elements.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElement.descents">
<code class="sig-name descname">descents</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">side</span><span class="o">=</span><span class="default_value">'left'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement.descents" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the set of descents on the appropriate side of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">side</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'left'</span></code>); if set to ‘right’, find the
right descents</p></li>
</ul>
<p>A generator <span class="math notranslate nohighlight">\(s\)</span> is called a left or right descent of an element <span class="math notranslate nohighlight">\(w\)</span> if
<span class="math notranslate nohighlight">\(l(sw)\)</span> or <span class="math notranslate nohighlight">\(l(ws)\)</span> is smaller than <span class="math notranslate nohighlight">\(l(w)\)</span>, respectively. If <span class="math notranslate nohighlight">\(w\)</span> is FC,
then <span class="math notranslate nohighlight">\(s\)</span> is a left descent of <span class="math notranslate nohighlight">\(w\)</span> if and only if <span class="math notranslate nohighlight">\(s\)</span> appears to in the
word and every generator to the left of the leftmost <span class="math notranslate nohighlight">\(s\)</span> in the word
commutes with <span class="math notranslate nohighlight">\(s\)</span>. A similar characterization exists for right descents
of FC elements.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FC</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">descents</span><span class="p">())</span>
<span class="go">[1, 4]</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">descents</span><span class="p">(</span><span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">{3}</span>
<span class="gp">sage: </span><span class="n">FC</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">descents</span><span class="p">())</span>
<span class="go">[1, 4]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement.find_descent" title="sage.combinat.fully_commutative_elements.FullyCommutativeElement.find_descent"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_descent()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElement.find_descent">
<code class="sig-name descname">find_descent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">side</span><span class="o">=</span><span class="default_value">'left'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement.find_descent" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <code class="docutils literal notranslate"><span class="pre">s</span></code> is a descent of <code class="docutils literal notranslate"><span class="pre">self</span></code> and find its position if so.</p>
<p>A generator <span class="math notranslate nohighlight">\(s\)</span> is called a left or right descent of an element <span class="math notranslate nohighlight">\(w\)</span> if
<span class="math notranslate nohighlight">\(l(sw)\)</span> or <span class="math notranslate nohighlight">\(l(ws)\)</span> is smaller than <span class="math notranslate nohighlight">\(l(w)\)</span>, respectively. If <span class="math notranslate nohighlight">\(w\)</span> is FC,
then <span class="math notranslate nohighlight">\(s\)</span> is a left descent of <span class="math notranslate nohighlight">\(w\)</span> if and only if <span class="math notranslate nohighlight">\(s\)</span> appears to in the
word and every generator to the left of the leftmost <span class="math notranslate nohighlight">\(s\)</span> in the word
commutes with <span class="math notranslate nohighlight">\(s\)</span>. A similar characterization exists for right descents
of FC elements.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> – integer representing a generator of the Coxeter system</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">side</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'left'</span></code>); if the argument is set to
‘right’, the function checks if <code class="docutils literal notranslate"><span class="pre">s</span></code> is a right descent of <code class="docutils literal notranslate"><span class="pre">self</span></code>
and finds the index of the rightmost occurrence of <code class="docutils literal notranslate"><span class="pre">s</span></code> if so</p></li>
</ul>
<p>OUTPUT:</p>
<p>Determine if the generator <code class="docutils literal notranslate"><span class="pre">s</span></code> is a left descent of <code class="docutils literal notranslate"><span class="pre">self</span></code>; return
the index of the leftmost occurrence of <code class="docutils literal notranslate"><span class="pre">s</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code> if so and
return <code class="docutils literal notranslate"><span class="pre">None</span></code> if not.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FC</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">find_descent</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">find_descent</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">find_descent</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">find_descent</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">find_descent</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElement.group_element">
<code class="sig-name descname">group_element</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement.group_element" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the actual element of the Coxeter group associated with
<code class="docutils literal notranslate"><span class="pre">self.parent()</span></code> corresponding to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">FC</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">group_element</span><span class="p">()</span>
<span class="go">[ 0 -1  1]</span>
<span class="go">[ 1 -1  1]</span>
<span class="go">[ 0  0  1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">group_element</span><span class="p">()</span> <span class="ow">in</span> <span class="n">W</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElement.has_descent">
<code class="sig-name descname">has_descent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">side</span><span class="o">=</span><span class="default_value">'left'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement.has_descent" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if <code class="docutils literal notranslate"><span class="pre">s</span></code> is a descent on the appropriate side of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">side</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'left'</span></code>); if set to ‘right’, determine
if <code class="docutils literal notranslate"><span class="pre">self</span></code> has <code class="docutils literal notranslate"><span class="pre">s</span></code> as a right descent</p></li>
</ul>
<p>OUTPUT: a boolean value</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FC</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">has_descent</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">has_descent</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">has_descent</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">has_descent</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement.find_descent" title="sage.combinat.fully_commutative_elements.FullyCommutativeElement.find_descent"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_descent()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElement.heap">
<code class="sig-name descname">heap</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement.heap" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the heap poset of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The heap of an FC element <span class="math notranslate nohighlight">\(w\)</span> is a labeled poset that can be defined
from any reduced word of <span class="math notranslate nohighlight">\(w\)</span>. Different reduced words yield isomorphic
labeled posets, so the heap is well defined.</p>
<p>Heaps are very useful for visualizing and studying FC elements; see, for
example, <a class="reference internal" href="../../../references/index.html#ste1996" id="id5"><span>[Ste1996]</span></a> and <a class="reference internal" href="../../../references/index.html#gx2020" id="id6"><span>[GX2020]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self</span></code> – list, a reduced word <span class="math notranslate nohighlight">\(w=s_0... s_{k-1}\)</span> of an FC element</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">one_index</span></code> – boolean (default: False). Setting the value to True
will change the underlying set of the poset to <span class="math notranslate nohighlight">\(\{1, 2, \dots, n\}\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">display_labeling</span></code> – boolean (default: False). Setting the value to
True will display the label <span class="math notranslate nohighlight">\(s_i\)</span> for each element <span class="math notranslate nohighlight">\(i\)</span> of the poset</p></li>
</ul>
<p>OUTPUT: A labeled poset where the underlying set is <span class="math notranslate nohighlight">\(\{0,1,...,k-1\}\)</span>
and where each element <span class="math notranslate nohighlight">\(i\)</span> carries <span class="math notranslate nohighlight">\(s_i\)</span> as its label. The partial order
<span class="math notranslate nohighlight">\(\prec\)</span> on the poset is defined by declaring <span class="math notranslate nohighlight">\(i\prec j\)</span> if <span class="math notranslate nohighlight">\(i&lt;j\)</span> and
<span class="math notranslate nohighlight">\(m(s_i,s_j)\neq 2\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FC</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">heap</span><span class="p">()</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[1, 2], [1, 3], [2, 5], [2, 4], [3, 5], [0, 4]]</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">heap</span><span class="p">(</span><span class="n">one_index</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">cover_relations</span><span class="p">()</span>
<span class="go">[[2, 3], [2, 4], [3, 6], [3, 5], [4, 6], [1, 5]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElement.is_fully_commutative">
<code class="sig-name descname">is_fully_commutative</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement.is_fully_commutative" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <code class="docutils literal notranslate"><span class="pre">self</span></code> is the reduced word of an FC element.</p>
<p>To check if <span class="math notranslate nohighlight">\(self\)</span> is FC, we use the well-known characterization that an
element <span class="math notranslate nohighlight">\(w\)</span> in a Coxeter system <span class="math notranslate nohighlight">\((W,S)\)</span> is FC if and only if for every
pair of generators <span class="math notranslate nohighlight">\(s,t \in S\)</span> for which <span class="math notranslate nohighlight">\(m(s,t)&gt;2\)</span>, no reduced word of
<span class="math notranslate nohighlight">\(w\)</span> contains the ‘braid’ word <span class="math notranslate nohighlight">\(sts...\)</span> of length <span class="math notranslate nohighlight">\(m(s,t)\)</span> as a
contiguous subword. See <a class="reference internal" href="../../../references/index.html#ste1996" id="id7"><span>[Ste1996]</span></a>.</p>
<p><a class="reference internal" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement.check" title="sage.combinat.fully_commutative_elements.FullyCommutativeElement.check"><code class="xref py py-func docutils literal notranslate"><span class="pre">check()</span></code></a> is an alias of this method, and is called automatically
when an element is created.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FC</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span> <span class="n">x</span><span class="o">.</span><span class="n">is_fully_commutative</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">FC</span><span class="o">.</span><span class="n">element_class</span><span class="p">(</span><span class="n">FC</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">check</span><span class="o">=</span><span class="bp">False</span><span class="p">);</span> <span class="n">x</span><span class="o">.</span><span class="n">is_fully_commutative</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElement.n_value">
<code class="sig-name descname">n_value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement.n_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the n-value of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The <em>n-value</em> of a fully commutative element is the <em>width</em> (length of
any longest antichain) of its heap. The n-value is important as it
coincides with Lusztig’s a-value for FC elements in all Weyl and affine
Weyl groups as well as so-called star-reducible groups; see <a class="reference internal" href="../../../references/index.html#gx2020" id="id8"><span>[GX2020]</span></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FC</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">n_value</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">n_value</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">n_value</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">n_value</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElement.normalize">
<code class="sig-name descname">normalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Mutate <code class="docutils literal notranslate"><span class="pre">self</span></code> into Cartier-Foata normal form.</p>
<p>EXAMPLES:</p>
<p>The following reduced words express the same FC elements in <span class="math notranslate nohighlight">\(B_5\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FC</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1"># indirect doctest</span>
<span class="go">[1, 4, 3, 5, 2, 4, 3]</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1"># indirect doctest</span>
<span class="go">[1, 4, 3, 5, 2, 4, 3]</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1"># indirect doctest</span>
<span class="go">[1, 4, 3, 5, 2, 4, 3]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Cartier–Foata form of a reduced word of an FC element <span class="math notranslate nohighlight">\(w\)</span> can
be found recursively by repeatedly moving left descents of
elements to the left and ordering the left descents from small to
large. In the above example, the left descents of the element are
4 and 1, therefore the Cartier–Foata form of the element is the
concatenation of [1,4] with the Cartier–Foata form of the
remaining part of the word. See <a class="reference internal" href="../../../references/index.html#gre2006" id="id9"><span>[Gre2006]</span></a>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement.descents" title="sage.combinat.fully_commutative_elements.FullyCommutativeElement.descents"><code class="xref py py-func docutils literal notranslate"><span class="pre">descents()</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElement.plot_heap">
<code class="sig-name descname">plot_heap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement.plot_heap" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the Hasse diagram of the heap of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The Hasse diagram is rendered in the lattice <span class="math notranslate nohighlight">\(S \times \NN\)</span>, with
every element <span class="math notranslate nohighlight">\(i\)</span> in the poset drawn as a point labelled by its label
<span class="math notranslate nohighlight">\(s_i\)</span>. Every point is placed in the column for its label at a certain
level. The levels start at 0 and the level k of an element <span class="math notranslate nohighlight">\(i\)</span> is the
maximal number <span class="math notranslate nohighlight">\(k\)</span> such that the heap contains a chain <span class="math notranslate nohighlight">\(i_0\prec
i_1\prec ... \prec i_k\)</span> where <span class="math notranslate nohighlight">\(i_k=i\)</span>. See <a class="reference internal" href="../../../references/index.html#ste1996" id="id10"><span>[Ste1996]</span></a> and <a class="reference internal" href="../../../references/index.html#gx2020" id="id11"><span>[GX2020]</span></a>.</p>
<p>OUTPUT: GraphicsObject</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FC</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">plot_heap</span><span class="p">()</span>
<span class="go">Graphics object consisting of 15 graphics primitives</span>
</pre></div>
</div>
<div class="figure align-default">
<a class="reference internal image-reference" href="../../_images/fully_commutative_elements-1.svg"><img alt="../../_images/fully_commutative_elements-1.svg" src="../../_images/fully_commutative_elements-1.svg" width="400px" /></a>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElement.star_operation">
<code class="sig-name descname">star_operation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">J</span></em>, <em class="sig-param"><span class="n">direction</span></em>, <em class="sig-param"><span class="n">side</span><span class="o">=</span><span class="default_value">'left'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement.star_operation" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a star operation on <code class="docutils literal notranslate"><span class="pre">self</span></code> relative to two noncommuting
generators.</p>
<p>Star operations were first defined on elements of Coxeter groups by
Kazhdan and Lusztig in <a class="reference internal" href="../../../references/index.html#kl1979" id="id12"><span>[KL1979]</span></a> with respect to pair of generators
<span class="math notranslate nohighlight">\(s,t\)</span> such that <span class="math notranslate nohighlight">\(m(s,t)=3\)</span>. Later, Lusztig generalized the definition in
<a class="reference internal" href="../../../references/index.html#lus1985" id="id13"><span>[Lus1985]</span></a>, via coset decompositions, to allow star operations with
respect to any pair of generators <span class="math notranslate nohighlight">\(s,t\)</span> such that <span class="math notranslate nohighlight">\(m(s,t)\ge 3\)</span>. Given
such a pair, we can potentially perform four types of star operations
corresponding to all combinations of a ‘direction’ and a ‘side’: upper
left, lower left, upper right and lower right; see <a class="reference internal" href="../../../references/index.html#gre2006" id="id14"><span>[Gre2006]</span></a>.</p>
<p>Let <span class="math notranslate nohighlight">\(w\)</span> be an element in <span class="math notranslate nohighlight">\(W\)</span> and let <span class="math notranslate nohighlight">\(J\)</span> be any pair <span class="math notranslate nohighlight">\(\{s, t\}\)</span> of
noncommuting generators in <span class="math notranslate nohighlight">\(S\)</span>. Consider the coset decomposition <span class="math notranslate nohighlight">\(w =
w_J \cdot {}^J w\)</span> of <span class="math notranslate nohighlight">\(w\)</span> relative to <span class="math notranslate nohighlight">\(J\)</span>. Then an upper left star
operation is defined on <span class="math notranslate nohighlight">\(w\)</span> if and only if  <span class="math notranslate nohighlight">\(1 \le l(w_J) \le m(s,t)-2\)</span>;
when this is the case, the operation returns <span class="math notranslate nohighlight">\(x\cdot w_J\cdot w^J\)</span> where
<span class="math notranslate nohighlight">\(x\)</span> is the letter <span class="math notranslate nohighlight">\(J\)</span> different from the leftmost letter of <span class="math notranslate nohighlight">\(w_J\)</span>. A
lower left star operation is defined on <span class="math notranslate nohighlight">\(w\)</span> if and only if <span class="math notranslate nohighlight">\(2 \le l(w_J)
\le m(s,t)-1\)</span>; when this is the case, the operation removes the leftmost
letter of <span class="math notranslate nohighlight">\(w_J\)</span> from <span class="math notranslate nohighlight">\(w\)</span>.  Similar facts hold for right star operations.
See <a class="reference internal" href="../../../references/index.html#gre2006" id="id15"><span>[Gre2006]</span></a>.</p>
<p>The facts of the previous paragraph hold in general, even if <span class="math notranslate nohighlight">\(w\)</span> is not
FC. Note that if <span class="math notranslate nohighlight">\(f\)</span> is a star operation of any kind, then for every
element <span class="math notranslate nohighlight">\(w \in W\)</span>, the elements <span class="math notranslate nohighlight">\(w\)</span> and <span class="math notranslate nohighlight">\(f(w)\)</span> are either both FC or
both not FC.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">J</span></code> – a set of two integers representing two noncommuting
generators of the Coxeter system</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">direction</span></code> – string, <code class="docutils literal notranslate"><span class="pre">'upper'</span></code> or <code class="docutils literal notranslate"><span class="pre">'lower'</span></code>; the function
performs an upper or lower star operation according to <code class="docutils literal notranslate"><span class="pre">direction</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">side</span></code> – string (default: <code class="docutils literal notranslate"><span class="pre">'left'</span></code>); if this is set to ‘right’,
the function performs a right star operation</p></li>
</ul>
<p>OUTPUT:</p>
<p>The Cartier–Foata form of the result of the star operation if the
operation is defined on <code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise.</p>
<p>EXAMPLES:</p>
<p>We will compute all star operations on the following FC element in type
<span class="math notranslate nohighlight">\(B_6\)</span> relative to <span class="math notranslate nohighlight">\(J = \{5, 6\}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FC</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
<p>Whether and how a left star operations can be applied depend on the
coset decomposition <span class="math notranslate nohighlight">\(w = w_J \cdot w^J\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">coset_decomposition</span><span class="p">({</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">})</span>
<span class="go">([6, 5, 6], [1, 2, 4, 5])</span>
</pre></div>
</div>
<p>Only the lower star operation is defined on the left on <span class="math notranslate nohighlight">\(w\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">star_operation</span><span class="p">({</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="s1">&#39;upper&#39;</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">star_operation</span><span class="p">({</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="s1">&#39;lower&#39;</span><span class="p">)</span>
<span class="go">[1, 5, 2, 4, 6, 5]</span>
</pre></div>
</div>
<p>Whether and how a right star operations can be applied depend on the
coset decomposition <span class="math notranslate nohighlight">\(w = w^J \cdot w_J\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">coset_decomposition</span><span class="p">({</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">([1, 6, 2, 5, 4], [6, 5])</span>
</pre></div>
</div>
<p>Both types of right star operations on defined for this example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">star_operation</span><span class="p">({</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span> <span class="s1">&#39;upper&#39;</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">[1, 6, 2, 5, 4, 6, 5, 6]</span>

<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">star_operation</span><span class="p">({</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span> <span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">[1, 6, 2, 5, 4, 6]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElements">
<em class="property">class </em><code class="sig-prename descclassname">sage.combinat.fully_commutative_elements.</code><code class="sig-name descname">FullyCommutativeElements</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coxeter_group</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage 9.3 Reference Manual: Parents and Elements v9.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></code></a>, <a class="reference external" href="../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage 9.3 Reference Manual: Parents and Elements v9.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>Class for the set of fully commutative (FC) elements of a Coxeter system.</p>
<p>Coxeter systems with finitely many FC elements, or <em>FC-finite</em> Coxeter
systems, are classfied by Stembridge in <a class="reference internal" href="../../../references/index.html#ste1996" id="id16"><span>[Ste1996]</span></a>. They fall into seven
families, namely the groups of types <span class="math notranslate nohighlight">\(A_n, B_n, D_n, E_n, F_n, H_n\)</span> and
<span class="math notranslate nohighlight">\(I_2(m)\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code> – CoxeterMatrix, CartanType, or the usual datum that can is
taken in the constructors for these classes (see
<a class="reference internal" href="root_system/coxeter_group.html#sage.combinat.root_system.coxeter_group.CoxeterGroup" title="sage.combinat.root_system.coxeter_group.CoxeterGroup"><code class="xref py py-func docutils literal notranslate"><span class="pre">sage.combinat.root_system.coxeter_group.CoxeterGroup()</span></code></a>)</p></li>
</ul>
<p>OUTPUT:</p>
<p>The class of fully commutative elements in the Coxeter group constructed
from <code class="docutils literal notranslate"><span class="pre">data</span></code>. This will belong to the category of enumerated sets. If the
Coxeter data corresponds to a Cartan type, the category is further refined
to either finite enumerated sets or infinite enumerated sets depending on i
whether the Coxeter group is FC-finite; the refinement is not carried out if
<code class="docutils literal notranslate"><span class="pre">data</span></code> is a Coxeter matrix not corresponding to a Cartan type.</p>
<div class="admonition-todo admonition" id="id17">
<p class="admonition-title">Todo</p>
<p>It would be ideal to implement the aforementioned refinement to finite
and infinite enumerated sets for all possible <code class="docutils literal notranslate"><span class="pre">data</span></code>, regardless of
whether it corresponds to a Cartan type. Doing so requires determining
if an arbitrary Coxeter matrix corresponds to a Cartan type. It may be
best to address this issue in <code class="docutils literal notranslate"><span class="pre">sage.combinat.root_system</span></code>. On the other
hand, the refinement in the general case may be unnecessary in light of
the fact that Stembridge’s classification of FC-finite groups contains
a very small number of easily-recognizable families.</p>
</div>
<p>EXAMPLES:</p>
<p>Create the enumerate set of fully commutative elements in <span class="math notranslate nohighlight">\(B_3\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FC</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">();</span> <span class="n">FC</span>
<span class="go">Fully commutative elements of Finite Coxeter group over Number Field in a with defining polynomial x^2 - 2 with a = 1.414213562373095? with Coxeter matrix:</span>
<span class="go">[1 3 2]</span>
<span class="go">[3 1 4]</span>
<span class="go">[2 4 1]</span>
</pre></div>
</div>
<p>Construct elements:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FC</span><span class="p">([])</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[1, 2]</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[2, 3, 2]</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">[3, 2, 3]</span>
</pre></div>
</div>
<p>Elements are normalized to Cartier–Foata normal form upon construction:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[1, 3]</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">[2, 1, 3]</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="n">FC</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Attempting to create an element from an input that is not the reduced word
of a fully commutative element throws a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the input is not a reduced word of a fully commutative element</span>
<span class="gp">sage: </span><span class="n">FC</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: the input is not a reduced word of a fully commutative element</span>
</pre></div>
</div>
<p>Enumerate the FC elements in <span class="math notranslate nohighlight">\(A_3\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FCA3</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FCA3</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite enumerated sets</span>
<span class="gp">sage: </span><span class="n">FCA3</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[],</span>
<span class="go"> [1],</span>
<span class="go"> [2],</span>
<span class="go"> [3],</span>
<span class="go"> [2, 1],</span>
<span class="go"> [1, 3],</span>
<span class="go"> [1, 2],</span>
<span class="go"> [3, 2],</span>
<span class="go"> [2, 3],</span>
<span class="go"> [3, 2, 1],</span>
<span class="go"> [2, 1, 3],</span>
<span class="go"> [1, 3, 2],</span>
<span class="go"> [1, 2, 3],</span>
<span class="go"> [2, 1, 3, 2]]</span>
</pre></div>
</div>
<p>Count the FC elements in <span class="math notranslate nohighlight">\(B_8\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FCB8</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">FCB8</span><span class="p">)</span>    <span class="c1"># long time (7 seconds)</span>
<span class="go">14299</span>
</pre></div>
</div>
<p>Iterate through the FC elements of length up to 2 in the non-FC-finite group
affine <span class="math notranslate nohighlight">\(A_2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FCAffineA2</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FCAffineA2</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of infinite enumerated sets</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">FCAffineA2</span><span class="o">.</span><span class="n">iterate_to_length</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[], [0], [1], [2], [1, 0], [2, 0], [0, 1], [2, 1], [0, 2], [1, 2]]</span>
</pre></div>
</div>
<p>The cardinality of the set is determined from the classification of
FC-finite Coxeter groups:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">CoxeterGroup</span><span class="p">(</span><span class="s1">&#39;A2&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite enumerated sets</span>
<span class="gp">sage: </span><span class="n">CoxeterGroup</span><span class="p">(</span><span class="s1">&#39;B7&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite enumerated sets</span>
<span class="gp">sage: </span><span class="n">CoxeterGroup</span><span class="p">(</span><span class="s1">&#39;A3~&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of infinite enumerated sets</span>
<span class="gp">sage: </span><span class="n">CoxeterGroup</span><span class="p">(</span><span class="s1">&#39;F4~&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite enumerated sets</span>
<span class="gp">sage: </span><span class="n">CoxeterGroup</span><span class="p">(</span><span class="s1">&#39;E8~&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite enumerated sets</span>
<span class="gp">sage: </span><span class="n">CoxeterGroup</span><span class="p">(</span><span class="s1">&#39;F4~xE8~&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite enumerated sets</span>
<span class="gp">sage: </span><span class="n">CoxeterGroup</span><span class="p">(</span><span class="s1">&#39;B4~xE8~&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of infinite enumerated sets</span>
</pre></div>
</div>
<dl class="py attribute">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElements.Element">
<code class="sig-name descname">Element</code><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElements.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElement" title="sage.combinat.fully_commutative_elements.FullyCommutativeElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">FullyCommutativeElement</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElements.coxeter_group">
<code class="sig-name descname">coxeter_group</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElements.coxeter_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain the Coxeter group associated with <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FCA3</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FCA3</span><span class="o">.</span><span class="n">coxeter_group</span><span class="p">()</span>
<span class="go">Finite Coxeter group over Integer Ring with Coxeter matrix:</span>
<span class="go">[1 3 2]</span>
<span class="go">[3 1 3]</span>
<span class="go">[2 3 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.fully_commutative_elements.FullyCommutativeElements.iterate_to_length">
<code class="sig-name descname">iterate_to_length</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">length</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.fully_commutative_elements.FullyCommutativeElements.iterate_to_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate through the elements of this class up to a maximum length.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">length</span></code> – integer; maximum length of element to generate</p></li>
</ul>
<p>OUTPUT: generator for elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> of length up to <code class="docutils literal notranslate"><span class="pre">length</span></code></p>
<p>EXAMPLES:</p>
<p>The following example produces all FC elements of length up to 2 in the
group <span class="math notranslate nohighlight">\(A_3\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FCA3</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">FCA3</span><span class="o">.</span><span class="n">iterate_to_length</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[], [1], [2], [3], [2, 1], [1, 3], [1, 2], [3, 2], [2, 3]]</span>
</pre></div>
</div>
<p>The lists for length 4 and 5 are the same since 4 is the maximum length
of an FC element in <span class="math notranslate nohighlight">\(A_3\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">FCA3</span><span class="o">.</span><span class="n">iterate_to_length</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">[[], [1], [2], [3], [2, 1], [1, 3], [1, 2], [3, 2], [2, 3],</span>
<span class="go"> [3, 2, 1], [2, 1, 3], [1, 3, 2], [1, 2, 3], [2, 1, 3, 2]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">FCA3</span><span class="o">.</span><span class="n">iterate_to_length</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">[[], [1], [2], [3], [2, 1], [1, 3], [1, 2], [3, 2], [2, 3],</span>
<span class="go"> [3, 2, 1], [2, 1, 3], [1, 3, 2], [1, 2, 3], [2, 1, 3, 2]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">FCA3</span><span class="o">.</span><span class="n">iterate_to_length</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">FCA3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The following example produces all FC elements of length up to 4 in the
affine Weyl group <span class="math notranslate nohighlight">\(\tilde A_2\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">FCAffineA2</span> <span class="o">=</span> <span class="n">CoxeterGroup</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">fully_commutative_elements</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">FCAffineA2</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of infinite enumerated sets</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">FCAffineA2</span><span class="o">.</span><span class="n">iterate_to_length</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">[[], [0], [1], [2], [1, 0], [2, 0], [0, 1], [2, 1], [0, 2],</span>
<span class="go"> [1, 2], [2, 1, 0], [1, 2, 0], [2, 0, 1], [0, 2, 1], [1, 0, 2],</span>
<span class="go"> [0, 1, 2], [0, 2, 1, 0], [0, 1, 2, 0], [1, 2, 0, 1],</span>
<span class="go"> [1, 0, 2, 1], [2, 1, 0, 2], [2, 0, 1, 2]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Fully commutative elements of Coxeter groups</a><ul>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="fast_vector_partitions.html"
                        title="previous chapter">Brent Yorgey’s fast algorithm for integer vector (multiset) partitions.</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="finite_state_machine.html"
                        title="next chapter">Finite State Machines, Automata, Transducers</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/combinat/fully_commutative_elements.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="finite_state_machine.html" title="Finite State Machines, Automata, Transducers"
             >next</a> |</li>
        <li class="right" >
          <a href="fast_vector_partitions.html" title="Brent Yorgey’s fast algorithm for integer vector (multiset) partitions."
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.3 Reference Manual: Combinatorics</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../module_list.html" >Comprehensive Module list</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Fully commutative elements of Coxeter groups</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2021, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>