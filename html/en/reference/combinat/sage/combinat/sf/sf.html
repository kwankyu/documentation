
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Symmetric functions, with their multiple realizations &#8212; Sage 9.5 Reference Manual: Combinatorics</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sage.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script async="async" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Symmetric Functions" href="sfa.html" />
    <link rel="prev" title="Symplectic Symmetric Functions" href="symplectic.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="sfa.html" title="Symmetric Functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="symplectic.html" title="Symplectic Symmetric Functions"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Sage 9.5 Reference Manual: Combinatorics</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../../module_list.html" accesskey="U">Comprehensive Module List</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Symmetric functions, with their multiple realizations</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="symmetric-functions-with-their-multiple-realizations">
<span id="sage-combinat-sf-sf"></span><h1>Symmetric functions, with their multiple realizations<a class="headerlink" href="#symmetric-functions-with-their-multiple-realizations" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.sf.sf"></span><dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.combinat.sf.sf.</span></span><span class="sig-name descname"><span class="pre">SymmetricFunctions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Sage 9.5 Reference Manual: Parents and Elements v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></code></a>, <a class="reference external" href="../../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage 9.5 Reference Manual: Parents and Elements v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>The abstract algebra of commutative symmetric functions</p>
<p class="rubric">Symmetric Functions in Sage</p>
<p>This document is an introduction to working with symmetric function
theory in Sage.
It is not intended to be an introduction to the theory
of symmetric functions (<a class="reference internal" href="#mac" id="id1"><span>[MAC]</span></a> and <a class="reference internal" href="#sta" id="id2"><span>[STA]</span></a>, Chapter 7, are two excellent
references.)  The reader is also expected to be familiar with Sage.</p>
<p class="rubric">The algebra of symmetric functions</p>
<p>The algebra of symmetric functions is the unique free commutative graded
connected algebra over the given ring, with one generator in each degree.  It
can also be thought of as the inverse limit (in the category of graded
algebras) of the algebra of symmetric polynomials in <span class="math notranslate nohighlight">\(n\)</span> variables as <span class="math notranslate nohighlight">\(n \rightarrow \infty\)</span>.
Sage allows us to construct the algebra of symmetric functions over
any ring.  We will use a base ring of rational numbers in these first
examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Sym</span>
<span class="go">Symmetric Functions over Rational Field</span>
</pre></div>
</div>
<p>Sage knows certain categorical information about this algebra:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of hopf algebras over Rational Field</span>
<span class="go">    and Category of graded algebras over Rational Field</span>
<span class="go">    and Category of commutative algebras over Rational Field</span>
<span class="go">    and Category of monoids with realizations</span>
<span class="go">    and Category of graded coalgebras over Rational Field</span>
<span class="go">    and Category of coalgebras over Rational Field with realizations</span>
<span class="go">    and Category of cocommutative coalgebras over Rational Field</span>
</pre></div>
</div>
<p>Notice that <code class="docutils literal notranslate"><span class="pre">Sym</span></code> is an <em>abstract</em> algebra.  This reflects the fact that
there are multiple natural bases.  To work with specific
elements, we need a <em>realization</em> of this algebra.  In practice, this
means we need to specify a basis.</p>
<p class="rubric">An example basis - power sums</p>
<p>Here is an example of how one might use the power sum realization:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">powersum</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span>
<span class="go">Symmetric Functions over Rational Field in the powersum basis</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">p</span></code> now represents the realization of the symmetric function algebra on
the power sum basis.  The basis itself is accessible through:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="go">Lazy family (Term map from Partitions to Symmetric Functions over Rational Field in the powersum basis(i))_{i in Partitions}</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">Partitions</span>
</pre></div>
</div>
<p>This last line means that <code class="docutils literal notranslate"><span class="pre">p.basis()</span></code> is an association between the set
of Partitions and the basis elements of the algebra <code class="docutils literal notranslate"><span class="pre">p</span></code>. To construct a
specific element one can therefore do:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="n">Partition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])]</span>
<span class="go">p[2, 1, 1]</span>
</pre></div>
</div>
<p>As this is rather cumbersome, realizations of the symmetric function
algebra allow for the following abuses of notation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="n">Partition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])]</span>
<span class="go">p[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="go">p[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">p[2, 1, 1]</span>
</pre></div>
</div>
<p>or even:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="p">[(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])]</span>
<span class="go">p[2, 1, 1]</span>
</pre></div>
</div>
<p>In the special case of the empty partition, due to a limitation in
Python syntax, one cannot use:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="p">[]</span>       <span class="c1"># todo: not implemented</span>
</pre></div>
</div>
<p>Please use instead:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="p">[[]]</span>
<span class="go">p[]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When elements are constructed using the <code class="docutils literal notranslate"><span class="pre">p[something</span> <span class="pre">]</span></code> syntax ,
an error will be raised if the input cannot be interpreted as a partition.
This is <em>not</em> the case when <code class="docutils literal notranslate"><span class="pre">p.basis()</span></code> is used:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;something&#39;</span><span class="p">]</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: all parts of &#39;something&#39; should be nonnegative integers</span>
<span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="s1">&#39;something&#39;</span><span class="p">]</span>
<span class="go">p&#39;something&#39;</span>
</pre></div>
</div>
</div>
<p>Elements of <code class="docutils literal notranslate"><span class="pre">p</span></code> are linear combinations of such compositions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*p[] + 2*p[1] + 3*p[2]</span>
</pre></div>
</div>
<p class="rubric">Algebra structure</p>
<p>Algebraic combinations of basis elements can be entered in a natural way:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">3*p[2, 1, 1] + 2*p[4, 1]</span>
</pre></div>
</div>
<p>Let us explore the other operations of <code class="docutils literal notranslate"><span class="pre">p</span></code>. We can ask for
the mathematical properties of <code class="docutils literal notranslate"><span class="pre">p</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">categories</span><span class="p">()</span>
<span class="go">[Category of graded bases of Symmetric Functions over Rational Field,</span>
<span class="go"> Category of filtered bases of Symmetric Functions over Rational Field,</span>
<span class="go"> Category of bases of Symmetric Functions over Rational Field,</span>
<span class="go"> Category of graded hopf algebras with basis over Rational Field,</span>
<span class="go"> ...]</span>
</pre></div>
</div>
<p>To start with, <code class="docutils literal notranslate"><span class="pre">p</span></code> is a graded algebra, the grading being induced
by the size of the partitions. Due to this, the one is the basis
element indexed by the empty partition:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="go">p[]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">p</span></code> basis is multiplicative; that is, multiplication is induced by
linearity from the (nonincreasingly sorted) concatenation of partitions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">p[3, 2, 1, 1]</span>

<span class="gp">sage: </span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">one</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="go">p[4, 2] + 2*p[4, 3, 2, 1]</span>
</pre></div>
</div>
<p class="rubric">The classical bases</p>
<p>In addition to the power sum basis, other classical bases of the
symmetric function algebra include the elementary, complete
homogeneous, monomial, and Schur bases:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">homogeneous</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
</pre></div>
</div>
<p>These and others can be defined all at once with the single command:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">inject_shorthands</span><span class="p">()</span>
<span class="go">Defining e as shorthand for Symmetric Functions over Rational Field in the elementary basis</span>
<span class="go">Defining f as shorthand for Symmetric Functions over Rational Field in the forgotten basis</span>
<span class="go">Defining h as shorthand for Symmetric Functions over Rational Field in the homogeneous basis</span>
<span class="go">Defining m as shorthand for Symmetric Functions over Rational Field in the monomial basis</span>
<span class="go">Defining p as shorthand for Symmetric Functions over Rational Field in the powersum basis</span>
<span class="go">Defining s as shorthand for Symmetric Functions over Rational Field in the Schur basis</span>
</pre></div>
</div>
<p>We can then do conversions from one basis to another:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">-s[1, 1, 1] + s[3]</span>

<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">m[3]</span>
<span class="gp">sage: </span><span class="n">m</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">m[3, 2] + m[5]</span>
</pre></div>
</div>
<p>For computations which mix bases, Sage will return a result with respect
to a single (not necessarily predictable) basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="go">1/2*p[2, 1, 1] + 1/2*p[2, 2] - p[4]</span>

<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">e</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">))</span>
<span class="go">p[1] + 1/12*p[1, 1, 1, 1, 1, 1] - 1/6*p[2, 1, 1, 1, 1] - 1/4*p[2, 2, 1, 1] + 1/6*p[3, 1, 1, 1] + 1/6*p[3, 2, 1]</span>
</pre></div>
</div>
<p>The one for different bases such as the power sum and Schur function is the same:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">one</span><span class="p">()</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">Basic computations</p>
<p>In this section, we explore some of the many methods that can be applied
to an arbitrary symmetric function:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span><span class="p">;</span> <span class="n">f</span>
<span class="go">s[2, 2] + s[3, 1] + s[4]</span>
</pre></div>
</div>
<p>For more methods than discussed here, create a symmetric function as
above, and use <code class="docutils literal notranslate"><span class="pre">f.&lt;tab&gt;</span></code>.</p>
<p class="rubric" id="representation-theory-of-the-symmetric-group">Representation theory of the symmetric group</p>
<p>The Schur functions <span class="math notranslate nohighlight">\(s_\lambda\)</span> can also be interpreted as irreducible characters of the symmetric
group <span class="math notranslate nohighlight">\(S_n\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the size of the partition <span class="math notranslate nohighlight">\(\lambda\)</span>. Since the Schur functions of
degree <span class="math notranslate nohighlight">\(n\)</span> form a basis of the symmetric functions of degree <span class="math notranslate nohighlight">\(n\)</span>, it
follows that an arbitrary symmetric function (homogeneous of degree
<span class="math notranslate nohighlight">\(n\)</span>) may be interpreted as a function on the symmetric group. In this
interpretation the power sum symmetric function <span class="math notranslate nohighlight">\(p_\lambda\)</span> is the characteristic
function of the conjugacy class with shape <span class="math notranslate nohighlight">\(\lambda\)</span>, multiplied by the order of
the centralizer of an element. Hence the irreducible characters can be computed
as follows:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">([[</span><span class="n">s</span><span class="p">[</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">P</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">))]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">))])</span>
<span class="gp">sage: </span><span class="n">M</span>
<span class="go">[ 1 -1  1  1 -1 -1  1]</span>
<span class="go">[ 4 -2  0  1  1  0 -1]</span>
<span class="go">[ 5 -1  1 -1 -1  1  0]</span>
<span class="go">[ 6  0 -2  0  0  0  1]</span>
<span class="go">[ 5  1  1 -1  1 -1  0]</span>
<span class="go">[ 4  2  0  1 -1  0 -1]</span>
<span class="go">[ 1  1  1  1  1  1  1]</span>
</pre></div>
</div>
<p>We can indeed check that this agrees with the character table of <span class="math notranslate nohighlight">\(S_5\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">character_table</span><span class="p">()</span> <span class="o">==</span> <span class="n">M</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In this interpretation of symmetric functions as characters on the
symmetric group, the multiplication and comultiplication are
interpreted as induction (from <span class="math notranslate nohighlight">\(S_n\times S_m\)</span> to <span class="math notranslate nohighlight">\(S_{n+m}\)</span>)
and restriction, respectively. The Schur functions can also be interpreted
as characters of <span class="math notranslate nohighlight">\(GL_n\)</span>, see <a class="reference external" href="../../../../../thematic_tutorials/lie/lie_basics.html#partitions-and-schur-polynomials">Partitions and Schur functions</a>.</p>
<p class="rubric">The omega involution</p>
<p>The <span class="math notranslate nohighlight">\(\omega\)</span> involution is the linear extension of the map which sends
<span class="math notranslate nohighlight">\(e_\lambda\)</span> to <span class="math notranslate nohighlight">\(h_{\lambda}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">h[2, 2]</span>
<span class="gp">sage: </span><span class="n">e</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">omega</span><span class="p">())</span>
<span class="go">e[2, 2]</span>
</pre></div>
</div>
<p class="rubric">The Hall scalar product</p>
<p>The Hall scalar product on the algebra of symmetric functions makes the
Schur functions into an orthonormal basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p class="rubric">Skewing</p>
<p><em>Skewing</em> is the adjoint operation to multiplication with respect to
this scalar product:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*s[2, 1] + 2*s[3]</span>
</pre></div>
</div>
<p>In general, <code class="docutils literal notranslate"><span class="pre">s[la].skew_by(s[mu])</span></code> is the symmetric function typically
denoted <span class="math notranslate nohighlight">\(s_{\lambda \setminus \mu}\)</span> or <span class="math notranslate nohighlight">\(s_{\lambda / \mu}\)</span>.</p>
<p class="rubric">Expanding into variables</p>
<p>We can expand a symmetric function into a symmetric polynomial in a
specified number of variables:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">x0^4 + 2*x0^3*x1 + 3*x0^2*x1^2 + 2*x0*x1^3 + x1^4</span>
</pre></div>
</div>
<p>See the documentation for <code class="docutils literal notranslate"><span class="pre">expand</span></code> for more examples.</p>
<p class="rubric">The Kronecker product</p>
<p>As in the section on the <a class="reference internal" href="#representation-theory-of-the-symmetric-group">Representation theory of
the symmetric group</a>, a symmetric function may be considered as a
class function on the symmetric group where the elements
<span class="math notranslate nohighlight">\(p_\mu/z_\mu\)</span> are the indicators of a permutation having
cycle structure <span class="math notranslate nohighlight">\(\mu\)</span>.  The Kronecker product of two
symmetric functions corresponds to the pointwise product
of these class functions.</p>
<p>Since the Schur functions are the irreducible characters
of the symmetric group under this identification, the Kronecker
product of two Schur functions corresponds to the internal
tensor product of two irreducible symmetric group representations.</p>
<p>Under this identification, the Kronecker
product of <span class="math notranslate nohighlight">\(p_\mu/z_\mu\)</span> and <span class="math notranslate nohighlight">\(p_\nu/z_\nu\)</span> is <span class="math notranslate nohighlight">\(p_\mu/z_\mu\)</span>
if <span class="math notranslate nohighlight">\(\mu=\nu\)</span>, and the result is equal to <span class="math notranslate nohighlight">\(0\)</span> otherwise.</p>
<p><code class="docutils literal notranslate"><span class="pre">internal_product</span></code>, <code class="docutils literal notranslate"><span class="pre">kronecker_product</span></code>, <code class="docutils literal notranslate"><span class="pre">inner_tensor</span></code> and
<code class="docutils literal notranslate"><span class="pre">itensor</span></code> are different names for the same function.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">kronecker_product</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">s[1, 1, 1, 1] + 3*s[2, 1, 1] + 4*s[2, 2] + 5*s[3, 1] + 3*s[4]</span>
</pre></div>
</div>
<p class="rubric">Plethysm</p>
<p>The <em>plethysm</em> of symmetric functions is the operation corresponding to
composition of representations of the general linear group.  See <a class="reference internal" href="#sta" id="id4"><span>[STA]</span></a>
Chapter 7, Appendix 2 for details.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2, 2] + s[4]</span>
</pre></div>
</div>
<p>Plethysm can also be written as a composition of functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span>
<span class="go">s[2, 2] + s[4]</span>
</pre></div>
</div>
<p>If the coefficient ring contains degree 1 elements, these are handled
properly by plethysm:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="o">.&lt;</span><span class="n">t</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[];</span> <span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
<span class="go">(t^2-t)*s[1, 1] + (-t+1)*s[2]</span>
</pre></div>
</div>
<p>See the documentation for <code class="docutils literal notranslate"><span class="pre">plethysm</span></code> for more information.</p>
<p class="rubric">Inner plethysm</p>
<p>The operation of inner plethysm <code class="docutils literal notranslate"><span class="pre">f.inner_plethysm(g)</span></code> models the
composition of the <span class="math notranslate nohighlight">\(S_n\)</span> representation represented by <span class="math notranslate nohighlight">\(g\)</span> with the
<span class="math notranslate nohighlight">\(GL_m\)</span> representation whose character is <span class="math notranslate nohighlight">\(f\)</span>.  See the documentation of
<code class="docutils literal notranslate"><span class="pre">inner_plethysm</span></code>, <a class="reference internal" href="#st94" id="id5"><span>[ST94]</span></a> or <a class="reference internal" href="#sta" id="id6"><span>[STA]</span></a>, exercise 7.74 solutions for more
information:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">inner_plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">s[2]</span>
</pre></div>
</div>
<p class="rubric">Hopf algebra structure</p>
<p>The ring of symmetric functions is further endowed with a coalgebra
structure. The coproduct is an algebra morphism, and therefore
determined by its values on the generators; the power sum generators
are primitive:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">p[] # p[1] + p[1] # p[]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">p[] # p[2] + p[2] # p[]</span>
</pre></div>
</div>
<p>The coproduct, being cocommutative on the generators, is cocommutative everywhere:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">p[] # p[2, 1] + p[1] # p[2] + p[2] # p[1] + p[2, 1] # p[]</span>
</pre></div>
</div>
<p>This coproduct, along with the counit which sends every symmetric function
to its <span class="math notranslate nohighlight">\(0\)</span>-th homogeneous component, makes the ring of symmetric functions
into a graded connected bialgebra. It is known that every graded connected
bialgebra has an antipode. For the ring of symmetric functions, the antipode
can be characterized explicitly: The antipode is an anti-algebra morphism
(thus an algebra morphism, since our algebra is commutative) which sends
<span class="math notranslate nohighlight">\(p_{\lambda}\)</span> to <span class="math notranslate nohighlight">\((-1)^{\mathrm{length}(\lambda)} p_{\lambda}\)</span> for every
partition <span class="math notranslate nohighlight">\(\lambda\)</span>. Thus, in particular, it sends the generators on the
<code class="docutils literal notranslate"><span class="pre">p</span></code> basis to their opposites:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">-p[3]</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">-p[3, 2, 1]</span>
</pre></div>
</div>
<p>The graded connected bialgebra of symmetric functions over a <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra
has a rather simply-understood structure: It is (isomorphic to) the
symmetric algebra of its space of primitives (which is spanned by the
power-sum symmetric functions).</p>
<p>Here are further examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">s[1, 1, 1, 1] + s[2, 1, 1] + s[2, 2]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">s[] # s[2, 2] + s[] # s[3, 1] + s[] # s[4] + 2*s[1] # s[2, 1] + 2*s[1] # s[3] + s[1, 1] # s[1, 1]</span>
<span class="go">+ s[1, 1] # s[2] + s[2] # s[1, 1] + 3*s[2] # s[2] + 2*s[2, 1] # s[1] + s[2, 2] # s[] + 2*s[3] # s[1]</span>
<span class="go">+ s[3, 1] # s[] + s[4] # s[]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span><span class="o">.</span><span class="n">apply_multilinear_morphism</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p class="rubric">Transformations of symmetric functions</p>
<p>There are many methods in Sage which make it easy to manipulate symmetric
functions.  For example, if we have some function which acts on partitions
(say, conjugation), it is a simple matter to apply it to the support of a
symmetric function.  Here is an example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">conj</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">mu</span><span class="p">:</span> <span class="n">mu</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">map_support</span><span class="p">(</span><span class="n">conj</span><span class="p">)</span>
<span class="go">h[1, 1, 1, 1] + 2*h[2, 1, 1]</span>
</pre></div>
</div>
<p>We can also easily modify the coefficients:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">coeff</span><span class="p">):</span> <span class="k">return</span> <span class="n">mu</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(),</span> <span class="o">-</span><span class="n">coeff</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">map_item</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="go">-h[1, 1, 1, 1] - 2*h[2, 1, 1]</span>
</pre></div>
</div>
<p>See also <code class="docutils literal notranslate"><span class="pre">map_coefficients</span></code>.</p>
<p>There are also methods for building functions directly:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">sum_of_monomials</span><span class="p">(</span><span class="n">mu</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">sum_of_monomials</span><span class="p">(</span><span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">s[1, 1, 1] + s[2, 1] + s[3]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">sum_of_terms</span><span class="p">(</span> <span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">s[1, 1, 1] + 2*s[2, 1] + 3*s[3]</span>
</pre></div>
</div>
<p>These are the preferred way to build elements within a program;
the result will usually be faster than using <a class="reference external" href="https://docs.python.org/library/functions.html#sum" title="(in Python v3.6)"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a>. It also
guarantees that empty sums yields the zero of <code class="docutils literal notranslate"><span class="pre">s</span></code> (see also
<code class="docutils literal notranslate"><span class="pre">s.sum</span></code>).</p>
<p>Note also that it is a good idea to use:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="go">s[]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>instead of <code class="docutils literal notranslate"><span class="pre">s(1)</span></code> and <code class="docutils literal notranslate"><span class="pre">s(0)</span></code> within programs where speed is important,
in order to prevent unnecessary coercions.</p>
<p class="rubric">Different base rings</p>
<p>Depending on the base ring, the different realizations of the symmetric
function algebra may not span the same space:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SZ</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SZ</span><span class="o">.</span><span class="n">power</span><span class="p">();</span> <span class="n">s</span> <span class="o">=</span> <span class="n">SZ</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: no conversion of this rational to integer</span>
</pre></div>
</div>
<p>Because of this, some functions may not behave as expected when working over
the integers, even though they make mathematical sense:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plethysm</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: no conversion of this rational to integer</span>
</pre></div>
</div>
<p>It is possible to work over different base rings simultaneously:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">power</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">sz</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">();</span> <span class="n">sz</span><span class="o">.</span><span class="n">_prefix</span> <span class="o">=</span> <span class="s1">&#39;sz&#39;</span>
<span class="gp">sage: </span><span class="n">pz</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">power</span><span class="p">();</span> <span class="n">pz</span><span class="o">.</span><span class="n">_prefix</span> <span class="o">=</span> <span class="s1">&#39;pz&#39;</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">sz</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1/6*p[1, 1, 1] - 1/2*p[2, 1] + 1/3*p[3]</span>
<span class="gp">sage: </span><span class="n">sz</span><span class="p">(</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">)</span>
<span class="go">sz[1, 1, 1]</span>
</pre></div>
</div>
<p>As shown in this example, if you are working over multiple base rings
simultaneously, it is a good idea to change the prefix in some cases, so that
you can tell from the output which realization your result is in.</p>
<p>Let us change the notation back for the remainder of this tutorial:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sz</span><span class="o">.</span><span class="n">_prefix</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>
<span class="gp">sage: </span><span class="n">pz</span><span class="o">.</span><span class="n">_prefix</span> <span class="o">=</span> <span class="s1">&#39;p&#39;</span>
</pre></div>
</div>
<p>One can also use the Sage standard renaming idiom to get shorter outputs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;Sym&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Sym</span>
<span class="go">Sym</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">rename</span><span class="p">()</span>
</pre></div>
</div>
<p>And we name it back:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;Symmetric Functions over Rational Field&quot;</span><span class="p">);</span> <span class="n">Sym</span>
<span class="go">Symmetric Functions over Rational Field</span>
</pre></div>
</div>
<p class="rubric">Other bases</p>
<p>There are two additional basis of the symmetric functions which are not
considered as classical bases:</p>
<ul class="simple">
<li><p>forgotten basis</p></li>
<li><p>Witt basis</p></li>
</ul>
<p>The forgotten basis is the dual basis of the elementary symmetric
functions basis with respect to the Hall scalar product. The Witt basis
can be constructed by</p>
<div class="math notranslate nohighlight">
\[\prod_{d=1}^{\infty} (1 - w_d t^d)^{-1} = \sum_{n=0}^{\infty} h_n t^n\]</div>
<p>where <span class="math notranslate nohighlight">\(t\)</span> is a formal variable.</p>
<p>There are further bases of the ring of symmetric functions, in general over
fields with parameters such as <span class="math notranslate nohighlight">\(q\)</span> and <span class="math notranslate nohighlight">\(t\)</span>:</p>
<ul class="simple">
<li><p>Hall-Littlewood bases</p></li>
<li><p>Jack bases</p></li>
<li><p>Macdonald bases</p></li>
<li><p><span class="math notranslate nohighlight">\(k\)</span>-Schur functions</p></li>
<li><p>Hecke character basis</p></li>
</ul>
<p>We briefly demonstrate how to access these bases. For more information, see
the documentation of the individual bases.</p>
<p>The <em>Jack polynomials</em> can be obtained as:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">Jack</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">jack</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Jack</span><span class="o">.</span><span class="n">P</span><span class="p">();</span> <span class="n">J</span> <span class="o">=</span> <span class="n">Jack</span><span class="o">.</span><span class="n">J</span><span class="p">();</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">Jack</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">(1/(t+2))*JackJ[2, 1]</span>
</pre></div>
</div>
<p>The parameter <span class="math notranslate nohighlight">\(t\)</span> can be specialized as follows:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Jack</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">jack</span><span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Jack</span><span class="o">.</span><span class="n">P</span><span class="p">();</span> <span class="n">J</span> <span class="o">=</span> <span class="n">Jack</span><span class="o">.</span><span class="n">J</span><span class="p">();</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">Jack</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1/3*JackJ[2, 1]</span>
</pre></div>
</div>
<p>Similarly one can access the Hall-Littlewood and Macdonald polynomials, etc:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">Mcd</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Mcd</span><span class="o">.</span><span class="n">P</span><span class="p">();</span> <span class="n">J</span> <span class="o">=</span> <span class="n">Mcd</span><span class="o">.</span><span class="n">J</span><span class="p">();</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">Mcd</span><span class="o">.</span><span class="n">Q</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">J</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">(1/(-q*t^4+2*q*t^3-q*t^2+t^2-2*t+1))*McdJ[2, 1]</span>
</pre></div>
</div>
<p>We can also construct the <span class="math notranslate nohighlight">\(\bar{q}\)</span> basis that can be used
to determine character tables for Hecke algebras (with quadratic
relation <span class="math notranslate nohighlight">\(T_i^2 = (1-q) T_i + q\)</span>):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">qbar</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">hecke_character</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">qbar</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">-s[1, 1, 1] + (q-1)*s[2, 1] + q*s[3]</span>
</pre></div>
</div>
<p class="rubric"><span class="math notranslate nohighlight">\(k\)</span>-Schur functions</p>
<p>The <span class="math notranslate nohighlight">\(k\)</span>-Schur functions live in the <span class="math notranslate nohighlight">\(k\)</span>-bounded subspace of the ring of
symmetric functions. It is possible to compute in the <span class="math notranslate nohighlight">\(k\)</span>-bounded subspace
directly:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ks</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">kschur</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">ks</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ks</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">];</span> <span class="n">f</span>
<span class="go">ks3[2, 2, 1, 1] + ks3[2, 2, 2] + ks3[3, 1, 1, 1]</span>
</pre></div>
</div>
<p>or to lift to the ring of symmetric functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">lift</span><span class="p">()</span>
<span class="go">s[2, 2, 1, 1] + s[2, 2, 2] + s[3, 1, 1, 1] + 2*s[3, 2, 1] + s[3, 3] + s[4, 1, 1] + s[4, 2]</span>
</pre></div>
</div>
<p>However, it is not always possible to convert a symmetric function to the <span class="math notranslate nohighlight">\(k\)</span>-bounded subspace:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ks</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: s[2, 1, 1] is not in the image</span>
</pre></div>
</div>
<p>The <span class="math notranslate nohighlight">\(k\)</span>-Schur functions are more generally defined with a parameter <span class="math notranslate nohighlight">\(t\)</span> and they are
a basis of the subspace spanned by the Hall-Littlewood <code class="docutils literal notranslate"><span class="pre">Qp</span></code> symmetric functions
indexed by partitions whose first part is less than or equal to <span class="math notranslate nohighlight">\(k\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">SymS3</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">kBoundedSubspace</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># default t=&#39;t&#39;</span>
<span class="gp">sage: </span><span class="n">ks</span> <span class="o">=</span> <span class="n">SymS3</span><span class="o">.</span><span class="n">kschur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Qp</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Qp</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ks</span><span class="p">(</span><span class="n">Qp</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">ks3[2, 1, 1, 1] + (t^2+t)*ks3[2, 2, 1] + (t^3+t^2)*ks3[3, 1, 1] + t^4*ks3[3, 2]</span>
</pre></div>
</div>
<p>The subspace spanned by the <span class="math notranslate nohighlight">\(k\)</span>-Schur functions with a parameter <span class="math notranslate nohighlight">\(t\)</span> are not known
to form a natural algebra.  However it is known that the product of a <span class="math notranslate nohighlight">\(k\)</span>-Schur
function and an <span class="math notranslate nohighlight">\(\ell\)</span>-Schur function is in the linear span of the <span class="math notranslate nohighlight">\(k+\ell\)</span>-Schur
functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ks</span><span class="p">(</span><span class="n">ks</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ks</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 1, 1] + s[3, 2] is not in the image</span>
<span class="gp">sage: </span><span class="n">ks</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ks</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">s[2, 1, 1, 1] + s[2, 2, 1] + s[3, 1, 1] + s[3, 2]</span>
<span class="gp">sage: </span><span class="n">ks6</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">kBoundedSubspace</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">kschur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ks6</span><span class="p">(</span><span class="n">ks</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">ks</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">ks6[3, 3, 1, 1] + ks6[4, 2, 1, 1] + (t+1)*ks6[4, 3, 1] + t*ks6[4, 4]</span>
<span class="go">+ ks6[5, 1, 1, 1] + ks6[5, 2, 1] + t*ks6[5, 3] + ks6[6, 1, 1]</span>
</pre></div>
</div>
<p>The <span class="math notranslate nohighlight">\(k\)</span>-split basis is a second basis of the ring spanned by the <span class="math notranslate nohighlight">\(k\)</span>-Schur
functions with a parameter <span class="math notranslate nohighlight">\(t\)</span>.  The <span class="math notranslate nohighlight">\(k\)</span>-split basis has the property that
<span class="math notranslate nohighlight">\(Q'_\lambda[X;t]\)</span> expands positively in the <span class="math notranslate nohighlight">\(k\)</span>-split basis and the
<span class="math notranslate nohighlight">\(k\)</span>-split basis conjecturally expands positively in the <span class="math notranslate nohighlight">\(k\)</span>-Schur functions.
The definition can be found in <a class="reference internal" href="k_dual.html#llmssz" id="id7"><span>[LLMSSZ]</span></a> p. 81.:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ksp3</span> <span class="o">=</span> <span class="n">SymS3</span><span class="o">.</span><span class="n">ksplit</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ksp3</span><span class="p">(</span><span class="n">Qp</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">ksp3[2, 1, 1, 1] + t^2*ksp3[2, 2, 1] + (t^3+t^2)*ksp3[3, 1, 1] + t^4*ksp3[3, 2]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">ks</span><span class="p">(</span><span class="n">ksp3</span><span class="p">(</span><span class="n">la</span><span class="p">))</span> <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ksp3</span><span class="p">(</span><span class="n">Qp</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">support</span><span class="p">())]</span>
<span class="go">[ks3[2, 1, 1, 1] + t*ks3[2, 2, 1], ks3[2, 2, 1], ks3[3, 1, 1], ks3[3, 2]]</span>
</pre></div>
</div>
<p class="rubric">dual <span class="math notranslate nohighlight">\(k\)</span>-Schur functions</p>
<p>The dual space to the subspace spanned by the <span class="math notranslate nohighlight">\(k\)</span>-Schur functions is most naturally
realized as a quotient of the ring of symmetric functions by an ideal.  When <span class="math notranslate nohighlight">\(t=1\)</span>
the ideal is generated by the monomial symmetric functions indexed by partitions
whose first part is greater than <span class="math notranslate nohighlight">\(k\)</span>.:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SymQ3</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">kBoundedQuotient</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">km</span> <span class="o">=</span> <span class="n">SymQ3</span><span class="o">.</span><span class="n">kmonomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">km</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">km</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">4*m3[2, 2, 1, 1] + 6*m3[2, 2, 2] + 2*m3[3, 2, 1] + 2*m3[3, 3]</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">SymQ3</span><span class="o">.</span><span class="n">affineSchur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">F</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">2*F3[1, 1, 1, 1, 1, 1] + 4*F3[2, 1, 1, 1, 1] + 4*F3[2, 2, 1, 1] + 4*F3[2, 2, 2]</span>
<span class="go">+ 2*F3[3, 1, 1, 1] + 4*F3[3, 2, 1] + 2*F3[3, 3]</span>
</pre></div>
</div>
<p>When <span class="math notranslate nohighlight">\(t\)</span> is not equal to <span class="math notranslate nohighlight">\(1\)</span>, the subspace spanned by the <span class="math notranslate nohighlight">\(k\)</span>-Schur functions is
realized as a quotient of the ring of symmetric functions by the ideal generated by
the Hall-Littlewood symmetric functions in the P basis indexed by partitions with
first part greater than <span class="math notranslate nohighlight">\(k\)</span>.:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">SymQ3</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">kBoundedQuotient</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">kHLP</span> <span class="o">=</span> <span class="n">SymQ3</span><span class="o">.</span><span class="n">kHallLittlewoodP</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">kHLP</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">kHLP</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">(t^2+2*t+1)*HLP3[2, 2, 1, 1] + (t^3+2*t^2+2*t+1)*HLP3[2, 2, 2]</span>
<span class="go">+ (-t^4-t^3+t+1)*HLP3[3, 1, 1, 1] + (-t^2+t+2)*HLP3[3, 2, 1] + (t+1)*HLP3[3, 3]</span>
<span class="gp">sage: </span><span class="n">HLP</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">P</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">kHLP</span><span class="p">(</span><span class="n">HLP</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">HLP3[3, 1]</span>
<span class="gp">sage: </span><span class="n">kHLP</span><span class="p">(</span><span class="n">HLP</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
<p>In this space, the basis which is dual to the <span class="math notranslate nohighlight">\(k\)</span>-Schur functions conjecturally
expands positively in the <span class="math notranslate nohighlight">\(k\)</span>-bounded Hall-Littlewood functions and has positive
structure coefficients.:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dks</span> <span class="o">=</span> <span class="n">SymQ3</span><span class="o">.</span><span class="n">dual_k_Schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">kHLP</span><span class="p">(</span><span class="n">dks</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">(t^4+t^2)*HLP3[1, 1, 1, 1] + t*HLP3[2, 1, 1] + HLP3[2, 2]</span>
<span class="gp">sage: </span><span class="n">dks</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">dks</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">(t^2+t)*dks3[1, 1, 1, 1, 1] + (t+1)*dks3[2, 1, 1, 1] + (t+1)*dks3[2, 2, 1]</span>
<span class="go">+ dks3[3, 1, 1] + dks3[3, 2]</span>
</pre></div>
</div>
<p>At <span class="math notranslate nohighlight">\(t=1\)</span> the <span class="math notranslate nohighlight">\(k\)</span>-bounded Hall-Littlewood basis is equal to the <span class="math notranslate nohighlight">\(k\)</span>-bounded monomial
basis and the dual <span class="math notranslate nohighlight">\(k\)</span>-Schur elements are equal to the affine Schur basis.  The
<span class="math notranslate nohighlight">\(k\)</span>-bounded monomial basis and affine Schur functions are faster and should be used
instead of the <span class="math notranslate nohighlight">\(k\)</span>-bounded Hall-Littlewood P basis and dual <span class="math notranslate nohighlight">\(k\)</span>-Schur functions when
<span class="math notranslate nohighlight">\(t=1\)</span>.:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymQ3</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">kBoundedQuotient</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dks</span> <span class="o">=</span> <span class="n">SymQ3</span><span class="o">.</span><span class="n">dual_k_Schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">SymQ3</span><span class="o">.</span><span class="n">affineSchur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">dks</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">Implementing new bases</p>
<p>In order to implement a new symmetric function basis, Sage will need
to know at a minimum how to change back and forth between at least one
other basis (although they do not necessarily have to be the same basis).
All of the standard functions associated with the basis will have a
default implementation (although a more specific implementation may
be more efficient).</p>
<p>To present an idea of how this is done, we will create
here the example of how to implement the basis <span class="math notranslate nohighlight">\(s_\mu[X(1-t)]\)</span>.</p>
<p>To begin, we import the class
<a class="reference internal" href="sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic()</span></code></a>.  Our
new basis will inherit all of the default methods from this class:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.sf.sfa</span> <span class="kn">import</span> <span class="n">SymmetricFunctionAlgebra_generic</span> <span class="k">as</span> <span class="n">SFA_generic</span>
</pre></div>
</div>
<p>Now the basis we are creating has a parameter <span class="math notranslate nohighlight">\(t\)</span> which is possible
to specialize. In this example we will convert to and from the Schur
basis.  For this we implement methods <code class="docutils literal notranslate"><span class="pre">_self_to_s</span></code> and <code class="docutils literal notranslate"><span class="pre">_s_to_self</span></code>.
By registering these two functions as coercions, Sage then knows
automatically how it possible to change between any two bases for
which there is a path of changes of bases.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.categories.morphism</span> <span class="kn">import</span> <span class="n">SetMorphism</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">SFA_st</span><span class="p">(</span><span class="n">SFA_generic</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Sym</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">SFA_generic</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Sym</span><span class="p">,</span> <span class="n">basis_name</span><span class="o">=</span>
<span class="gp">....: </span>          <span class="s2">&quot;Schur functions with a plethystic substitution of X -&gt; X(1-t)&quot;</span><span class="p">,</span>
<span class="gp">....: </span>          <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;st&#39;</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="n">cat</span> <span class="o">=</span> <span class="n">HopfAlgebras</span><span class="p">(</span><span class="n">Sym</span><span class="o">.</span><span class="n">base_ring</span><span class="p">())</span><span class="o">.</span><span class="n">WithBasis</span><span class="p">()</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">register_coercion</span><span class="p">(</span>
<span class="gp">....: </span>          <span class="n">SetMorphism</span><span class="p">(</span><span class="n">Hom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">cat</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s_to_self</span><span class="p">))</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">register_coercion</span><span class="p">(</span>
<span class="gp">....: </span>          <span class="n">SetMorphism</span><span class="p">(</span><span class="n">Hom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="p">,</span> <span class="n">cat</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_self_to_s</span><span class="p">))</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">_s_to_self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="c1"># f is a Schur function and the output is in the st basis</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_dict</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">_monomial_coefficients</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">_self_to_s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="c1"># f is in the st basis and the output is in the Schur basis</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cmu</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_s</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">theta_qt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">mu</span><span class="p">,</span><span class="n">cmu</span> <span class="ow">in</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">class</span> <span class="nc">Element</span><span class="p">(</span><span class="n">SFA_generic</span><span class="o">.</span><span class="n">Element</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">pass</span>
</pre></div>
</div>
<p>An instance of this basis is created by calling it with a symmetric
function ring <code class="docutils literal notranslate"><span class="pre">Sym</span></code> and a parameter <code class="docutils literal notranslate"><span class="pre">t</span></code> which is in the base ring
of <code class="docutils literal notranslate"><span class="pre">Sym</span></code>.  The <code class="docutils literal notranslate"><span class="pre">Element</span></code> class inherits all of the methods from
<a class="reference internal" href="sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element</span></code></a>.</p>
<p>In the reference <a class="reference internal" href="#mac" id="id8"><span>[MAC]</span></a> on page 354, this basis is denoted
<span class="math notranslate nohighlight">\(S_\lambda(x;t)\)</span> and the change of basis coefficients of the
Macdonald <code class="docutils literal notranslate"><span class="pre">J</span></code> basis are the coefficients <span class="math notranslate nohighlight">\(K_{\lambda\mu}(q,t)\)</span>.
Here is an example of its use:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QQqt</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">QQqt</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">st</span> <span class="o">=</span> <span class="n">SFA_st</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQqt</span><span class="p">),</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">st</span>
<span class="go">Symmetric Functions over Fraction Field of Multivariate Polynomial</span>
<span class="go"> Ring in q, t over Rational Field in the Schur functions with a</span>
<span class="go"> plethystic substitution of X -&gt; X(1-t) basis</span>
<span class="gp">sage: </span><span class="n">st</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">st</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">st[2, 1, 1] + st[2, 2] + st[3, 1]</span>
<span class="gp">sage: </span><span class="n">st</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">st[] # st[2] + st[1] # st[1] + st[2] # st[]</span>
<span class="gp">sage: </span><span class="n">J</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">symmetric_function_ring</span><span class="p">()</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">J</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">st</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">q*st[1, 1, 1] + (q*t+1)*st[2, 1] + t*st[3]</span>
</pre></div>
</div>
<p class="rubric">Acknowledgements</p>
<p>The design is heavily inspired from the implementation of
symmetric functions in MuPAD-Combinat (see <a class="reference internal" href="#ht04" id="id9"><span>[HT04]</span></a> and <a class="reference internal" href="#fd06" id="id10"><span>[FD06]</span></a>).</p>
<p>REFERENCES:</p>
<blockquote>
<div><dl class="citation">
<dt class="label" id="fd06"><span class="brackets"><a class="fn-backref" href="#id10">FD06</a></span></dt>
<dd><p>Francois Descouens, Making research on symmetric functions using MuPAD-Combinat.
In Andres Iglesias and Nobuki Takayama, editors, 2nd International Congress on Mathematical Software (ICMS’06),
volume 4151 of LNCS, pages 407-418, Castro Urdiales, Spain, September 2006. Springer-Verlag.
<a class="reference external" href="https://arxiv.org/abs/0806.1873">arXiv 0806.1873</a></p>
</dd>
<dt class="label" id="ht04"><span class="brackets"><a class="fn-backref" href="#id9">HT04</a></span></dt>
<dd><p>Florent Hivert and Nicolas M. Thiery,
MuPAD-Combinat, an open-source package for research in algebraic combinatorics.
Sem. Lothar. Combin., 51 :Art. B51z, 70 pp. (electronic), 2004.
<a class="reference external" href="http://mupad-combinat.sf.net/">http://mupad-combinat.sf.net/</a>.</p>
</dd>
<dt class="label" id="mac"><span class="brackets">MAC</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id8">2</a>)</span></dt>
<dd><p>Ian Macdonald, Symmetric Functions and Orthogonal Polynomials,
Second edition. With contributions by A. Zelevinsky. Oxford Mathematical Monographs.
Oxford Science Publications. The Clarendon Press, Oxford University Press, New York, 1995. x+475 pp.
ISBN: 0-19-853489-2</p>
</dd>
<dt class="label" id="sta"><span class="brackets">STA</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id4">2</a>,<a href="#id6">3</a>)</span></dt>
<dd><p>Richard Stanley, Enumerative combinatorics. Vol. 2.
With a foreword by Gian-Carlo Rota and appendix 1 by Sergey Fomin.
Cambridge Studies in Advanced Mathematics, 62. Cambridge University Press, Cambridge, 1999. xii+581 pp.
ISBN: 0-521-56069-1; 0-521-78987-7</p>
</dd>
<dt class="label" id="st94"><span class="brackets"><a class="fn-backref" href="#id5">ST94</a></span></dt>
<dd><p>Scharf, Thomas, Thibon, Jean-Yves,
A Hopf-algebra approach to inner plethysm.
Adv. Math.  104  (1994),  no. 1, 30-58.
<a class="reference external" href="https://doi.org/10.1006/aima.1994.1019">doi:10.1006/aima.1994.1019</a></p>
</dd>
</dl>
</div></blockquote>
<p class="rubric">Further tests</p>
<div class="admonition-todo admonition" id="id11">
<p class="admonition-title">Todo</p>
<ul class="simple">
<li><p>Introduce fields with degree 1 elements as in
MuPAD-Combinat, to get proper plethysm.</p></li>
<li><p>Use UniqueRepresentation to get rid of all the manual cache
handling for the bases</p></li>
<li><p>Devise a mechanism so that pickling bases of symmetric
functions pickles the coercions which have a cache.</p></li>
</ul>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.Schur">
<span class="sig-name descname"><span class="pre">Schur</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.Schur" title="Permalink to this definition">¶</a></dt>
<dd><p>The Schur basis of the Symmetric Functions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the Schur basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.Witt">
<span class="sig-name descname"><span class="pre">Witt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coerce_h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coerce_e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coerce_p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.Witt" title="Permalink to this definition">¶</a></dt>
<dd><p>The Witt basis of the symmetric functions.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">witt</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the Witt basis</span>
<span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">witt</span><span class="p">(</span><span class="n">coerce_p</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Symmetric Functions over Rational Field in the Witt basis</span>
<span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">witt</span><span class="p">(</span><span class="n">coerce_h</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">coerce_e</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">coerce_p</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Symmetric Functions over Rational Field in the Witt basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.a_realization">
<span class="sig-name descname"><span class="pre">a_realization</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.a_realization" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a particular realization of <code class="docutils literal notranslate"><span class="pre">self</span></code> (the Schur basis).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">a_realization</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the Schur basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.complete">
<span class="sig-name descname"><span class="pre">complete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.complete" title="Permalink to this definition">¶</a></dt>
<dd><p>The complete basis of the Symmetric Functions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the homogeneous basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.e">
<span class="sig-name descname"><span class="pre">e</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.e" title="Permalink to this definition">¶</a></dt>
<dd><p>The elementary basis of the Symmetric Functions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the elementary basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.elementary">
<span class="sig-name descname"><span class="pre">elementary</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.elementary" title="Permalink to this definition">¶</a></dt>
<dd><p>The elementary basis of the Symmetric Functions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the elementary basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.f">
<span class="sig-name descname"><span class="pre">f</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.f" title="Permalink to this definition">¶</a></dt>
<dd><p>The forgotten basis of the Symmetric Functions (or the basis dual to
the elementary basis with respect to the Hall scalar product).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">forgotten</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the forgotten basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.forgotten">
<span class="sig-name descname"><span class="pre">forgotten</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.forgotten" title="Permalink to this definition">¶</a></dt>
<dd><p>The forgotten basis of the Symmetric Functions (or the basis dual to
the elementary basis with respect to the Hall scalar product).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">forgotten</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the forgotten basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.from_polynomial">
<span class="sig-name descname"><span class="pre">from_polynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.from_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a symmetric polynomial <code class="docutils literal notranslate"><span class="pre">f</span></code> to a symmetric function.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> – a symmetric polynomial</p></li>
</ul>
<p>This function converts a symmetric polynomial <span class="math notranslate nohighlight">\(f\)</span> in a polynomial ring in finitely
many variables to a symmetric function in the monomial
basis of the ring of symmetric functions over the same base ring.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">m[1]</span>

<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">from_polynomial</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ValueError: x0 + 2*x1 + x2 is not a symmetric polynomial</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.h">
<span class="sig-name descname"><span class="pre">h</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.h" title="Permalink to this definition">¶</a></dt>
<dd><p>The complete basis of the Symmetric Functions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the homogeneous basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.hall_littlewood">
<span class="sig-name descname"><span class="pre">hall_littlewood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'t'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.hall_littlewood" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the entry point for the various Hall-Littlewood bases.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – parameter</p></li>
</ul>
<p>Hall-Littlewood symmetric functions including bases <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(Qp\)</span>.
The Hall-Littlewood <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> functions at <span class="math notranslate nohighlight">\(t=-1\)</span> are the
Schur-P and Schur-Q functions when indexed by strict partitions.</p>
<p>The parameter <span class="math notranslate nohighlight">\(t\)</span> must be in the base ring of parent.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">P</span><span class="p">();</span> <span class="n">P</span>
<span class="go">Symmetric Functions over Fraction Field of Univariate Polynomial Ring in t over Rational Field in the Hall-Littlewood P basis</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">HLP[2]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Symmetric Functions over Fraction Field of Univariate Polynomial Ring in t over Rational Field in the Hall-Littlewood Q basis</span>
<span class="gp">sage: </span><span class="n">Q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">HLQ[2]</span>
<span class="gp">sage: </span><span class="n">Qp</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">hall_littlewood</span><span class="p">()</span><span class="o">.</span><span class="n">Qp</span><span class="p">();</span> <span class="n">Qp</span>
<span class="go">Symmetric Functions over Fraction Field of Univariate Polynomial Ring in t over Rational Field in the Hall-Littlewood Qp basis</span>
<span class="gp">sage: </span><span class="n">Qp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">HLQp[2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.hecke_character">
<span class="sig-name descname"><span class="pre">hecke_character</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'q'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.hecke_character" title="Permalink to this definition">¶</a></dt>
<dd><p>The basis of symmetric functions that determines the character
tables for Hecke algebras.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span><span class="o">.</span><span class="n">hecke_character</span><span class="p">()</span>
<span class="go">Symmetric Functions over</span>
<span class="go"> Fraction Field of Univariate Polynomial Ring in q over Integer Ring</span>
<span class="go"> in the Hecke character with q=q basis</span>
<span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">hecke_character</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Symmetric Functions over Rational Field in the Hecke character with q=1/2 basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.homogeneous">
<span class="sig-name descname"><span class="pre">homogeneous</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.homogeneous" title="Permalink to this definition">¶</a></dt>
<dd><p>The complete basis of the Symmetric Functions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the homogeneous basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.ht">
<span class="sig-name descname"><span class="pre">ht</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.ht" title="Permalink to this definition">¶</a></dt>
<dd><p>The induced trivial character basis of the Symmetric Functions.</p>
<p>The trivial character of</p>
<div class="math notranslate nohighlight">
\[S_{n-|\lambda|} \times S_{\lambda_1} \times S_{\lambda_2} \times
\cdots \times S_{\lambda_\ell(\lambda)}\]</div>
<p>induced to the group <span class="math notranslate nohighlight">\(S_{n}\)</span> is a symmetric function in the
eigenvalues of a permutation matrix.  This basis is that character.</p>
<p>It has the property that if the element indexed by the
partition <span class="math notranslate nohighlight">\(\lambda\)</span> is evaluated at the roots of a permutation of
cycle structure <span class="math notranslate nohighlight">\(\rho\)</span> then the value is the coefficient
<span class="math notranslate nohighlight">\(\left&lt; h_{(n-|\lambda|,\lambda)}, p_\rho \right&gt;\)</span>.</p>
<p>In terms of methods that are implemented in Sage, if <code class="docutils literal notranslate"><span class="pre">n</span></code> is
a sufficiently large integer, then
<code class="docutils literal notranslate"><span class="pre">ht(lam).character_to_frobenius_image(n)</span></code> is equal the complete
function indexed by <code class="docutils literal notranslate"><span class="pre">[n-sum(lam)]+lam</span></code>.</p>
<p>This basis is introduced in <a class="reference internal" href="character.html#oz2015" id="id12"><span>[OZ2015]</span></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.character_to_frobenius_image" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.character_to_frobenius_image"><code class="xref py py-meth docutils literal notranslate"><span class="pre">character_to_frobenius_image()</span></code></a>,
<a class="reference internal" href="sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eval_at_permutation_roots()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">induced_trivial_character</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the induced trivial symmetric group character basis</span>
<span class="gp">sage: </span><span class="n">ht</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ht</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">ht</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="go">h[4, 3, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">ht</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">h[3, 2, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">ht</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">h[3, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">ht</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">h</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">rho</span><span class="p">))</span> <span class="k">for</span> <span class="n">rho</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="go">[0, 1, 0, 2, 1, 3, 5]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">ht</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">eval_at_permutation_roots</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="k">for</span> <span class="n">rho</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="go">[0, 1, 0, 2, 1, 3, 5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.induced_trivial_character">
<span class="sig-name descname"><span class="pre">induced_trivial_character</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.induced_trivial_character" title="Permalink to this definition">¶</a></dt>
<dd><p>The induced trivial character basis of the Symmetric Functions.</p>
<p>The trivial character of</p>
<div class="math notranslate nohighlight">
\[S_{n-|\lambda|} \times S_{\lambda_1} \times S_{\lambda_2} \times
\cdots \times S_{\lambda_\ell(\lambda)}\]</div>
<p>induced to the group <span class="math notranslate nohighlight">\(S_{n}\)</span> is a symmetric function in the
eigenvalues of a permutation matrix.  This basis is that character.</p>
<p>It has the property that if the element indexed by the
partition <span class="math notranslate nohighlight">\(\lambda\)</span> is evaluated at the roots of a permutation of
cycle structure <span class="math notranslate nohighlight">\(\rho\)</span> then the value is the coefficient
<span class="math notranslate nohighlight">\(\left&lt; h_{(n-|\lambda|,\lambda)}, p_\rho \right&gt;\)</span>.</p>
<p>In terms of methods that are implemented in Sage, if <code class="docutils literal notranslate"><span class="pre">n</span></code> is
a sufficiently large integer, then
<code class="docutils literal notranslate"><span class="pre">ht(lam).character_to_frobenius_image(n)</span></code> is equal the complete
function indexed by <code class="docutils literal notranslate"><span class="pre">[n-sum(lam)]+lam</span></code>.</p>
<p>This basis is introduced in <a class="reference internal" href="character.html#oz2015" id="id13"><span>[OZ2015]</span></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.character_to_frobenius_image" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.character_to_frobenius_image"><code class="xref py py-meth docutils literal notranslate"><span class="pre">character_to_frobenius_image()</span></code></a>,
<a class="reference internal" href="sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eval_at_permutation_roots()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">induced_trivial_character</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the induced trivial symmetric group character basis</span>
<span class="gp">sage: </span><span class="n">ht</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ht</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">ht</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="go">h[4, 3, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">ht</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">h[3, 2, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">ht</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">h[3, 2]</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">ht</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">p</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">h</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="n">rho</span><span class="p">))</span> <span class="k">for</span> <span class="n">rho</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="go">[0, 1, 0, 2, 1, 3, 5]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">ht</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">eval_at_permutation_roots</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span> <span class="k">for</span> <span class="n">rho</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="go">[0, 1, 0, 2, 1, 3, 5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.irreducible_symmetric_group_character">
<span class="sig-name descname"><span class="pre">irreducible_symmetric_group_character</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.irreducible_symmetric_group_character" title="Permalink to this definition">¶</a></dt>
<dd><p>The irreducible <span class="math notranslate nohighlight">\(S_n\)</span> character basis of the Symmetric Functions.</p>
<p>This basis has the property that if the element indexed by the
partition <span class="math notranslate nohighlight">\(\lambda\)</span> is evaluated at the roots of a permutation of
cycle structure <span class="math notranslate nohighlight">\(\rho\)</span> then the value is the irreducible character
<span class="math notranslate nohighlight">\(\chi^{(|\rho|-|\lambda|,\lambda)}(\rho)\)</span>.</p>
<p>In terms of methods that are implemented in Sage, if <code class="docutils literal notranslate"><span class="pre">n</span></code> is
a sufficiently large integer, then
<code class="docutils literal notranslate"><span class="pre">st(lam).character_to_frobenius_image(n)</span></code> is equal the Schur function
indexed by <code class="docutils literal notranslate"><span class="pre">[n-sum(lam)]+lam</span></code>.</p>
<p>This basis is introduced in <a class="reference internal" href="character.html#oz2015" id="id14"><span>[OZ2015]</span></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.character_to_frobenius_image" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.character_to_frobenius_image"><code class="xref py py-meth docutils literal notranslate"><span class="pre">character_to_frobenius_image()</span></code></a>,
<a class="reference internal" href="sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eval_at_permutation_roots()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">irreducible_symmetric_group_character</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the irreducible symmetric group character basis</span>
<span class="gp">sage: </span><span class="n">st</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">st</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">st</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="go">s[4, 3, 2]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">st</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">st</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="go">-s[2, 2, 2]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">character_table</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[4, 2, 0, 1, -1, 0, -1]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">([</span><span class="n">st</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">eval_at_permutation_roots</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="gp">....: </span>  <span class="k">for</span> <span class="n">rho</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)]))</span>
<span class="go">[4, 2, 0, 1, -1, 0, -1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.jack">
<span class="sig-name descname"><span class="pre">jack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'t'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.jack" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the entry point for the various Jack bases.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – parameter</p></li>
</ul>
<p>Jack symmetric functions including bases <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(Qp\)</span>.</p>
<p>The parameter <span class="math notranslate nohighlight">\(t\)</span> must be in the base ring of parent.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">JP</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">jack</span><span class="p">()</span><span class="o">.</span><span class="n">P</span><span class="p">();</span> <span class="n">JP</span>
<span class="go">Symmetric Functions over Fraction Field of Univariate Polynomial Ring in t over Rational Field in the Jack P basis</span>
<span class="gp">sage: </span><span class="n">JQ</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">jack</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">();</span> <span class="n">JQ</span>
<span class="go">Symmetric Functions over Fraction Field of Univariate Polynomial Ring in t over Rational Field in the Jack Q basis</span>
<span class="gp">sage: </span><span class="n">JJ</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">jack</span><span class="p">()</span><span class="o">.</span><span class="n">J</span><span class="p">();</span> <span class="n">JJ</span>
<span class="go">Symmetric Functions over Fraction Field of Univariate Polynomial Ring in t over Rational Field in the Jack J basis</span>
<span class="gp">sage: </span><span class="n">JQp</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">jack</span><span class="p">()</span><span class="o">.</span><span class="n">Qp</span><span class="p">();</span> <span class="n">JQp</span>
<span class="go">Symmetric Functions over Fraction Field of Univariate Polynomial Ring in t over Rational Field in the Jack Qp basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.kBoundedQuotient">
<span class="sig-name descname"><span class="pre">kBoundedQuotient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'t'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.kBoundedQuotient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <span class="math notranslate nohighlight">\(k\)</span>-bounded quotient space of the ring of symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> - a positive integer</p></li>
</ul>
<p>The quotient of the ring of symmetric functions …</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="k_dual.html#sage.combinat.sf.k_dual.KBoundedQuotient" title="sage.combinat.sf.k_dual.KBoundedQuotient"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.combinat.sf.k_dual.KBoundedQuotient()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">KQ</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">kBoundedQuotient</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">KQ</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: unable to convert &#39;t&#39; to a rational</span>
<span class="gp">sage: </span><span class="n">KQ</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">kBoundedQuotient</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span> <span class="n">KQ</span>
<span class="go">3-Bounded Quotient of Symmetric Functions over Rational Field with t=1</span>
<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">KQ</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">kBoundedQuotient</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">KQ</span>
<span class="go">3-Bounded Quotient of Symmetric Functions over Fraction Field of Univariate Polynomial Ring in t over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.kBoundedSubspace">
<span class="sig-name descname"><span class="pre">kBoundedSubspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'t'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.kBoundedSubspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(k\)</span>-bounded subspace of the ring of symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> - a positive integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> a formal parameter; <span class="math notranslate nohighlight">\(t=1\)</span> yields a subring</p></li>
</ul>
<p>The subspace of the ring of symmetric functions spanned by
<span class="math notranslate nohighlight">\(\{ s_{\lambda}[X/(1-t)] \}_{\lambda_1\le k} = \{ s_{\lambda}^{(k)}[X,t]\}_{\lambda_1 \le k}\)</span>
over the base ring <span class="math notranslate nohighlight">\(\QQ[t]\)</span>. When <span class="math notranslate nohighlight">\(t=1\)</span>, this space is in fact a subalgebra of
the ring of symmetric functions generated by the complete homogeneous symmetric functions
<span class="math notranslate nohighlight">\(h_i\)</span> for <span class="math notranslate nohighlight">\(1\le i \le k\)</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="new_kschur.html#sage.combinat.sf.new_kschur.KBoundedSubspace" title="sage.combinat.sf.new_kschur.KBoundedSubspace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sage.combinat.sf.new_kschur.KBoundedSubspace()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">KB</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">kBoundedSubspace</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="n">KB</span>
<span class="go">3-bounded Symmetric Functions over Rational Field with t=1</span>

<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">kBoundedSubspace</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3-bounded Symmetric Functions over Univariate Polynomial Ring in t over Rational Field</span>

<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">kBoundedSubspace</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">z</span><span class="p">)</span>
<span class="go">3-bounded Symmetric Functions over Univariate Polynomial Ring in z over Rational Field with t=z</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.khomogeneous">
<span class="sig-name descname"><span class="pre">khomogeneous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.khomogeneous" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the homogeneous symmetric functions in the <span class="math notranslate nohighlight">\(k\)</span>-bounded subspace.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">kh</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">khomogeneous</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">kh</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">kh</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="go">h4[4, 3]</span>
<span class="gp">sage: </span><span class="n">kh</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">lift</span><span class="p">()</span>
<span class="go">h[4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.kschur">
<span class="sig-name descname"><span class="pre">kschur</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'t'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.kschur" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <span class="math notranslate nohighlight">\(k\)</span>-Schur functions.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ks</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">kschur</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ks</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">ks</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">ks3[2, 2] + ks3[3, 1]</span>
<span class="gp">sage: </span><span class="n">ks</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lift</span><span class="p">()</span>
<span class="go">s[2, 1, 1] + s[3, 1]</span>

<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">ks</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">kschur</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ks</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lift</span><span class="p">()</span>
<span class="go">s[2, 2, 1] + t*s[3, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.ksplit">
<span class="sig-name descname"><span class="pre">ksplit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'t'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.ksplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(k\)</span>-split basis of the <span class="math notranslate nohighlight">\(k\)</span>-bounded subspace.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ksp</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">ksplit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ksp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">ksp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">ksp3[2, 2] + ksp3[3, 1]</span>
<span class="gp">sage: </span><span class="n">ksp</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lift</span><span class="p">()</span>
<span class="go">s[2, 1, 1] + s[2, 2] + s[3, 1]</span>

<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">ksp</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">ksplit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ksp</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lift</span><span class="p">()</span>
<span class="go">s[2, 1, 1] + t*s[2, 2] + t*s[3, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.llt">
<span class="sig-name descname"><span class="pre">llt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'t'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.llt" title="Permalink to this definition">¶</a></dt>
<dd><p>The LLT symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> – a positive integer indicating the level</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – a parameter (default: <span class="math notranslate nohighlight">\(t\)</span>)</p></li>
</ul>
<p>LLT polynomials in <span class="math notranslate nohighlight">\(hspin\)</span> and <span class="math notranslate nohighlight">\(hcospin\)</span> bases.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">llt3</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span><span class="o">.</span><span class="n">llt</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">llt3</span>
<span class="go">level 3 LLT polynomials over Fraction Field of Univariate Polynomial Ring in t over Rational Field</span>
<span class="gp">sage: </span><span class="n">llt3</span><span class="o">.</span><span class="n">hspin</span><span class="p">()</span>
<span class="go">Symmetric Functions over Fraction Field of Univariate Polynomial Ring in t over Rational Field in the level 3 LLT spin basis</span>
<span class="gp">sage: </span><span class="n">llt3</span><span class="o">.</span><span class="n">hcospin</span><span class="p">()</span>
<span class="go">Symmetric Functions over Fraction Field of Univariate Polynomial Ring in t over Rational Field in the level 3 LLT cospin basis</span>
<span class="gp">sage: </span><span class="n">llt3</span><span class="o">.</span><span class="n">hcospin</span><span class="p">()</span>
<span class="go">Symmetric Functions over Fraction Field of Univariate Polynomial Ring in t over Rational Field in the level 3 LLT cospin basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.m">
<span class="sig-name descname"><span class="pre">m</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.m" title="Permalink to this definition">¶</a></dt>
<dd><p>The monomial basis of the Symmetric Functions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the monomial basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.macdonald">
<span class="sig-name descname"><span class="pre">macdonald</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'q'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'t'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.macdonald" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the entry point for the various Macdonald bases.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code> – parameters</p></li>
</ul>
<p>Macdonald symmetric functions including bases <span class="math notranslate nohighlight">\(P\)</span>, <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(J\)</span>, <span class="math notranslate nohighlight">\(H\)</span>, <span class="math notranslate nohighlight">\(Ht\)</span>.
This also contains the <span class="math notranslate nohighlight">\(S\)</span> basis which is dual to the Schur basis with
respect to the <span class="math notranslate nohighlight">\(q,t\)</span> scalar product.</p>
<p>The parameters <span class="math notranslate nohighlight">\(q\)</span> and <span class="math notranslate nohighlight">\(t\)</span> must be in the base_ring of parent.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">FractionField</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">,</span><span class="s1">&#39;t&#39;</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">P</span><span class="p">();</span> <span class="n">P</span>
<span class="go">Symmetric Functions over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field in the Macdonald P basis</span>
<span class="gp">sage: </span><span class="n">P</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">McdP[2]</span>
<span class="gp">sage: </span><span class="n">Q</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">Q</span><span class="p">();</span> <span class="n">Q</span>
<span class="go">Symmetric Functions over Fraction Field of Multivariate Polynomial Ring in q, t over Rational Field in the Macdonald Q basis</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">matrix</span><span class="p">([[</span><span class="n">S</span><span class="p">(</span><span class="n">la</span><span class="p">)</span><span class="o">.</span><span class="n">scalar_qt</span><span class="p">(</span><span class="n">s</span><span class="p">(</span><span class="n">mu</span><span class="p">))</span> <span class="k">for</span> <span class="n">la</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
<span class="go">[1 0 0]</span>
<span class="go">[0 1 0]</span>
<span class="go">[0 0 1]</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">()</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">q^2*s[1, 1, 1, 1] + (q^2*t+q*t+q)*s[2, 1, 1] + (q^2*t^2+1)*s[2, 2] + (q*t^2+q*t+t)*s[3, 1] + t^2*s[4]</span>

<span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="s1">&#39;q&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Hzq</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">z</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H1z</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">macdonald</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">H1z</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">s[1, 1, 1, 1] + (2*z+1)*s[2, 1, 1] + (z^2+1)*s[2, 2] + (z^2+2*z)*s[3, 1] + z^2*s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">Hzq</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">z^2*s[1, 1, 1, 1] + (z^2*q+z*q+z)*s[2, 1, 1] + (z^2*q^2+1)*s[2, 2] + (z*q^2+z*q+q)*s[3, 1] + q^2*s[4]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">H1z</span><span class="p">(</span><span class="n">Hzq</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">z^2*s[1, 1, 1, 1] + (z^2*q+z*q+z)*s[2, 1, 1] + (z^2*q^2+1)*s[2, 2] + (z*q^2+z*q+q)*s[3, 1] + q^2*s[4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.monomial">
<span class="sig-name descname"><span class="pre">monomial</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.monomial" title="Permalink to this definition">¶</a></dt>
<dd><p>The monomial basis of the Symmetric Functions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">monomial</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the monomial basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.o">
<span class="sig-name descname"><span class="pre">o</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.o" title="Permalink to this definition">¶</a></dt>
<dd><p>The orthogonal basis of the symmetric functions.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orthogonal.html#sage.combinat.sf.orthogonal.SymmetricFunctionAlgebra_orthogonal" title="sage.combinat.sf.orthogonal.SymmetricFunctionAlgebra_orthogonal"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricFunctionAlgebra_orthogonal</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the orthogonal basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.orthogonal">
<span class="sig-name descname"><span class="pre">orthogonal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.orthogonal" title="Permalink to this definition">¶</a></dt>
<dd><p>The orthogonal basis of the symmetric functions.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="orthogonal.html#sage.combinat.sf.orthogonal.SymmetricFunctionAlgebra_orthogonal" title="sage.combinat.sf.orthogonal.SymmetricFunctionAlgebra_orthogonal"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricFunctionAlgebra_orthogonal</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the orthogonal basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.p">
<span class="sig-name descname"><span class="pre">p</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.p" title="Permalink to this definition">¶</a></dt>
<dd><p>The power sum basis of the Symmetric Functions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">powersum</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the powersum basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.power">
<span class="sig-name descname"><span class="pre">power</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.power" title="Permalink to this definition">¶</a></dt>
<dd><p>The power sum basis of the Symmetric Functions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">powersum</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the powersum basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.powersum">
<span class="sig-name descname"><span class="pre">powersum</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.powersum" title="Permalink to this definition">¶</a></dt>
<dd><p>The power sum basis of the Symmetric Functions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">powersum</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the powersum basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.qbar">
<span class="sig-name descname"><span class="pre">qbar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'q'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.qbar" title="Permalink to this definition">¶</a></dt>
<dd><p>The basis of symmetric functions that determines the character
tables for Hecke algebras.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fraction_field</span><span class="p">())</span><span class="o">.</span><span class="n">hecke_character</span><span class="p">()</span>
<span class="go">Symmetric Functions over</span>
<span class="go"> Fraction Field of Univariate Polynomial Ring in q over Integer Ring</span>
<span class="go"> in the Hecke character with q=q basis</span>
<span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">hecke_character</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Symmetric Functions over Rational Field in the Hecke character with q=1/2 basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.register_isomorphism">
<span class="sig-name descname"><span class="pre">register_isomorphism</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">morphism</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">only_conversion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.register_isomorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Register an isomorphism between two bases of <code class="docutils literal notranslate"><span class="pre">self</span></code>, as a canonical coercion
(unless the optional keyword <code class="docutils literal notranslate"><span class="pre">only_conversion</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
in which case the isomorphism is registered as conversion only).</p>
<p>EXAMPLES:</p>
<p>We override the canonical coercion from the Schur basis to the
powersum basis by a (stupid!) map <span class="math notranslate nohighlight">\(s_\lambda\mapsto 2p_\lambda\)</span>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;zorglub&#39;</span><span class="p">])</span> <span class="c1"># make sure we are not going to screw up later tests</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">();</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">()</span><span class="o">.</span><span class="n">dual_basis</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phi</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">module_morphism</span><span class="p">(</span><span class="n">diagonal</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">2*d_p[2, 1]</span>
<span class="gp">sage: </span><span class="n">Sym</span><span class="o">.</span><span class="n">register_isomorphism</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*d_p[2, 1]</span>
</pre></div>
</div>
<p>The map is supposed to implement the canonical isomorphism
between the two bases. Otherwise, the results will be
mathematically wrong, as above. Use with care!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.s">
<span class="sig-name descname"><span class="pre">s</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.s" title="Permalink to this definition">¶</a></dt>
<dd><p>The Schur basis of the Symmetric Functions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the Schur basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.schur">
<span class="sig-name descname"><span class="pre">schur</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.schur" title="Permalink to this definition">¶</a></dt>
<dd><p>The Schur basis of the Symmetric Functions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">schur</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the Schur basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.sp">
<span class="sig-name descname"><span class="pre">sp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.sp" title="Permalink to this definition">¶</a></dt>
<dd><p>The symplectic basis of the symmetric functions.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="symplectic.html#sage.combinat.sf.symplectic.SymmetricFunctionAlgebra_symplectic" title="sage.combinat.sf.symplectic.SymmetricFunctionAlgebra_symplectic"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricFunctionAlgebra_symplectic</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">symplectic</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the symplectic basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.st">
<span class="sig-name descname"><span class="pre">st</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.st" title="Permalink to this definition">¶</a></dt>
<dd><p>The irreducible <span class="math notranslate nohighlight">\(S_n\)</span> character basis of the Symmetric Functions.</p>
<p>This basis has the property that if the element indexed by the
partition <span class="math notranslate nohighlight">\(\lambda\)</span> is evaluated at the roots of a permutation of
cycle structure <span class="math notranslate nohighlight">\(\rho\)</span> then the value is the irreducible character
<span class="math notranslate nohighlight">\(\chi^{(|\rho|-|\lambda|,\lambda)}(\rho)\)</span>.</p>
<p>In terms of methods that are implemented in Sage, if <code class="docutils literal notranslate"><span class="pre">n</span></code> is
a sufficiently large integer, then
<code class="docutils literal notranslate"><span class="pre">st(lam).character_to_frobenius_image(n)</span></code> is equal the Schur function
indexed by <code class="docutils literal notranslate"><span class="pre">[n-sum(lam)]+lam</span></code>.</p>
<p>This basis is introduced in <a class="reference internal" href="character.html#oz2015" id="id15"><span>[OZ2015]</span></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.character_to_frobenius_image" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.character_to_frobenius_image"><code class="xref py py-meth docutils literal notranslate"><span class="pre">character_to_frobenius_image()</span></code></a>,
<a class="reference internal" href="sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.eval_at_permutation_roots"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eval_at_permutation_roots()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">irreducible_symmetric_group_character</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the irreducible symmetric group character basis</span>
<span class="gp">sage: </span><span class="n">st</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">st</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">st</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="go">s[4, 3, 2]</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">st</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">st</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">character_to_frobenius_image</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="go">-s[2, 2, 2]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">character_table</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[4, 2, 0, 1, -1, 0, -1]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">([</span><span class="n">st</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">eval_at_permutation_roots</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="gp">....: </span>  <span class="k">for</span> <span class="n">rho</span> <span class="ow">in</span> <span class="n">Partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)]))</span>
<span class="go">[4, 2, 0, 1, -1, 0, -1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.symplectic">
<span class="sig-name descname"><span class="pre">symplectic</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.symplectic" title="Permalink to this definition">¶</a></dt>
<dd><p>The symplectic basis of the symmetric functions.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="symplectic.html#sage.combinat.sf.symplectic.SymmetricFunctionAlgebra_symplectic" title="sage.combinat.sf.symplectic.SymmetricFunctionAlgebra_symplectic"><code class="xref py py-class docutils literal notranslate"><span class="pre">SymmetricFunctionAlgebra_symplectic</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">symplectic</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the symplectic basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.w">
<span class="sig-name descname"><span class="pre">w</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coerce_h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coerce_e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coerce_p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.w" title="Permalink to this definition">¶</a></dt>
<dd><p>The Witt basis of the symmetric functions.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">witt</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the Witt basis</span>
<span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">witt</span><span class="p">(</span><span class="n">coerce_p</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Symmetric Functions over Rational Field in the Witt basis</span>
<span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">witt</span><span class="p">(</span><span class="n">coerce_h</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">coerce_e</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">coerce_p</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Symmetric Functions over Rational Field in the Witt basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.witt">
<span class="sig-name descname"><span class="pre">witt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coerce_h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coerce_e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coerce_p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.witt" title="Permalink to this definition">¶</a></dt>
<dd><p>The Witt basis of the symmetric functions.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">witt</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the Witt basis</span>
<span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">witt</span><span class="p">(</span><span class="n">coerce_p</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Symmetric Functions over Rational Field in the Witt basis</span>
<span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">witt</span><span class="p">(</span><span class="n">coerce_h</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">coerce_e</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">coerce_p</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Symmetric Functions over Rational Field in the Witt basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricFunctions.zonal">
<span class="sig-name descname"><span class="pre">zonal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricFunctions.zonal" title="Permalink to this definition">¶</a></dt>
<dd><p>The zonal basis of the Symmetric Functions</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">zonal</span><span class="p">()</span>
<span class="go">Symmetric Functions over Rational Field in the zonal basis</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.sf.sf.SymmetricaConversionOnBasis">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.combinat.sf.sf.</span></span><span class="sig-name descname"><span class="pre">SymmetricaConversionOnBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">domain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">codomain</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.sf.sf.SymmetricaConversionOnBasis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Initialization of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">t</span></code> – a function taking a monomial in CombinatorialFreeModule(QQ, Partitions()),</dt><dd><p>and returning a (partition, coefficient) list.</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">domain</span></code>, <code class="docutils literal notranslate"><span class="pre">codomain</span></code> – parents</p></li>
</ul>
<p>Construct a function mapping a partition to an element of <code class="docutils literal notranslate"><span class="pre">codomain</span></code>.</p>
<p>This is a temporary quick hack to wrap around the existing
symmetrica conversions, without changing their specs.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sym</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">p</span><span class="p">();</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Sym</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">t</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">:</span> <span class="p">[(</span><span class="n">p</span><span class="p">,</span><span class="n">c</span><span class="p">)]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="k">return</span> <span class="p">[</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">c</span><span class="p">),</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(),</span> <span class="n">c</span><span class="p">)</span> <span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">sage</span><span class="o">.</span><span class="n">combinat</span><span class="o">.</span><span class="n">sf</span><span class="o">.</span><span class="n">sf</span><span class="o">.</span><span class="n">SymmetricaConversionOnBasis</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">Partition</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[2, 1, 1] + 2*s[3, 1]</span>
</pre></div>
</div>
</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="symplectic.html"
                        title="previous chapter">Symplectic Symmetric Functions</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="sfa.html"
                        title="next chapter">Symmetric Functions</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/sage/combinat/sf/sf.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="sfa.html" title="Symmetric Functions"
             >next</a> |</li>
        <li class="right" >
          <a href="symplectic.html" title="Symplectic Symmetric Functions"
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Sage 9.5 Reference Manual: Combinatorics</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../../module_list.html" >Comprehensive Module List</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Symmetric functions, with their multiple realizations</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2022, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>