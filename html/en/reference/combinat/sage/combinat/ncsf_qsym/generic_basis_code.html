
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="viewport" content="width=600, initial-scale=1">
    <title>Generic code for bases &#8212; Sage 9.3 Reference Manual: Combinatorics</title>
    <link rel="stylesheet" href="../../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    <script async="async" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Non-Commutative Symmetric Functions" href="ncsf.html" />
    <link rel="prev" title="Common combinatorial tools" href="combinatorics.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ncsf.html" title="Non-Commutative Symmetric Functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="combinatorics.html" title="Common combinatorial tools"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Sage 9.3 Reference Manual: Combinatorics</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../../module_list.html" accesskey="U">Comprehensive Module list</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Generic code for bases</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="generic-code-for-bases">
<span id="sage-combinat-ncsf-qsym-generic-basis-code"></span><h1>Generic code for bases<a class="headerlink" href="#generic-code-for-bases" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.ncsf_qsym.generic_basis_code"></span><p>This is a collection of code that is shared by bases of noncommutative
symmetric functions and quasisymmetric functions.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Jason Bandlow</p></li>
<li><p>Franco Saliola</p></li>
<li><p>Chris Berg</p></li>
</ul>
<dl class="py class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.AlgebraMorphism">
<em class="property">class </em><code class="sig-prename descclassname">sage.combinat.ncsf_qsym.generic_basis_code.</code><code class="sig-name descname">AlgebraMorphism</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">domain</span></em>, <em class="sig-param"><span class="n">on_generators</span></em>, <em class="sig-param"><span class="n">position</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">codomain</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">category</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">anti</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.AlgebraMorphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../modules/sage/modules/with_basis/morphism.html#sage.modules.with_basis.morphism.ModuleMorphismByLinearity" title="(in Sage 9.3 Reference Manual: Modules v9.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.morphism.ModuleMorphismByLinearity</span></code></a></p>
<p>A class for algebra morphism defined on a free algebra from the image of the generators</p>
</dd></dl>

<dl class="py class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF">
<em class="property">class </em><code class="sig-prename descclassname">sage.combinat.ncsf_qsym.generic_basis_code.</code><code class="sig-name descname">BasesOfQSymOrNCSF</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">parent_with_realization</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Sage 9.3 Reference Manual: Category Framework v9.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.realizations.Category_realization_of_parent</span></code></a></p>
<dl class="py class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods">
<em class="property">class </em><code class="sig-name descname">ElementMethods</code><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.degree">
<code class="sig-name descname">degree</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.degree" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum of the degrees of the homogeneous summands.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">homogeneous_degree()</span></code></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">F</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.degree_negation">
<code class="sig-name descname">degree_negation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.degree_negation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the degree negation
automorphism of the parent of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The degree negation is the automorphism which scales every
homogeneous element of degree <span class="math notranslate nohighlight">\(k\)</span> by <span class="math notranslate nohighlight">\((-1)^k\)</span> (for all <span class="math notranslate nohighlight">\(k\)</span>).</p>
<p>Calling <code class="docutils literal notranslate"><span class="pre">degree_negation(self)</span></code> is equivalent to calling
<code class="docutils literal notranslate"><span class="pre">self.parent().degree_negation(self)</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">S</span><span class="p">[[]]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">()</span>
<span class="go">-3*S[] + 4*S[1, 1] + 5*S[1, 2] - 2*S[2, 1]</span>

<span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dI</span> <span class="o">=</span> <span class="n">QSym</span><span class="o">.</span><span class="n">dualImmaculate</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">dI</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">dI</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dI</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">()</span>
<span class="go">-2*dI[1] + 4*dI[2] + 3*dI[2, 1]</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>Generalize this to all graded vector spaces?</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.duality_pairing">
<code class="sig-name descname">duality_pairing</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.duality_pairing" title="Permalink to this definition">¶</a></dt>
<dd><p>The duality pairing between elements of <span class="math notranslate nohighlight">\(NSym\)</span> and elements
of <span class="math notranslate nohighlight">\(QSym\)</span>.</p>
<p>The complete basis is dual to the monomial basis with respect
to this pairing.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> – an element of the dual Hopf algebra of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The result of pairing <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Elementary</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.skew_by">
<code class="sig-name descname">skew_by</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">side</span><span class="o">=</span><span class="default_value">'left'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.skew_by" title="Permalink to this definition">¶</a></dt>
<dd><p>The operation which is dual to multiplication by <code class="docutils literal notranslate"><span class="pre">y</span></code>, where <code class="docutils literal notranslate"><span class="pre">y</span></code>
is an element of the dual space of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This is calculated through the coproduct of <code class="docutils literal notranslate"><span class="pre">self</span></code> and the
expansion of <code class="docutils literal notranslate"><span class="pre">y</span></code> in the dual basis.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> – an element of the dual Hopf algebra of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">side</span></code> – (Default=’left’) Either ‘left’ or ‘right’</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The result of skewing <code class="docutils literal notranslate"><span class="pre">self</span></code> by <code class="docutils literal notranslate"><span class="pre">y</span></code>, on the side <code class="docutils literal notranslate"><span class="pre">side</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<p>Skewing an element of NCSF by an element of QSym:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">R[1, 1, 2] + R[1, 2, 1] + R[1, 3] + R[2, 1, 1] + 2*R[2, 2] + R[3, 1] + R[4]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">R[1, 1, 2] + R[1, 2, 1] + R[1, 3] + R[2, 1, 1] + 3*R[2, 2] + R[3, 1] + R[4]</span>
</pre></div>
</div>
<p>Skewing an element of QSym by an element of NCSF:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">F</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">F[2]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">F[2]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">F[2]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">F[1, 2]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">F[2, 2]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">M[3]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">M[2]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">skew_by</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods">
<em class="property">class </em><code class="sig-name descname">ParentMethods</code><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.alternating_sum_of_compositions">
<code class="sig-name descname">alternating_sum_of_compositions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.alternating_sum_of_compositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternating sum over compositions of <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>Note that this differs from the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.alternating_sum_of_finer_compositions" title="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.alternating_sum_of_finer_compositions"><code class="xref py py-meth docutils literal notranslate"><span class="pre">alternating_sum_of_finer_compositions()</span></code></a> because the
coefficient of the composition <span class="math notranslate nohighlight">\(1^n\)</span> is positive.  This
method is used in the expansion of the elementary generators
into the complete generators and vice versa.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a positive integer</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The expansion of the complete generator indexed by <code class="docutils literal notranslate"><span class="pre">n</span></code>
into the elementary basis.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">alternating_sum_of_compositions</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">L[]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">alternating_sum_of_compositions</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">L[1]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">alternating_sum_of_compositions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">L[1, 1] - L[2]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">alternating_sum_of_compositions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">L[1, 1, 1] - L[1, 2] - L[2, 1] + L[3]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">alternating_sum_of_compositions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">S[1, 1, 1] - S[1, 2] - S[2, 1] + S[3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.alternating_sum_of_fatter_compositions">
<code class="sig-name descname">alternating_sum_of_fatter_compositions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">composition</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.alternating_sum_of_fatter_compositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the alternating sum of fatter compositions in a basis of the
non-commutative symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">composition</span></code> – a composition</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The alternating sum of the compositions fatter than <code class="docutils literal notranslate"><span class="pre">composition</span></code>,
in the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>. The alternation is upon the length of the
compositions, and is normalized so that <code class="docutils literal notranslate"><span class="pre">composition</span></code> has
coefficient <span class="math notranslate nohighlight">\(1\)</span>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">elementary</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">elementary</span><span class="o">.</span><span class="n">alternating_sum_of_fatter_compositions</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">L[2, 2, 1] - L[2, 3] - L[4, 1] + L[5]</span>
<span class="gp">sage: </span><span class="n">elementary</span><span class="o">.</span><span class="n">alternating_sum_of_fatter_compositions</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">L[1, 2] - L[3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.alternating_sum_of_finer_compositions">
<code class="sig-name descname">alternating_sum_of_finer_compositions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">composition</span></em>, <em class="sig-param"><span class="n">conjugate</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.alternating_sum_of_finer_compositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the alternating sum of finer compositions in a basis of the
non-commutative symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">composition</span></code> – a composition</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">conjugate</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) a boolean</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The alternating sum of the compositions finer than <code class="docutils literal notranslate"><span class="pre">composition</span></code>,
in the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>. The alternation is upon the length of the
compositions, and is normalized so that <code class="docutils literal notranslate"><span class="pre">composition</span></code> has
coefficient <span class="math notranslate nohighlight">\(1\)</span>. If the variable <code class="docutils literal notranslate"><span class="pre">conjugate</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>,
then the conjugate of <code class="docutils literal notranslate"><span class="pre">composition</span></code> is used instead of
<code class="docutils literal notranslate"><span class="pre">composition</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">elementary</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">elementary</span><span class="o">.</span><span class="n">alternating_sum_of_finer_compositions</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">L[1, 1, 1, 1, 1] - L[1, 1, 2, 1] - L[2, 1, 1, 1] + L[2, 2, 1]</span>
<span class="gp">sage: </span><span class="n">elementary</span><span class="o">.</span><span class="n">alternating_sum_of_finer_compositions</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">-L[1, 1, 1] + L[1, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.counit_on_basis">
<code class="sig-name descname">counit_on_basis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">I</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.counit_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>The counit is defined by sending all elements of positive degree to zero.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">counit_on_basis</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">counit_on_basis</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.degree_negation">
<code class="sig-name descname">degree_negation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">element</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.degree_negation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">element</span></code> under the degree negation
automorphism of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The degree negation is the automorphism which scales every
homogeneous element of degree <span class="math notranslate nohighlight">\(k\)</span> by <span class="math notranslate nohighlight">\((-1)^k\)</span> (for all <span class="math notranslate nohighlight">\(k\)</span>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">element</span></code> – element of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">S</span><span class="p">[[]]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">-3*S[] + 4*S[1, 1] + 5*S[1, 2] - 2*S[2, 1]</span>

<span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dI</span> <span class="o">=</span> <span class="n">QSym</span><span class="o">.</span><span class="n">dualImmaculate</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">dI</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">dI</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dI</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">dI</span><span class="o">.</span><span class="n">degree_negation</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">-2*dI[1] + 4*dI[2] + 3*dI[2, 1]</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<p>Generalize this to all graded vector spaces?</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.degree_on_basis">
<code class="sig-name descname">degree_on_basis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">I</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.degree_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree of the basis element indexed by <span class="math notranslate nohighlight">\(I\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">I</span></code> – a composition</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The degree of the non-commutative symmetric function basis
element of <code class="docutils literal notranslate"><span class="pre">self</span></code> indexed by <code class="docutils literal notranslate"><span class="pre">I</span></code>. By definition, this is
the size of the composition <code class="docutils literal notranslate"><span class="pre">I</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">degree_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">degree_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">degree_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([]))</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.duality_pairing">
<code class="sig-name descname">duality_pairing</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.duality_pairing" title="Permalink to this definition">¶</a></dt>
<dd><p>The duality pairing between elements of <span class="math notranslate nohighlight">\(NSym\)</span> and elements
of <span class="math notranslate nohighlight">\(QSym\)</span>.</p>
<p>This is a default implementation that uses
<code class="docutils literal notranslate"><span class="pre">self.realizations_of().a_realization()</span></code> and its dual basis.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – an element of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> – an element in the dual basis of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The result of pairing the function <code class="docutils literal notranslate"><span class="pre">x</span></code> from <code class="docutils literal notranslate"><span class="pre">self</span></code> with the function
<code class="docutils literal notranslate"><span class="pre">y</span></code> from the dual basis of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.duality_pairing_by_coercion">
<code class="sig-name descname">duality_pairing_by_coercion</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.duality_pairing_by_coercion" title="Permalink to this definition">¶</a></dt>
<dd><p>The duality pairing between elements of NSym and elements of QSym.</p>
<p>This is a default implementation that uses
<code class="docutils literal notranslate"><span class="pre">self.realizations_of().a_realization()</span></code> and its dual basis.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – an element of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> – an element in the dual basis of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The result of pairing the function <code class="docutils literal notranslate"><span class="pre">x</span></code> from <code class="docutils literal notranslate"><span class="pre">self</span></code> with
the function <code class="docutils literal notranslate"><span class="pre">y</span></code> from the dual basis of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Elementary</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">duality_pairing_by_coercion</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">duality_pairing_by_coercion</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">duality_pairing_by_coercion</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">duality_pairing_by_coercion</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.duality_pairing_matrix">
<code class="sig-name descname">duality_pairing_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">basis</span></em>, <em class="sig-param"><span class="n">degree</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.duality_pairing_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The matrix of scalar products between elements of NSym and
elements of QSym.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">basis</span></code> – A basis of the dual Hopf algebra</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">degree</span></code> – a non-negative integer</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The matrix of scalar products between the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>
and the basis <code class="docutils literal notranslate"><span class="pre">basis</span></code> in the dual Hopf algebra in
degree <code class="docutils literal notranslate"><span class="pre">degree</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The ribbon basis of NCSF is dual to the fundamental basis of
QSym:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[1 0 0 0]</span>
<span class="go">[0 1 0 0]</span>
<span class="go">[0 0 1 0]</span>
<span class="go">[0 0 0 1]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[1 0 0 0]</span>
<span class="go">[0 1 0 0]</span>
<span class="go">[0 0 1 0]</span>
<span class="go">[0 0 0 1]</span>
</pre></div>
</div>
<p>The complete basis of NCSF is dual to the monomial basis of
QSym:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[1 0 0 0]</span>
<span class="go">[0 1 0 0]</span>
<span class="go">[0 0 1 0]</span>
<span class="go">[0 0 0 1]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[1 0 0 0]</span>
<span class="go">[0 1 0 0]</span>
<span class="go">[0 0 1 0]</span>
<span class="go">[0 0 0 1]</span>
</pre></div>
</div>
<p>The matrix between the ribbon basis of NCSF and the monomial
basis of QSym:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[ 1 -1 -1  1]</span>
<span class="go">[ 0  1  0 -1]</span>
<span class="go">[ 0  0  1 -1]</span>
<span class="go">[ 0  0  0  1]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[ 1  0  0  0]</span>
<span class="go">[-1  1  0  0]</span>
<span class="go">[-1  0  1  0]</span>
<span class="go">[ 1 -1 -1  1]</span>
</pre></div>
</div>
<p>The matrix between the complete basis of NCSF and the
fundamental basis of QSym:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[1 1 1 1]</span>
<span class="go">[0 1 0 1]</span>
<span class="go">[0 0 1 1]</span>
<span class="go">[0 0 0 1]</span>
</pre></div>
</div>
<p>A base case test:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.one_basis">
<code class="sig-name descname">one_basis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.one_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the empty composition.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The empty composition.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">parent</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">one_basis</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.skew">
<code class="sig-name descname">skew</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">side</span><span class="o">=</span><span class="default_value">'left'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.skew" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a function <code class="docutils literal notranslate"><span class="pre">x</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code> skewed by a function
<code class="docutils literal notranslate"><span class="pre">y</span></code> in the Hopf dual of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – a non-commutative or quasi-symmetric function; it is
an element of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code> – a quasi-symmetric or non-commutative symmetric
function; it is an element of the dual algebra of <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">side</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'left'</span></code>)
either <code class="docutils literal notranslate"><span class="pre">'left'</span></code> or <code class="docutils literal notranslate"><span class="pre">'right'</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The result of skewing the element <code class="docutils literal notranslate"><span class="pre">x</span></code> by the Hopf algebra
element <code class="docutils literal notranslate"><span class="pre">y</span></code> (either from the left or from the right, as
determined by <code class="docutils literal notranslate"><span class="pre">side</span></code>), written in the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">S[1, 1, 2] + S[1, 2, 1] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">S[1, 1, 2] + S[1, 2, 1] + S[2, 1, 1] + 3*S[2, 2]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Fundamental</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">R[1, 1, 2] + R[1, 2, 1] + R[1, 3] + R[2, 1, 1] + 2*R[2, 2] + R[3, 1] + R[4]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">F</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">R[1, 1, 2] + R[1, 2, 1] + R[1, 3] + R[2, 1, 1] + 3*R[2, 2] + R[3, 1] + R[4]</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">M[3]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">M[2]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.sum_of_fatter_compositions">
<code class="sig-name descname">sum_of_fatter_compositions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">composition</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.sum_of_fatter_compositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of all fatter compositions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">composition</span></code> – a composition</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the sum of all basis elements which are indexed by
compositions fatter (coarser?) than <code class="docutils literal notranslate"><span class="pre">composition</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">sum_of_fatter_compositions</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">L[2, 1] + L[3]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">sum_of_fatter_compositions</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">R[1, 3] + R[4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.sum_of_finer_compositions">
<code class="sig-name descname">sum_of_finer_compositions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">composition</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.sum_of_finer_compositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of all finer compositions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">composition</span></code> – a composition</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The sum of all basis <code class="docutils literal notranslate"><span class="pre">self</span></code> elements which are indexed by
compositions finer than <code class="docutils literal notranslate"><span class="pre">composition</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">sum_of_finer_compositions</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">L[1, 1, 1] + L[2, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">sum_of_finer_compositions</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">R[1, 1, 1, 1] + R[1, 1, 2] + R[1, 2, 1] + R[1, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.sum_of_partition_rearrangements">
<code class="sig-name descname">sum_of_partition_rearrangements</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">par</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ParentMethods.sum_of_partition_rearrangements" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of all basis elements indexed by compositions which can be
sorted to obtain a given partition.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">par</span></code> – a partition</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The sum of all <code class="docutils literal notranslate"><span class="pre">self</span></code> basis elements indexed by compositions
which are permutations of <code class="docutils literal notranslate"><span class="pre">par</span></code> (without multiplicity).</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">elementary</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">elementary</span><span class="o">.</span><span class="n">sum_of_partition_rearrangements</span><span class="p">(</span><span class="n">Partition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">L[1, 2, 2] + L[2, 1, 2] + L[2, 2, 1]</span>
<span class="gp">sage: </span><span class="n">elementary</span><span class="o">.</span><span class="n">sum_of_partition_rearrangements</span><span class="p">(</span><span class="n">Partition</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">L[1, 2, 3] + L[1, 3, 2] + L[2, 1, 3] + L[2, 3, 1] + L[3, 1, 2] + L[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">elementary</span><span class="o">.</span><span class="n">sum_of_partition_rearrangements</span><span class="p">(</span><span class="n">Partition</span><span class="p">([]))</span>
<span class="go">L[]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.super_categories">
<code class="sig-name descname">super_categories</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.super_categories" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct">
<em class="property">class </em><code class="sig-prename descclassname">sage.combinat.ncsf_qsym.generic_basis_code.</code><code class="sig-name descname">GradedModulesWithInternalProduct</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">base</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/category_types.html#sage.categories.category_types.Category_over_base_ring" title="(in Sage 9.3 Reference Manual: Category Framework v9.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.category_types.Category_over_base_ring</span></code></a></p>
<p>Constructs the class of modules with internal product. This is used to give an internal
product structure to the non-commutative symmetric functions.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.ncsf_qsym.generic_basis_code</span> <span class="kn">import</span> <span class="n">GradedModulesWithInternalProduct</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="ow">in</span> <span class="n">GradedModulesWithInternalProduct</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="py class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods">
<em class="property">class </em><code class="sig-name descname">ElementMethods</code><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product">
<code class="sig-name descname">internal_product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal product of two non-commutative
symmetric functions.</p>
<p>The internal product on the algebra of non-commutative symmetric
functions is adjoint to the internal coproduct on the algebra of
quasisymmetric functions with respect to the duality pairing
between these two algebras. This means, explicitly, that any
two non-commutative symmetric functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> and any
quasi-symmetric function <span class="math notranslate nohighlight">\(h\)</span> satisfy</p>
<div class="math notranslate nohighlight">
\[\langle f * g, h \rangle
= \sum_i \left\langle f, h^{\prime}_i \right\rangle
\left\langle g, h^{\prime\prime}_i \right\rangle,\]</div>
<p>where we write <span class="math notranslate nohighlight">\(\Delta^{\times}(h)\)</span> as <span class="math notranslate nohighlight">\(\sum_i h^{\prime}_i
\otimes h^{\prime\prime}_i\)</span>. Here, <span class="math notranslate nohighlight">\(f * g\)</span> denotes the internal
product of the non-commutative symmetric functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are two homogeneous elements of <span class="math notranslate nohighlight">\(NSym\)</span> having
distinct degrees, then the internal product <span class="math notranslate nohighlight">\(f * g\)</span> is zero.</p>
<p>Explicit formulas can be given for internal products of
elements of the complete and the Psi bases. First, the formula
for the Complete basis (<a class="reference internal" href="qsym.html#ncsf1" id="id3"><span>[NCSF1]</span></a> Proposition 5.1): If <span class="math notranslate nohighlight">\(I\)</span> and
<span class="math notranslate nohighlight">\(J\)</span> are two compositions of lengths <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span>, respectively,
then the corresponding Complete homogeneous non-commutative
symmetric functions <span class="math notranslate nohighlight">\(S^I\)</span> and <span class="math notranslate nohighlight">\(S^J\)</span> have internal product</p>
<div class="math notranslate nohighlight">
\[S^I * S^J = \sum S^{\operatorname*{comp}M},\]</div>
<p>where the sum ranges over all <span class="math notranslate nohighlight">\(p \times q\)</span>-matrices
<span class="math notranslate nohighlight">\(M \in \NN^{p \times q}\)</span> (with nonnegative integers as
entries) whose row sum vector is <span class="math notranslate nohighlight">\(I\)</span> (that is, the sum of the
entries of the <span class="math notranslate nohighlight">\(r\)</span>-th row is the <span class="math notranslate nohighlight">\(r\)</span>-th part of <span class="math notranslate nohighlight">\(I\)</span> for all
<span class="math notranslate nohighlight">\(r\)</span>) and whose column sum vector is <span class="math notranslate nohighlight">\(J\)</span> (that is, the sum of
all entries of the <span class="math notranslate nohighlight">\(s\)</span>-th row is the <span class="math notranslate nohighlight">\(s\)</span>-th part of <span class="math notranslate nohighlight">\(J\)</span> for
all <span class="math notranslate nohighlight">\(s\)</span>). Here, for any <span class="math notranslate nohighlight">\(M \in \NN^{p \times q}\)</span>, we denote
by <span class="math notranslate nohighlight">\(\operatorname*{comp}M\)</span> the composition obtained by
reading the entries of the matrix <span class="math notranslate nohighlight">\(M\)</span> in the usual order
(row by row, proceeding left to right in each row,
traversing the rows from top to bottom).</p>
<p>The formula on the Psi basis (<a class="reference internal" href="qsym.html#ncsf2" id="id4"><span>[NCSF2]</span></a> Lemma 3.10) is more
complicated. Let <span class="math notranslate nohighlight">\(I\)</span> and <span class="math notranslate nohighlight">\(J\)</span> be two compositions of lengths
<span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span>, respectively, having the same size <span class="math notranslate nohighlight">\(|I| = |J|\)</span>.
We denote by <span class="math notranslate nohighlight">\(\Psi^K\)</span> the element of the Psi basis
corresponding to any composition <span class="math notranslate nohighlight">\(K\)</span>.</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(p &gt; q\)</span>, then <span class="math notranslate nohighlight">\(\Psi^I * \Psi^J\)</span> is plainly <span class="math notranslate nohighlight">\(0\)</span>.</p></li>
<li><p>Assume that <span class="math notranslate nohighlight">\(p = q\)</span>. Let <span class="math notranslate nohighlight">\(\widetilde{\delta}_{I, J}\)</span> denote
the integer <span class="math notranslate nohighlight">\(1\)</span> if the compositions <span class="math notranslate nohighlight">\(I\)</span> and <span class="math notranslate nohighlight">\(J\)</span> are
permutations of each other, and the integer <span class="math notranslate nohighlight">\(0\)</span> otherwise.
For every positive integer <span class="math notranslate nohighlight">\(i\)</span>, let <span class="math notranslate nohighlight">\(m_i\)</span> denote the number
of parts of <span class="math notranslate nohighlight">\(I\)</span> equal to <span class="math notranslate nohighlight">\(i\)</span>. Then, <span class="math notranslate nohighlight">\(\Psi^I * \Psi^J\)</span> equals
<span class="math notranslate nohighlight">\(\widetilde{\delta}_{I, J} \prod_{i&gt;0} i^{m_i} m_i! \Psi^I\)</span>.</p></li>
<li><p>Now assume that <span class="math notranslate nohighlight">\(p &lt; q\)</span>. Write the composition <span class="math notranslate nohighlight">\(I\)</span> as
<span class="math notranslate nohighlight">\(I = (i_1, i_2, \ldots, i_p)\)</span>. For every nonempty
composition <span class="math notranslate nohighlight">\(K = (k_1, k_2, \ldots, k_s)\)</span>, denote by
<span class="math notranslate nohighlight">\(\Gamma_K\)</span> the non-commutative symmetric function
<span class="math notranslate nohighlight">\(k_1 [\ldots [[\Psi_{k_1}, \Psi_{k_2}], \Psi_{k_3}],
\ldots \Psi_{k_s}]\)</span>. For any subset <span class="math notranslate nohighlight">\(A\)</span> of
<span class="math notranslate nohighlight">\(\{ 1, 2, \ldots, q \}\)</span>, let <span class="math notranslate nohighlight">\(J_A\)</span> be the composition
obtained from <span class="math notranslate nohighlight">\(J\)</span> by removing the <span class="math notranslate nohighlight">\(r\)</span>-th parts for all
<span class="math notranslate nohighlight">\(r \notin A\)</span> (while keeping the <span class="math notranslate nohighlight">\(r\)</span>-th parts for all
<span class="math notranslate nohighlight">\(r \in A\)</span> in order). Then, <span class="math notranslate nohighlight">\(\Psi^I * \Psi^J\)</span> equals the
sum of <span class="math notranslate nohighlight">\(\Gamma_{J_{K_1}} \Gamma_{J_{K_2}} \cdots
\Gamma_{J_{K_p}}\)</span> over all ordered set partitions
<span class="math notranslate nohighlight">\((K_1, K_2, \ldots, K_p)\)</span> of <span class="math notranslate nohighlight">\(\{ 1, 2, \ldots, q \}\)</span>
into <span class="math notranslate nohighlight">\(p\)</span> parts such that each <span class="math notranslate nohighlight">\(1 \leq k \leq p\)</span> satisfies
<span class="math notranslate nohighlight">\(\left\lvert J_{K_k} \right\rvert = i_k\)</span>.
(See
<a class="reference internal" href="../set_partition_ordered.html#sage.combinat.set_partition_ordered.OrderedSetPartition" title="sage.combinat.set_partition_ordered.OrderedSetPartition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OrderedSetPartition()</span></code></a>
for the meaning of “ordered set partition”.)</p></li>
</ul>
<p>Aliases for <a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product()</span></code></a> are <a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.itensor" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a> and
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.kronecker_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.kronecker_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kronecker_product()</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> – another non-commutative symmetric function</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The result of taking the internal product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with
<code class="docutils literal notranslate"><span class="pre">other</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*S[] + 2*S[1] + 3*S[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">3*S[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*S[1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">S[1, 1, 1] + S[1, 2]</span>
</pre></div>
</div>
<p>Let us check the duality between the inner product and the inner
coproduct in degree <span class="math notranslate nohighlight">\(4\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_incopr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>  <span class="c1"># computes \sum_i \left&lt; f, h&#39;_i \right&gt; \left&lt; g, h&#39;&#39;_i \right&gt;</span>
<span class="gp">....: </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">h_parent</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">partition_pair</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span><span class="o">.</span><span class="n">monomial_coefficients</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">f</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">h_parent</span><span class="p">[</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="n">g</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">h_parent</span><span class="p">[</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">result</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">testall</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_incopr</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
<span class="gp">....: </span>                          <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>                     <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>                <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># not tested, too long</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The internal product on the algebra of non-commutative symmetric
functions commutes with the canonical commutative projection on
the symmetric functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">int_pr_of_S_in_e</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">J</span><span class="p">]))</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">int_pr_of_S_in_e</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">J</span><span class="p">]</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">())</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.itensor">
<code class="sig-name descname">itensor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.itensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal product of two non-commutative
symmetric functions.</p>
<p>The internal product on the algebra of non-commutative symmetric
functions is adjoint to the internal coproduct on the algebra of
quasisymmetric functions with respect to the duality pairing
between these two algebras. This means, explicitly, that any
two non-commutative symmetric functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> and any
quasi-symmetric function <span class="math notranslate nohighlight">\(h\)</span> satisfy</p>
<div class="math notranslate nohighlight">
\[\langle f * g, h \rangle
= \sum_i \left\langle f, h^{\prime}_i \right\rangle
\left\langle g, h^{\prime\prime}_i \right\rangle,\]</div>
<p>where we write <span class="math notranslate nohighlight">\(\Delta^{\times}(h)\)</span> as <span class="math notranslate nohighlight">\(\sum_i h^{\prime}_i
\otimes h^{\prime\prime}_i\)</span>. Here, <span class="math notranslate nohighlight">\(f * g\)</span> denotes the internal
product of the non-commutative symmetric functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are two homogeneous elements of <span class="math notranslate nohighlight">\(NSym\)</span> having
distinct degrees, then the internal product <span class="math notranslate nohighlight">\(f * g\)</span> is zero.</p>
<p>Explicit formulas can be given for internal products of
elements of the complete and the Psi bases. First, the formula
for the Complete basis (<a class="reference internal" href="qsym.html#ncsf1" id="id5"><span>[NCSF1]</span></a> Proposition 5.1): If <span class="math notranslate nohighlight">\(I\)</span> and
<span class="math notranslate nohighlight">\(J\)</span> are two compositions of lengths <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span>, respectively,
then the corresponding Complete homogeneous non-commutative
symmetric functions <span class="math notranslate nohighlight">\(S^I\)</span> and <span class="math notranslate nohighlight">\(S^J\)</span> have internal product</p>
<div class="math notranslate nohighlight">
\[S^I * S^J = \sum S^{\operatorname*{comp}M},\]</div>
<p>where the sum ranges over all <span class="math notranslate nohighlight">\(p \times q\)</span>-matrices
<span class="math notranslate nohighlight">\(M \in \NN^{p \times q}\)</span> (with nonnegative integers as
entries) whose row sum vector is <span class="math notranslate nohighlight">\(I\)</span> (that is, the sum of the
entries of the <span class="math notranslate nohighlight">\(r\)</span>-th row is the <span class="math notranslate nohighlight">\(r\)</span>-th part of <span class="math notranslate nohighlight">\(I\)</span> for all
<span class="math notranslate nohighlight">\(r\)</span>) and whose column sum vector is <span class="math notranslate nohighlight">\(J\)</span> (that is, the sum of
all entries of the <span class="math notranslate nohighlight">\(s\)</span>-th row is the <span class="math notranslate nohighlight">\(s\)</span>-th part of <span class="math notranslate nohighlight">\(J\)</span> for
all <span class="math notranslate nohighlight">\(s\)</span>). Here, for any <span class="math notranslate nohighlight">\(M \in \NN^{p \times q}\)</span>, we denote
by <span class="math notranslate nohighlight">\(\operatorname*{comp}M\)</span> the composition obtained by
reading the entries of the matrix <span class="math notranslate nohighlight">\(M\)</span> in the usual order
(row by row, proceeding left to right in each row,
traversing the rows from top to bottom).</p>
<p>The formula on the Psi basis (<a class="reference internal" href="qsym.html#ncsf2" id="id6"><span>[NCSF2]</span></a> Lemma 3.10) is more
complicated. Let <span class="math notranslate nohighlight">\(I\)</span> and <span class="math notranslate nohighlight">\(J\)</span> be two compositions of lengths
<span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span>, respectively, having the same size <span class="math notranslate nohighlight">\(|I| = |J|\)</span>.
We denote by <span class="math notranslate nohighlight">\(\Psi^K\)</span> the element of the Psi basis
corresponding to any composition <span class="math notranslate nohighlight">\(K\)</span>.</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(p &gt; q\)</span>, then <span class="math notranslate nohighlight">\(\Psi^I * \Psi^J\)</span> is plainly <span class="math notranslate nohighlight">\(0\)</span>.</p></li>
<li><p>Assume that <span class="math notranslate nohighlight">\(p = q\)</span>. Let <span class="math notranslate nohighlight">\(\widetilde{\delta}_{I, J}\)</span> denote
the integer <span class="math notranslate nohighlight">\(1\)</span> if the compositions <span class="math notranslate nohighlight">\(I\)</span> and <span class="math notranslate nohighlight">\(J\)</span> are
permutations of each other, and the integer <span class="math notranslate nohighlight">\(0\)</span> otherwise.
For every positive integer <span class="math notranslate nohighlight">\(i\)</span>, let <span class="math notranslate nohighlight">\(m_i\)</span> denote the number
of parts of <span class="math notranslate nohighlight">\(I\)</span> equal to <span class="math notranslate nohighlight">\(i\)</span>. Then, <span class="math notranslate nohighlight">\(\Psi^I * \Psi^J\)</span> equals
<span class="math notranslate nohighlight">\(\widetilde{\delta}_{I, J} \prod_{i&gt;0} i^{m_i} m_i! \Psi^I\)</span>.</p></li>
<li><p>Now assume that <span class="math notranslate nohighlight">\(p &lt; q\)</span>. Write the composition <span class="math notranslate nohighlight">\(I\)</span> as
<span class="math notranslate nohighlight">\(I = (i_1, i_2, \ldots, i_p)\)</span>. For every nonempty
composition <span class="math notranslate nohighlight">\(K = (k_1, k_2, \ldots, k_s)\)</span>, denote by
<span class="math notranslate nohighlight">\(\Gamma_K\)</span> the non-commutative symmetric function
<span class="math notranslate nohighlight">\(k_1 [\ldots [[\Psi_{k_1}, \Psi_{k_2}], \Psi_{k_3}],
\ldots \Psi_{k_s}]\)</span>. For any subset <span class="math notranslate nohighlight">\(A\)</span> of
<span class="math notranslate nohighlight">\(\{ 1, 2, \ldots, q \}\)</span>, let <span class="math notranslate nohighlight">\(J_A\)</span> be the composition
obtained from <span class="math notranslate nohighlight">\(J\)</span> by removing the <span class="math notranslate nohighlight">\(r\)</span>-th parts for all
<span class="math notranslate nohighlight">\(r \notin A\)</span> (while keeping the <span class="math notranslate nohighlight">\(r\)</span>-th parts for all
<span class="math notranslate nohighlight">\(r \in A\)</span> in order). Then, <span class="math notranslate nohighlight">\(\Psi^I * \Psi^J\)</span> equals the
sum of <span class="math notranslate nohighlight">\(\Gamma_{J_{K_1}} \Gamma_{J_{K_2}} \cdots
\Gamma_{J_{K_p}}\)</span> over all ordered set partitions
<span class="math notranslate nohighlight">\((K_1, K_2, \ldots, K_p)\)</span> of <span class="math notranslate nohighlight">\(\{ 1, 2, \ldots, q \}\)</span>
into <span class="math notranslate nohighlight">\(p\)</span> parts such that each <span class="math notranslate nohighlight">\(1 \leq k \leq p\)</span> satisfies
<span class="math notranslate nohighlight">\(\left\lvert J_{K_k} \right\rvert = i_k\)</span>.
(See
<a class="reference internal" href="../set_partition_ordered.html#sage.combinat.set_partition_ordered.OrderedSetPartition" title="sage.combinat.set_partition_ordered.OrderedSetPartition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OrderedSetPartition()</span></code></a>
for the meaning of “ordered set partition”.)</p></li>
</ul>
<p>Aliases for <a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product()</span></code></a> are <a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.itensor" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a> and
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.kronecker_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.kronecker_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kronecker_product()</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> – another non-commutative symmetric function</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The result of taking the internal product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with
<code class="docutils literal notranslate"><span class="pre">other</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*S[] + 2*S[1] + 3*S[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">3*S[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*S[1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">S[1, 1, 1] + S[1, 2]</span>
</pre></div>
</div>
<p>Let us check the duality between the inner product and the inner
coproduct in degree <span class="math notranslate nohighlight">\(4\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_incopr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>  <span class="c1"># computes \sum_i \left&lt; f, h&#39;_i \right&gt; \left&lt; g, h&#39;&#39;_i \right&gt;</span>
<span class="gp">....: </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">h_parent</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">partition_pair</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span><span class="o">.</span><span class="n">monomial_coefficients</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">f</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">h_parent</span><span class="p">[</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="n">g</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">h_parent</span><span class="p">[</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">result</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">testall</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_incopr</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
<span class="gp">....: </span>                          <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>                     <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>                <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># not tested, too long</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The internal product on the algebra of non-commutative symmetric
functions commutes with the canonical commutative projection on
the symmetric functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">int_pr_of_S_in_e</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">J</span><span class="p">]))</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">int_pr_of_S_in_e</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">J</span><span class="p">]</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">())</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.kronecker_product">
<code class="sig-name descname">kronecker_product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.kronecker_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal product of two non-commutative
symmetric functions.</p>
<p>The internal product on the algebra of non-commutative symmetric
functions is adjoint to the internal coproduct on the algebra of
quasisymmetric functions with respect to the duality pairing
between these two algebras. This means, explicitly, that any
two non-commutative symmetric functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> and any
quasi-symmetric function <span class="math notranslate nohighlight">\(h\)</span> satisfy</p>
<div class="math notranslate nohighlight">
\[\langle f * g, h \rangle
= \sum_i \left\langle f, h^{\prime}_i \right\rangle
\left\langle g, h^{\prime\prime}_i \right\rangle,\]</div>
<p>where we write <span class="math notranslate nohighlight">\(\Delta^{\times}(h)\)</span> as <span class="math notranslate nohighlight">\(\sum_i h^{\prime}_i
\otimes h^{\prime\prime}_i\)</span>. Here, <span class="math notranslate nohighlight">\(f * g\)</span> denotes the internal
product of the non-commutative symmetric functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are two homogeneous elements of <span class="math notranslate nohighlight">\(NSym\)</span> having
distinct degrees, then the internal product <span class="math notranslate nohighlight">\(f * g\)</span> is zero.</p>
<p>Explicit formulas can be given for internal products of
elements of the complete and the Psi bases. First, the formula
for the Complete basis (<a class="reference internal" href="qsym.html#ncsf1" id="id7"><span>[NCSF1]</span></a> Proposition 5.1): If <span class="math notranslate nohighlight">\(I\)</span> and
<span class="math notranslate nohighlight">\(J\)</span> are two compositions of lengths <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span>, respectively,
then the corresponding Complete homogeneous non-commutative
symmetric functions <span class="math notranslate nohighlight">\(S^I\)</span> and <span class="math notranslate nohighlight">\(S^J\)</span> have internal product</p>
<div class="math notranslate nohighlight">
\[S^I * S^J = \sum S^{\operatorname*{comp}M},\]</div>
<p>where the sum ranges over all <span class="math notranslate nohighlight">\(p \times q\)</span>-matrices
<span class="math notranslate nohighlight">\(M \in \NN^{p \times q}\)</span> (with nonnegative integers as
entries) whose row sum vector is <span class="math notranslate nohighlight">\(I\)</span> (that is, the sum of the
entries of the <span class="math notranslate nohighlight">\(r\)</span>-th row is the <span class="math notranslate nohighlight">\(r\)</span>-th part of <span class="math notranslate nohighlight">\(I\)</span> for all
<span class="math notranslate nohighlight">\(r\)</span>) and whose column sum vector is <span class="math notranslate nohighlight">\(J\)</span> (that is, the sum of
all entries of the <span class="math notranslate nohighlight">\(s\)</span>-th row is the <span class="math notranslate nohighlight">\(s\)</span>-th part of <span class="math notranslate nohighlight">\(J\)</span> for
all <span class="math notranslate nohighlight">\(s\)</span>). Here, for any <span class="math notranslate nohighlight">\(M \in \NN^{p \times q}\)</span>, we denote
by <span class="math notranslate nohighlight">\(\operatorname*{comp}M\)</span> the composition obtained by
reading the entries of the matrix <span class="math notranslate nohighlight">\(M\)</span> in the usual order
(row by row, proceeding left to right in each row,
traversing the rows from top to bottom).</p>
<p>The formula on the Psi basis (<a class="reference internal" href="qsym.html#ncsf2" id="id8"><span>[NCSF2]</span></a> Lemma 3.10) is more
complicated. Let <span class="math notranslate nohighlight">\(I\)</span> and <span class="math notranslate nohighlight">\(J\)</span> be two compositions of lengths
<span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span>, respectively, having the same size <span class="math notranslate nohighlight">\(|I| = |J|\)</span>.
We denote by <span class="math notranslate nohighlight">\(\Psi^K\)</span> the element of the Psi basis
corresponding to any composition <span class="math notranslate nohighlight">\(K\)</span>.</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(p &gt; q\)</span>, then <span class="math notranslate nohighlight">\(\Psi^I * \Psi^J\)</span> is plainly <span class="math notranslate nohighlight">\(0\)</span>.</p></li>
<li><p>Assume that <span class="math notranslate nohighlight">\(p = q\)</span>. Let <span class="math notranslate nohighlight">\(\widetilde{\delta}_{I, J}\)</span> denote
the integer <span class="math notranslate nohighlight">\(1\)</span> if the compositions <span class="math notranslate nohighlight">\(I\)</span> and <span class="math notranslate nohighlight">\(J\)</span> are
permutations of each other, and the integer <span class="math notranslate nohighlight">\(0\)</span> otherwise.
For every positive integer <span class="math notranslate nohighlight">\(i\)</span>, let <span class="math notranslate nohighlight">\(m_i\)</span> denote the number
of parts of <span class="math notranslate nohighlight">\(I\)</span> equal to <span class="math notranslate nohighlight">\(i\)</span>. Then, <span class="math notranslate nohighlight">\(\Psi^I * \Psi^J\)</span> equals
<span class="math notranslate nohighlight">\(\widetilde{\delta}_{I, J} \prod_{i&gt;0} i^{m_i} m_i! \Psi^I\)</span>.</p></li>
<li><p>Now assume that <span class="math notranslate nohighlight">\(p &lt; q\)</span>. Write the composition <span class="math notranslate nohighlight">\(I\)</span> as
<span class="math notranslate nohighlight">\(I = (i_1, i_2, \ldots, i_p)\)</span>. For every nonempty
composition <span class="math notranslate nohighlight">\(K = (k_1, k_2, \ldots, k_s)\)</span>, denote by
<span class="math notranslate nohighlight">\(\Gamma_K\)</span> the non-commutative symmetric function
<span class="math notranslate nohighlight">\(k_1 [\ldots [[\Psi_{k_1}, \Psi_{k_2}], \Psi_{k_3}],
\ldots \Psi_{k_s}]\)</span>. For any subset <span class="math notranslate nohighlight">\(A\)</span> of
<span class="math notranslate nohighlight">\(\{ 1, 2, \ldots, q \}\)</span>, let <span class="math notranslate nohighlight">\(J_A\)</span> be the composition
obtained from <span class="math notranslate nohighlight">\(J\)</span> by removing the <span class="math notranslate nohighlight">\(r\)</span>-th parts for all
<span class="math notranslate nohighlight">\(r \notin A\)</span> (while keeping the <span class="math notranslate nohighlight">\(r\)</span>-th parts for all
<span class="math notranslate nohighlight">\(r \in A\)</span> in order). Then, <span class="math notranslate nohighlight">\(\Psi^I * \Psi^J\)</span> equals the
sum of <span class="math notranslate nohighlight">\(\Gamma_{J_{K_1}} \Gamma_{J_{K_2}} \cdots
\Gamma_{J_{K_p}}\)</span> over all ordered set partitions
<span class="math notranslate nohighlight">\((K_1, K_2, \ldots, K_p)\)</span> of <span class="math notranslate nohighlight">\(\{ 1, 2, \ldots, q \}\)</span>
into <span class="math notranslate nohighlight">\(p\)</span> parts such that each <span class="math notranslate nohighlight">\(1 \leq k \leq p\)</span> satisfies
<span class="math notranslate nohighlight">\(\left\lvert J_{K_k} \right\rvert = i_k\)</span>.
(See
<a class="reference internal" href="../set_partition_ordered.html#sage.combinat.set_partition_ordered.OrderedSetPartition" title="sage.combinat.set_partition_ordered.OrderedSetPartition"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OrderedSetPartition()</span></code></a>
for the meaning of “ordered set partition”.)</p></li>
</ul>
<p>Aliases for <a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product()</span></code></a> are <a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.itensor" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.itensor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itensor()</span></code></a> and
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.kronecker_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.kronecker_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kronecker_product()</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">other</span></code> – another non-commutative symmetric function</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The result of taking the internal product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with
<code class="docutils literal notranslate"><span class="pre">other</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*S[] + 2*S[1] + 3*S[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">3*S[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*S[1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">S[1, 1, 1] + S[1, 2]</span>
</pre></div>
</div>
<p>Let us check the duality between the inner product and the inner
coproduct in degree <span class="math notranslate nohighlight">\(4\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">FiniteField</span><span class="p">(</span><span class="mi">29</span><span class="p">))</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">tensor_incopr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>  <span class="c1"># computes \sum_i \left&lt; f, h&#39;_i \right&gt; \left&lt; g, h&#39;&#39;_i \right&gt;</span>
<span class="gp">....: </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">base_ring</span><span class="p">()</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">h_parent</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">partition_pair</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">internal_coproduct</span><span class="p">()</span><span class="o">.</span><span class="n">monomial_coefficients</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">....: </span>        <span class="n">result</span> <span class="o">+=</span> <span class="n">coeff</span> <span class="o">*</span> <span class="n">f</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">h_parent</span><span class="p">[</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="n">g</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">h_parent</span><span class="p">[</span><span class="n">partition_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">result</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">testall</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">tensor_incopr</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">itensor</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">v</span><span class="p">]))</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">w</span><span class="p">])</span>
<span class="gp">....: </span>                          <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>                     <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>                <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">testall</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># not tested, too long</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The internal product on the algebra of non-commutative symmetric
functions commutes with the canonical commutative projection on
the symmetric functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">e</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">int_pr_of_S_in_e</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">J</span><span class="p">]))</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">int_pr_of_S_in_e</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">J</span><span class="p">]</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">())</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods">
<em class="property">class </em><code class="sig-name descname">ParentMethods</code><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product">
<code class="sig-name descname">internal_product</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product" title="Permalink to this definition">¶</a></dt>
<dd><p>The bilinear product inherited from the isomorphism with
the descent algebra.</p>
<p>This is constructed by extending the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product_on_basis" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product_on_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product_on_basis()</span></code></a> bilinearly, if available,
or using the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods.internal_product_by_coercion" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods.internal_product_by_coercion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product_by_coercion()</span></code></a>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The internal product map of the algebra the non-commutative
symmetric functions.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span>
<span class="go">Generic endomorphism of Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*S[1, 1, 1, 1] + S[1, 1, 2] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product</span>
<span class="go">&lt;bound method ....internal_product_by_coercion ...&gt;</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product_by_coercion</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">R[2]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product_on_basis">
<code class="sig-name descname">internal_product_on_basis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">I</span></em>, <em class="sig-param"><span class="n">J</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>The internal product of the two basis elements indexed by <code class="docutils literal notranslate"><span class="pre">I</span></code> and
<code class="docutils literal notranslate"><span class="pre">J</span></code> (optional)</p>
<p>INPUT:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">I</span></code>, <code class="docutils literal notranslate"><span class="pre">J</span></code> – compositions indexing two elements of the basis of self</p></li>
</ul>
</div></blockquote>
<p>Returns the internal product of the corresponding basis elements.
If this method is implemented, the internal product is defined from
it by linearity.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product_on_basis</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*S[1, 1, 1, 1] + S[1, 1, 2] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product_on_basis</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.itensor">
<code class="sig-name descname">itensor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.itensor" title="Permalink to this definition">¶</a></dt>
<dd><p>The bilinear product inherited from the isomorphism with
the descent algebra.</p>
<p>This is constructed by extending the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product_on_basis" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product_on_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product_on_basis()</span></code></a> bilinearly, if available,
or using the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods.internal_product_by_coercion" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods.internal_product_by_coercion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product_by_coercion()</span></code></a>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The internal product map of the algebra the non-commutative
symmetric functions.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span>
<span class="go">Generic endomorphism of Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*S[1, 1, 1, 1] + S[1, 1, 2] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product</span>
<span class="go">&lt;bound method ....internal_product_by_coercion ...&gt;</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product_by_coercion</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">R[2]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.kronecker_product">
<code class="sig-name descname">kronecker_product</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.kronecker_product" title="Permalink to this definition">¶</a></dt>
<dd><p>The bilinear product inherited from the isomorphism with
the descent algebra.</p>
<p>This is constructed by extending the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product_on_basis" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ParentMethods.internal_product_on_basis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product_on_basis()</span></code></a> bilinearly, if available,
or using the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods.internal_product_by_coercion" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods.internal_product_by_coercion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product_by_coercion()</span></code></a>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The internal product map of the algebra the non-commutative
symmetric functions.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span>
<span class="go">Generic endomorphism of Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*S[1, 1, 1, 1] + S[1, 1, 2] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product</span>
<span class="go">&lt;bound method ....internal_product_by_coercion ...&gt;</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product_by_coercion</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">R[2]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">internal_product</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations">
<em class="property">class </em><code class="sig-name descname">Realizations</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">category</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.RealizationsCategory" title="(in Sage 9.3 Reference Manual: Category Framework v9.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.realizations.RealizationsCategory</span></code></a></p>
<dl class="py class">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods">
<em class="property">class </em><code class="sig-name descname">ParentMethods</code><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods.internal_product_by_coercion">
<code class="sig-name descname">internal_product_by_coercion</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">left</span></em>, <em class="sig-param"><span class="n">right</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.Realizations.ParentMethods.internal_product_by_coercion" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal product of <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code>.</p>
<p>This is a default implementation that computes
the internal product in the realization specified
by <code class="docutils literal notranslate"><span class="pre">self.realization_of().a_realization()</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">left</span></code> – an element of the non-commutative symmetric functions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">right</span></code> – an element of the non-commutative symmetric functions</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The internal product of <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product_by_coercion</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">S[2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product_by_coercion</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.super_categories">
<code class="sig-name descname">super_categories</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.combinat.ncsf_qsym.generic_basis_code</span> <span class="kn">import</span> <span class="n">GradedModulesWithInternalProduct</span>
<span class="gp">sage: </span><span class="n">GradedModulesWithInternalProduct</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">super_categories</span><span class="p">()</span>
<span class="go">[Category of graded modules over Integer Ring]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="combinatorics.html"
                        title="previous chapter">Common combinatorial tools</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ncsf.html"
                        title="next chapter">Non-Commutative Symmetric Functions</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/sage/combinat/ncsf_qsym/generic_basis_code.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ncsf.html" title="Non-Commutative Symmetric Functions"
             >next</a> |</li>
        <li class="right" >
          <a href="combinatorics.html" title="Common combinatorial tools"
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Sage 9.3 Reference Manual: Combinatorics</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../../module_list.html" >Comprehensive Module list</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Generic code for bases</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2021, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>