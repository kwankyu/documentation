
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Non-Commutative Symmetric Functions &#8212; Combinatorics</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sage.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/thebelab.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Quasisymmetric functions" href="qsym.html" />
    <link rel="prev" title="Generic code for bases" href="generic_basis_code.html" />
  <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />
  <!-- <script src="../../../../_static/thebe.js" type="text/javascript"></script> -->
  <!-- <script src="../../../../_static/thebe-sage.js" type="text/javascript"></script> -->

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="qsym.html" title="Quasisymmetric functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="generic_basis_code.html" title="Generic code for bases"
             accesskey="P">previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="../../../../_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../../../../../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="../../../../index.html">Reference Manual</a> &#187;
      
      <a href="../../../index.html">Combinatorics</a> &#187;
    
  </li>

          <li class="nav-item nav-item-1"><a href="../../../module_list.html" accesskey="U">Comprehensive Module List</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Non-Commutative Symmetric Functions</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="non-commutative-symmetric-functions">
<span id="sage-combinat-ncsf-qsym-ncsf"></span><h1>Non-Commutative Symmetric Functions<a class="headerlink" href="#non-commutative-symmetric-functions" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.ncsf_qsym.ncsf"></span><dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.ncsf_qsym.ncsf.</span></span><span class="sig-name descname"><span class="pre">NonCommutativeSymmetricFunctions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></code></a>, <a class="reference external" href="../../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>The abstract algebra of non-commutative symmetric functions.</p>
<p>We construct the abstract algebra of non-commutative symmetric
functions over the rational numbers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">NCSF</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="go">S[2, 1, 1, 2] - S[2, 1, 3]</span>
</pre></div>
</div>
<p>NCSF is the unique free (non-commutative!) graded connected algebra with
one generator in each degree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Join of Category of hopf algebras over Rational Field</span>
<span class="go">    and Category of graded algebras over Rational Field</span>
<span class="go">    and Category of monoids with realizations</span>
<span class="go">    and Category of graded coalgebras over Rational Field</span>
<span class="go">    and Category of coalgebras over Rational Field with realizations</span>
<span class="go">    and Category of cocommutative coalgebras over Rational Field</span>

<span class="gp">sage: </span><span class="p">[</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</pre></div>
</div>
<p>We use the Sage standard renaming idiom to get shorter outputs:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;NCSF&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">NCSF</span>
<span class="go">NCSF</span>
</pre></div>
</div>
<p>NCSF has many representations as a concrete algebra. Each of them
has a distinguished basis, and its elements are expanded in this
basis. Here is the <span class="math notranslate nohighlight">\(\Psi\)</span>
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi"><code class="xref py py-class docutils literal notranslate"><span class="pre">Psi</span></code></a>)
representation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span>
<span class="go">NCSF in the Psi basis</span>
</pre></div>
</div>
<p>Elements of <code class="docutils literal notranslate"><span class="pre">Psi</span></code> are linear combinations of basis elements indexed
by compositions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*Psi[] + 2*Psi[1] + 3*Psi[1, 1]</span>
</pre></div>
</div>
<p>The basis itself is accessible through:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span>
<span class="go">Lazy family (Term map from Compositions of non-negative integers...</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">basis</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">Compositions of non-negative integers</span>
</pre></div>
</div>
<p>To construct an element one can therefore do:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">basis</span><span class="p">()[</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])]</span>
<span class="go">Psi[2, 1, 3]</span>
</pre></div>
</div>
<p>As this is rather cumbersome, the following abuses of notation are
allowed:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])]</span>
<span class="go">Psi[2, 1, 3]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="go">Psi[2, 1, 3]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="go">Psi[2, 1, 3]</span>
</pre></div>
</div>
<p>or even:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])]</span>
<span class="go">Psi[2, 1, 3]</span>
</pre></div>
</div>
<p>Unfortunately, due to a limitation in Python syntax, one cannot use:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[]</span>       <span class="c1"># not implemented</span>
</pre></div>
</div>
<p>Instead, you can use:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[[]]</span>
<span class="go">Psi[]</span>
</pre></div>
</div>
<p>Now, we can construct linear combinations of basis elements:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">Psi</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*Psi[2, 1] + Psi[2, 1, 3] + 2*Psi[4]</span>
</pre></div>
</div>
<p class="rubric">Algebra structure</p>
<p>To start with, <code class="docutils literal notranslate"><span class="pre">Psi</span></code> is a graded algebra, the grading being induced by
the size of compositions. The one is the basis element indexed by the empty
composition:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="go">Psi[]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="go">S[]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="go">R[]</span>
</pre></div>
</div>
<p>As we have seen above, the <code class="docutils literal notranslate"><span class="pre">Psi</span></code> basis is multiplicative; that is
multiplication is induced by linearity from the concatenation of
compositions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Psi[1, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Psi</span><span class="o">.</span><span class="n">one</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="go">2*Psi[1, 3, 2, 4] + Psi[2, 4]</span>
</pre></div>
</div>
<p class="rubric">Hopf algebra structure</p>
<p><code class="docutils literal notranslate"><span class="pre">Psi</span></code> is further endowed with a coalgebra structure. The coproduct
is an algebra morphism, and therefore determined by its values on
the generators; those are primitive:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">Psi[] # Psi[1] + Psi[1] # Psi[]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">Psi[] # Psi[2] + Psi[2] # Psi[]</span>
</pre></div>
</div>
<p>The coproduct, being cocommutative on the generators, is
cocommutative everywhere:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">Psi[] # Psi[1, 2] + Psi[1] # Psi[2] + Psi[1, 2] # Psi[] + Psi[2] # Psi[1]</span>
</pre></div>
</div>
<p>The algebra and coalgebra structures on <code class="docutils literal notranslate"><span class="pre">Psi</span></code> combine to form a
bialgebra structure, which cooperates with the grading to form a
connected graded bialgebra. Thus, as any connected graded bialgebra,
<code class="docutils literal notranslate"><span class="pre">Psi</span></code> is a Hopf algebra. Over <code class="docutils literal notranslate"><span class="pre">QQ</span></code> (or any other <span class="math notranslate nohighlight">\(\QQ\)</span>-algebra),
this Hopf algebra <code class="docutils literal notranslate"><span class="pre">Psi</span></code> is isomorphic to the tensor algebra of
its space of primitive elements.</p>
<p>The antipode is an anti-algebra morphism; in the <code class="docutils literal notranslate"><span class="pre">Psi</span></code> basis, it
sends the generators to their opposites and changes their sign if
they are of odd degree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">-Psi[3]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="go">-Psi[2, 3, 1]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span><span class="o">.</span><span class="n">apply_multilinear_morphism</span><span class="p">(</span><span class="k">lambda</span> <span class="n">be</span><span class="p">,</span><span class="n">ga</span><span class="p">:</span> <span class="n">Psi</span><span class="p">(</span><span class="n">be</span><span class="p">)</span><span class="o">*</span><span class="n">Psi</span><span class="p">(</span><span class="n">ga</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">())</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The counit is defined by sending all elements of positive degree to
zero:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">degree</span><span class="p">(),</span> <span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">degree</span><span class="p">(),</span> <span class="n">S</span><span class="o">.</span><span class="n">one</span><span class="p">()</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
<span class="go">(3, 6, 0)</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">counit</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">counit</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">one</span><span class="p">()</span><span class="o">.</span><span class="n">counit</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">counit</span><span class="p">()</span>
<span class="go">7</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">counit</span><span class="p">()</span>
<span class="go">7</span>
</pre></div>
</div>
<p>It is possible to change the prefix used to display the basis
elements using the method
<a class="reference external" href="../../../../structure/sage/structure/indexed_generators.html#sage.structure.indexed_generators.IndexedGenerators.print_options" title="(in Parents and Elements v9.6)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">print_options()</span></code></a>.
Say that for instance one wanted to display the
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete"><code class="xref py py-class docutils literal notranslate"><span class="pre">Complete</span></code></a> basis as having
a prefix <code class="docutils literal notranslate"><span class="pre">H</span></code> instead of the default <code class="docutils literal notranslate"><span class="pre">S</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*S[] + 2*S[1] + 3*S[1, 1]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">print_options</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*H[] + 2*H[1] + 3*H[1, 1]</span>
<span class="gp">sage: </span><span class="n">H</span><span class="o">.</span><span class="n">print_options</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;S&#39;</span><span class="p">)</span> <span class="c1">#restore to &#39;S&#39;</span>
</pre></div>
</div>
<p class="rubric">Concrete representations</p>
<p>NCSF admits the concrete realizations defined in <a class="reference internal" href="qsym.html#ncsf1" id="id1"><span>[NCSF1]</span></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Phi</span>        <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span>        <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">ribbon</span>     <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">complete</span>   <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">elementary</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
</pre></div>
</div>
<p>To change from one basis to another, one simply does:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Phi</span><span class="p">(</span><span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">Phi[1]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">(</span><span class="n">Psi</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">-1/4*Phi[1, 2] + 1/4*Phi[2, 1] + Phi[3]</span>
</pre></div>
</div>
<p>In general, one can mix up different bases in computations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Phi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Phi[1, 1]</span>
</pre></div>
</div>
<p>Some of the changes of basis are easy to guess:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ribbon</span><span class="p">(</span><span class="n">complete</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">R[1, 3, 2] + R[1, 5] + R[4, 2] + R[6]</span>
</pre></div>
</div>
<p>This is the sum of all fatter compositions. Using the usual
Möbius function for the boolean lattice, the inverse change of
basis is given by the alternating sum of all fatter compositions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">complete</span><span class="p">(</span><span class="n">ribbon</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">S[1, 3, 2] - S[1, 5] - S[4, 2] + S[6]</span>
</pre></div>
</div>
<p>The analogue of the elementary basis is the sum over
all finer compositions than the ‘complement’ of the composition
in the ribbon basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span>
<span class="go">[2, 1, 2, 1]</span>
<span class="gp">sage: </span><span class="n">ribbon</span><span class="p">(</span><span class="n">elementary</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">R[1, 1, 1, 1, 1, 1] + R[1, 1, 1, 2, 1] + R[2, 1, 1, 1, 1] + R[2, 1, 2, 1]</span>
</pre></div>
</div>
<p>By Möbius inversion on the composition poset, the ribbon
basis element corresponding to a composition <span class="math notranslate nohighlight">\(I\)</span> is then the
alternating sum over all compositions fatter than the
complement composition of <span class="math notranslate nohighlight">\(I\)</span> in the elementary basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">elementary</span><span class="p">(</span><span class="n">ribbon</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">L[1, 3, 2] - L[1, 5] - L[4, 2] + L[6]</span>
</pre></div>
</div>
<p>The <span class="math notranslate nohighlight">\(\Phi\)</span>
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi"><code class="xref py py-class docutils literal notranslate"><span class="pre">Phi</span></code></a>)
and <span class="math notranslate nohighlight">\(\Psi\)</span> bases are computed by changing to and from the
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete"><code class="xref py py-class docutils literal notranslate"><span class="pre">Complete</span></code></a>
basis. The expansion of <span class="math notranslate nohighlight">\(\Psi\)</span> basis is given in Proposition 4.5
of <a class="reference internal" href="qsym.html#ncsf1" id="id2"><span>[NCSF1]</span></a> by the formulae</p>
<div class="math notranslate nohighlight">
\[S^I = \sum_{J \geq I} \frac{1}{\pi_u(J,I)} \Psi^J\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\Psi^I = \sum_{J \geq I} (-1)^{\ell(J)-\ell(I)} lp(J,I) S^J\]</div>
<p>where the coefficients <span class="math notranslate nohighlight">\(\pi_u(J,I)\)</span> and <span class="math notranslate nohighlight">\(lp(J,I)\)</span> are coefficients in the
methods <a class="reference internal" href="combinatorics.html#sage.combinat.ncsf_qsym.combinatorics.coeff_pi" title="sage.combinat.ncsf_qsym.combinatorics.coeff_pi"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coeff_pi()</span></code></a> and
<a class="reference internal" href="combinatorics.html#sage.combinat.ncsf_qsym.combinatorics.coeff_lp" title="sage.combinat.ncsf_qsym.combinatorics.coeff_lp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coeff_lp()</span></code></a> respectively.  For
example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="p">(</span><span class="n">complete</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">1/6*Psi[1, 1, 1] + 1/3*Psi[1, 2] + 1/6*Psi[2, 1] + 1/3*Psi[3]</span>
<span class="gp">sage: </span><span class="n">complete</span><span class="p">(</span><span class="n">Psi</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">S[1, 1, 1] - 2*S[1, 2] - S[2, 1] + 3*S[3]</span>
</pre></div>
</div>
<p>The
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi"><code class="xref py py-class docutils literal notranslate"><span class="pre">Phi</span></code></a>
basis is another analogue of the power sum basis from the algebra of
symmetric functions and the expansion in the Complete basis is given in
Proposition 4.9 of <a class="reference internal" href="qsym.html#ncsf1" id="id3"><span>[NCSF1]</span></a> by the formulae</p>
<div class="math notranslate nohighlight">
\[S^I = \sum_{J \geq I} \frac{1}{sp(J,I)} \Phi^J\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\Phi^I = \sum_{J \geq I} (-1)^{\ell(J)-\ell(I)}
\frac{\prod_i I_i}{\ell(J,I)} S^J\]</div>
<p>where the coefficients <span class="math notranslate nohighlight">\(sp(J,I)\)</span> and <span class="math notranslate nohighlight">\(\ell(J,I)\)</span> are coefficients in the
methods <a class="reference internal" href="combinatorics.html#sage.combinat.ncsf_qsym.combinatorics.coeff_sp" title="sage.combinat.ncsf_qsym.combinatorics.coeff_sp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coeff_sp()</span></code></a> and
<a class="reference internal" href="combinatorics.html#sage.combinat.ncsf_qsym.combinatorics.coeff_ell" title="sage.combinat.ncsf_qsym.combinatorics.coeff_ell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coeff_ell()</span></code></a> respectively.
For example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Phi</span><span class="p">(</span><span class="n">complete</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">1/6*Phi[1, 1, 1] + 1/4*Phi[1, 2] + 1/4*Phi[2, 1] + 1/3*Phi[3]</span>
<span class="gp">sage: </span><span class="n">complete</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">S[1, 1, 1] - 3/2*S[1, 2] - 3/2*S[2, 1] + 3*S[3]</span>
</pre></div>
</div>
<p>Here is how to fetch the conversion morphisms:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">complete</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">elementary</span><span class="p">);</span> <span class="n">f</span>
<span class="go">Generic morphism:</span>
<span class="go">  From: NCSF in the Elementary basis</span>
<span class="go">  To:   NCSF in the Complete basis</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">elementary</span><span class="o">.</span><span class="n">coerce_map_from</span><span class="p">(</span><span class="n">complete</span><span class="p">);</span> <span class="n">g</span>
<span class="go">Generic morphism:</span>
<span class="go">  From: NCSF in the Complete basis</span>
<span class="go">  To:   NCSF in the Elementary basis</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of homsets of unital magmas and right modules over Rational Field and</span>
<span class="go">  left modules over Rational Field</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">elementary</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">S[1, 1, 1, 1, 1] - S[1, 1, 1, 2] - S[1, 2, 1, 1] + S[1, 2, 2]</span>
<span class="gp">sage: </span><span class="n">g</span><span class="p">(</span><span class="n">complete</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">L[1, 1, 1, 1, 1] - L[1, 1, 1, 2] - L[1, 2, 1, 1] + L[1, 2, 2]</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">f</span><span class="o">*</span><span class="n">g</span><span class="p">;</span> <span class="n">h</span>
<span class="go">Composite map:</span>
<span class="go">  From: NCSF in the Complete basis</span>
<span class="go">  To:   NCSF in the Complete basis</span>
<span class="go">  Defn:   Generic morphism:</span>
<span class="go">          From: NCSF in the Complete basis</span>
<span class="go">          To:   NCSF in the Elementary basis</span>
<span class="go">        then</span>
<span class="go">          Generic morphism:</span>
<span class="go">          From: NCSF in the Elementary basis</span>
<span class="go">          To:   NCSF in the Complete basis</span>
<span class="gp">sage: </span><span class="n">h</span><span class="p">(</span><span class="n">complete</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">S[1, 3, 2]</span>
</pre></div>
</div>
<p class="rubric">Additional concrete representations</p>
<p>NCSF has some additional bases which appear in the literature:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Monomial</span>                 <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Immaculate</span>               <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Immaculate</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">dualQuasisymmetric_Schur</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">dualQuasisymmetric_Schur</span><span class="p">()</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Monomial" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Monomial"><code class="xref py py-class docutils literal notranslate"><span class="pre">Monomial</span></code></a>
basis was introduced in <a class="reference internal" href="combinatorics.html#tev2007" id="id4"><span>[Tev2007]</span></a> and the
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Immaculate</span></code></a>
basis was introduced in <a class="reference internal" href="qsym.html#bbssz2012" id="id5"><span>[BBSSZ2012]</span></a>.  The
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quasisymmetric_Schur</span></code></a>
were defined in <a class="reference internal" href="combinatorics.html#qschur" id="id6"><span>[QSCHUR]</span></a> and the dual basis is implemented here as
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur"><code class="xref py py-class docutils literal notranslate"><span class="pre">dualQuasisymmetric_Schur</span></code></a>.
Refer to the documentation for the use and definition of these bases.</p>
<div class="admonition-todo admonition" id="id7">
<p class="admonition-title">Todo</p>
<ul class="simple">
<li><p>implement fundamental, forgotten, and simple (coming
from the simple modules of HS_n) bases.</p></li>
</ul>
</div>
<p>We revert back to the original name from our custom short name NCSF:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span>
<span class="go">NCSF</span>
<span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">rename</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">NCSF</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Bases</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parent_with_realization</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Category Framework v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.realizations.Category_realization_of_parent</span></code></a></p>
<p>Category of bases of non-commutative symmetric functions.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Bases</span><span class="p">()</span>
<span class="go">Category of bases of Non-Commutative Symmetric Functions over the Rational Field</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">Bases</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ElementMethods</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.bernstein_creation_operator">
<span class="sig-name descname"><span class="pre">bernstein_creation_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.bernstein_creation_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the <span class="math notranslate nohighlight">\(n\)</span>-th Bernstein
creation operator.</p>
<p>Let <span class="math notranslate nohighlight">\(n\)</span> be an integer. The <span class="math notranslate nohighlight">\(n\)</span>-th Bernstein creation
operator <span class="math notranslate nohighlight">\(\mathbb{B}_n\)</span> is defined as the endomorphism of
the space <span class="math notranslate nohighlight">\(NSym\)</span> of noncommutative symmetric functions
which sends every <span class="math notranslate nohighlight">\(f\)</span> to</p>
<div class="math notranslate nohighlight">
\[\sum_{i \geq 0} (-1)^i H_{n+i} F_{1^i}^\perp,\]</div>
<p>where usual notations are in place (the letter <span class="math notranslate nohighlight">\(H\)</span> stands
for the complete basis of <span class="math notranslate nohighlight">\(NSym\)</span>, the letter <span class="math notranslate nohighlight">\(F\)</span> stands
for the fundamental basis of the algebra <span class="math notranslate nohighlight">\(QSym\)</span> of
quasisymmetric functions, and <span class="math notranslate nohighlight">\(F_{1^i}^\perp\)</span> means
skewing (<a class="reference internal" href="generic_basis_code.html#sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.skew_by" title="sage.combinat.ncsf_qsym.generic_basis_code.BasesOfQSymOrNCSF.ElementMethods.skew_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">skew_by()</span></code></a>)
by <span class="math notranslate nohighlight">\(F_{1^i}\)</span>). Notice that <span class="math notranslate nohighlight">\(F_{1^i}\)</span> is nothing other than the
elementary symmetric function <span class="math notranslate nohighlight">\(e_i\)</span>.</p>
<p>This has been introduced in <a class="reference internal" href="qsym.html#bbssz2012" id="id8"><span>[BBSSZ2012]</span></a>, section 3.1, in
analogy to the Bernstein creation operators on the
symmetric functions
(<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.bernstein_creation_operator" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.bernstein_creation_operator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bernstein_creation_operator()</span></code></a>),
and studied further in <a class="reference internal" href="qsym.html#bbssz2012" id="id9"><span>[BBSSZ2012]</span></a>, mainly in the context
of immaculate functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Immaculate</span></code></a>).
In fact, if <span class="math notranslate nohighlight">\((\alpha_1, \alpha_2, \ldots, \alpha_m)\)</span> is
an <span class="math notranslate nohighlight">\(m\)</span>-tuple of integers, then</p>
<div class="math notranslate nohighlight">
\[\mathbb{B}_n I_{(\alpha_1, \alpha_2, \ldots, \alpha_m)}
= I_{(n, \alpha_1, \alpha_2, \ldots, \alpha_m)},\]</div>
<p>where <span class="math notranslate nohighlight">\(I_{(\alpha_1, \alpha_2, \ldots, \alpha_m)}\)</span> is the
immaculate function associated to the <span class="math notranslate nohighlight">\(m\)</span>-tuple
<span class="math notranslate nohighlight">\((\alpha_1, \alpha_2, \ldots, \alpha_m)\)</span> (see
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.immaculate_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.immaculate_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">immaculate_function()</span></code></a>).</p>
<p>EXAMPLES:</p>
<p>We get the immaculate functions by repeated application of
Bernstein creation operators:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">I</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">immaculate_by_bernstein</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="c1"># immaculate function corresponding to integer</span>
<span class="gp">....: </span>    <span class="c1"># tuple ``xs``, computed by iterated application</span>
<span class="gp">....: </span>    <span class="c1"># of Bernstein creation operators.</span>
<span class="gp">....: </span>    <span class="n">res</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">res</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">immaculate_by_bernstein</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Some examples:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">S[2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">S[1, 2, 1] - S[2, 2] - S[3, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">-S[1, 2, 2] - S[1, 3, 1] + S[2, 2, 1] + S[3, 2]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">S[1, 3, 2] - S[2, 2, 2] - S[2, 3, 1] + S[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">S[2, 3, 2] - S[3, 2, 2] - S[3, 3, 1] + S[4, 2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.chi">
<span class="sig-name descname"><span class="pre">chi</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.chi" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the commutative image of a non-commutative symmetric function.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The commutative image of <code class="docutils literal notranslate"><span class="pre">self</span></code>. This will be a symmetric function.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*R[] + 2*R[1] + 3*R[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="go">2*s[] + 2*s[1] + 3*s[1, 1]</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="go">h[1, 1, 1, 1] - 3*h[2, 1, 1] + 3*h[3, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.expand">
<span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphabet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the noncommutative symmetric function into an
element of a free algebra in <code class="docutils literal notranslate"><span class="pre">n</span></code> indeterminates of
an alphabet, which by default is <code class="docutils literal notranslate"><span class="pre">'x'</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a nonnegative integer; the number of variables
in the expansion</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">alphabet</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">'x'</span></code>); the alphabet in
which <code class="docutils literal notranslate"><span class="pre">self</span></code> is to be expanded</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>An expansion of <code class="docutils literal notranslate"><span class="pre">self</span></code> into the <code class="docutils literal notranslate"><span class="pre">n</span></code> variables
specified by <code class="docutils literal notranslate"><span class="pre">alphabet</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x0^3 + x0^2*x1 + x0^2*x2 + x0*x1^2 + x0*x1*x2</span>
<span class="go"> + x0*x2^2 + x1^3 + x1^2*x2 + x1*x2^2 + x2^3</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x2*x1*x0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x1*x0 + x2*x0 + x2*x1</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">x2*x1*x0 + x3*x1*x0 + x3*x2*x0 + x3*x2*x1</span>
<span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">x0^3 + x0^2*x1 + x0^2*x2 + x0*x1*x0 + x0*x1^2 + x0*x1*x2</span>
<span class="go"> + x0*x2*x0 + x0*x2*x1 + x0*x2^2 - x1*x0^2 - x1*x0*x1</span>
<span class="go"> - x1*x0*x2 + x1^2*x0 + x1^3 + x1^2*x2 + x1*x2*x0</span>
<span class="go"> + x1*x2*x1 + x1*x2^2 - x2*x0^2 - x2*x0*x1 - x2*x0*x2</span>
<span class="go"> - x2*x1*x0 - x2*x1^2 - x2*x1*x2 + x2^2*x0 + x2^2*x1 + x2^3</span>
</pre></div>
</div>
<p>One can use a different set of variables by adding an optional
argument <code class="docutils literal notranslate"><span class="pre">alphabet=...</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">alphabet</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
<span class="go">y2*y1*y0 + y3*y1*y0 + y3*y2*y0 + y3*y2*y1</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id10">
<p class="admonition-title">Todo</p>
<p>So far this is only implemented on the elementary
basis, and everything else goes through coercion.
Maybe it is worth shortcutting some of the other
bases?</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.left_padded_kronecker_product">
<span class="sig-name descname"><span class="pre">left_padded_kronecker_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.left_padded_kronecker_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the left-padded Kronecker product of <code class="docutils literal notranslate"><span class="pre">self</span></code> and
<code class="docutils literal notranslate"><span class="pre">x</span></code> in the basis of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The left-padded Kronecker product is a bilinear map
mapping two non-commutative symmetric functions to
another, not necessarily preserving degree.
It can be defined as follows: Let <span class="math notranslate nohighlight">\(*\)</span> denote the internal
product (<a class="reference internal" href="generic_basis_code.html#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product()</span></code></a>)
on the space of non-commutative symmetric functions. For any
composition <span class="math notranslate nohighlight">\(I\)</span>, let <span class="math notranslate nohighlight">\(S^I\)</span> denote the complete homogeneous
symmetric function indexed by <span class="math notranslate nohighlight">\(I\)</span>. For any compositions
<span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(\beta\)</span>, <span class="math notranslate nohighlight">\(\gamma\)</span>, let
<span class="math notranslate nohighlight">\(g^{\gamma}_{\alpha, \beta}\)</span> denote the coefficient of
<span class="math notranslate nohighlight">\(S^{\gamma}\)</span> in the internal product
<span class="math notranslate nohighlight">\(S^{\alpha} * S^{\beta}\)</span>.
For every composition <span class="math notranslate nohighlight">\(I = (i_1, i_2, \ldots, i_k)\)</span>
and every integer <span class="math notranslate nohighlight">\(n &gt; \left\lvert I \right\rvert\)</span>, define the
<em>`n`-completion of `I`</em> to be the composition
<span class="math notranslate nohighlight">\((n - \left\lvert I \right\rvert, i_1, i_2, \ldots, i_k)\)</span>;
this <span class="math notranslate nohighlight">\(n\)</span>-completion is denoted by <span class="math notranslate nohighlight">\(I[n]\)</span>.
Then, for any compositions <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> and every
integer <span class="math notranslate nohighlight">\(n &gt; \left\lvert \alpha \right\rvert
+ \left\lvert\beta\right\rvert\)</span>, we can write the
internal product <span class="math notranslate nohighlight">\(S^{\alpha[n]} * S^{\beta[n]}\)</span> in the form</p>
<div class="math notranslate nohighlight">
\[S^{\alpha[n]} * S^{\beta[n]} =
\sum_{\gamma} g^{\gamma[n]}_{\alpha[n], \beta[n]}
S^{\gamma[n]}\]</div>
<p>with <span class="math notranslate nohighlight">\(\gamma\)</span> ranging over all compositions. The
coefficients <span class="math notranslate nohighlight">\(g^{\gamma[n]}_{\alpha[n], \beta[n]}\)</span>
are independent on <span class="math notranslate nohighlight">\(n\)</span>. These coefficients
<span class="math notranslate nohighlight">\(g^{\gamma[n]}_{\alpha[n], \beta[n]}\)</span> are denoted by
<span class="math notranslate nohighlight">\(\widetilde{g}^{\gamma}_{\alpha, \beta}\)</span>, and the
non-commutative symmetric function</p>
<div class="math notranslate nohighlight">
\[\sum_{\gamma} \widetilde{g}^{\gamma}_{\alpha, \beta}
S^{\gamma}\]</div>
<p>is said to be the <em>left-padded Kronecker product</em> of
<span class="math notranslate nohighlight">\(S^{\alpha}\)</span> and <span class="math notranslate nohighlight">\(S^{\beta}\)</span>. By bilinearity, this
extends to a definition of a left-padded Kronecker product
of any two non-commutative symmetric functions.</p>
<p>The left-padded Kronecker product on the non-commutative
symmetric functions lifts the left-padded Kronecker
product on the symmetric functions. More precisely: Let
<span class="math notranslate nohighlight">\(\pi\)</span> denote the canonical projection
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_symmetric_function()</span></code></a>) from the non-commutative
symmetric functions to the symmetric functions. Then, any
two non-commutative symmetric functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>
satisfy</p>
<div class="math notranslate nohighlight">
\[\pi(f \overline{*} g) = \pi(f) \overline{*} \pi(g),\]</div>
<p>where the <span class="math notranslate nohighlight">\(\overline{*}\)</span> on the left-hand side denotes the
left-padded Kronecker product on the non-commutative
symmetric functions, and the <span class="math notranslate nohighlight">\(\overline{*}\)</span> on the
right-hand side denotes the left-padded Kronecker product
on the symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> – element of the ring of non-commutative
symmetric functions over the same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the left-padded Kronecker product of <code class="docutils literal notranslate"><span class="pre">self</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span></code>
(an element of the ring of non-commutative symmetric
functions in the same basis as <code class="docutils literal notranslate"><span class="pre">self</span></code>)</p></li>
</ul>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Darij Grinberg (15 Mar 2014)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">S[1, 1, 1, 1] + S[1, 2, 1] + S[2, 1] + S[2, 1, 1, 1] + S[2, 2, 1] + S[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">S[1, 1, 1] + S[1, 2, 1] + S[2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">S[1, 1, 1] + S[2, 1] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">S[1, 1] + 2*S[1, 1, 1] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">S[1, 1, 1, 1] + S[1, 2, 1] + S[1, 2, 1, 1] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">S[1, 2] + S[2, 1, 1] + S[3, 2]</span>
</pre></div>
</div>
<p>Taking the left-padded Kronecker product with
<span class="math notranslate nohighlight">\(1 = S^{\empty}\)</span> is the identity map on the ring of
non-commutative symmetric functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">S</span><span class="p">[</span><span class="n">Composition</span><span class="p">([])]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">lam</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">S</span><span class="p">[</span><span class="n">lam</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">Composition</span><span class="p">([])])</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">S</span><span class="p">[</span><span class="n">lam</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">lam</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Here is a rule for the left-padded Kronecker product of
<span class="math notranslate nohighlight">\(S_1\)</span> (this is the same as <span class="math notranslate nohighlight">\(S^{(1)}\)</span>) with any complete
homogeneous function: Let <span class="math notranslate nohighlight">\(I\)</span> be a composition.
Then, the left-padded Kronecker product of <span class="math notranslate nohighlight">\(S_1\)</span> and
<span class="math notranslate nohighlight">\(S^I\)</span> is <span class="math notranslate nohighlight">\(\sum_K a_K S^K\)</span>, where the sum runs
over all compositions <span class="math notranslate nohighlight">\(K\)</span>, and the coefficient <span class="math notranslate nohighlight">\(a_K\)</span> is
defined as the number of ways to obtain <span class="math notranslate nohighlight">\(K\)</span> from <span class="math notranslate nohighlight">\(I\)</span> by
one of the following two operations:</p>
<ul class="simple">
<li><p>Insert a <span class="math notranslate nohighlight">\(1\)</span> at the end of <span class="math notranslate nohighlight">\(I\)</span>.</p></li>
<li><p>Subtract <span class="math notranslate nohighlight">\(1\)</span> from one of the entries of <span class="math notranslate nohighlight">\(I\)</span> (and remove
the entry if it thus becomes <span class="math notranslate nohighlight">\(0\)</span>), and insert a <span class="math notranslate nohighlight">\(1\)</span> at
the end of <span class="math notranslate nohighlight">\(I\)</span>.</p></li>
</ul>
<p>We check this for compositions of size <span class="math notranslate nohighlight">\(\leq 4\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">mults1</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="c1"># Left left-padded Kronecker multiplication by S[1].</span>
<span class="gp">....: </span>    <span class="n">res</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">)):</span>
<span class="gp">....: </span>        <span class="n">I2</span> <span class="o">=</span> <span class="n">I</span><span class="p">[:]</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">I2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="n">I2</span> <span class="o">=</span> <span class="n">I2</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">I2</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="gp">....: </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="n">I2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
<span class="gp">....: </span>        <span class="n">res</span> <span class="o">+=</span> <span class="n">S</span><span class="p">[</span><span class="n">I2</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">res</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">mults1</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">==</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A similar rule can be made for the left-padded Kronecker
product of any complete homogeneous function with <span class="math notranslate nohighlight">\(S_1\)</span>:
Let <span class="math notranslate nohighlight">\(I\)</span> be a composition. Then, the left-padded Kronecker
product of <span class="math notranslate nohighlight">\(S^I\)</span> and <span class="math notranslate nohighlight">\(S_1\)</span> is <span class="math notranslate nohighlight">\(\sum_K b_K S^K\)</span>, where the
sum runs over all compositions <span class="math notranslate nohighlight">\(K\)</span>, and the coefficient
<span class="math notranslate nohighlight">\(b_K\)</span> is defined as the number of ways to obtain <span class="math notranslate nohighlight">\(K\)</span> from
<span class="math notranslate nohighlight">\(I\)</span> by one of the following two operations:</p>
<ul class="simple">
<li><p>Insert a <span class="math notranslate nohighlight">\(1\)</span> at the front of <span class="math notranslate nohighlight">\(I\)</span>.</p></li>
<li><p>Subtract <span class="math notranslate nohighlight">\(1\)</span> from one of the entries of <span class="math notranslate nohighlight">\(I\)</span> (and remove
the entry if it thus becomes <span class="math notranslate nohighlight">\(0\)</span>), and insert a <span class="math notranslate nohighlight">\(1\)</span>
right after this entry.</p></li>
</ul>
<p>We check this for compositions of size <span class="math notranslate nohighlight">\(\leq 4\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">mults2</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="c1"># Left left-padded Kronecker multiplication by S[1].</span>
<span class="gp">....: </span>    <span class="n">res</span> <span class="o">=</span> <span class="n">S</span><span class="p">[[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">I</span><span class="p">[:]]</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">)):</span>
<span class="gp">....: </span>        <span class="n">I2</span> <span class="o">=</span> <span class="n">I</span><span class="p">[:]</span>
<span class="gp">....: </span>        <span class="n">i2k</span> <span class="o">=</span> <span class="n">I2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">i2k</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="n">I2</span> <span class="o">=</span> <span class="n">I2</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i2k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">I2</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="gp">....: </span>        <span class="n">res</span> <span class="o">+=</span> <span class="n">S</span><span class="p">[</span><span class="n">I2</span><span class="p">]</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">res</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">mults2</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">==</span> <span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Checking the
<span class="math notranslate nohighlight">\(\pi(f \overline{*} g) = \pi(f) \overline{*} \pi(g)\)</span>
equality:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">testpi</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="n">a</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="gp">....: </span>            <span class="n">b</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">J</span><span class="p">]</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="gp">....: </span>            <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">....: </span>            <span class="n">y</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">left_padded_kronecker_product</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">J</span><span class="p">])</span>
<span class="gp">....: </span>            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="gp">....: </span>            <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">:</span>
<span class="gp">....: </span>                <span class="k">return</span> <span class="kc">False</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="kc">True</span>
<span class="gp">sage: </span><span class="n">testpi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.omega_involution">
<span class="sig-name descname"><span class="pre">omega_involution</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.omega_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<code class="docutils literal notranslate"><span class="pre">self</span></code> under the omega involution.</p>
<p>The omega involution is defined as the algebra antihomomorphism
<span class="math notranslate nohighlight">\(NCSF \to NCSF\)</span> which, for every positive integer <span class="math notranslate nohighlight">\(n\)</span>, sends
the <span class="math notranslate nohighlight">\(n\)</span>-th complete non-commutative symmetric function <span class="math notranslate nohighlight">\(S_n\)</span> to
the <span class="math notranslate nohighlight">\(n\)</span>-th elementary non-commutative symmetric function
<span class="math notranslate nohighlight">\(\Lambda_n\)</span>. This omega involution is denoted by <span class="math notranslate nohighlight">\(\omega\)</span>. It
can be shown that every composition <span class="math notranslate nohighlight">\(I\)</span> satisfies</p>
<div class="math notranslate nohighlight">
\[\omega(S^I) = \Lambda^{I^r}, \quad
\omega(\Lambda^I) = S^{I^r}, \quad
\omega(R_I) = R_{I^t}, \quad
\omega(\Phi^I) = (-1)^{|I|-\ell(I)} \Phi^{I^r},
\omega(\Psi^I) = (-1)^{|I|-\ell(I)} \Psi^{I^r},\]</div>
<p>where <span class="math notranslate nohighlight">\(I^r\)</span> denotes the reversed composition of <span class="math notranslate nohighlight">\(I\)</span>, and
<span class="math notranslate nohighlight">\(I^t\)</span> denotes the conjugate composition of <span class="math notranslate nohighlight">\(I\)</span>, and <span class="math notranslate nohighlight">\(\ell(I)\)</span>
denotes the length of the
composition <span class="math notranslate nohighlight">\(I\)</span>, and standard notations for classical bases
of <span class="math notranslate nohighlight">\(NCSF\)</span> are being used (<span class="math notranslate nohighlight">\(S\)</span> for the complete basis,
<span class="math notranslate nohighlight">\(\Lambda\)</span> for the elementary basis, <span class="math notranslate nohighlight">\(R\)</span> for the ribbon
basis, <span class="math notranslate nohighlight">\(\Phi\)</span> for that of the power-sums of the second
kind, and <span class="math notranslate nohighlight">\(\Psi\)</span> for that of the power-sums of the first
kind). More generally, if <span class="math notranslate nohighlight">\(f\)</span> is a homogeneous element of
<span class="math notranslate nohighlight">\(NCSF\)</span> of degree <span class="math notranslate nohighlight">\(n\)</span>, then</p>
<div class="math notranslate nohighlight">
\[\omega(f) = (-1)^n S(f),\]</div>
<p>where <span class="math notranslate nohighlight">\(S\)</span> denotes the antipode of <span class="math notranslate nohighlight">\(NCSF\)</span>.</p>
<p>The omega involution <span class="math notranslate nohighlight">\(\omega\)</span> is an involution and a
coalgebra automorphism of <span class="math notranslate nohighlight">\(NCSF\)</span>. It is an automorphism of the
graded vector space <span class="math notranslate nohighlight">\(NCSF\)</span>. If <span class="math notranslate nohighlight">\(\pi\)</span> denotes the projection
from <span class="math notranslate nohighlight">\(NCSF\)</span> to the ring of symmetric functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_symmetric_function()</span></code></a>), then
<span class="math notranslate nohighlight">\(\pi(\omega(f)) = \omega(\pi(f))\)</span> for every <span class="math notranslate nohighlight">\(f \in NCSF\)</span>,
where the <span class="math notranslate nohighlight">\(\omega\)</span> on the right hand side denotes the omega
automorphism of <span class="math notranslate nohighlight">\(Sym\)</span>.</p>
<p>The omega involution on <span class="math notranslate nohighlight">\(NCSF\)</span> is adjoint to the omega
involution on <span class="math notranslate nohighlight">\(QSym\)</span> by the standard adjunction between <span class="math notranslate nohighlight">\(NCSF\)</span>
and <span class="math notranslate nohighlight">\(QSym\)</span>.</p>
<p>The omega involution has been denoted by <span class="math notranslate nohighlight">\(\omega\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id11"><span>[LMvW13]</span></a>,
section 3.6.
See <a class="reference internal" href="qsym.html#ncsf1" id="id12"><span>[NCSF1]</span></a>, section 3.1 for the properties of this map.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.omega_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.omega_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">omega</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></code></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">())</span>
<span class="go">L[2, 3]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">())</span>
<span class="go">L[3, 6]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">())</span>
<span class="go">L[3, 1]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">((</span><span class="n">S</span><span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">S</span><span class="p">[[]])</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">())</span> <span class="c1"># long time</span>
<span class="go">4*L[] + L[1, 9] - L[2, 8] - 3*L[3] + 2*L[4, 6]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">((</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">())</span>
<span class="go">-2*L[2] + L[3, 3]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">(</span><span class="n">S</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">())</span>
<span class="go">L[2, 4]</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span>
<span class="go">R[1, 2, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span>
<span class="go">-Phi[1, 2]</span>
<span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span>
<span class="go">-Psi[1, 2]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span>
<span class="go">Psi[1, 3]</span>
</pre></div>
</div>
<p>Testing the <span class="math notranslate nohighlight">\(\pi(\omega(f)) = \omega(\pi(f))\)</span> relation noticed
above:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The omega involution on <span class="math notranslate nohighlight">\(QSym\)</span> is adjoint to the omega
involution on <span class="math notranslate nohighlight">\(NSym\)</span> with respect to the duality pairing:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QSym</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">M</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">()</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="n">M</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">.</span><span class="n">omega_involution</span><span class="p">())</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution">
<span class="sig-name descname"><span class="pre">psi_involution</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<code class="docutils literal notranslate"><span class="pre">self</span></code> under the involution <span class="math notranslate nohighlight">\(\psi\)</span>.</p>
<p>The involution <span class="math notranslate nohighlight">\(\psi\)</span> is defined as the linear map
<span class="math notranslate nohighlight">\(NCSF \to NCSF\)</span> which, for every composition <span class="math notranslate nohighlight">\(I\)</span>, sends the
complete noncommutative symmetric function <span class="math notranslate nohighlight">\(S^I\)</span> to the
elementary noncommutative symmetric function <span class="math notranslate nohighlight">\(\Lambda^I\)</span>.
It can be shown that every composition <span class="math notranslate nohighlight">\(I\)</span> satisfies</p>
<div class="math notranslate nohighlight">
\[\psi(R_I) = R_{I^c}, \quad \psi(S^I) = \Lambda^I, \quad
\psi(\Lambda^I) = S^I, \quad
\psi(\Phi^I) = (-1)^{|I| - \ell(I)} \Phi^I\]</div>
<p>where <span class="math notranslate nohighlight">\(I^c\)</span> denotes the complement of the composition <span class="math notranslate nohighlight">\(I\)</span>, and
<span class="math notranslate nohighlight">\(\ell(I)\)</span> denotes the length of <span class="math notranslate nohighlight">\(I\)</span>, and where standard
notations for classical bases of <span class="math notranslate nohighlight">\(NCSF\)</span> are being used
(<span class="math notranslate nohighlight">\(S\)</span> for the complete basis, <span class="math notranslate nohighlight">\(\Lambda\)</span> for the elementary basis,
<span class="math notranslate nohighlight">\(\Phi\)</span> for the basis of the power sums of the second kind,
and <span class="math notranslate nohighlight">\(R\)</span> for the ribbon basis). The map <span class="math notranslate nohighlight">\(\psi\)</span> is an involution
and a graded Hopf algebra automorphism of <span class="math notranslate nohighlight">\(NCSF\)</span>. If <span class="math notranslate nohighlight">\(\pi\)</span>
denotes the projection from <span class="math notranslate nohighlight">\(NCSF\)</span> to the ring of symmetric
functions (<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_symmetric_function()</span></code></a>), then
<span class="math notranslate nohighlight">\(\pi(\psi(f)) = \omega(\pi(f))\)</span> for every <span class="math notranslate nohighlight">\(f \in NCSF\)</span>, where
the <span class="math notranslate nohighlight">\(\omega\)</span> on the right hand side denotes the omega
automorphism of <span class="math notranslate nohighlight">\(Sym\)</span>.</p>
<p>The involution <span class="math notranslate nohighlight">\(\psi\)</span> of <span class="math notranslate nohighlight">\(NCSF\)</span> is adjoint to the involution
<span class="math notranslate nohighlight">\(\psi\)</span> of <span class="math notranslate nohighlight">\(QSym\)</span> by the standard adjunction between <span class="math notranslate nohighlight">\(NCSF\)</span> and
<span class="math notranslate nohighlight">\(QSym\)</span>.</p>
<p>The involution <span class="math notranslate nohighlight">\(\psi\)</span> has been denoted by <span class="math notranslate nohighlight">\(\psi\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id13"><span>[LMvW13]</span></a>,
section 3.6.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.psi_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></code></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">R[1, 1, 2, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">R[1, 1, 1, 1, 1, 2, 1, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">R</span><span class="p">[[]])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">4*R[] - 3*R[1, 1, 1] + R[1, 1, 1, 1, 1, 1, 1, 1, 2] - R[1, 1, 1, 1, 1, 1, 1, 2, 1] + 2*R[1, 2, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">-2*R[1, 1] + R[1, 1, 2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">R[1, 3]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">S[1, 1, 1] - S[2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">-Phi[2, 1]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">Phi[3, 1]</span>
</pre></div>
</div>
<p>The Psi basis doesn’t behave as nicely:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">-Psi[2, 1]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">1/2*Psi[1, 2, 1] - 1/2*Psi[2, 1, 1] + Psi[3, 1]</span>
</pre></div>
</div>
<p>The involution <span class="math notranslate nohighlight">\(\psi\)</span> commutes with the antipode:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Testing the <span class="math notranslate nohighlight">\(\pi(\psi(f)) = \omega(\pi(f))\)</span> relation noticed
above:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span><span class="o">.</span><span class="n">omega</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The involution <span class="math notranslate nohighlight">\(\psi\)</span> of <span class="math notranslate nohighlight">\(QSym\)</span> is adjoint to the involution
<span class="math notranslate nohighlight">\(\psi\)</span> of <span class="math notranslate nohighlight">\(NSym\)</span> with respect to the duality pairing:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QSym</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">M</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="n">M</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">())</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution">
<span class="sig-name descname"><span class="pre">star_involution</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<code class="docutils literal notranslate"><span class="pre">self</span></code> under the star involution.</p>
<p>The star involution is defined as the algebra antihomomorphism
<span class="math notranslate nohighlight">\(NCSF \to NCSF\)</span> which, for every positive integer <span class="math notranslate nohighlight">\(n\)</span>, sends
the <span class="math notranslate nohighlight">\(n\)</span>-th complete non-commutative symmetric function <span class="math notranslate nohighlight">\(S_n\)</span> to
<span class="math notranslate nohighlight">\(S_n\)</span>. Denoting by <span class="math notranslate nohighlight">\(f^{\ast}\)</span> the image of an element
<span class="math notranslate nohighlight">\(f \in NCSF\)</span> under this star involution, it can be shown that
every composition <span class="math notranslate nohighlight">\(I\)</span> satisfies</p>
<div class="math notranslate nohighlight">
\[(S^I)^{\ast} = S^{I^r}, \quad
(\Lambda^I)^{\ast} = \Lambda^{I^r}, \quad
R_I^{\ast} = R_{I^r}, \quad
(\Phi^I)^{\ast} = \Phi^{I^r},\]</div>
<p>where <span class="math notranslate nohighlight">\(I^r\)</span> denotes the reversed composition of <span class="math notranslate nohighlight">\(I\)</span>, and
standard notations for classical bases of <span class="math notranslate nohighlight">\(NCSF\)</span> are being used
(<span class="math notranslate nohighlight">\(S\)</span> for the complete basis, <span class="math notranslate nohighlight">\(\Lambda\)</span> for the elementary basis,
<span class="math notranslate nohighlight">\(R\)</span> for the ribbon basis, and <span class="math notranslate nohighlight">\(\Phi\)</span> for that of the power-sums
of the second kind). The star involution is an involution and a
coalgebra automorphism of <span class="math notranslate nohighlight">\(NCSF\)</span>. It is an automorphism of the
graded vector space <span class="math notranslate nohighlight">\(NCSF\)</span>. Under the canonical isomorphism
between the <span class="math notranslate nohighlight">\(n\)</span>-th graded component of <span class="math notranslate nohighlight">\(NCSF\)</span> and the descent
algebra of the symmetric group <span class="math notranslate nohighlight">\(S_n\)</span> (see
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_descent_algebra()</span></code></a>), the star involution (restricted to
the <span class="math notranslate nohighlight">\(n\)</span>-th graded component) corresponds to the automorphism
of the descent algebra given by
<span class="math notranslate nohighlight">\(x \mapsto \omega_n x \omega_n\)</span>, where <span class="math notranslate nohighlight">\(\omega_n\)</span> is the
permutation <span class="math notranslate nohighlight">\((n, n-1, \ldots, 1) \in S_n\)</span> (written here in
one-line notation). If <span class="math notranslate nohighlight">\(\pi\)</span> denotes the projection from <span class="math notranslate nohighlight">\(NCSF\)</span>
to the ring of symmetric functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_symmetric_function()</span></code></a>), then <span class="math notranslate nohighlight">\(\pi(f^{\ast}) = \pi(f)\)</span>
for every <span class="math notranslate nohighlight">\(f \in NCSF\)</span>.</p>
<p>The star involution on <span class="math notranslate nohighlight">\(NCSF\)</span> is adjoint to the star involution
on <span class="math notranslate nohighlight">\(QSym\)</span> by the standard adjunction between <span class="math notranslate nohighlight">\(NCSF\)</span> and <span class="math notranslate nohighlight">\(QSym\)</span>.</p>
<p>The star involution has been denoted by <span class="math notranslate nohighlight">\(\rho\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id14"><span>[LMvW13]</span></a>,
section 3.6.
See <a class="reference internal" href="qsym.html#ncsf2" id="id15"><span>[NCSF2]</span></a>, section 2.3 for the properties of this map.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.star_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></code></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">S[2, 3]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">S[3, 6]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">S</span><span class="p">[[]])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">4*S[] + S[1, 9] - S[2, 8] - 3*S[3] + 2*S[4, 6]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">-2*S[2] + S[3, 3]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">S[2, 4]</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">R[2, 4]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">Phi[1, 2]</span>
</pre></div>
</div>
<p>The Psi basis doesn’t behave as nicely:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">Psi[1, 2]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">1/2*Psi[1, 1, 2] - 1/2*Psi[1, 2, 1] + Psi[1, 3]</span>
</pre></div>
</div>
<p>The star involution commutes with the antipode:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Checking the relation with the descent algebra described
above:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">descent_test</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">DA</span> <span class="o">=</span> <span class="n">DescentAlgebra</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">DAD</span> <span class="o">=</span> <span class="n">DA</span><span class="o">.</span><span class="n">D</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">w_n</span> <span class="o">=</span> <span class="n">DAD</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)))</span>
<span class="gp">....: </span>    <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="gp">....: </span>                <span class="o">==</span> <span class="n">w_n</span> <span class="o">*</span> <span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">to_descent_algebra</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">w_n</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="kc">False</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="kc">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">descent_test</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">descent_test</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">)</span> <span class="c1"># long time</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Testing the <span class="math notranslate nohighlight">\(\pi(f^{\ast}) = \pi(f)\)</span> relation noticed above:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The star involution on <span class="math notranslate nohighlight">\(QSym\)</span> is adjoint to the star involution
on <span class="math notranslate nohighlight">\(NSym\)</span> with respect to the duality pairing:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QSym</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">M</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="n">M</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">.</span><span class="n">star_involution</span><span class="p">())</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra">
<span class="sig-name descname"><span class="pre">to_descent_algebra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the <code class="docutils literal notranslate"><span class="pre">n</span></code>-th degree homogeneous component
of <code class="docutils literal notranslate"><span class="pre">self</span></code> in the descent algebra of <span class="math notranslate nohighlight">\(S_n\)</span> over the same
base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This is based upon the canonical isomorphism from the
<span class="math notranslate nohighlight">\(n\)</span>-th degree homogeneous component of the algebra of
noncommutative symmetric functions to the descent algebra
of <span class="math notranslate nohighlight">\(S_n\)</span>. This isomorphism maps the inner product of
noncommutative symmetric functions either to the product
in the descent algebra of <span class="math notranslate nohighlight">\(S_n\)</span> or to its opposite
(depending on how the latter is defined).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">n</span></code> is not specified, it will be taken to be the highest
homogeneous component of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The image of the <code class="docutils literal notranslate"><span class="pre">n</span></code>-th homogeneous component of <code class="docutils literal notranslate"><span class="pre">self</span></code>
under the isomorphism into the descent algebra of <span class="math notranslate nohighlight">\(S_n\)</span>
over the same base ring as <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_descent_algebra</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">B[2, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">to_descent_algebra</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">-3*B[1, 1, 2] + B[1, 2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_descent_algebra</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_descent_algebra</span><span class="p">()</span>
<span class="go">B[2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span><span class="o">.</span><span class="n">to_descent_algebra</span><span class="p">()</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">Descent algebra of 0 over Integer Ring in the subset basis</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">to_descent_algebra</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_fqsym">
<span class="sig-name descname"><span class="pre">to_fqsym</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_fqsym" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the non-commutative symmetric
function <code class="docutils literal notranslate"><span class="pre">self</span></code> under the morphism
<span class="math notranslate nohighlight">\(\iota : NSym \to FQSym\)</span>.</p>
<p>This morphism is the injective algebra homomorphism
<span class="math notranslate nohighlight">\(NSym \to FQSym\)</span> that sends each Complete generator
<span class="math notranslate nohighlight">\(S_n\)</span> to <span class="math notranslate nohighlight">\(F_{[1, 2, \ldots, n]}\)</span>. It is the inclusion
map, if we regard both <span class="math notranslate nohighlight">\(NSym\)</span> and <span class="math notranslate nohighlight">\(FQSym\)</span> as rings of
noncommutative power series.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../fqsym.html#sage.combinat.fqsym.FreeQuasisymmetricFunctions" title="sage.combinat.fqsym.FreeQuasisymmetricFunctions"><code class="xref py py-class docutils literal notranslate"><span class="pre">FreeQuasisymmetricFunctions</span></code></a> for a definition
of <span class="math notranslate nohighlight">\(FQSym\)</span>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[[]]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">to_fqsym</span><span class="p">()</span>
<span class="go">2*F[] + 2*F[1] + 3*F[1, 2]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_fqsym</span><span class="p">()</span>
<span class="go">F[1, 3, 2] + F[3, 1, 2]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*R[] + 2*R[1] + 3*R[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">to_fqsym</span><span class="p">()</span>
<span class="go">2*F[] + 2*F[1] + 3*F[2, 1]</span>

<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">to_fqsym</span><span class="p">()</span>
<span class="go">F[1, 2, 3] - F[1, 3, 2] + F[2, 1, 3] + F[2, 3, 1]</span>
<span class="go"> - F[3, 1, 2] - F[3, 2, 1]</span>

<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">to_fqsym</span><span class="p">()</span>
<span class="go">F[1, 2]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">to_fqsym</span><span class="p">()</span>
<span class="go">F[1, 2, 3] + F[2, 1, 3] + F[2, 3, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_fqsym</span><span class="p">()</span>
<span class="go">F[1, 2, 3] + F[1, 3, 2] + F[3, 1, 2]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_fqsym</span><span class="p">()</span>
<span class="go">F[1, 2, 3, 4] + F[1, 2, 4, 3] + F[1, 4, 2, 3]</span>
<span class="go"> + F[2, 1, 3, 4] + F[2, 1, 4, 3] + F[2, 3, 1, 4]</span>
<span class="go"> + F[2, 3, 4, 1] + F[2, 4, 1, 3] + F[2, 4, 3, 1]</span>
<span class="go"> + F[4, 1, 2, 3] + F[4, 2, 1, 3] + F[4, 2, 3, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_fsym">
<span class="sig-name descname"><span class="pre">to_fsym</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_fsym" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the natural map to
<span class="math notranslate nohighlight">\(FSym\)</span>.</p>
<p>There is an injective Hopf algebra morphism from <span class="math notranslate nohighlight">\(NSym\)</span> to
<span class="math notranslate nohighlight">\(FSym\)</span> (see
<a class="reference internal" href="../chas/fsym.html#sage.combinat.chas.fsym.FreeSymmetricFunctions" title="sage.combinat.chas.fsym.FreeSymmetricFunctions"><code class="xref py py-class docutils literal notranslate"><span class="pre">FreeSymmetricFunctions</span></code></a>),
which maps the ribbon <span class="math notranslate nohighlight">\(R_\alpha\)</span> indexed by a composition
<span class="math notranslate nohighlight">\(\alpha\)</span> to the sum of all tableaux whose descent
composition is <span class="math notranslate nohighlight">\(\alpha\)</span>.
If we regard <span class="math notranslate nohighlight">\(NSym\)</span> as a Hopf subalgebra of <span class="math notranslate nohighlight">\(FQSym\)</span> via
the morphism <span class="math notranslate nohighlight">\(\iota : NSym \to FQSym\)</span> (implemented as
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_fqsym" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_fqsym"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_fqsym()</span></code></a>), then this injective morphism is just
the inclusion map.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[[]]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">to_fsym</span><span class="p">()</span>
<span class="go">2*G[] + 2*G[1] + 3*G[12]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_fsym</span><span class="p">()</span>
<span class="go">G[12|3]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">to_fsym</span><span class="p">()</span>
<span class="go">G[13|2]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">to_fsym</span><span class="p">()</span>
<span class="go">G[12|35|4] + G[125|3|4]</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*R[] + 2*R[1] + 3*R[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">to_fsym</span><span class="p">()</span>
<span class="go">2*G[] + 2*G[1] + 3*G[1|2]</span>

<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">to_fsym</span><span class="p">()</span>
<span class="go">-G[1|2|3] - G[12|3] + G[123] + G[13|2]</span>

<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">to_fsym</span><span class="p">()</span>
<span class="go">G[12]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_fsym</span><span class="p">()</span>
<span class="go">G[12|3] + G[123]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_ncsym">
<span class="sig-name descname"><span class="pre">to_ncsym</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_ncsym" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the injective
algebra homomorphism <span class="math notranslate nohighlight">\(\kappa : NSym \to NCSym\)</span>
that fixes the symmetric functions.</p>
<p>As usual, <span class="math notranslate nohighlight">\(NCSym\)</span> denotes the ring of symmetric
functions in non-commuting variables.
Let <span class="math notranslate nohighlight">\(S_n\)</span> denote a generator of the complete basis.
The algebra homomorphism <span class="math notranslate nohighlight">\(\kappa : NSym \to NCSym\)</span>
is defined by</p>
<div class="math notranslate nohighlight">
\[S_n \mapsto \sum_{A \vdash [n]}
\frac{\lambda(A)! \lambda(A)^!}{n!} \mathbf{m}_A .\]</div>
<p>It has the property that the canonical maps
<span class="math notranslate nohighlight">\(\chi : NCSym \to Sym\)</span> and <span class="math notranslate nohighlight">\(\rho : NSym \to Sym\)</span>
satisfy <span class="math notranslate nohighlight">\(\chi \circ \kappa = \rho\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A remark in <a class="reference internal" href="../ncsym/ncsym.html#brrz08" id="id16"><span>[BRRZ08]</span></a>  makes it clear that the embedding
of <span class="math notranslate nohighlight">\(NSym\)</span> into <span class="math notranslate nohighlight">\(NCSym\)</span> that preserves the projection into
the symmetric functions is not unique.  While this seems
to be a natural embedding, any free set of algebraic
generators of <span class="math notranslate nohighlight">\(NSym\)</span> can be sent to a set of free elements
in <span class="math notranslate nohighlight">\(NCSym\)</span> to form another embedding.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonCommutativeSymmetricFunctions</span></code></a> for a definition
of <span class="math notranslate nohighlight">\(NCSym\)</span>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">to_ncsym</span><span class="p">()</span>
<span class="go">1/2*m{{1}, {2}} + m{{1, 2}}</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_ncsym</span><span class="p">()</span>
<span class="go">1/2*m{{1}, {2}, {3}, {4}} + 1/2*m{{1}, {2}, {3, 4}} + m{{1}, {2, 3}, {4}}</span>
<span class="go"> + m{{1}, {2, 3, 4}} + 1/2*m{{1}, {2, 4}, {3}} + 1/2*m{{1, 2}, {3}, {4}}</span>
<span class="go"> + 1/2*m{{1, 2}, {3, 4}} + m{{1, 2, 3}, {4}} + m{{1, 2, 3, 4}}</span>
<span class="go"> + 1/2*m{{1, 2, 4}, {3}} + 1/2*m{{1, 3}, {2}, {4}} + 1/2*m{{1, 3}, {2, 4}}</span>
<span class="go"> + 1/2*m{{1, 3, 4}, {2}} + 1/2*m{{1, 4}, {2}, {3}} + m{{1, 4}, {2, 3}}</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">to_ncsym</span><span class="p">()</span>
<span class="go">1/2*m{{1}, {2}, {3}} + m{{1}, {2, 3}} + 1/2*m{{1, 2}, {3}}</span>
<span class="go"> + m{{1, 2, 3}} + 1/2*m{{1, 3}, {2}}</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[[]]</span><span class="o">.</span><span class="n">to_ncsym</span><span class="p">()</span>
<span class="go">m{}</span>

<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*R[] + 2*R[1] + 3*R[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">to_ncsym</span><span class="p">()</span>
<span class="go">2*m{} + 2*m{{1}} + 3/2*m{{1}, {2}}</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_ncsym</span><span class="p">()</span>
<span class="go">1/3*m{{1}, {2}, {3}} + 1/6*m{{1}, {2, 3}}</span>
<span class="go"> + 2/3*m{{1, 2}, {3}} + 1/6*m{{1, 3}, {2}}</span>

<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">to_ncsym</span><span class="p">()</span>
<span class="go">m{{1}, {2, 3}} + m{{1, 2, 3}}</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">to_ncsym</span><span class="p">()</span>
<span class="go">-1/4*m{{1}, {2}, {3, 4}} - 1/4*m{{1}, {2, 3}, {4}} + m{{1}, {2, 3, 4}}</span>
<span class="go"> + 1/2*m{{1}, {2, 4}, {3}} - 1/4*m{{1, 2}, {3, 4}} - 1/4*m{{1, 2, 3}, {4}}</span>
<span class="go"> + m{{1, 2, 3, 4}} + 1/2*m{{1, 2, 4}, {3}} + 1/2*m{{1, 3}, {2, 4}}</span>
<span class="go"> - 1/4*m{{1, 3, 4}, {2}} - 1/4*m{{1, 4}, {2, 3}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function">
<span class="sig-name descname"><span class="pre">to_symmetric_function</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the commutative image of a non-commutative symmetric function.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The commutative image of <code class="docutils literal notranslate"><span class="pre">self</span></code>. This will be a symmetric function.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*R[] + 2*R[1] + 3*R[1, 1]</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="go">2*s[] + 2*s[1] + 3*s[1, 1]</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="go">h[1, 1, 1, 1] - 3*h[2, 1, 1] + 3*h[3, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_group_algebra">
<span class="sig-name descname"><span class="pre">to_symmetric_group_algebra</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_group_algebra" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of a non-commutative symmetric function into the
symmetric group algebra where the ribbon basis element indexed by a
composition is associated with the sum of all permutations which have
descent set equal to said composition. In compliance with the anti-
isomorphism between the descent algebra and the non-commutative
symmetric functions, we index descent positions by the reversed composition.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the embedding of the <span class="math notranslate nohighlight">\(n\)</span>-th
degree homogeneous component of the non-commutative
symmetric functions in the symmetric group algebra of
<span class="math notranslate nohighlight">\(S_n\)</span>. This can behave unexpectedly when <code class="docutils literal notranslate"><span class="pre">self</span></code> is
not homogeneous.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to_symmetric_group_algebra</span><span class="p">()</span>
<span class="go">[1, 3, 2] + [2, 3, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([])</span><span class="o">.</span><span class="n">to_symmetric_group_algebra</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung">
<span class="sig-name descname"><span class="pre">verschiebung</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<code class="docutils literal notranslate"><span class="pre">self</span></code> under the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator.</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator <span class="math notranslate nohighlight">\(\mathbf{V}_n\)</span> is defined
to be the map from the <span class="math notranslate nohighlight">\(\mathbf{k}\)</span>-algebra of noncommutative
symmetric functions to itself that sends the complete function
<span class="math notranslate nohighlight">\(S^I\)</span> indexed by a composition <span class="math notranslate nohighlight">\(I = (i_1, i_2, \ldots , i_k)\)</span>
to <span class="math notranslate nohighlight">\(S^{(i_1/n, i_2/n, \ldots , i_k/n)}\)</span> if all of the numbers
<span class="math notranslate nohighlight">\(i_1, i_2, \ldots, i_k\)</span> are divisible by <span class="math notranslate nohighlight">\(n\)</span>, and to <span class="math notranslate nohighlight">\(0\)</span>
otherwise. This operator <span class="math notranslate nohighlight">\(\mathbf{V}_n\)</span> is a Hopf algebra
endomorphism. For every positive integer <span class="math notranslate nohighlight">\(r\)</span> with <span class="math notranslate nohighlight">\(n \mid r\)</span>,
it satisfies</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n(S_r) = S_{r/n},
\quad \mathbf{V}_n(\Lambda_r) = (-1)^{r - r/n} \Lambda_{r/n},
\quad \mathbf{V}_n(\Psi_r) = n \Psi_{r/n},
\quad \mathbf{V}_n(\Phi_r) = n \Phi_{r/n}\]</div>
<p>(where <span class="math notranslate nohighlight">\(S_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th complete non-commutative
symmetric function, <span class="math notranslate nohighlight">\(\Lambda_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th elementary
non-commutative symmetric function, <span class="math notranslate nohighlight">\(\Psi_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th
power-sum non-commutative symmetric function of the first kind,
and <span class="math notranslate nohighlight">\(\Phi_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th power-sum non-commutative
symmetric function of the second kind). For every positive
integer <span class="math notranslate nohighlight">\(r\)</span> with <span class="math notranslate nohighlight">\(n \nmid r\)</span>, it satisfes</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n(S_r) = \mathbf{V}_n(\Lambda_r)
= \mathbf{V}_n(\Psi_r) = \mathbf{V}_n(\Phi_r) = 0.\]</div>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator is also called the <span class="math notranslate nohighlight">\(n\)</span>-th
Verschiebung endomorphism.</p>
<p>It is a lift of the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator on the ring
of symmetric functions
(<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verschiebung()</span></code></a>)
to the ring of noncommutative symmetric functions.</p>
<p>The action of the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator can also be
described on the ribbon Schur functions. Namely, every
composition <span class="math notranslate nohighlight">\(I\)</span> of size <span class="math notranslate nohighlight">\(n \ell\)</span> satisfies</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n ( R_I )
= (-1)^{\ell(I) - \ell(J)} \cdot R_{J / n},\]</div>
<p>where <span class="math notranslate nohighlight">\(J\)</span> denotes the meet of the compositions <span class="math notranslate nohighlight">\(I\)</span> and
<span class="math notranslate nohighlight">\((\underbrace{n, n, \ldots, n}_{|I|/n \mbox{ times}})\)</span>,
where <span class="math notranslate nohighlight">\(\ell(I)\)</span> is the length of <span class="math notranslate nohighlight">\(I\)</span>, and
where <span class="math notranslate nohighlight">\(J / n\)</span> denotes the composition obtained by dividing
every entry of <span class="math notranslate nohighlight">\(J\)</span> by <span class="math notranslate nohighlight">\(n\)</span>.
For a composition <span class="math notranslate nohighlight">\(I\)</span> of size not divisible by <span class="math notranslate nohighlight">\(n\)</span>, we have
<span class="math notranslate nohighlight">\(\mathbf{V}_n( R_I ) = 0\)</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius"><code class="xref py py-meth docutils literal notranslate"><span class="pre">frobenius</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">QSym</span></code></a>,
<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">Sym</span></code></a></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a positive integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator (on the
ring of noncommutative symmetric functions) to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">S[3, 2]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">S</span><span class="p">[[]])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*S[] + 2*S[3, 2] - S[4, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">S[1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">S[4, 2]</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">R[2, 1]</span>
</pre></div>
</div>
<p>Being Hopf algebra endomorphisms, the Verschiebung operators
commute with the antipode:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>They lift the Verschiebung operators of the ring of symmetric
functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">S</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="o">==</span> <span class="n">S</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">()</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The Frobenius operators on <span class="math notranslate nohighlight">\(QSym\)</span> are adjoint to the
Verschiebung operators on <span class="math notranslate nohighlight">\(NSym\)</span> with respect to the duality
pairing:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">QSym</span> <span class="o">=</span> <span class="n">QuasiSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">QSym</span><span class="o">.</span><span class="n">M</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="nb">all</span><span class="p">(</span> <span class="n">M</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">frobenius</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>
<span class="gp">....: </span>          <span class="o">==</span> <span class="n">M</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">duality_pairing</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">....: </span>          <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">J</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ParentMethods</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.immaculate_function">
<span class="sig-name descname"><span class="pre">immaculate_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.immaculate_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the immaculate function corresponding to the
integer vector <code class="docutils literal notranslate"><span class="pre">xs</span></code>, written in the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>If <span class="math notranslate nohighlight">\(\alpha\)</span> is any integer vector – i.e., an element of
<span class="math notranslate nohighlight">\(\ZZ^m\)</span> for some <span class="math notranslate nohighlight">\(m \in \NN\)</span> –, the <em>immaculate function
corresponding to</em> <span class="math notranslate nohighlight">\(\alpha\)</span> is a non-commutative symmetric
function denoted by <span class="math notranslate nohighlight">\(\mathfrak{S}_{\alpha}\)</span>. One way to
define this function is by setting</p>
<div class="math notranslate nohighlight">
\[\mathfrak{S}_{\alpha}
= \sum_{\sigma \in S_m} (-1)^{\sigma}
S_{\alpha_1 + \sigma(1) - 1}
S_{\alpha_2 + \sigma(2) - 2}
\cdots
S_{\alpha_m + \sigma(m) - m},\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is written in the form
<span class="math notranslate nohighlight">\((\alpha_1, \alpha_2, \ldots, \alpha_m)\)</span>, and where <span class="math notranslate nohighlight">\(S\)</span>
stands for the complete basis
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete"><code class="xref py py-class docutils literal notranslate"><span class="pre">Complete</span></code></a>).</p>
<p>The immaculate function <span class="math notranslate nohighlight">\(\mathfrak{S}_{\alpha}\)</span> first
appeared in <a class="reference internal" href="qsym.html#bbssz2012" id="id17"><span>[BBSSZ2012]</span></a> (where it was defined
differently, but the definition we gave above appeared as
Theorem 3.27).</p>
<p>The immaculate functions <span class="math notranslate nohighlight">\(\mathfrak{S}_{\alpha}\)</span> for
<span class="math notranslate nohighlight">\(\alpha\)</span> running over all compositions (i.e., finite
sequences of positive integers) form a basis of <span class="math notranslate nohighlight">\(NCSF\)</span>.
This is the <em>immaculate basis</em>
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Immaculate</span></code></a>).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xs</span></code> – list (or tuple or any iterable – possibly a
composition) of integers</p></li>
</ul>
<p>OUTPUT:</p>
<p>The immaculate function <span class="math notranslate nohighlight">\(\mathfrak{S}_{xs}\)</span>
written in the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<p>Let us first check that, for <code class="docutils literal notranslate"><span class="pre">xs</span></code> a composition, we get
the same as the result of
<code class="docutils literal notranslate"><span class="pre">self.realization_of().I()[xs]</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_comp</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="n">I</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">I</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">I</span><span class="p">[</span><span class="n">xs</span><span class="p">]</span> <span class="o">==</span> <span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_allcomp</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span> <span class="n">test_comp</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">)</span>
<span class="gp">sage: </span><span class="n">test_allcomp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_allcomp</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_allcomp</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Now some examples of non-composition immaculate
functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">I</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">-I[1, 1]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">-I[]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">I[2]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">-I[1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">-I[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">I[1, 1, 1, 1] + I[1, 2, 1]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">immaculate_function</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">I[2, 1, 1, 1, 1] + I[2, 1, 2, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.to_symmetric_function">
<span class="sig-name descname"><span class="pre">to_symmetric_function</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.to_symmetric_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Morphism to the algebra of symmetric functions.</p>
<p>This is constructed by extending the computation on the basis
or by coercion to the complete basis.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The module morphism from the basis <code class="docutils literal notranslate"><span class="pre">self</span></code> to the symmetric
functions which corresponds to taking a commutative image.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">an_element</span><span class="p">();</span> <span class="n">x</span>
<span class="go">2*R[] + 2*R[1] + 3*R[1, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">2*s[] + 2*s[1] + 3*s[1, 1]</span>
<span class="gp">sage: </span><span class="n">nM</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Monomial</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">nM</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">nM</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">h[1, 1, 1, 1] - 7/2*h[2, 1, 1] + h[2, 2] + 7/2*h[3, 1] - 2*h[4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.to_symmetric_function_on_basis">
<span class="sig-name descname"><span class="pre">to_symmetric_function_on_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">I</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.to_symmetric_function_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>The image of the basis element indexed by <code class="docutils literal notranslate"><span class="pre">I</span></code> under the map
to the symmetric functions.</p>
<p>This default implementation does a change of basis and
computes the image in the complete basis.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">I</span></code> – a composition</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The image of the non-commutative basis element of
<code class="docutils literal notranslate"><span class="pre">self</span></code> indexed by the composition <code class="docutils literal notranslate"><span class="pre">I</span></code> under the map from
non-commutative symmetric functions to the symmetric
functions. This will be a symmetric function.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Immaculate</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">-h[2, 2] + h[3, 1]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">==</span><span class="n">Phi</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">([])</span>
<span class="go">h[]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.super_categories">
<span class="sig-name descname"><span class="pre">super_categories</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the super categories of the category of bases of the
non-commutative symmetric functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>list</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Complete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">NCSF</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></code></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Utilities v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.misc.bindable_class.BindableClass</span></code></a></p>
<p>The Hopf algebra of non-commutative symmetric functions in the
Complete basis.</p>
<p>The Complete basis is defined in Definition 3.4 of <a class="reference internal" href="qsym.html#ncsf1" id="id18"><span>[NCSF1]</span></a>, where
it is denoted by <span class="math notranslate nohighlight">\((S^I)_I\)</span>. It is a multiplicative basis, and is
connected to the elementary generators <span class="math notranslate nohighlight">\(\Lambda_i\)</span> of the ring of
non-commutative symmetric functions by the following relation:
Define a non-commutative symmetric function <span class="math notranslate nohighlight">\(S_n\)</span> for every
nonnegative integer <span class="math notranslate nohighlight">\(n\)</span> by the power series identity</p>
<div class="math notranslate nohighlight">
\[\sum_{k \geq 0} t^k S_k
= \left( \sum_{k \geq 0} (-t)^k \Lambda_k \right)^{-1},\]</div>
<p>with <span class="math notranslate nohighlight">\(\Lambda_0\)</span> denoting <span class="math notranslate nohighlight">\(1\)</span>. For every composition
<span class="math notranslate nohighlight">\((i_1, i_2, \ldots, i_k)\)</span>, we have
<span class="math notranslate nohighlight">\(S^{(i_1, i_2, \ldots, i_k)} = S_{i_1} S_{i_2} \cdots S_{i_k}\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Complete</span><span class="p">();</span> <span class="n">S</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*S[] + 2*S[1] + 3*S[1, 1]</span>
</pre></div>
</div>
<p>The following are aliases for this basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
<span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.Element">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Element</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../modules/sage/modules/with_basis/indexed_element.html#sage.modules.with_basis.indexed_element.IndexedFreeModuleElement" title="(in Modules v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.indexed_element.IndexedFreeModuleElement</span></code></a></p>
<p>An element in the Complete basis.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.Element.psi_involution">
<span class="sig-name descname"><span class="pre">psi_involution</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.Element.psi_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<code class="docutils literal notranslate"><span class="pre">self</span></code> under the involution <span class="math notranslate nohighlight">\(\psi\)</span>.</p>
<p>The involution <span class="math notranslate nohighlight">\(\psi\)</span> is defined as the linear map
<span class="math notranslate nohighlight">\(NCSF \to NCSF\)</span> which, for every composition <span class="math notranslate nohighlight">\(I\)</span>, sends the
complete noncommutative symmetric function <span class="math notranslate nohighlight">\(S^I\)</span> to the
elementary noncommutative symmetric function <span class="math notranslate nohighlight">\(\Lambda^I\)</span>.
It can be shown that every composition <span class="math notranslate nohighlight">\(I\)</span> satisfies</p>
<div class="math notranslate nohighlight">
\[\psi(R_I) = R_{I^c}, \quad \psi(S^I) = \Lambda^I, \quad
\psi(\Lambda^I) = S^I, \quad
\psi(\Phi^I) = (-1)^{|I| - \ell(I)} \Phi^I\]</div>
<p>where <span class="math notranslate nohighlight">\(I^c\)</span> denotes the complement of the composition <span class="math notranslate nohighlight">\(I\)</span>, and
<span class="math notranslate nohighlight">\(\ell(I)\)</span> denotes the length of <span class="math notranslate nohighlight">\(I\)</span>, and where standard
notations for classical bases of <span class="math notranslate nohighlight">\(NCSF\)</span> are being used
(<span class="math notranslate nohighlight">\(S\)</span> for the complete basis, <span class="math notranslate nohighlight">\(\Lambda\)</span> for the elementary
basis, <span class="math notranslate nohighlight">\(\Phi\)</span> for the basis of the power sums of the second
kind, and <span class="math notranslate nohighlight">\(R\)</span> for the ribbon basis). The map <span class="math notranslate nohighlight">\(\psi\)</span> is an
involution and a graded Hopf algebra automorphism of <span class="math notranslate nohighlight">\(NCSF\)</span>.
If <span class="math notranslate nohighlight">\(\pi\)</span> denotes the projection from <span class="math notranslate nohighlight">\(NCSF\)</span> to the ring of
symmetric functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_symmetric_function()</span></code></a>),
then <span class="math notranslate nohighlight">\(\pi(\psi(f)) = \omega(\pi(f))\)</span> for every <span class="math notranslate nohighlight">\(f \in NCSF\)</span>, where
the <span class="math notranslate nohighlight">\(\omega\)</span> on the right hand side denotes the omega
automorphism of <span class="math notranslate nohighlight">\(Sym\)</span>.</p>
<p>The involution <span class="math notranslate nohighlight">\(\psi\)</span> of <span class="math notranslate nohighlight">\(NCSF\)</span> is adjoint to the involution
<span class="math notranslate nohighlight">\(\psi\)</span> of <span class="math notranslate nohighlight">\(QSym\)</span> by the standard adjunction between <span class="math notranslate nohighlight">\(NCSF\)</span> and
<span class="math notranslate nohighlight">\(QSym\)</span>.</p>
<p>The involution <span class="math notranslate nohighlight">\(\psi\)</span> has been denoted by <span class="math notranslate nohighlight">\(\psi\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id19"><span>[LMvW13]</span></a>,
section 3.6.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.psi_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></code></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">S[1, 1, 1, 1] - S[1, 2, 1] - S[2, 1, 1] + S[3, 1]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">())</span>
<span class="go">L[3, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[[]]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">S[]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">S[1, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">-2*S[1, 1] + S[1, 1, 1] + 2*S[2] - S[2, 1]</span>
</pre></div>
</div>
<p>The implementation at hand is tailored to the complete basis.
It is equivalent to the generic implementation via the
ribbon basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">())</span> <span class="o">==</span> <span class="n">R</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">I</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.dual">
<span class="sig-name descname"><span class="pre">dual</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual basis to the complete basis of non-commutative symmetric
functions. This is the Monomial basis of quasi-symmetric functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The Monomial basis of quasi-symmetric functions.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="go">Quasisymmetric functions over the Rational Field in the Monomial basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.internal_product_on_basis">
<span class="sig-name descname"><span class="pre">internal_product_on_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.internal_product_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>The internal product of two non-commutative symmetric
complete functions.</p>
<p>See <a class="reference internal" href="generic_basis_code.html#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product()</span></code></a>
for a thorough documentation of this operation.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">I</span></code>, <code class="docutils literal notranslate"><span class="pre">J</span></code> – compositions</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The internal product of the complete non-commutative symmetric
function basis elements indexed by <code class="docutils literal notranslate"><span class="pre">I</span></code> and <code class="docutils literal notranslate"><span class="pre">J</span></code>, expressed in
the complete basis.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product_on_basis</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">2*S[1, 1, 1, 1] + S[1, 1, 2] + S[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">internal_product_on_basis</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.to_symmetric_function">
<span class="sig-name descname"><span class="pre">to_symmetric_function</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.to_symmetric_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Morphism to the algebra of symmetric functions.</p>
<p>This is constructed by extending the computation on the
complete basis.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The module morphism from the basis <code class="docutils literal notranslate"><span class="pre">self</span></code> to the symmetric
functions which corresponds to taking a commutative image.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">h[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">S</span><span class="p">[[]])</span>
<span class="go">h[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.to_symmetric_function_on_basis">
<span class="sig-name descname"><span class="pre">to_symmetric_function_on_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">I</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete.to_symmetric_function_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>The commutative image of a complete element</p>
<p>The commutative image of a basis element is obtained by sorting
the indexing composition of the basis element and the output
is in the complete basis of the symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">I</span></code> – a composition</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The commutative image of the complete basis element
indexed by <code class="docutils literal notranslate"><span class="pre">I</span></code>. The result is the complete symmetric function
indexed by the partition obtained by sorting <code class="docutils literal notranslate"><span class="pre">I</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">h[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">([])</span>
<span class="go">h[]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Elementary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">NCSF</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></code></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Utilities v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.misc.bindable_class.BindableClass</span></code></a></p>
<p>The Hopf algebra of non-commutative symmetric functions in the
Elementary basis.</p>
<p>The Elementary basis is defined in Definition 3.4 of <a class="reference internal" href="qsym.html#ncsf1" id="id20"><span>[NCSF1]</span></a>,
where it is denoted by <span class="math notranslate nohighlight">\((\Lambda^I)_I\)</span>. It is a multiplicative
basis, and is obtained from the elementary generators
<span class="math notranslate nohighlight">\(\Lambda_i\)</span> of the ring of non-commutative symmetric functions
through the formula
<span class="math notranslate nohighlight">\(\Lambda^{(i_1, i_2, \ldots, i_k)}
= \Lambda_{i_1} \Lambda_{i_2} \cdots \Lambda_{i_k}\)</span>
for every composition <span class="math notranslate nohighlight">\((i_1, i_2, \ldots, i_k)\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Elementary</span><span class="p">();</span> <span class="n">L</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Elementary basis</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*L[] + 2*L[1] + 3*L[1, 1]</span>
</pre></div>
</div>
<p>The following are aliases for this basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Elementary basis</span>
<span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Elementary basis</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary.Element">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Element</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../modules/sage/modules/with_basis/indexed_element.html#sage.modules.with_basis.indexed_element.IndexedFreeModuleElement" title="(in Modules v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.indexed_element.IndexedFreeModuleElement</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary.Element.psi_involution">
<span class="sig-name descname"><span class="pre">psi_involution</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary.Element.psi_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<code class="docutils literal notranslate"><span class="pre">self</span></code> under the involution <span class="math notranslate nohighlight">\(\psi\)</span>.</p>
<p>The involution <span class="math notranslate nohighlight">\(\psi\)</span> is defined as the linear map
<span class="math notranslate nohighlight">\(NCSF \to NCSF\)</span> which, for every composition <span class="math notranslate nohighlight">\(I\)</span>, sends the
complete noncommutative symmetric function <span class="math notranslate nohighlight">\(S^I\)</span> to the
elementary noncommutative symmetric function <span class="math notranslate nohighlight">\(\Lambda^I\)</span>.
It can be shown that every composition <span class="math notranslate nohighlight">\(I\)</span> satisfies</p>
<div class="math notranslate nohighlight">
\[\psi(R_I) = R_{I^c}, \quad \psi(S^I) = \Lambda^I, \quad
\psi(\Lambda^I) = S^I, \quad
\psi(\Phi^I) = (-1)^{|I| - \ell(I)} \Phi^I\]</div>
<p>where <span class="math notranslate nohighlight">\(I^c\)</span> denotes the complement of the composition <span class="math notranslate nohighlight">\(I\)</span>, and
<span class="math notranslate nohighlight">\(\ell(I)\)</span> denotes the length of <span class="math notranslate nohighlight">\(I\)</span>, and where standard
notations for classical bases of <span class="math notranslate nohighlight">\(NCSF\)</span> are being used
(<span class="math notranslate nohighlight">\(S\)</span> for the complete basis, <span class="math notranslate nohighlight">\(\Lambda\)</span> for the elementary basis,
<span class="math notranslate nohighlight">\(\Phi\)</span> for the basis of the power sums of the second kind,
and <span class="math notranslate nohighlight">\(R\)</span> for the ribbon basis). The map <span class="math notranslate nohighlight">\(\psi\)</span> is an involution
and a graded Hopf algebra automorphism of <span class="math notranslate nohighlight">\(NCSF\)</span>. If <span class="math notranslate nohighlight">\(\pi\)</span>
denotes the projection from <span class="math notranslate nohighlight">\(NCSF\)</span> to the ring of symmetric functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_symmetric_function()</span></code></a>),
then <span class="math notranslate nohighlight">\(\pi(\psi(f)) = \omega(\pi(f))\)</span> for every <span class="math notranslate nohighlight">\(f \in NCSF\)</span>, where
the <span class="math notranslate nohighlight">\(\omega\)</span> on the right hand side denotes the omega
automorphism of <span class="math notranslate nohighlight">\(Sym\)</span>.</p>
<p>The involution <span class="math notranslate nohighlight">\(\psi\)</span> of <span class="math notranslate nohighlight">\(NCSF\)</span> is adjoint to the involution
<span class="math notranslate nohighlight">\(\psi\)</span> of <span class="math notranslate nohighlight">\(QSym\)</span> by the standard adjunction between <span class="math notranslate nohighlight">\(NCSF\)</span> and
<span class="math notranslate nohighlight">\(QSym\)</span>.</p>
<p>The involution <span class="math notranslate nohighlight">\(\psi\)</span> has been denoted by <span class="math notranslate nohighlight">\(\psi\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id21"><span>[LMvW13]</span></a>,
section 3.6.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.psi_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></code></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">L[1, 1, 1, 1] - L[1, 2, 1] - L[2, 1, 1] + L[3, 1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">())</span>
<span class="go">S[3, 1]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[[]]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">L[]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">L[1, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">-2*L[1, 1] + L[1, 1, 1] + 2*L[2] - L[2, 1]</span>
</pre></div>
</div>
<p>The implementation at hand is tailored to the elementary basis.
It is equivalent to the generic implementation via the
ribbon basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">())</span> <span class="o">==</span> <span class="n">R</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">I</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">())</span> <span class="o">==</span> <span class="n">R</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">I</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary.Element.star_involution">
<span class="sig-name descname"><span class="pre">star_involution</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary.Element.star_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<code class="docutils literal notranslate"><span class="pre">self</span></code> under the star involution.</p>
<p>The star involution is defined as the algebra antihomomorphism
<span class="math notranslate nohighlight">\(NCSF \to NCSF\)</span> which, for every positive integer <span class="math notranslate nohighlight">\(n\)</span>, sends
the <span class="math notranslate nohighlight">\(n\)</span>-th complete non-commutative symmetric function <span class="math notranslate nohighlight">\(S_n\)</span> to
<span class="math notranslate nohighlight">\(S_n\)</span>. Denoting by <span class="math notranslate nohighlight">\(f^{\ast}\)</span> the image of an element
<span class="math notranslate nohighlight">\(f \in NCSF\)</span> under this star involution, it can be shown that
every composition <span class="math notranslate nohighlight">\(I\)</span> satisfies</p>
<div class="math notranslate nohighlight">
\[(S^I)^{\ast} = S^{I^r}, \quad
(\Lambda^I)^{\ast} = \Lambda^{I^r}, \quad
R_I^{\ast} = R_{I^r}, \quad
(\Phi^I)^{\ast} = \Phi^{I^r},\]</div>
<p>where <span class="math notranslate nohighlight">\(I^r\)</span> denotes the reversed composition of <span class="math notranslate nohighlight">\(I\)</span>, and
standard notations for classical bases of <span class="math notranslate nohighlight">\(NCSF\)</span> are being used
(<span class="math notranslate nohighlight">\(S\)</span> for the complete basis, <span class="math notranslate nohighlight">\(\Lambda\)</span> for the elementary basis,
<span class="math notranslate nohighlight">\(R\)</span> for the ribbon basis, and <span class="math notranslate nohighlight">\(\Phi\)</span> for that of the power-sums
of the second kind). The star involution is an involution and a
coalgebra automorphism of <span class="math notranslate nohighlight">\(NCSF\)</span>. It is an automorphism of the
graded vector space <span class="math notranslate nohighlight">\(NCSF\)</span>. Under the canonical isomorphism
between the <span class="math notranslate nohighlight">\(n\)</span>-th graded component of <span class="math notranslate nohighlight">\(NCSF\)</span> and the descent
algebra of the symmetric group <span class="math notranslate nohighlight">\(S_n\)</span> (see
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_descent_algebra()</span></code></a>),
the star involution (restricted to
the <span class="math notranslate nohighlight">\(n\)</span>-th graded component) corresponds to the automorphism
of the descent algebra given by
<span class="math notranslate nohighlight">\(x \mapsto \omega_n x \omega_n\)</span>, where <span class="math notranslate nohighlight">\(\omega_n\)</span> is the
permutation <span class="math notranslate nohighlight">\((n, n-1, \ldots, 1) \in S_n\)</span> (written here in
one-line notation). If <span class="math notranslate nohighlight">\(\pi\)</span> denotes the projection from <span class="math notranslate nohighlight">\(NCSF\)</span>
to the ring of symmetric functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_symmetric_function()</span></code></a>),
then <span class="math notranslate nohighlight">\(\pi(f^{\ast}) = \pi(f)\)</span> for every <span class="math notranslate nohighlight">\(f \in NCSF\)</span>.</p>
<p>The star involution on <span class="math notranslate nohighlight">\(NCSF\)</span> is adjoint to the star involution
on <span class="math notranslate nohighlight">\(QSym\)</span> by the standard adjunction between <span class="math notranslate nohighlight">\(NCSF\)</span> and <span class="math notranslate nohighlight">\(QSym\)</span>.</p>
<p>The star involution has been denoted by <span class="math notranslate nohighlight">\(\rho\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id22"><span>[LMvW13]</span></a>,
section 3.6.
See <a class="reference internal" href="qsym.html#ncsf2" id="id23"><span>[NCSF2]</span></a>, section 2.3 for the properties of this map.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.star_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">L[3, 2, 3, 3]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">L[3, 3, 6]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">L</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">L</span><span class="p">[[]])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">4*L[] + L[1, 9, 1] - L[2, 8] - 3*L[3] + 2*L[4, 6]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">-2*L[2] + L[3, 3]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">L[1, 4]</span>
</pre></div>
</div>
<p>The implementation at hand is tailored to the elementary basis.
It is equivalent to the generic implementation via the
complete basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">S</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">())</span> <span class="o">==</span> <span class="n">S</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">I</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary.Element.verschiebung">
<span class="sig-name descname"><span class="pre">verschiebung</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary.Element.verschiebung" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<code class="docutils literal notranslate"><span class="pre">self</span></code> under the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator.</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator <span class="math notranslate nohighlight">\(\mathbf{V}_n\)</span> is defined
to be the map from the <span class="math notranslate nohighlight">\(\mathbf{k}\)</span>-algebra of noncommutative
symmetric functions to itself that sends the complete function
<span class="math notranslate nohighlight">\(S^I\)</span> indexed by a composition <span class="math notranslate nohighlight">\(I = (i_1, i_2, \ldots , i_k)\)</span>
to <span class="math notranslate nohighlight">\(S^{(i_1/n, i_2/n, \ldots , i_k/n)}\)</span> if all of the numbers
<span class="math notranslate nohighlight">\(i_1, i_2, \ldots, i_k\)</span> are divisible by <span class="math notranslate nohighlight">\(n\)</span>, and to <span class="math notranslate nohighlight">\(0\)</span>
otherwise. This operator <span class="math notranslate nohighlight">\(\mathbf{V}_n\)</span> is a Hopf algebra
endomorphism. For every positive integer <span class="math notranslate nohighlight">\(r\)</span> with <span class="math notranslate nohighlight">\(n \mid r\)</span>,
it satisfies</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n(S_r) = S_{r/n},
\quad \mathbf{V}_n(\Lambda_r) = (-1)^{r - r/n} \Lambda_{r/n},
\quad \mathbf{V}_n(\Psi_r) = n \Psi_{r/n},
\quad \mathbf{V}_n(\Phi_r) = n \Phi_{r/n}\]</div>
<p>(where <span class="math notranslate nohighlight">\(S_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th complete non-commutative
symmetric function, <span class="math notranslate nohighlight">\(\Lambda_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th elementary
non-commutative symmetric function, <span class="math notranslate nohighlight">\(\Psi_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th
power-sum non-commutative symmetric function of the first kind,
and <span class="math notranslate nohighlight">\(\Phi_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th power-sum non-commutative
symmetric function of the second kind). For every positive
integer <span class="math notranslate nohighlight">\(r\)</span> with <span class="math notranslate nohighlight">\(n \nmid r\)</span>, it satisfes</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n(S_r) = \mathbf{V}_n(\Lambda_r)
= \mathbf{V}_n(\Psi_r) = \mathbf{V}_n(\Phi_r) = 0.\]</div>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator is also called the <span class="math notranslate nohighlight">\(n\)</span>-th
Verschiebung endomorphism.</p>
<p>It is a lift of the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator on the ring
of symmetric functions
(<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verschiebung()</span></code></a>)
to the ring of noncommutative symmetric functions.</p>
<p>The action of the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator can also be
described on the ribbon Schur functions. Namely, every
composition <span class="math notranslate nohighlight">\(I\)</span> of size <span class="math notranslate nohighlight">\(n \ell\)</span> satisfies</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n ( R_I )
= (-1)^{\ell(I) - \ell(J)} \cdot R_{J / n},\]</div>
<p>where <span class="math notranslate nohighlight">\(J\)</span> denotes the meet of the compositions <span class="math notranslate nohighlight">\(I\)</span> and
<span class="math notranslate nohighlight">\((\underbrace{n, n, \ldots, n}_{|I|/n \mbox{ times}})\)</span>,
where <span class="math notranslate nohighlight">\(\ell(I)\)</span> is the length of <span class="math notranslate nohighlight">\(I\)</span>, and
where <span class="math notranslate nohighlight">\(J / n\)</span> denotes the composition obtained by
dividing every entry of <span class="math notranslate nohighlight">\(J\)</span> by <span class="math notranslate nohighlight">\(n\)</span>.
For a composition <span class="math notranslate nohighlight">\(I\)</span> of size not divisible by <span class="math notranslate nohighlight">\(n\)</span>, we
have <span class="math notranslate nohighlight">\(\mathbf{V}_n ( R_I ) = 0\)</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius"><code class="xref py py-meth docutils literal notranslate"><span class="pre">frobenius</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">QSym</span></code></a>,
<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">Sym</span></code></a></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a positive integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator (on the
ring of noncommutative symmetric functions) to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">L</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-L[2, 1]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-L[1, 2]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">6</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-L[3]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">L[]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">7</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">L[1]</span>
<span class="gp">sage: </span><span class="n">L</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">L[1] - L[2] + 2*L[3]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.I">
<span class="sig-name descname"><span class="pre">I</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.I" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonCommutativeSymmetricFunctions.Immaculate</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Immaculate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">NCSF</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></code></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Utilities v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.misc.bindable_class.BindableClass</span></code></a></p>
<p>The immaculate basis of the non-commutative symmetric
functions.</p>
<p>The immaculate basis first appears in Berg, Bergeron,
Saliola, Serrano and Zabrocki’s <a class="reference internal" href="qsym.html#bbssz2012" id="id24"><span>[BBSSZ2012]</span></a>. It can be
described as the family <span class="math notranslate nohighlight">\((\mathfrak{S}_{\alpha})\)</span>, where
<span class="math notranslate nohighlight">\(\alpha\)</span> runs over all compositions, and
<span class="math notranslate nohighlight">\(\mathfrak{S}_{\alpha}\)</span> denotes the immaculate function
corresponding to <span class="math notranslate nohighlight">\(\alpha\)</span> (see
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.immaculate_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.immaculate_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">immaculate_function()</span></code></a>).</p>
<p>If <span class="math notranslate nohighlight">\(\alpha\)</span> is a composition <span class="math notranslate nohighlight">\((\alpha_1, \alpha_2, \ldots,
\alpha_m)\)</span>, then</p>
<div class="math notranslate nohighlight">
\[\mathfrak{S}_{\alpha}
= \sum_{\sigma \in S_m} (-1)^{\sigma}
S_{\alpha_1 + \sigma(1) - 1} S_{\alpha_2 + \sigma(2) - 2}
\cdots S_{\alpha_m + \sigma(m) - m}.\]</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This <em>basis</em> contains only the immaculate functions
indexed by compositions (i.e., finite sequences of
positive integers). To obtain the remaining immaculate
functions (sensu lato), use the
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.immaculate_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ParentMethods.immaculate_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">immaculate_function()</span></code></a>
method. Calling the immaculate <em>basis</em> with a list
which is not a composition will currently return
garbage!</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">I</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">I</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">I</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">I[1, 3, 2, 1] + I[1, 3, 3] + I[1, 4, 2] + I[2, 3, 2]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">I</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">I[1, 1, 3, 2] - I[2, 2, 1, 2] - I[2, 2, 2, 1] - I[2, 2, 3] - I[3, 2, 2]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">I</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">I[1, 3, 1, 1] + I[1, 4, 1] + I[2, 3, 1] + I[2, 4]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">I</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">I[3, 1, 2, 1] + I[3, 2, 1, 1] + I[3, 2, 2] + I[3, 3, 1] + I[4, 1, 1, 1] + I[4, 1, 2] + 2*I[4, 2, 1] + I[4, 3] + I[5, 1, 1] + I[5, 2]</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">I</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">I[1, 3, 1] + I[2, 2, 1] + I[2, 3] + I[3, 1, 1] + I[3, 2]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">(</span><span class="n">I</span><span class="p">(</span><span class="n">R</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])))</span>
<span class="go">R[2, 1, 3]</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate.Element">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Element</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../modules/sage/modules/with_basis/indexed_element.html#sage.modules.with_basis.indexed_element.IndexedFreeModuleElement" title="(in Modules v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.indexed_element.IndexedFreeModuleElement</span></code></a></p>
<p>An element in the Immaculate basis.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate.Element.bernstein_creation_operator">
<span class="sig-name descname"><span class="pre">bernstein_creation_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate.Element.bernstein_creation_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of <code class="docutils literal notranslate"><span class="pre">self</span></code> under the <span class="math notranslate nohighlight">\(n\)</span>-th Bernstein
creation operator.</p>
<p>Let <span class="math notranslate nohighlight">\(n\)</span> be an integer. The <span class="math notranslate nohighlight">\(n\)</span>-th Bernstein creation
operator <span class="math notranslate nohighlight">\(\mathbb{B}_n\)</span> is defined as the endomorphism of
the space <span class="math notranslate nohighlight">\(NSym\)</span> of noncommutative symmetric functions
given by</p>
<div class="math notranslate nohighlight">
\[\mathbb{B}_n I_{(\alpha_1, \alpha_2, \ldots, \alpha_m)}
= I_{(n, \alpha_1, \alpha_2, \ldots, \alpha_m)},\]</div>
<p>where <span class="math notranslate nohighlight">\(I_{(\alpha_1, \alpha_2, \ldots, \alpha_m)}\)</span> is the
immaculate function associated to the <span class="math notranslate nohighlight">\(m\)</span>-tuple
<span class="math notranslate nohighlight">\((\alpha_1, \alpha_2, \ldots, \alpha_m) \in \ZZ^m\)</span>.</p>
<p>This has been introduced in <a class="reference internal" href="qsym.html#bbssz2012" id="id25"><span>[BBSSZ2012]</span></a>, section 3.1, in
analogy to the Bernstein creation operators on the
symmetric functions.</p>
<p>For more information on the <span class="math notranslate nohighlight">\(n\)</span>-th Bernstein creation
operator, see
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.bernstein_creation_operator" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.bernstein_creation_operator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bernstein_creation_operator()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">I</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">I[3, 1, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">b</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">I[5, 1, 3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">elt</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">I</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">elt</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">I[1, 1, 3, 2, 1] + 3*I[1, 4, 1, 2]</span>
</pre></div>
</div>
<p>We check that this agrees with the definition on the
Complete basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">S</span><span class="p">(</span><span class="n">elt</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Check on non-positive values of <span class="math notranslate nohighlight">\(n\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">I</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">I[1, 1, 1, 2] + I[1, 1, 2, 1] + I[1, 2, 1, 1] - I[1, 2, 2]</span>
<span class="gp">sage: </span><span class="n">I</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">bernstein_creation_operator</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">-I[1, 1, 3, 2] - I[1, 2, 2, 2] - I[1, 2, 3, 1] + I[2, 3, 2]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate.dual">
<span class="sig-name descname"><span class="pre">dual</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Immaculate.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual basis to the Immaculate basis of NCSF.</p>
<p>The basis returned is the dualImmaculate basis of QSym.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The dualImmaculate basis of the quasi-symmetric functions.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">I</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Immaculate</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">I</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="go">Quasisymmetric functions over the Rational Field in the dualImmaculate</span>
<span class="go">basis</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.L">
<span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.L" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonCommutativeSymmetricFunctions.Elementary</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Monomial">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Monomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">NCSF</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Monomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></code></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Utilities v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.misc.bindable_class.BindableClass</span></code></a></p>
<p>The monomial basis defined in Tevlin’s paper <a class="reference internal" href="combinatorics.html#tev2007" id="id26"><span>[Tev2007]</span></a>.</p>
<p>The monomial basis is well-defined only when the base ring is a
<span class="math notranslate nohighlight">\(\QQ\)</span>-algebra. It is the basis denoted by <span class="math notranslate nohighlight">\((M^I)_I\)</span> in <a class="reference internal" href="combinatorics.html#tev2007" id="id27"><span>[Tev2007]</span></a>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MultiplicativeBases</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parent_with_realization</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Category Framework v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.realizations.Category_realization_of_parent</span></code></a></p>
<p>Category of multiplicative bases of non-commutative symmetric functions.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBases</span><span class="p">()</span>
<span class="go">Category of multiplicative bases of Non-Commutative Symmetric Functions over the Rational Field</span>
</pre></div>
</div>
<p>The complete basis is a multiplicative basis, but the ribbon basis is not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Complete</span><span class="p">()</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBases</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Ribbon</span><span class="p">()</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBases</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ParentMethods</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.algebra_generators">
<span class="sig-name descname"><span class="pre">algebra_generators</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.algebra_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the algebra generators of a given multiplicative basis of
non-commutative symmetric functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The family of generators of the multiplicative basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Psi</span><span class="o">.</span><span class="n">algebra_generators</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">Lazy family (&lt;lambda&gt;(i))_{i in Positive integers}</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">(Psi[1], Psi[2], Psi[3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.algebra_morphism">
<span class="sig-name descname"><span class="pre">algebra_morphism</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">on_generators</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.algebra_morphism" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a map defined on the generators of the multiplicative
basis <code class="docutils literal notranslate"><span class="pre">self</span></code>, return the algebra morphism that extends
this map to the whole algebra of non-commutative symmetric
functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">on_generators</span></code> – a function defined on the index set of
the generators (that is, on the positive integers)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">anti</span></code> – a boolean; defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">category</span></code> – a category; defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code></p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The algebra morphism of <code class="docutils literal notranslate"><span class="pre">self</span></code> which is defined by
<code class="docutils literal notranslate"><span class="pre">on_generators</span></code> in the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>. When <code class="docutils literal notranslate"><span class="pre">anti</span></code>
is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, an algebra anti-morphism is
computed instead of an algebra morphism.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">double</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">Psi</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Psi</span><span class="o">.</span><span class="n">algebra_morphism</span><span class="p">(</span><span class="n">double</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Psi</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">Generic endomorphism of Non-Commutative Symmetric Functions over the Rational Field in the Psi basis</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Psi</span><span class="p">[[]]</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">)</span>
<span class="go">2*Psi[] + 3*Psi[1, 1, 3, 3, 2, 2] + Psi[2, 2, 4, 4]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of endsets of unital magmas and right modules over Rational Field and left modules over Rational Field</span>
</pre></div>
</div>
<p>When extra properties about the morphism are known, one
can specify the category of which it is a morphism:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">negate</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="o">-</span><span class="n">Psi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Psi</span><span class="o">.</span><span class="n">algebra_morphism</span><span class="p">(</span><span class="n">negate</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Psi</span><span class="p">,</span> <span class="n">category</span> <span class="o">=</span> <span class="n">GradedHopfAlgebrasWithBasis</span><span class="p">(</span><span class="n">QQ</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">Generic endomorphism of Non-Commutative Symmetric Functions over the Rational Field in the Psi basis</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Psi</span><span class="p">[[]]</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">)</span>
<span class="go">2*Psi[] - 3*Psi[1, 3, 2] + Psi[2, 4]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of endsets of hopf algebras over Rational Field and graded modules over Rational Field</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">anti</span></code> is true, this returns an anti-algebra morphism:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">Psi</span><span class="o">.</span><span class="n">algebra_morphism</span><span class="p">(</span><span class="n">double</span><span class="p">,</span> <span class="n">codomain</span> <span class="o">=</span> <span class="n">Psi</span><span class="p">,</span> <span class="n">anti</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">Generic endomorphism of Non-Commutative Symmetric Functions over the Rational Field in the Psi basis</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Psi</span><span class="p">[[]]</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">)</span>
<span class="go">2*Psi[] + 3*Psi[2, 2, 3, 3, 1, 1] + Psi[4, 4, 2, 2]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of endsets of modules with basis over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.antipode">
<span class="sig-name descname"><span class="pre">antipode</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.antipode" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the antipode morphism on the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The antipode of <span class="math notranslate nohighlight">\(NSym\)</span> is closely related to the omega
involution; see
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.omega_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.omega_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">omega_involution()</span></code></a>
for the latter.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The antipode module map from non-commutative symmetric
functions on basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">antipode</span>
<span class="go">Generic endomorphism of Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.coproduct">
<span class="sig-name descname"><span class="pre">coproduct</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.coproduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coproduct morphism in the basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The coproduct module map from non-commutative symmetric
functions on basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">coproduct</span>
<span class="go">Generic morphism:</span>
<span class="go">  From: Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
<span class="go">  To:   Non-Commutative Symmetric Functions over the Rational Field in the Complete basis # Non-Commutative Symmetric Functions over the Rational Field in the Complete basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.product_on_basis">
<span class="sig-name descname"><span class="pre">product_on_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">composition1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">composition2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.product_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of two basis elements from the multiplicative basis.
Multiplication is just concatenation on compositions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">composition1</span></code>, <code class="docutils literal notranslate"><span class="pre">composition2</span></code> – integer compositions</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The product of the two non-commutative symmetric functions
indexed by <code class="docutils literal notranslate"><span class="pre">composition1</span></code> and <code class="docutils literal notranslate"><span class="pre">composition2</span></code> in the
multiplicative basis <code class="docutils literal notranslate"><span class="pre">self</span></code>. This will be again
a non-commutative symmetric function.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">product_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
<span class="go">S[2, 1, 1, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.to_symmetric_function">
<span class="sig-name descname"><span class="pre">to_symmetric_function</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.to_symmetric_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Morphism to the algebra of symmetric functions.</p>
<p>This is constructed by extending the algebra morphism
by the image of the generators.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The module morphism from the basis <code class="docutils literal notranslate"><span class="pre">self</span></code> to the symmetric
functions which corresponds to taking a commutative image.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">h[3, 1]</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">h[1, 1, 1, 1] - 3*h[2, 1, 1] + 3*h[3, 1]</span>
<span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">(</span><span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">h[1, 1, 1, 1] - 3*h[2, 1, 1] + 3*h[3, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.to_symmetric_function_on_generators">
<span class="sig-name descname"><span class="pre">to_symmetric_function_on_generators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.ParentMethods.to_symmetric_function_on_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Morphism of the generators to symmetric functions.</p>
<p>This is constructed by coercion to the complete basis
and applying the morphism.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The module morphism from the basis <code class="docutils literal notranslate"><span class="pre">self</span></code> to the symmetric
functions which corresponds to taking a commutative image.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="o">.</span><span class="n">to_symmetric_function_on_generators</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">h[1, 1, 1] - 3*h[2, 1] + 3*h[3]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="o">.</span><span class="n">to_symmetric_function_on_generators</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">h[]</span>
<span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">to_symmetric_function_on_generators</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">h[1, 1, 1] - 3*h[2, 1] + 3*h[3]</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">elementary</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">to_symmetric_function_on_generators</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">h[1, 1, 1] - 2*h[2, 1] + h[3]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.super_categories">
<span class="sig-name descname"><span class="pre">super_categories</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBases.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the super categories of the category of multiplicative
bases of the non-commutative symmetric functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>list</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MultiplicativeBasesOnGroupLikeElements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parent_with_realization</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Category Framework v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.realizations.Category_realization_of_parent</span></code></a></p>
<p>Category of multiplicative bases on grouplike elements of
non-commutative symmetric functions.</p>
<p>Here, a “multiplicative basis on grouplike elements” means
a multiplicative basis whose generators <span class="math notranslate nohighlight">\((f_1, f_2, f_3, \ldots )\)</span>
satisfy</p>
<div class="math notranslate nohighlight">
\[\Delta(f_i) = \sum_{j=0}^{i} f_j \otimes f_{i-j}\]</div>
<p>with <span class="math notranslate nohighlight">\(f_0 = 1\)</span>. (In other words, the generators are to form a
divided power sequence in the sense of a coalgebra.) This
does not mean that the generators are grouplike, but means that
the element <span class="math notranslate nohighlight">\(1 + f_1 + f_2 + f_3 + \cdots\)</span> in the completion of
the ring of non-commutative symmetric functions with respect
to the grading is grouplike.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnGroupLikeElements</span><span class="p">()</span>
<span class="go">Category of multiplicative bases on group like elements of Non-Commutative Symmetric Functions over the Rational Field</span>
</pre></div>
</div>
<p>The complete basis is a multiplicative basis, but the ribbon basis is not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Complete</span><span class="p">()</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnGroupLikeElements</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Ribbon</span><span class="p">()</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnGroupLikeElements</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.ParentMethods">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ParentMethods</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.ParentMethods.antipode_on_basis">
<span class="sig-name descname"><span class="pre">antipode_on_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">composition</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.ParentMethods.antipode_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the application of the antipode to a basis element.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">composition</span></code> – a composition</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The image of the basis element indexed by <code class="docutils literal notranslate"><span class="pre">composition</span></code>
under the antipode map.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">antipode_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">-S[1, 1, 1] + S[1, 2]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="c1"># indirect doctest</span>
<span class="go">-S[1]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="c1"># indirect doctest</span>
<span class="go">S[1, 1] - S[2]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="c1"># indirect doctest</span>
<span class="go">-S[1, 1, 1] + S[1, 2] + S[2, 1] - S[3]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span><span class="o">.</span><span class="n">apply_multilinear_morphism</span><span class="p">(</span><span class="k">lambda</span> <span class="n">be</span><span class="p">,</span><span class="n">ga</span><span class="p">:</span> <span class="n">S</span><span class="p">(</span><span class="n">be</span><span class="p">)</span><span class="o">*</span><span class="n">S</span><span class="p">(</span><span class="n">ga</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">())</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span><span class="o">.</span><span class="n">apply_multilinear_morphism</span><span class="p">(</span><span class="k">lambda</span> <span class="n">be</span><span class="p">,</span><span class="n">ga</span><span class="p">:</span> <span class="n">S</span><span class="p">(</span><span class="n">be</span><span class="p">)</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span><span class="o">*</span><span class="n">S</span><span class="p">(</span><span class="n">ga</span><span class="p">))</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.ParentMethods.coproduct_on_generators">
<span class="sig-name descname"><span class="pre">coproduct_on_generators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.ParentMethods.coproduct_on_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the <span class="math notranslate nohighlight">\(i^{th}\)</span> generator of the algebra under
the coproduct.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code> – a positive integer</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The result of applying the coproduct to the <span class="math notranslate nohighlight">\(i^{th}\)</span>
generator of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">coproduct_on_generators</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">S[] # S[3] + S[1] # S[2] + S[2] # S[1] + S[3] # S[]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.super_categories">
<span class="sig-name descname"><span class="pre">super_categories</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnGroupLikeElements.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the super categories of the category of multiplicative
bases of group-like elements of the non-commutative symmetric
functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>list</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MultiplicativeBasesOnPrimitiveElements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parent_with_realization</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../categories/sage/categories/realizations.html#sage.categories.realizations.Category_realization_of_parent" title="(in Category Framework v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.categories.realizations.Category_realization_of_parent</span></code></a></p>
<p>Category of multiplicative bases of the non-commutative symmetric
functions whose generators are primitive elements.</p>
<p>An element <span class="math notranslate nohighlight">\(x\)</span> of a bialgebra is <em>primitive</em> if
<span class="math notranslate nohighlight">\(\Delta(x) = x \otimes 1 + 1 \otimes x\)</span>, where
<span class="math notranslate nohighlight">\(\Delta\)</span> is the coproduct of the bialgebra.</p>
<p>Given a multiplicative basis and knowing the coproducts and antipodes
of its generators, one can compute the coproduct and the antipode of
any element, since they are respectively algebra morphisms and
anti-morphisms. See <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods.antipode_on_generators" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods.antipode_on_generators"><code class="xref py py-meth docutils literal notranslate"><span class="pre">antipode_on_generators()</span></code></a> and
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods.coproduct_on_generators" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods.coproduct_on_generators"><code class="xref py py-meth docutils literal notranslate"><span class="pre">coproduct_on_generators()</span></code></a>.</p>
<div class="admonition-todo admonition" id="id28">
<p class="admonition-title">Todo</p>
<p>this could be generalized to any free algebra.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnPrimitiveElements</span><span class="p">()</span>
<span class="go">Category of multiplicative bases on primitive elements of Non-Commutative Symmetric Functions over the Rational Field</span>
</pre></div>
</div>
<p>The Phi and Psi bases are multiplicative bases whose generators
are primitive elements, but the complete and ribbon bases are not:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnPrimitiveElements</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnPrimitiveElements</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Complete</span><span class="p">()</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnPrimitiveElements</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">N</span><span class="o">.</span><span class="n">Ribbon</span><span class="p">()</span> <span class="ow">in</span> <span class="n">N</span><span class="o">.</span><span class="n">MultiplicativeBasesOnPrimitiveElements</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ParentMethods</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods.antipode_on_generators">
<span class="sig-name descname"><span class="pre">antipode_on_generators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods.antipode_on_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of a generator of a primitive basis of
the non-commutative symmetric functions under the antipode
map.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code> – a positive integer</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The image of the <span class="math notranslate nohighlight">\(i\)</span>-th generator of the multiplicative
basis <code class="docutils literal notranslate"><span class="pre">self</span></code> under the antipode of the algebra of
non-commutative symmetric functions.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">antipode_on_generators</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-Psi[2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods.coproduct_on_generators">
<span class="sig-name descname"><span class="pre">coproduct_on_generators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.ParentMethods.coproduct_on_generators" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the <span class="math notranslate nohighlight">\(i^{th}\)</span> generator of the
multiplicative basis <code class="docutils literal notranslate"><span class="pre">self</span></code> under the coproduct.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code> – a positive integer</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The result of applying the coproduct to the
<span class="math notranslate nohighlight">\(i^{th}\)</span> generator of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">coproduct_on_generators</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Psi[] # Psi[3] + Psi[3] # Psi[]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.super_categories">
<span class="sig-name descname"><span class="pre">super_categories</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.MultiplicativeBasesOnPrimitiveElements.super_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the super categories of the category of multiplicative
bases of primitive elements of the non-commutative symmetric
functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>list</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Phi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">NCSF</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></code></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Utilities v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.misc.bindable_class.BindableClass</span></code></a></p>
<p>The Hopf algebra of non-commutative symmetric functions in the
Phi basis.</p>
<p>The Phi basis is defined in Definition 3.4 of <a class="reference internal" href="qsym.html#ncsf1" id="id29"><span>[NCSF1]</span></a>, where
it is denoted by <span class="math notranslate nohighlight">\((\Phi^I)_I\)</span>. It is a multiplicative basis, and
is connected to the elementary generators <span class="math notranslate nohighlight">\(\Lambda_i\)</span> of the ring
of non-commutative symmetric functions by the following relation:
Define a non-commutative symmetric function <span class="math notranslate nohighlight">\(\Phi_n\)</span> for every
positive integer <span class="math notranslate nohighlight">\(n\)</span> by the power series identity</p>
<div class="math notranslate nohighlight">
\[\sum_{k\geq 1} t^k \frac{1}{k} \Phi_k
= -\log \left( \sum_{k \geq 0} (-t)^k \Lambda_k \right),\]</div>
<p>with <span class="math notranslate nohighlight">\(\Lambda_0\)</span> denoting <span class="math notranslate nohighlight">\(1\)</span>. For every composition
<span class="math notranslate nohighlight">\((i_1, i_2, \ldots, i_k)\)</span>, we have
<span class="math notranslate nohighlight">\(\Phi^{(i_1, i_2, \ldots, i_k)}
= \Phi_{i_1} \Phi_{i_2} \cdots \Phi_{i_k}\)</span>.</p>
<p>The <span class="math notranslate nohighlight">\(\Phi\)</span>-basis is well-defined only when the base ring is a
<span class="math notranslate nohighlight">\(\QQ\)</span>-algebra. The elements of the <span class="math notranslate nohighlight">\(\Phi\)</span>-basis are known as the
“power-sum non-commutative symmetric functions of the second
kind”.</p>
<p>The generators <span class="math notranslate nohighlight">\(\Phi_n\)</span> are related to the (first) Eulerian
idempotents in the descent algebras of the symmetric groups (see
<a class="reference internal" href="qsym.html#ncsf1" id="id30"><span>[NCSF1]</span></a>, 5.4 for details).</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Phi</span><span class="p">();</span> <span class="n">Phi</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Phi basis</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*Phi[] + 2*Phi[1] + 3*Phi[1, 1]</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi.Element">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Element</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../modules/sage/modules/with_basis/indexed_element.html#sage.modules.with_basis.indexed_element.IndexedFreeModuleElement" title="(in Modules v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.indexed_element.IndexedFreeModuleElement</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi.Element.psi_involution">
<span class="sig-name descname"><span class="pre">psi_involution</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi.Element.psi_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<code class="docutils literal notranslate"><span class="pre">self</span></code> under the involution <span class="math notranslate nohighlight">\(\psi\)</span>.</p>
<p>The involution <span class="math notranslate nohighlight">\(\psi\)</span> is defined as the linear map
<span class="math notranslate nohighlight">\(NCSF \to NCSF\)</span> which, for every composition <span class="math notranslate nohighlight">\(I\)</span>, sends the
complete noncommutative symmetric function <span class="math notranslate nohighlight">\(S^I\)</span> to the
elementary noncommutative symmetric function <span class="math notranslate nohighlight">\(\Lambda^I\)</span>.
It can be shown that every composition <span class="math notranslate nohighlight">\(I\)</span> satisfies</p>
<div class="math notranslate nohighlight">
\[\psi(R_I) = R_{I^c}, \quad \psi(S^I) = \Lambda^I, \quad
\psi(\Lambda^I) = S^I, \quad
\psi(\Phi^I) = (-1)^{|I| - \ell(I)} \Phi^I\]</div>
<p>where <span class="math notranslate nohighlight">\(I^c\)</span> denotes the complement of the composition <span class="math notranslate nohighlight">\(I\)</span>, and
<span class="math notranslate nohighlight">\(\ell(I)\)</span> denotes the length of <span class="math notranslate nohighlight">\(I\)</span>, and where standard
notations for classical bases of <span class="math notranslate nohighlight">\(NCSF\)</span> are being used
(<span class="math notranslate nohighlight">\(S\)</span> for the complete basis, <span class="math notranslate nohighlight">\(\Lambda\)</span> for the elementary basis,
<span class="math notranslate nohighlight">\(\Phi\)</span> for the basis of the power sums of the second kind,
and <span class="math notranslate nohighlight">\(R\)</span> for the ribbon basis). The map <span class="math notranslate nohighlight">\(\psi\)</span> is an involution
and a graded Hopf algebra automorphism of <span class="math notranslate nohighlight">\(NCSF\)</span>. If <span class="math notranslate nohighlight">\(\pi\)</span>
denotes the projection from <span class="math notranslate nohighlight">\(NCSF\)</span> to the ring of symmetric functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_symmetric_function()</span></code></a>),
then <span class="math notranslate nohighlight">\(\pi(\psi(f)) = \omega(\pi(f))\)</span> for every <span class="math notranslate nohighlight">\(f \in NCSF\)</span>, where
the <span class="math notranslate nohighlight">\(\omega\)</span> on the right hand side denotes the omega
automorphism of <span class="math notranslate nohighlight">\(Sym\)</span>.</p>
<p>The involution <span class="math notranslate nohighlight">\(\psi\)</span> of <span class="math notranslate nohighlight">\(NCSF\)</span> is adjoint to the involution
<span class="math notranslate nohighlight">\(\psi\)</span> of <span class="math notranslate nohighlight">\(QSym\)</span> by the standard adjunction between <span class="math notranslate nohighlight">\(NCSF\)</span> and
<span class="math notranslate nohighlight">\(QSym\)</span>.</p>
<p>The involution <span class="math notranslate nohighlight">\(\psi\)</span> has been denoted by <span class="math notranslate nohighlight">\(\psi\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id31"><span>[LMvW13]</span></a>,
section 3.6.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.psi_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></code></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">-Phi[3, 2]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">Phi[2, 2]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">[[]]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">Phi[]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">Phi</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">2*Phi[2] - Phi[2, 1]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The implementation at hand is tailored to the Phi basis.
It is equivalent to the generic implementation via the
ribbon basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">R</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">())</span> <span class="o">==</span> <span class="n">R</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="n">I</span><span class="p">])</span><span class="o">.</span><span class="n">psi_involution</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi.Element.star_involution">
<span class="sig-name descname"><span class="pre">star_involution</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi.Element.star_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<code class="docutils literal notranslate"><span class="pre">self</span></code> under the star involution.</p>
<p>The star involution is defined as the algebra antihomomorphism
<span class="math notranslate nohighlight">\(NCSF \to NCSF\)</span> which, for every positive integer <span class="math notranslate nohighlight">\(n\)</span>, sends
the <span class="math notranslate nohighlight">\(n\)</span>-th complete non-commutative symmetric function <span class="math notranslate nohighlight">\(S_n\)</span> to
<span class="math notranslate nohighlight">\(S_n\)</span>. Denoting by <span class="math notranslate nohighlight">\(f^{\ast}\)</span> the image of an element
<span class="math notranslate nohighlight">\(f \in NCSF\)</span> under this star involution, it can be shown that
every composition <span class="math notranslate nohighlight">\(I\)</span> satisfies</p>
<div class="math notranslate nohighlight">
\[(S^I)^{\ast} = S^{I^r}, \quad
(\Lambda^I)^{\ast} = \Lambda^{I^r}, \quad
R_I^{\ast} = R_{I^r}, \quad
(\Phi^I)^{\ast} = \Phi^{I^r},\]</div>
<p>where <span class="math notranslate nohighlight">\(I^r\)</span> denotes the reversed composition of <span class="math notranslate nohighlight">\(I\)</span>, and
standard notations for classical bases of <span class="math notranslate nohighlight">\(NCSF\)</span> are being used
(<span class="math notranslate nohighlight">\(S\)</span> for the complete basis, <span class="math notranslate nohighlight">\(\Lambda\)</span> for the elementary basis,
<span class="math notranslate nohighlight">\(R\)</span> for the ribbon basis, and <span class="math notranslate nohighlight">\(\Phi\)</span> for that of the power-sums
of the second kind). The star involution is an involution and a
coalgebra automorphism of <span class="math notranslate nohighlight">\(NCSF\)</span>. It is an automorphism of the
graded vector space <span class="math notranslate nohighlight">\(NCSF\)</span>. Under the canonical isomorphism
between the <span class="math notranslate nohighlight">\(n\)</span>-th graded component of <span class="math notranslate nohighlight">\(NCSF\)</span> and the descent
algebra of the symmetric group <span class="math notranslate nohighlight">\(S_n\)</span> (see
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_descent_algebra()</span></code></a>),
the star involution (restricted to
the <span class="math notranslate nohighlight">\(n\)</span>-th graded component) corresponds to the automorphism
of the descent algebra given by
<span class="math notranslate nohighlight">\(x \mapsto \omega_n x \omega_n\)</span>, where <span class="math notranslate nohighlight">\(\omega_n\)</span> is the
permutation <span class="math notranslate nohighlight">\((n, n-1, \ldots, 1) \in S_n\)</span> (written here in
one-line notation). If <span class="math notranslate nohighlight">\(\pi\)</span> denotes the projection from <span class="math notranslate nohighlight">\(NCSF\)</span>
to the ring of symmetric functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_symmetric_function()</span></code></a>),
then <span class="math notranslate nohighlight">\(\pi(f^{\ast}) = \pi(f)\)</span> for every <span class="math notranslate nohighlight">\(f \in NCSF\)</span>.</p>
<p>The star involution on <span class="math notranslate nohighlight">\(NCSF\)</span> is adjoint to the star involution
on <span class="math notranslate nohighlight">\(QSym\)</span> by the standard adjunction between <span class="math notranslate nohighlight">\(NCSF\)</span> and <span class="math notranslate nohighlight">\(QSym\)</span>.</p>
<p>The star involution has been denoted by <span class="math notranslate nohighlight">\(\rho\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id32"><span>[LMvW13]</span></a>,
section 3.6.
See <a class="reference internal" href="qsym.html#ncsf2" id="id33"><span>[NCSF2]</span></a>, section 2.3 for the properties of this map.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.star_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">Phi[4, 1, 1, 3]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">Phi[1, 2, 4]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">Phi</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">Phi</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">Phi</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">Phi</span><span class="p">[[]])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">4*Phi[] - 3*Phi[3] - Phi[3, 2] + Phi[4, 1] + 2*Phi[4, 5]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">Phi</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">3*Phi[1] + Phi[3, 3]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">Phi[1, 2]</span>
</pre></div>
</div>
<p>The implementation at hand is tailored to the Phi basis.
It is equivalent to the generic implementation via the
complete basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">S</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">())</span> <span class="o">==</span> <span class="n">S</span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="n">I</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi.Element.verschiebung">
<span class="sig-name descname"><span class="pre">verschiebung</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Phi.Element.verschiebung" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<code class="docutils literal notranslate"><span class="pre">self</span></code> under the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator.</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator <span class="math notranslate nohighlight">\(\mathbf{V}_n\)</span> is defined
to be the map from the <span class="math notranslate nohighlight">\(\mathbf{k}\)</span>-algebra of noncommutative
symmetric functions to itself that sends the complete function
<span class="math notranslate nohighlight">\(S^I\)</span> indexed by a composition <span class="math notranslate nohighlight">\(I = (i_1, i_2, \ldots , i_k)\)</span>
to <span class="math notranslate nohighlight">\(S^{(i_1/n, i_2/n, \ldots , i_k/n)}\)</span> if all of the numbers
<span class="math notranslate nohighlight">\(i_1, i_2, \ldots, i_k\)</span> are divisible by <span class="math notranslate nohighlight">\(n\)</span>, and to <span class="math notranslate nohighlight">\(0\)</span>
otherwise. This operator <span class="math notranslate nohighlight">\(\mathbf{V}_n\)</span> is a Hopf algebra
endomorphism. For every positive integer <span class="math notranslate nohighlight">\(r\)</span> with <span class="math notranslate nohighlight">\(n \mid r\)</span>,
it satisfies</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n(S_r) = S_{r/n},
\quad \mathbf{V}_n(\Lambda_r) = (-1)^{r - r/n} \Lambda_{r/n},
\quad \mathbf{V}_n(\Psi_r) = n \Psi_{r/n},
\quad \mathbf{V}_n(\Phi_r) = n \Phi_{r/n}\]</div>
<p>(where <span class="math notranslate nohighlight">\(S_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th complete non-commutative
symmetric function, <span class="math notranslate nohighlight">\(\Lambda_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th elementary
non-commutative symmetric function, <span class="math notranslate nohighlight">\(\Psi_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th
power-sum non-commutative symmetric function of the first kind,
and <span class="math notranslate nohighlight">\(\Phi_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th power-sum non-commutative
symmetric function of the second kind). For every positive
integer <span class="math notranslate nohighlight">\(r\)</span> with <span class="math notranslate nohighlight">\(n \nmid r\)</span>, it satisfes</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n(S_r) = \mathbf{V}_n(\Lambda_r)
= \mathbf{V}_n(\Psi_r) = \mathbf{V}_n(\Phi_r) = 0.\]</div>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator is also called the <span class="math notranslate nohighlight">\(n\)</span>-th
Verschiebung endomorphism.</p>
<p>It is a lift of the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator on the ring
of symmetric functions
(<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verschiebung()</span></code></a>)
to the ring of noncommutative symmetric functions.</p>
<p>The action of the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator can also be
described on the ribbon Schur functions. Namely, every
composition <span class="math notranslate nohighlight">\(I\)</span> of size <span class="math notranslate nohighlight">\(n \ell\)</span> satisfies</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n ( R_I )
= (-1)^{\ell(I) - \ell(J)} \cdot R_{J / n},\]</div>
<p>where <span class="math notranslate nohighlight">\(J\)</span> denotes the meet of the compositions <span class="math notranslate nohighlight">\(I\)</span> and
<span class="math notranslate nohighlight">\((\underbrace{n, n, \ldots, n}_{|I|/n \mbox{ times}})\)</span>,
where <span class="math notranslate nohighlight">\(\ell(I)\)</span> is the length of <span class="math notranslate nohighlight">\(I\)</span>, and
where <span class="math notranslate nohighlight">\(J / n\)</span> denotes the composition obtained by
dividing every entry of <span class="math notranslate nohighlight">\(J\)</span> by <span class="math notranslate nohighlight">\(n\)</span>.
For a composition <span class="math notranslate nohighlight">\(I\)</span> of size not divisible by <span class="math notranslate nohighlight">\(n\)</span>, we
have <span class="math notranslate nohighlight">\(\mathbf{V}_n ( R_I ) = 0\)</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius"><code class="xref py py-meth docutils literal notranslate"><span class="pre">frobenius</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">QSym</span></code></a>,
<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">Sym</span></code></a></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a positive integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator (on the
ring of noncommutative symmetric functions) to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Phi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Phi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*Phi[2, 1]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*Phi[1, 2]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">6</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2*Phi[3]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Phi[]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">7</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">7*Phi[1]</span>
<span class="gp">sage: </span><span class="n">Phi</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Phi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Phi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">Phi</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Phi[1] - Phi[2] + 2*Phi[3]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Psi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">NCSF</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></code></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Utilities v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.misc.bindable_class.BindableClass</span></code></a></p>
<p>The Hopf algebra of non-commutative symmetric functions in the
Psi basis.</p>
<p>The Psi basis is defined in Definition 3.4 of <a class="reference internal" href="qsym.html#ncsf1" id="id34"><span>[NCSF1]</span></a>, where
it is denoted by <span class="math notranslate nohighlight">\((\Psi^I)_I\)</span>. It is a multiplicative basis, and
is connected to the elementary generators <span class="math notranslate nohighlight">\(\Lambda_i\)</span> of the ring
of non-commutative symmetric functions by the following relation:
Define a non-commutative symmetric function <span class="math notranslate nohighlight">\(\Psi_n\)</span> for every
positive integer <span class="math notranslate nohighlight">\(n\)</span> by the power series identity</p>
<div class="math notranslate nohighlight">
\[\frac{d}{dt} \sigma(t)
= \sigma(t) \cdot \left( \sum_{k \geq 1} t^{k-1} \Psi_k \right),\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\sigma(t) = \left( \sum_{k \geq 0} (-t)^k \Lambda_k \right)^{-1}\]</div>
<p>and where <span class="math notranslate nohighlight">\(\Lambda_0\)</span> denotes <span class="math notranslate nohighlight">\(1\)</span>. For every composition
<span class="math notranslate nohighlight">\((i_1, i_2, \ldots, i_k)\)</span>, we have
<span class="math notranslate nohighlight">\(\Psi^{(i_1, i_2, \ldots, i_k)}
= \Psi_{i_1} \Psi_{i_2} \cdots \Psi_{i_k}\)</span>.</p>
<p>The <span class="math notranslate nohighlight">\(\Psi\)</span>-basis is a basis only when the base ring is a
<span class="math notranslate nohighlight">\(\QQ\)</span>-algebra (although the <span class="math notranslate nohighlight">\(\Psi^I\)</span> can be defined over any base
ring). The elements of the <span class="math notranslate nohighlight">\(\Psi\)</span>-basis are known as the
“power-sum non-commutative symmetric functions of the first kind”.
The generators <span class="math notranslate nohighlight">\(\Psi_n\)</span> correspond to the Dynkin
(quasi-)idempotents in the descent algebras of the symmetric
groups (see <a class="reference internal" href="qsym.html#ncsf1" id="id35"><span>[NCSF1]</span></a>, 5.2 for details).</p>
<p>Another (equivalent) definition of <span class="math notranslate nohighlight">\(\Psi_n\)</span> is</p>
<div class="math notranslate nohighlight">
\[\Psi_n = \sum_{i=0}^{n-1} (-1)^i R_{1^i, n-i},\]</div>
<p>where <span class="math notranslate nohighlight">\(R\)</span> denotes the ribbon basis of <span class="math notranslate nohighlight">\(NCSF\)</span>, and where <span class="math notranslate nohighlight">\(1^i\)</span>
stands for <span class="math notranslate nohighlight">\(i\)</span> repetitions of the integer <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Psi</span><span class="p">();</span> <span class="n">Psi</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Psi basis</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*Psi[] + 2*Psi[1] + 3*Psi[1, 1]</span>
</pre></div>
</div>
<p>Checking the equivalent definition of <span class="math notranslate nohighlight">\(\Psi_n\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">test_psi</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="n">R</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">Psi</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">....: </span>    <span class="n">a</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">sum</span><span class="p">([(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">i</span> <span class="o">*</span> <span class="n">R</span><span class="p">[[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">]]</span>
<span class="gp">....: </span>               <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">==</span> <span class="n">R</span><span class="p">(</span><span class="n">Psi</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">test_psi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_psi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">test_psi</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi.Element">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Element</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../modules/sage/modules/with_basis/indexed_element.html#sage.modules.with_basis.indexed_element.IndexedFreeModuleElement" title="(in Modules v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.indexed_element.IndexedFreeModuleElement</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi.Element.verschiebung">
<span class="sig-name descname"><span class="pre">verschiebung</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi.Element.verschiebung" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<code class="docutils literal notranslate"><span class="pre">self</span></code> under the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator.</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator <span class="math notranslate nohighlight">\(\mathbf{V}_n\)</span> is defined
to be the map from the <span class="math notranslate nohighlight">\(\mathbf{k}\)</span>-algebra of noncommutative
symmetric functions to itself that sends the complete function
<span class="math notranslate nohighlight">\(S^I\)</span> indexed by a composition <span class="math notranslate nohighlight">\(I = (i_1, i_2, \ldots , i_k)\)</span>
to <span class="math notranslate nohighlight">\(S^{(i_1/n, i_2/n, \ldots , i_k/n)}\)</span> if all of the numbers
<span class="math notranslate nohighlight">\(i_1, i_2, \ldots, i_k\)</span> are divisible by <span class="math notranslate nohighlight">\(n\)</span>, and to <span class="math notranslate nohighlight">\(0\)</span>
otherwise. This operator <span class="math notranslate nohighlight">\(\mathbf{V}_n\)</span> is a Hopf algebra
endomorphism. For every positive integer <span class="math notranslate nohighlight">\(r\)</span> with <span class="math notranslate nohighlight">\(n \mid r\)</span>,
it satisfies</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n(S_r) = S_{r/n},
\quad \mathbf{V}_n(\Lambda_r) = (-1)^{r - r/n} \Lambda_{r/n},
\quad \mathbf{V}_n(\Psi_r) = n \Psi_{r/n},
\quad \mathbf{V}_n(\Phi_r) = n \Phi_{r/n}\]</div>
<p>(where <span class="math notranslate nohighlight">\(S_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th complete non-commutative
symmetric function, <span class="math notranslate nohighlight">\(\Lambda_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th elementary
non-commutative symmetric function, <span class="math notranslate nohighlight">\(\Psi_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th
power-sum non-commutative symmetric function of the first kind,
and <span class="math notranslate nohighlight">\(\Phi_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th power-sum non-commutative
symmetric function of the second kind). For every positive
integer <span class="math notranslate nohighlight">\(r\)</span> with <span class="math notranslate nohighlight">\(n \nmid r\)</span>, it satisfes</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n(S_r) = \mathbf{V}_n(\Lambda_r)
= \mathbf{V}_n(\Psi_r) = \mathbf{V}_n(\Phi_r) = 0.\]</div>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator is also called the <span class="math notranslate nohighlight">\(n\)</span>-th
Verschiebung endomorphism.</p>
<p>It is a lift of the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator on the ring
of symmetric functions
(<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verschiebung()</span></code></a>)
to the ring of noncommutative symmetric functions.</p>
<p>The action of the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator can also be
described on the ribbon Schur functions. Namely, every
composition <span class="math notranslate nohighlight">\(I\)</span> of size <span class="math notranslate nohighlight">\(n \ell\)</span> satisfies</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n ( R_I )
= (-1)^{\ell(I) - \ell(J)} \cdot R_{J / n},\]</div>
<p>where <span class="math notranslate nohighlight">\(J\)</span> denotes the meet of the compositions <span class="math notranslate nohighlight">\(I\)</span> and
<span class="math notranslate nohighlight">\((\underbrace{n, n, \ldots, n}_{|I|/n \mbox{ times}})\)</span>,
where <span class="math notranslate nohighlight">\(\ell(I)\)</span> is the length of <span class="math notranslate nohighlight">\(I\)</span>, and
where <span class="math notranslate nohighlight">\(J / n\)</span> denotes the composition obtained by
dividing every entry of <span class="math notranslate nohighlight">\(J\)</span> by <span class="math notranslate nohighlight">\(n\)</span>.
For a composition <span class="math notranslate nohighlight">\(I\)</span> of size not divisible by <span class="math notranslate nohighlight">\(n\)</span>, we
have <span class="math notranslate nohighlight">\(\mathbf{V}_n ( R_I ) = 0\)</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius"><code class="xref py py-meth docutils literal notranslate"><span class="pre">frobenius</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">QSym</span></code></a>,
<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">Sym</span></code></a></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a positive integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator (on the
ring of noncommutative symmetric functions) to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*Psi[2, 1]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*Psi[1, 2]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">6</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2*Psi[3]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Psi[]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">7</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">7*Psi[1]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">Psi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Psi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">Psi</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Psi[1] - Psi[2] + 2*Psi[3]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi.internal_product_on_basis_by_bracketing">
<span class="sig-name descname"><span class="pre">internal_product_on_basis_by_bracketing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Psi.internal_product_on_basis_by_bracketing" title="Permalink to this definition">¶</a></dt>
<dd><p>The internal product of two elements of the Psi basis.</p>
<p>See <a class="reference internal" href="generic_basis_code.html#sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product" title="sage.combinat.ncsf_qsym.generic_basis_code.GradedModulesWithInternalProduct.ElementMethods.internal_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">internal_product()</span></code></a>
for a thorough documentation of this operation.</p>
<p>This is an implementation using <a class="reference internal" href="qsym.html#ncsf2" id="id36"><span>[NCSF2]</span></a> Lemma 3.10.
It is fast when the length of <span class="math notranslate nohighlight">\(I\)</span> is small, but can get
very slow otherwise. Therefore it is not being used by
default for internally multiplying Psi functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">I</span></code>, <code class="docutils literal notranslate"><span class="pre">J</span></code> – compositions</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The internal product of the elements of the Psi basis of
<span class="math notranslate nohighlight">\(NSym\)</span> indexed by <code class="docutils literal notranslate"><span class="pre">I</span></code> and <code class="docutils literal notranslate"><span class="pre">J</span></code>, expressed in the Psi
basis.</p></li>
</ul>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Travis Scrimshaw, 29 Mar 2014</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Psi</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">Psi</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">internal_product_on_basis_by_bracketing</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">internal_product_on_basis_by_bracketing</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">4*Psi[1, 2, 1]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">internal_product_on_basis_by_bracketing</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">4*Psi[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">internal_product_on_basis_by_bracketing</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">internal_product_on_basis_by_bracketing</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">-Psi[1, 2, 1] + Psi[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">internal_product_on_basis_by_bracketing</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">internal_product_on_basis_by_bracketing</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Psi</span><span class="o">.</span><span class="n">internal_product_on_basis_by_bracketing</span><span class="p">([</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">-Psi[1, 1, 2] + 2*Psi[1, 2, 1] - Psi[2, 1, 1]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.R">
<span class="sig-name descname"><span class="pre">R</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.R" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonCommutativeSymmetricFunctions.Ribbon</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Ribbon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">NCSF</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></code></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Utilities v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.misc.bindable_class.BindableClass</span></code></a></p>
<p>The Hopf algebra of non-commutative symmetric functions in the
Ribbon basis.</p>
<p>The Ribbon basis is defined in Definition 3.12 of <a class="reference internal" href="qsym.html#ncsf1" id="id37"><span>[NCSF1]</span></a>, where
it is denoted by <span class="math notranslate nohighlight">\((R_I)_I\)</span>. It is connected to the complete
basis of the ring of non-commutative symmetric functions by the
following relation: For every composition <span class="math notranslate nohighlight">\(I\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[R_I = \sum_J (-1)^{\ell(I) - \ell(J)} S^J,\]</div>
<p>where the sum is over all compositions <span class="math notranslate nohighlight">\(J\)</span> which are coarser than
<span class="math notranslate nohighlight">\(I\)</span> and <span class="math notranslate nohighlight">\(\ell(I)\)</span> denotes the length of <span class="math notranslate nohighlight">\(I\)</span>. (See the proof of
Proposition 4.13 in <a class="reference internal" href="qsym.html#ncsf1" id="id38"><span>[NCSF1]</span></a>.)</p>
<p>The elements of the Ribbon basis are commonly referred to as the
ribbon Schur functions.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">Ribbon</span><span class="p">();</span> <span class="n">R</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Ribbon basis</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">an_element</span><span class="p">()</span>
<span class="go">2*R[] + 2*R[1] + 3*R[1, 1]</span>
</pre></div>
</div>
<p>The following are aliases for this basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Ribbon basis</span>
<span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="go">Non-Commutative Symmetric Functions over the Rational Field in the Ribbon basis</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.Element">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Element</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../modules/sage/modules/with_basis/indexed_element.html#sage.modules.with_basis.indexed_element.IndexedFreeModuleElement" title="(in Modules v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.modules.with_basis.indexed_element.IndexedFreeModuleElement</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.Element.star_involution">
<span class="sig-name descname"><span class="pre">star_involution</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.Element.star_involution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<code class="docutils literal notranslate"><span class="pre">self</span></code> under the star involution.</p>
<p>The star involution is defined as the algebra antihomomorphism
<span class="math notranslate nohighlight">\(NCSF \to NCSF\)</span> which, for every positive integer <span class="math notranslate nohighlight">\(n\)</span>, sends
the <span class="math notranslate nohighlight">\(n\)</span>-th complete non-commutative symmetric function <span class="math notranslate nohighlight">\(S_n\)</span> to
<span class="math notranslate nohighlight">\(S_n\)</span>. Denoting by <span class="math notranslate nohighlight">\(f^{\ast}\)</span> the image of an element
<span class="math notranslate nohighlight">\(f \in NCSF\)</span> under this star involution, it can be shown that
every composition <span class="math notranslate nohighlight">\(I\)</span> satisfies</p>
<div class="math notranslate nohighlight">
\[(S^I)^{\ast} = S^{I^r}, \quad
(\Lambda^I)^{\ast} = \Lambda^{I^r}, \quad
R_I^{\ast} = R_{I^r}, \quad
(\Phi^I)^{\ast} = \Phi^{I^r},\]</div>
<p>where <span class="math notranslate nohighlight">\(I^r\)</span> denotes the reversed composition of <span class="math notranslate nohighlight">\(I\)</span>, and
standard notations for classical bases of <span class="math notranslate nohighlight">\(NCSF\)</span> are being used
(<span class="math notranslate nohighlight">\(S\)</span> for the complete basis, <span class="math notranslate nohighlight">\(\Lambda\)</span> for the elementary basis,
<span class="math notranslate nohighlight">\(R\)</span> for the ribbon basis, and <span class="math notranslate nohighlight">\(\Phi\)</span> for that of the power-sums
of the second kind). The star involution is an involution and a
coalgebra automorphism of <span class="math notranslate nohighlight">\(NCSF\)</span>. It is an automorphism of the
graded vector space <span class="math notranslate nohighlight">\(NCSF\)</span>. Under the canonical isomorphism
between the <span class="math notranslate nohighlight">\(n\)</span>-th graded component of <span class="math notranslate nohighlight">\(NCSF\)</span> and the descent
algebra of the symmetric group <span class="math notranslate nohighlight">\(S_n\)</span> (see
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_descent_algebra"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_descent_algebra()</span></code></a>),
the star involution (restricted to
the <span class="math notranslate nohighlight">\(n\)</span>-th graded component) corresponds to the automorphism
of the descent algebra given by
<span class="math notranslate nohighlight">\(x \mapsto \omega_n x \omega_n\)</span>, where <span class="math notranslate nohighlight">\(\omega_n\)</span> is the
permutation <span class="math notranslate nohighlight">\((n, n-1, \ldots, 1) \in S_n\)</span> (written here in
one-line notation). If <span class="math notranslate nohighlight">\(\pi\)</span> denotes the projection from <span class="math notranslate nohighlight">\(NCSF\)</span>
to the ring of symmetric functions
(<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_symmetric_function()</span></code></a>),
then <span class="math notranslate nohighlight">\(\pi(f^{\ast}) = \pi(f)\)</span> for every <span class="math notranslate nohighlight">\(f \in NCSF\)</span>.</p>
<p>The star involution on <span class="math notranslate nohighlight">\(NCSF\)</span> is adjoint to the star involution
on <span class="math notranslate nohighlight">\(QSym\)</span> by the standard adjunction between <span class="math notranslate nohighlight">\(NCSF\)</span> and <span class="math notranslate nohighlight">\(QSym\)</span>.</p>
<p>The star involution has been denoted by <span class="math notranslate nohighlight">\(\rho\)</span> in <a class="reference internal" href="qsym.html#lmvw13" id="id39"><span>[LMvW13]</span></a>,
section 3.6.
See <a class="reference internal" href="qsym.html#ncsf2" id="id40"><span>[NCSF2]</span></a>, section 2.3 for the properties of this map.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.star_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.star_involution" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.star_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">star</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">QSym</span></code></a>,
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.psi_involution"><code class="xref py py-meth docutils literal notranslate"><span class="pre">psi</span> <span class="pre">involution</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">R[2, 4, 1, 3]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">R[2, 1, 4]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">R</span><span class="p">[[]])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">4*R[] + R[1] - R[2] - 3*R[3] + 2*R[4, 5]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">21</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">-21*R[1] + R[3, 3]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">14</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="go">R[1, 14]</span>
</pre></div>
</div>
<p>The implementation at hand is tailored to the ribbon basis.
It is equivalent to the generic implementation via the
complete basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">S</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">star_involution</span><span class="p">())</span> <span class="o">==</span> <span class="n">S</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">I</span><span class="p">])</span><span class="o">.</span><span class="n">star_involution</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.Element.verschiebung">
<span class="sig-name descname"><span class="pre">verschiebung</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.Element.verschiebung" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the image of the noncommutative symmetric function
<code class="docutils literal notranslate"><span class="pre">self</span></code> under the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator.</p>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator <span class="math notranslate nohighlight">\(\mathbf{V}_n\)</span> is defined
to be the map from the <span class="math notranslate nohighlight">\(\mathbf{k}\)</span>-algebra of noncommutative
symmetric functions to itself that sends the complete function
<span class="math notranslate nohighlight">\(S^I\)</span> indexed by a composition <span class="math notranslate nohighlight">\(I = (i_1, i_2, \ldots , i_k)\)</span>
to <span class="math notranslate nohighlight">\(S^{(i_1/n, i_2/n, \ldots , i_k/n)}\)</span> if all of the numbers
<span class="math notranslate nohighlight">\(i_1, i_2, \ldots, i_k\)</span> are divisible by <span class="math notranslate nohighlight">\(n\)</span>, and to <span class="math notranslate nohighlight">\(0\)</span>
otherwise. This operator <span class="math notranslate nohighlight">\(\mathbf{V}_n\)</span> is a Hopf algebra
endomorphism. For every positive integer <span class="math notranslate nohighlight">\(r\)</span> with <span class="math notranslate nohighlight">\(n \mid r\)</span>,
it satisfies</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n(S_r) = S_{r/n},
\quad \mathbf{V}_n(\Lambda_r) = (-1)^{r - r/n} \Lambda_{r/n},
\quad \mathbf{V}_n(\Psi_r) = n \Psi_{r/n},
\quad \mathbf{V}_n(\Phi_r) = n \Phi_{r/n}\]</div>
<p>(where <span class="math notranslate nohighlight">\(S_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th complete non-commutative
symmetric function, <span class="math notranslate nohighlight">\(\Lambda_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th elementary
non-commutative symmetric function, <span class="math notranslate nohighlight">\(\Psi_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th
power-sum non-commutative symmetric function of the first kind,
and <span class="math notranslate nohighlight">\(\Phi_r\)</span> denotes the <span class="math notranslate nohighlight">\(r\)</span>-th power-sum non-commutative
symmetric function of the second kind). For every positive
integer <span class="math notranslate nohighlight">\(r\)</span> with <span class="math notranslate nohighlight">\(n \nmid r\)</span>, it satisfes</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n(S_r) = \mathbf{V}_n(\Lambda_r)
= \mathbf{V}_n(\Psi_r) = \mathbf{V}_n(\Phi_r) = 0.\]</div>
<p>The <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator is also called the <span class="math notranslate nohighlight">\(n\)</span>-th
Verschiebung endomorphism.</p>
<p>It is a lift of the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator on the ring
of symmetric functions
(<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verschiebung()</span></code></a>)
to the ring of noncommutative symmetric functions.</p>
<p>The action of the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator can also be
described on the ribbon Schur functions. Namely, every
composition <span class="math notranslate nohighlight">\(I\)</span> of size <span class="math notranslate nohighlight">\(n \ell\)</span> satisfies</p>
<div class="math notranslate nohighlight">
\[\mathbf{V}_n ( R_I )
= (-1)^{\ell(I) - \ell(J)} \cdot R_{J / n},\]</div>
<p>where <span class="math notranslate nohighlight">\(J\)</span> denotes the meet of the compositions <span class="math notranslate nohighlight">\(I\)</span> and
<span class="math notranslate nohighlight">\((\underbrace{n, n, \ldots, n}_{|I|/n \mbox{ times}})\)</span>,
where <span class="math notranslate nohighlight">\(\ell(I)\)</span> is the length of <span class="math notranslate nohighlight">\(I\)</span>, and
where <span class="math notranslate nohighlight">\(J / n\)</span> denotes the composition obtained by
dividing every entry of <span class="math notranslate nohighlight">\(J\)</span> by <span class="math notranslate nohighlight">\(n\)</span>.
For a composition <span class="math notranslate nohighlight">\(I\)</span> of size not divisible by <span class="math notranslate nohighlight">\(n\)</span>, we
have <span class="math notranslate nohighlight">\(\mathbf{V}_n ( R_I ) = 0\)</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.verschiebung"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">NCSF</span></code></a>,
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Bases.ElementMethods.frobenius"><code class="xref py py-meth docutils literal notranslate"><span class="pre">frobenius</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">QSym</span></code></a>,
<a class="reference internal" href="../sf/sfa.html#sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung" title="sage.combinat.sf.sfa.SymmetricFunctionAlgebra_generic_Element.verschiebung"><code class="xref py py-meth docutils literal notranslate"><span class="pre">verschiebung</span> <span class="pre">method</span> <span class="pre">of</span> <span class="pre">Sym</span></code></a></p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a positive integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>The result of applying the <span class="math notranslate nohighlight">\(n\)</span>-th Verschiebung operator (on the
ring of noncommutative symmetric functions) to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NSym</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NSym</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">R[2, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">-R[1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">R[]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">-R[2]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">-R[1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-R[3]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">-R[1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">verschiebung</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">R[1] - R[2] + 2*R[3]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.antipode_on_basis">
<span class="sig-name descname"><span class="pre">antipode_on_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">composition</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.antipode_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the application of the antipode to a basis element
of the ribbon basis <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">composition</span></code> – a composition</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The image of the basis element indexed by <code class="docutils literal notranslate"><span class="pre">composition</span></code>
under the antipode map.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">antipode_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">-R[2, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="c1"># indirect doctest</span>
<span class="go">R[2, 1, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[[]]</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span> <span class="c1"># indirect doctest</span>
<span class="go">R[]</span>
</pre></div>
</div>
<p>We check that the implementation of the antipode at hand does
not contradict the generic one:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">all</span><span class="p">(</span> <span class="n">S</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">.</span><span class="n">antipode</span><span class="p">())</span> <span class="o">==</span> <span class="n">S</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">I</span><span class="p">])</span><span class="o">.</span><span class="n">antipode</span><span class="p">()</span>
<span class="gp">....: </span>     <span class="k">for</span> <span class="n">I</span> <span class="ow">in</span> <span class="n">Compositions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.dual">
<span class="sig-name descname"><span class="pre">dual</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual basis to the ribbon basis of the non-commutative symmetric
functions. This is the Fundamental basis of the quasi-symmetric functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The fundamental basis of the quasi-symmetric functions.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="go">Quasisymmetric functions over the Rational Field in the Fundamental basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.product_on_basis">
<span class="sig-name descname"><span class="pre">product_on_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">I</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.product_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of two ribbon basis elements of the non-commutative
symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">I</span></code>, <code class="docutils literal notranslate"><span class="pre">J</span></code> – compositions</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The product of the ribbon functions indexed by <code class="docutils literal notranslate"><span class="pre">I</span></code> and <code class="docutils literal notranslate"><span class="pre">J</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">ribbon</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">R[1, 2, 1, 3, 1] + R[1, 2, 4, 1]</span>
<span class="gp">sage: </span><span class="p">(</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">)</span> <span class="o">*</span> <span class="p">(</span> <span class="n">R</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
<span class="go">R[1, 2, 1, 2, 1] + R[1, 2, 3, 1] + R[1, 3, 2, 1] + R[1, 5, 1] + R[3, 1, 2, 1] + R[3, 3, 1] + R[4, 2, 1] + R[6, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.to_symmetric_function_on_basis">
<span class="sig-name descname"><span class="pre">to_symmetric_function_on_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">I</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon.to_symmetric_function_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the commutative image of a ribbon basis element of the
non-commutative symmetric functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">I</span></code> – a composition</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The commutative image of the ribbon basis element indexed by
<code class="docutils literal notranslate"><span class="pre">I</span></code>. This will be expressed as a symmetric function in the
Schur basis.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">R</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[3, 1, 1]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">s[4, 2, 1] + s[5, 1, 1] + s[5, 2]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">(</span><span class="n">Composition</span><span class="p">([]))</span>
<span class="go">s[]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.S">
<span class="sig-name descname"><span class="pre">S</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.S" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonCommutativeSymmetricFunctions.Complete</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.ZL">
<span class="sig-name descname"><span class="pre">ZL</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.ZL" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Zassenhaus_left" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Zassenhaus_left"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonCommutativeSymmetricFunctions.Zassenhaus_left</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.ZR">
<span class="sig-name descname"><span class="pre">ZR</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.ZR" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Zassenhaus_right" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Zassenhaus_right"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonCommutativeSymmetricFunctions.Zassenhaus_right</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Zassenhaus_left">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Zassenhaus_left</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">NCSF</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Zassenhaus_left" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></code></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Utilities v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.misc.bindable_class.BindableClass</span></code></a></p>
<p>The Hopf algebra of non-commutative symmetric functions in the
left Zassenhaus basis.</p>
<p>This basis is the left-version of the basis defined in Section 2.5.1
of <a class="reference internal" href="qsym.html#hlnt09" id="id41"><span>[HLNT09]</span></a>.
It is multiplicative, with <span class="math notranslate nohighlight">\(Z_n\)</span> defined as the element of <span class="math notranslate nohighlight">\(NCSF_n\)</span>
satisfying the equation</p>
<div class="math notranslate nohighlight">
\[\sigma_1 = \cdots exp(Z_n) \cdots exp(Z_2) exp(Z_1),\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\sigma_1 = \sum_{n \geq 0} S_n .\]</div>
<p>It can be recursively computed by the formula</p>
<div class="math notranslate nohighlight">
\[S_n = \sum_{\lambda \vdash n}
\frac{1}{m_1(\lambda)! m_2(\lambda)! m_3(\lambda)! \cdots}
Z_{\lambda_1} Z_{\lambda_2} Z_{\lambda_3} \cdots\]</div>
<p>for all <span class="math notranslate nohighlight">\(n \geq 0\)</span>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Zassenhaus_right">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Zassenhaus_right</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">NCSF</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Zassenhaus_right" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></code></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Utilities v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.misc.bindable_class.BindableClass</span></code></a></p>
<p>The Hopf algebra of non-commutative symmetric functions in
the right Zassenhaus basis.</p>
<p>This basis is defined in Section 2.5.1 of <a class="reference internal" href="qsym.html#hlnt09" id="id42"><span>[HLNT09]</span></a>.
It is multiplicative, with <span class="math notranslate nohighlight">\(Z_n\)</span> defined as the element of <span class="math notranslate nohighlight">\(NCSF_n\)</span>
satisfying the equation</p>
<div class="math notranslate nohighlight">
\[\sigma_1 = exp(Z_1) exp(Z_2) exp(Z_3) \cdots exp(Z_n) \cdots\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\sigma_1 = \sum_{n \geq 0} S_n .\]</div>
<p>It can be recursively computed by the formula</p>
<div class="math notranslate nohighlight">
\[S_n = \sum_{\lambda \vdash n}
\frac{1}{m_1(\lambda)! m_2(\lambda)! m_3(\lambda)! \cdots}
\cdots Z_{\lambda_3} Z_{\lambda_2} Z_{\lambda_1}\]</div>
<p>for all <span class="math notranslate nohighlight">\(n \geq 0\)</span>.</p>
<p>Note that there is a variant (called the “noncommutative
power sum symmetric functions of the third kind”)
in Definition 5.26 of <a class="reference internal" href="qsym.html#ncsf2" id="id43"><span>[NCSF2]</span></a> that satisfies:</p>
<div class="math notranslate nohighlight">
\[\sigma_1 = exp(Z_1) exp(Z_2/2) exp(Z_3/3) \cdots exp(Z_n/n) \cdots.\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.a_realization">
<span class="sig-name descname"><span class="pre">a_realization</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.a_realization" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a realization of the algebra of non-commutative symmetric functions. This
particular realization is the complete basis of non-commutative symmetric functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The realization of the non-commutative symmetric functions in the
complete basis.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">ZZ</span><span class="p">)</span><span class="o">.</span><span class="n">a_realization</span><span class="p">()</span>
<span class="go">Non-Commutative Symmetric Functions over the Integer Ring in the Complete basis</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.complete">
<span class="sig-name descname"><span class="pre">complete</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.complete" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Complete"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonCommutativeSymmetricFunctions.Complete</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dQS">
<span class="sig-name descname"><span class="pre">dQS</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dQS" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dYQS">
<span class="sig-name descname"><span class="pre">dYQS</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dYQS" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualYoungQuasisymmetric_Schur" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualYoungQuasisymmetric_Schur"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonCommutativeSymmetricFunctions.dualYoungQuasisymmetric_Schur</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dual">
<span class="sig-name descname"><span class="pre">dual</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual to the non-commutative symmetric functions.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The dual of the non-commutative symmetric functions over a ring. This
is the algebra of quasi-symmetric functions over the ring.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">NCSF</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="go">Quasisymmetric functions over the Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dualQuasisymmetric_Schur</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">NCSF</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></code></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Utilities v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.misc.bindable_class.BindableClass</span></code></a></p>
<p>The basis of NCSF dual to the Quasisymmetric-Schur basis of QSym.</p>
<p>The
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quasisymmetric_Schur</span></code></a>
functions are defined in <a class="reference internal" href="combinatorics.html#qschur" id="id44"><span>[QSCHUR]</span></a> (see also
Definition 5.1.1 of <a class="reference internal" href="qsym.html#lmvw13" id="id45"><span>[LMvW13]</span></a>).  The dual basis in the algebra
of non-commutative symmetric functions is defined by the following
formula:</p>
<div class="math notranslate nohighlight">
\[R_\alpha = \sum_{T} dQS_{shape(T)},\]</div>
<p>where the sum is over all standard composition tableaux with
descent composition equal to <span class="math notranslate nohighlight">\(\alpha\)</span>.
The
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quasisymmetric_Schur</span></code></a>
basis <span class="math notranslate nohighlight">\(QS_\alpha\)</span> has the property that</p>
<div class="math notranslate nohighlight">
\[s_\lambda = \sum_{sort(\alpha) = \lambda} QS_\alpha.\]</div>
<p>As a consequence the commutative image of a dual
Quasisymmetric-Schur element in the algebra of symmetric functions
(the map defined in the method
<a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Bases.ElementMethods.to_symmetric_function"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_symmetric_function()</span></code></a>)
is equal to the Schur function indexed by the decreasing sort of the
indexing composition.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../composition_tableau.html#sage.combinat.composition_tableau.CompositionTableaux" title="sage.combinat.composition_tableau.CompositionTableaux"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompositionTableaux</span></code></a>,
<a class="reference internal" href="../composition_tableau.html#sage.combinat.composition_tableau.CompositionTableau" title="sage.combinat.composition_tableau.CompositionTableau"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompositionTableau</span></code></a>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dQS</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">dQS</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">dQS</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">dQS[1, 2, 4] + dQS[1, 3, 2, 1] + dQS[1, 3, 3] + dQS[3, 2, 2]</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">dQS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">dQS[1, 1, 3, 2] + dQS[1, 3, 3] + dQS[1, 4, 2] + dQS[2, 3, 2]</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">dQS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">dQS[1, 3, 1, 1] + dQS[1, 4, 1] + dQS[3, 2, 1] + dQS[4, 2]</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">dQS</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">dQS[1, 1, 4, 1] + dQS[1, 4, 2] + dQS[1, 5, 1] + dQS[2, 4, 1] + dQS[3, 1,</span>
<span class="go">2, 1] + dQS[3, 2, 2] + dQS[3, 3, 1] + dQS[4, 3] + dQS[5, 2]</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">dQS[] # dQS[1, 1] + dQS[1] # dQS[1] + dQS[1, 1] # dQS[]</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span><span class="o">.</span><span class="n">monomial_coefficients</span><span class="p">()[(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span><span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]))]</span>
<span class="go">-1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">dQS[1, 3, 1] + dQS[1, 4] + dQS[3, 2] + dQS[4, 1] + dQS[5]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">(</span><span class="n">dQS</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">S[1, 3, 1] - S[3, 2] - S[4, 1] + S[5]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">dQS</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">())</span>
<span class="go">s[3, 2, 1]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur.dual">
<span class="sig-name descname"><span class="pre">dual</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>The dual basis to the dual Quasisymmetric-Schur basis of NCSF.</p>
<p>The basis returned is the
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quasisymmetric_Schur</span></code></a>
basis of QSym.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the Quasisymmetric-Schur basis of the quasi-symmetric functions</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dQS</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">dualQuasisymmetric_Schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="go">Quasisymmetric functions over the Rational Field in the Quasisymmetric</span>
<span class="go">Schur basis</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">dQS</span><span class="o">.</span><span class="n">dual</span><span class="p">(),</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[1 0 0 0]</span>
<span class="go">[0 1 0 0]</span>
<span class="go">[0 0 1 0]</span>
<span class="go">[0 0 0 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur.to_symmetric_function_on_basis">
<span class="sig-name descname"><span class="pre">to_symmetric_function_on_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">I</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualQuasisymmetric_Schur.to_symmetric_function_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>The commutative image of a dual quasi-symmetric Schur element</p>
<p>The commutative image of a basis element is obtained by sorting
the indexing composition of the basis element.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">I</span></code> – a composition</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The commutative image of the dual quasi-Schur basis element
indexed by <code class="docutils literal notranslate"><span class="pre">I</span></code>. The result is the Schur symmetric function
indexed by the partition obtained by sorting <code class="docutils literal notranslate"><span class="pre">I</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dQS</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">dQS</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">s[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">dQS</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">([])</span>
<span class="go">s[]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualYoungQuasisymmetric_Schur">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dualYoungQuasisymmetric_Schur</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">NCSF</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualYoungQuasisymmetric_Schur" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../free_module.html#sage.combinat.free_module.CombinatorialFreeModule" title="sage.combinat.free_module.CombinatorialFreeModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.free_module.CombinatorialFreeModule</span></code></a>, <a class="reference external" href="../../../../misc/sage/misc/bindable_class.html#sage.misc.bindable_class.BindableClass" title="(in Utilities v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.misc.bindable_class.BindableClass</span></code></a></p>
<p>The basis of NCSF dual to the Young Quasisymmetric-Schur basis of QSym.</p>
<p>The
<code class="xref py py-class docutils literal notranslate"><span class="pre">YoungQuasisymmetric_Schur</span></code>
functions are given in Definition 5.2.1 of <a class="reference internal" href="qsym.html#lmvw13" id="id46"><span>[LMvW13]</span></a>.  The dual basis
in the algebra of non-commutative symmetric functions are related by
an involution reversing the indexing composition of the complete
expansion of a quasi-Schur basis element.  This basis has many of the
same properties as the Quasisymmetric Schur basis and is related to
that basis by an algebraic transformation.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">NCSF</span> <span class="o">=</span> <span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dYQS</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">dYQS</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">dYQS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">dYQS</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">dYQS[1, 3, 2, 1] + dYQS[1, 3, 3] + dYQS[1, 4, 2] + dYQS[2, 3, 2]</span>
<span class="gp">sage: </span><span class="n">dYQS</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">dYQS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">dYQS[1, 1, 3, 2] + dYQS[2, 3, 2] + dYQS[3, 3, 1] + dYQS[4, 1, 2]</span>
<span class="gp">sage: </span><span class="n">dYQS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="n">dYQS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">dYQS[1, 3, 1, 1] + dYQS[1, 4, 1] + dYQS[2, 3, 1] + dYQS[2, 4]</span>
<span class="gp">sage: </span><span class="n">dYQS</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">dYQS</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">dYQS[3, 1, 2, 1] + dYQS[3, 2, 2] + dYQS[3, 3, 1] + dYQS[4, 1, 1, 1]</span>
<span class="go"> + dYQS[4, 1, 2] + dYQS[4, 2, 1] + dYQS[4, 3] + dYQS[5, 1, 1]</span>
<span class="go"> + dYQS[5, 2]</span>
<span class="gp">sage: </span><span class="n">dYQS</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span>
<span class="go">dYQS[] # dYQS[1, 1] + dYQS[1] # dYQS[1] + dYQS[1, 1] # dYQS[]</span>
<span class="gp">sage: </span><span class="n">dYQS</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">coproduct</span><span class="p">()</span><span class="o">.</span><span class="n">monomial_coefficients</span><span class="p">()[(</span><span class="n">Composition</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span><span class="n">Composition</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))]</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">NCSF</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">dYQS</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">dYQS[1, 3, 1] + dYQS[1, 4] + dYQS[2, 3] + dYQS[4, 1] + dYQS[5]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="p">(</span><span class="n">dYQS</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">S[1, 3, 1] - S[1, 4] - S[2, 3] + S[5]</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">dYQS</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span><span class="o">.</span><span class="n">to_symmetric_function</span><span class="p">())</span>
<span class="go">s[3, 2, 1]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualYoungQuasisymmetric_Schur.dual">
<span class="sig-name descname"><span class="pre">dual</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualYoungQuasisymmetric_Schur.dual" title="Permalink to this definition">¶</a></dt>
<dd><p>The dual basis to the dual Quasisymmetric-Schur basis of NCSF.</p>
<p>The basis returned is the
<a class="reference internal" href="qsym.html#sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur" title="sage.combinat.ncsf_qsym.qsym.QuasiSymmetricFunctions.Quasisymmetric_Schur"><code class="xref py py-class docutils literal notranslate"><span class="pre">Quasisymmetric_Schur</span></code></a>
basis of QSym.</p>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>the Young Quasisymmetric-Schur basis of quasi-symmetric functions</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dYQS</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">dualYoungQuasisymmetric_Schur</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">dYQS</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span>
<span class="go">Quasisymmetric functions over the Rational Field in the Young</span>
<span class="go">Quasisymmetric Schur basis</span>
<span class="gp">sage: </span><span class="n">dYQS</span><span class="o">.</span><span class="n">duality_pairing_matrix</span><span class="p">(</span><span class="n">dYQS</span><span class="o">.</span><span class="n">dual</span><span class="p">(),</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[1 0 0 0]</span>
<span class="go">[0 1 0 0]</span>
<span class="go">[0 0 1 0]</span>
<span class="go">[0 0 0 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualYoungQuasisymmetric_Schur.to_symmetric_function_on_basis">
<span class="sig-name descname"><span class="pre">to_symmetric_function_on_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">I</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.dualYoungQuasisymmetric_Schur.to_symmetric_function_on_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>The commutative image of a dual Young quasi-symmetric
Schur element.</p>
<p>The commutative image of a basis element is obtained by sorting
the indexing composition of the basis element.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">I</span></code> – a composition</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>The commutative image of the dual Young quasi-Schur basis element
indexed by <code class="docutils literal notranslate"><span class="pre">I</span></code>. The result is the Schur symmetric function
indexed by the partition obtained by sorting <code class="docutils literal notranslate"><span class="pre">I</span></code>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">dYQS</span><span class="o">=</span><span class="n">NonCommutativeSymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">dYQS</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">dYQS</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">s[3, 2, 1]</span>
<span class="gp">sage: </span><span class="n">dYQS</span><span class="o">.</span><span class="n">to_symmetric_function_on_basis</span><span class="p">([])</span>
<span class="go">s[]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.elementary">
<span class="sig-name descname"><span class="pre">elementary</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.elementary" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Elementary"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonCommutativeSymmetricFunctions.Elementary</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.monomial">
<span class="sig-name descname"><span class="pre">monomial</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.monomial" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Monomial" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Monomial"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonCommutativeSymmetricFunctions.Monomial</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.nM">
<span class="sig-name descname"><span class="pre">nM</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.nM" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Monomial" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Monomial"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonCommutativeSymmetricFunctions.Monomial</span></code></a></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.ribbon">
<span class="sig-name descname"><span class="pre">ribbon</span></span><a class="headerlink" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.ribbon" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon" title="sage.combinat.ncsf_qsym.ncsf.NonCommutativeSymmetricFunctions.Ribbon"><code class="xref py py-class docutils literal notranslate"><span class="pre">NonCommutativeSymmetricFunctions.Ribbon</span></code></a></p>
</dd></dl>

</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="generic_basis_code.html"
                          title="previous chapter">Generic code for bases</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="qsym.html"
                          title="next chapter">Quasisymmetric functions</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/sage/combinat/ncsf_qsym/ncsf.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="qsym.html" title="Quasisymmetric functions"
             >next</a> |</li>
        <li class="right" >
          <a href="generic_basis_code.html" title="Generic code for bases"
             >previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="../../../../_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../../../../../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="../../../../index.html">Reference Manual</a> &#187;
      
      <a href="../../../index.html">Combinatorics</a> &#187;
    
  </li>

          <li class="nav-item nav-item-1"><a href="../../../module_list.html" >Comprehensive Module List</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Non-Commutative Symmetric Functions</a></li> 
      </ul>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2022, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
  </script>
  <script type="text/javascript">
/* detex the document title by removing "\(", "\)", "\", "$" */
document.title = document.title.replace(/\\\(/g, '').replace(/\\\)/g, '').replace(/\\/g, '').replace(/\$/g, '');
  </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>