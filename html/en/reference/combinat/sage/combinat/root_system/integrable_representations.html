
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Integrable Representations of Affine Lie Algebras &#8212; Combinatorics</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sage.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/thebelab.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/thebelab-helper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script async="async" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Nonsymmetric Macdonald polynomials" href="non_symmetric_macdonald_polynomials.html" />
    <link rel="prev" title="Hecke algebra representations" href="hecke_algebra_representation.html" />
  <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />
  <!-- <script src="../../../../_static/thebe.js" type="text/javascript"></script> -->
  <!-- <script src="../../../../_static/thebe-sage.js" type="text/javascript"></script> -->

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="non_symmetric_macdonald_polynomials.html" title="Nonsymmetric Macdonald polynomials"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="hecke_algebra_representation.html" title="Hecke algebra representations"
             accesskey="P">previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="../../../../_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../../../../../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="../../../../index.html">Reference Manual</a> &#187;
      
      <a href="../../../index.html">Combinatorics</a> &#187;
    
  </li>

          <li class="nav-item nav-item-1"><a href="../../../module_list.html" accesskey="U">Comprehensive Module List</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Integrable Representations of Affine Lie Algebras</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="integrable-representations-of-affine-lie-algebras">
<span id="sage-combinat-root-system-integrable-representations"></span><h1>Integrable Representations of Affine Lie Algebras<a class="headerlink" href="#integrable-representations-of-affine-lie-algebras" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.combinat.root_system.integrable_representations"></span><dl class="py class">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sage.combinat.root_system.integrable_representations.</span></span><span class="sig-name descname"><span class="pre">IntegrableRepresentation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Lam</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/unique_representation.html#sage.structure.unique_representation.UniqueRepresentation" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.unique_representation.UniqueRepresentation</span></code></a>, <a class="reference external" href="../../../../structure/sage/structure/category_object.html#sage.structure.category_object.CategoryObject" title="(in Parents and Elements v9.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.category_object.CategoryObject</span></code></a></p>
<p>An irreducible integrable highest weight representation of
an affine Lie algebra.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Lam</span></code> – a dominant weight in an extended weight lattice
of affine type</p></li>
</ul>
<p>REFERENCES:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../../../../references/index.html#ka1990" id="id1"><span>[Ka1990]</span></a></p></li>
</ul>
<dl class="citation">
<dt class="label" id="kmps"><span class="brackets">KMPS</span></dt>
<dd><p>Kass, Moody, Patera and Slansky, <em>Affine Lie algebras,
weight multiplicities, and branching rules</em>. Vols. 1, 2. University
of California Press, Berkeley, CA, 1990.</p>
</dd>
<dt class="label" id="kacpeterson"><span class="brackets">KacPeterson</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id9">2</a>)</span></dt>
<dd><p>Kac and Peterson. <em>Infinite-dimensional Lie algebras,
theta functions and modular forms</em>. Adv. in Math. 53 (1984),
no. 2, 125-264.</p>
</dd>
<dt class="label" id="carter"><span class="brackets">Carter</span></dt>
<dd><p>Carter, <em>Lie algebras of finite and affine type</em>. Cambridge 
University Press, 2005</p>
</dd>
</dl>
<p>If <span class="math notranslate nohighlight">\(\Lambda\)</span> is a dominant integral weight for an affine root system,
there exists a unique integrable representation <span class="math notranslate nohighlight">\(V=V_\Lambda\)</span> of highest
weight <span class="math notranslate nohighlight">\(\Lambda\)</span>. If <span class="math notranslate nohighlight">\(\mu\)</span> is another weight, let <span class="math notranslate nohighlight">\(m(\mu)\)</span> denote the
multiplicity of the weight <span class="math notranslate nohighlight">\(\mu\)</span> in this representation. The set
<span class="math notranslate nohighlight">\(\operatorname{supp}(V)\)</span> of <span class="math notranslate nohighlight">\(\mu\)</span> such that <span class="math notranslate nohighlight">\(m(\mu) &gt; 0\)</span> is contained in the
paraboloid</p>
<div class="math notranslate nohighlight">
\[(\Lambda+\rho | \Lambda+\rho) - (\mu+\rho | \mu+\rho) \geq 0\]</div>
<p>where <span class="math notranslate nohighlight">\((\, | \,)\)</span> is the invariant inner product on the weight
lattice and <span class="math notranslate nohighlight">\(\rho\)</span> is the Weyl vector. Moreover if <span class="math notranslate nohighlight">\(m(\mu)&gt;0\)</span>
then <span class="math notranslate nohighlight">\(\mu\in\operatorname{supp}(V)\)</span> differs from <span class="math notranslate nohighlight">\(\Lambda\)</span> by an element
of the root lattice (<a class="reference internal" href="../../../../references/index.html#ka1990" id="id2"><span>[Ka1990]</span></a>, Propositions 11.3 and 11.4).</p>
<p>Let <span class="math notranslate nohighlight">\(\delta\)</span> be the nullroot, which is the lowest positive imaginary
root. Then by <a class="reference internal" href="../../../../references/index.html#ka1990" id="id3"><span>[Ka1990]</span></a>, Proposition 11.3 or Corollary 11.9, for fixed <span class="math notranslate nohighlight">\(\mu\)</span>
the function <span class="math notranslate nohighlight">\(m(\mu - k\delta)\)</span> is a monotone increasing function of
<span class="math notranslate nohighlight">\(k\)</span>. It is useful to take <span class="math notranslate nohighlight">\(\mu\)</span> to be such that this function is nonzero
if and only if <span class="math notranslate nohighlight">\(k \geq 0\)</span>. Therefore we make the following definition.  If
<span class="math notranslate nohighlight">\(\mu\)</span> is such that <span class="math notranslate nohighlight">\(m(\mu) \neq 0\)</span> but <span class="math notranslate nohighlight">\(m(\mu + \delta) = 0\)</span> then <span class="math notranslate nohighlight">\(\mu\)</span> is
called <em>maximal</em>.</p>
<p>Since <span class="math notranslate nohighlight">\(\delta\)</span> is fixed under the action of the affine Weyl group,
and since the weight multiplicities are Weyl group invariant, the
function <span class="math notranslate nohighlight">\(k \mapsto m(\mu - k \delta)\)</span> is unchanged if <span class="math notranslate nohighlight">\(\mu\)</span> is replaced
by an equivalent weight. Therefore in tabulating these functions, we may
assume that <span class="math notranslate nohighlight">\(\mu\)</span> is dominant. There are only a finite number of dominant
maximal weights.</p>
<p>Since every nonzero weight multiplicity appears in the string
<span class="math notranslate nohighlight">\(\mu - k\delta\)</span> for one of the finite number of dominant maximal
weights <span class="math notranslate nohighlight">\(\mu\)</span>, it is important to be able to compute these. We may
do this as follows.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">print_strings</span><span class="p">()</span>
<span class="go">2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655</span>
<span class="go">Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570</span>
<span class="go">Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570</span>
<span class="go">Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178</span>
<span class="go">3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324</span>
<span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;D&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">print_strings</span><span class="p">()</span>                        <span class="c1"># long time</span>
<span class="go">Lambda[0] + Lambda[1]: 1 10 62 293 1165 4097 13120 38997 109036 289575 735870 1799620</span>
<span class="go">Lambda[3] + Lambda[4] - delta: 3 25 136 590 2205 7391 22780 65613 178660 463842 1155717 2777795</span>
</pre></div>
</div>
<p>In this example, we construct the extended weight lattice of Cartan
type <span class="math notranslate nohighlight">\(A_3^{(1)}\)</span>, then define <code class="docutils literal notranslate"><span class="pre">Lambda</span></code> to be the fundamental
weights <span class="math notranslate nohighlight">\((\Lambda_i)_{i \in I}\)</span>. We find there are 5 maximal
dominant weights in irreducible representation of highest weight
<span class="math notranslate nohighlight">\(\Lambda_1 + \Lambda_2 + \Lambda_3\)</span>, and we determine their strings.</p>
<p>It was shown in <a class="reference internal" href="#kacpeterson" id="id4"><span>[KacPeterson]</span></a> that each string is the set of Fourier
coefficients of a modular form.</p>
<p>Every weight <span class="math notranslate nohighlight">\(\mu\)</span> such that the weight multiplicity <span class="math notranslate nohighlight">\(m(\mu)\)</span> is
nonzero has the form</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\Lambda - n_0 \alpha_0 - n_1 \alpha_1 - \cdots,\]</div>
</div></blockquote>
<p>where the <span class="math notranslate nohighlight">\(n_i\)</span> are nonnegative integers. This is represented internally
as a tuple <span class="math notranslate nohighlight">\((n_0, n_1, n_2, \ldots)\)</span>. If you want an individual
multiplicity you use the method <a class="reference internal" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.m" title="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.m"><code class="xref py py-meth docutils literal notranslate"><span class="pre">m()</span></code></a> and supply it with this tuple:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="n">V</span>
<span class="go">Integrable representation of [&#39;C&#39;, 2, 1] with highest weight 2*Lambda[0]</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">m</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="go">18</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation" title="sage.combinat.root_system.integrable_representations.IntegrableRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegrableRepresentation</span></code></a> class has methods <a class="reference internal" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.to_weight" title="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.to_weight"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_weight()</span></code></a>
and <a class="reference internal" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.from_weight" title="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.from_weight"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_weight()</span></code></a> to convert between this internal representation
and the weight lattice:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">delta</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">()</span><span class="o">.</span><span class="n">null_root</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">to_weight</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="go">-3*Lambda[0] + 6*Lambda[1] - Lambda[2] - 4*delta</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">from_weight</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Lambda</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">delta</span><span class="p">)</span>
<span class="go">(4, 3, 2)</span>
</pre></div>
</div>
<p>To get more values, use the depth parameter:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L0</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weight</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">L0</span>
<span class="go">Lambda[0]</span>
<span class="gp">sage: </span><span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">L0</span><span class="p">)</span><span class="o">.</span><span class="n">print_strings</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="go">4*Lambda[0]: 1 1 3 6 13 23 44 75 131 215 354 561 889 1368 2097 3153 4712 6936 10151 14677</span>
<span class="go">2*Lambda[0] + 2*Lambda[1] - delta: 1 2 5 10 20 36 66 112 190 310 501 788 1230 1880 2850 4256 6303 9222 13396 19262</span>
<span class="go">4*Lambda[1] - 2*delta: 1 2 6 11 23 41 75 126 215 347 561 878 1368 2082 3153 4690 6936 10121 14677 21055</span>
</pre></div>
</div>
<p>An example in type <span class="math notranslate nohighlight">\(C_2^{(1)}\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">print_strings</span><span class="p">()</span>    <span class="c1"># long time</span>
<span class="go">2*Lambda[0]: 1 2 9 26 77 194 477 1084 2387 5010 10227 20198</span>
<span class="go">Lambda[0] + Lambda[2] - delta: 1 5 18 55 149 372 872 1941 4141 8523 17005 33019</span>
<span class="go">2*Lambda[1] - delta: 1 4 15 44 122 304 721 1612 3469 7176 14414 28124</span>
<span class="go">2*Lambda[2] - 2*delta: 2 7 26 72 194 467 1084 2367 5010 10191 20198 38907</span>
</pre></div>
</div>
<p>Examples for twisted affine types:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">strings</span><span class="p">()</span>
<span class="go">{Lambda[0]: [1, 1, 2, 3, 5, 7, 11, 15, 22, 30, 42, 56]}</span>
<span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;G&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">dual</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">print_strings</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">6*Lambdacheck[0]: 4 28 100 320 944 2460 6064 14300 31968 69020 144676 293916</span>
<span class="go">3*Lambdacheck[0] + Lambdacheck[1]: 2 16 58 192 588 1568 3952 9520 21644 47456 100906 207536</span>
<span class="go">4*Lambdacheck[0] + Lambdacheck[2]: 4 22 84 276 800 2124 5288 12470 28116 61056 128304 261972</span>
<span class="go">2*Lambdacheck[1] - deltacheck: 2 8 32 120 354 980 2576 6244 14498 32480 69776 145528</span>
<span class="go">Lambdacheck[0] + Lambdacheck[1] + Lambdacheck[2]: 1 6 26 94 294 832 2184 5388 12634 28390 61488 128976</span>
<span class="go">2*Lambdacheck[0] + 2*Lambdacheck[2]: 2 12 48 164 492 1344 3428 8256 18960 41844 89208 184512</span>
<span class="go">3*Lambdacheck[2] - deltacheck: 4 16 60 208 592 1584 4032 9552 21728 47776 101068 207888</span>
<span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">print_strings</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">5*Lambda[0]: 3 42 378 2508 13707 64650 272211 1045470 3721815 12425064 39254163 118191378</span>
<span class="go">3*Lambda[0] + Lambda[2]: 1 23 234 1690 9689 47313 204247 800029 2893198 9786257 31262198 95035357</span>
<span class="go">Lambda[0] + 2*Lambda[1]: 1 14 154 1160 6920 34756 153523 612354 2248318 7702198 24875351 76341630</span>
<span class="go">Lambda[0] + Lambda[1] + Lambda[3] - 2*delta: 6 87 751 4779 25060 113971 464842 1736620 6034717 19723537 61152367 181068152</span>
<span class="go">Lambda[0] + 2*Lambda[2] - 2*delta: 3 54 499 3349 18166 84836 353092 1341250 4725259 15625727 48938396 146190544</span>
<span class="go">Lambda[0] + 2*Lambda[3] - 4*delta: 15 195 1539 9186 45804 200073 789201 2866560 9723582 31120281 94724550 275919741</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.branch">
<span class="sig-name descname"><span class="pre">branch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weyl_character_ring</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sequence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.branch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the branching rule on <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>Removing any node from the extended Dynkin diagram of the affine
Lie algebra results in the Dynkin diagram of a classical Lie
algebra, which is therefore a Lie subalgebra. For example
removing the <span class="math notranslate nohighlight">\(0\)</span> node from the Dynkin diagram of type <code class="docutils literal notranslate"><span class="pre">[X,</span> <span class="pre">r,</span> <span class="pre">1]</span></code>
produces the classical Dynkin diagram of <code class="docutils literal notranslate"><span class="pre">[X,</span> <span class="pre">r]</span></code>.</p>
<p>Thus for each <span class="math notranslate nohighlight">\(i\)</span> in the index set, we may restrict <code class="docutils literal notranslate"><span class="pre">self</span></code> to
the corresponding classical subalgebra. Of course <code class="docutils literal notranslate"><span class="pre">self</span></code> is
an infinite dimensional representation, but each weight <span class="math notranslate nohighlight">\(\mu\)</span>
is assigned a grading by the number of times the simple root
<span class="math notranslate nohighlight">\(\alpha_i\)</span> appears in <span class="math notranslate nohighlight">\(\Lambda-\mu\)</span>. Thus the branched
representation is graded and we get sequence of finite-dimensional
representations which this method is able to compute.</p>
<p>OPTIONAL:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code> – (default: 0) an element of the index set</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">weyl_character_ring</span></code> – a WeylCharacterRing</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sequence</span></code> – a dictionary</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">depth</span></code> – (default: 5) an upper bound for <span class="math notranslate nohighlight">\(k\)</span> determining
how many terms to give</p></li>
</ul>
<p>In the default case where <span class="math notranslate nohighlight">\(i = 0\)</span>, you do not need to specify
anything else, though you may want to increase the depth if
you need more terms.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">branch</span><span class="p">();</span> <span class="n">b</span>
<span class="go">[A2(0,0),</span>
<span class="go"> A2(1,1),</span>
<span class="go"> A2(0,0) + 2*A2(1,1) + A2(2,2),</span>
<span class="go"> 2*A2(0,0) + 2*A2(0,3) + 4*A2(1,1) + 2*A2(3,0) + 2*A2(2,2),</span>
<span class="go"> 4*A2(0,0) + 3*A2(0,3) + 10*A2(1,1) + 3*A2(3,0) + A2(1,4) + 6*A2(2,2) + A2(4,1),</span>
<span class="go"> 6*A2(0,0) + 9*A2(0,3) + 20*A2(1,1) + 9*A2(3,0) + 3*A2(1,4) + 12*A2(2,2) + 3*A2(4,1) + A2(3,3)]</span>
</pre></div>
</div>
<p>If the parameter <code class="docutils literal notranslate"><span class="pre">weyl_character_ring</span></code> is omitted, the ring may be recovered
as the parent of one of the branched coefficients:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A2</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span><span class="p">();</span> <span class="n">A2</span>
<span class="go">The Weyl Character Ring of Type A2 with Integer Ring coefficients</span>
</pre></div>
</div>
<p>If <span class="math notranslate nohighlight">\(i\)</span> is not zero then you should specify the <a class="reference internal" href="weyl_characters.html#sage.combinat.root_system.weyl_characters.WeylCharacterRing" title="sage.combinat.root_system.weyl_characters.WeylCharacterRing"><code class="xref py py-class docutils literal notranslate"><span class="pre">WeylCharacterRing</span></code></a> that you
are branching to. This is determined by the Dynkin diagram:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">cartan_type</span><span class="p">()</span><span class="o">.</span><span class="n">dynkin_diagram</span><span class="p">()</span>
<span class="go">    O 0</span>
<span class="go">    |</span>
<span class="go">    |</span>
<span class="go">O---O=&gt;=O</span>
<span class="go">1   2   3   </span>
<span class="go">B3~</span>
</pre></div>
</div>
<p>In this example, we observe that removing the <span class="math notranslate nohighlight">\(i=2\)</span> node from the
Dynkin diagram produces a reducible diagram of type <code class="docutils literal notranslate"><span class="pre">A1xA1xA1</span></code>.
Thus we have a branching to
<span class="math notranslate nohighlight">\(\mathfrak{sl}(2) \times \mathfrak{sl}(2) \times \mathfrak{sl}(2)\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">A1xA1xA1</span> <span class="o">=</span> <span class="n">WeylCharacterRing</span><span class="p">(</span><span class="s2">&quot;A1xA1xA1&quot;</span><span class="p">,</span><span class="n">style</span><span class="o">=</span><span class="s2">&quot;coroots&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">branch</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">weyl_character_ring</span><span class="o">=</span><span class="n">A1xA1xA1</span><span class="p">)</span>
<span class="go">[A1xA1xA1(1,0,0),</span>
<span class="go"> A1xA1xA1(0,1,2),</span>
<span class="go"> A1xA1xA1(1,0,0) + A1xA1xA1(1,2,0) + A1xA1xA1(1,0,2),</span>
<span class="go"> A1xA1xA1(2,1,2) + A1xA1xA1(0,1,0) + 2*A1xA1xA1(0,1,2),</span>
<span class="go"> 3*A1xA1xA1(1,0,0) + 2*A1xA1xA1(1,2,0) + A1xA1xA1(1,2,2) + 2*A1xA1xA1(1,0,2) + A1xA1xA1(1,0,4) + A1xA1xA1(3,0,0),</span>
<span class="go"> A1xA1xA1(2,1,0) + 3*A1xA1xA1(2,1,2) + 2*A1xA1xA1(0,1,0) + 5*A1xA1xA1(0,1,2) + A1xA1xA1(0,1,4) + A1xA1xA1(0,3,2)]</span>
</pre></div>
</div>
<p>If the nodes of the two Dynkin diagrams are not in the same order, you
must specify an additional parameter, <code class="docutils literal notranslate"><span class="pre">sequence</span></code> which gives a dictionary
to the affine Dynkin diagram to the classical one.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">cartan_type</span><span class="p">()</span><span class="o">.</span><span class="n">dynkin_diagram</span><span class="p">()</span>
<span class="go">O---O---O=&gt;=O---O</span>
<span class="go">0   1   2   3   4   </span>
<span class="go">F4~</span>
<span class="gp">sage: </span><span class="n">A1xC3</span><span class="o">=</span><span class="n">WeylCharacterRing</span><span class="p">(</span><span class="s2">&quot;A1xC3&quot;</span><span class="p">,</span><span class="n">style</span><span class="o">=</span><span class="s2">&quot;coroots&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A1xC3</span><span class="o">.</span><span class="n">dynkin_diagram</span><span class="p">()</span>
<span class="go">O</span>
<span class="go">1   </span>
<span class="go">O---O=&lt;=O</span>
<span class="go">2   3   4   </span>
<span class="go">A1xC3</span>
</pre></div>
</div>
<p>Observe that removing the <span class="math notranslate nohighlight">\(i=1\)</span> node from the <code class="docutils literal notranslate"><span class="pre">F4~</span></code> Dynkin diagram
gives the <code class="docutils literal notranslate"><span class="pre">A1xC3</span></code> diagram, but the roots are in a different order.
The nodes <span class="math notranslate nohighlight">\(0, 2, 3, 4\)</span> of <code class="docutils literal notranslate"><span class="pre">F4~</span></code> correspond to <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">4,</span> <span class="pre">3,</span> <span class="pre">2</span></code>
of <code class="docutils literal notranslate"><span class="pre">A1xC3</span></code> and so we encode this in a dictionary:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">branch</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">weyl_character_ring</span><span class="o">=</span><span class="n">A1xC3</span><span class="p">,</span><span class="n">sequence</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span> <span class="c1"># long time</span>
<span class="go">[A1xC3(1,0,0,0),</span>
<span class="go"> A1xC3(0,0,0,1),</span>
<span class="go"> A1xC3(1,0,0,0) + A1xC3(1,2,0,0),</span>
<span class="go"> A1xC3(2,0,0,1) + A1xC3(0,0,0,1) + A1xC3(0,1,1,0),</span>
<span class="go"> 2*A1xC3(1,0,0,0) + A1xC3(1,0,1,0) + 2*A1xC3(1,2,0,0) + A1xC3(1,0,2,0) + A1xC3(3,0,0,0),</span>
<span class="go"> 2*A1xC3(2,0,0,1) + A1xC3(2,1,1,0) + A1xC3(0,1,0,0) + 3*A1xC3(0,0,0,1) + 2*A1xC3(0,1,1,0) + A1xC3(0,2,0,1)]</span>
</pre></div>
</div>
<p>The branch method gives a way of computing the graded dimension of the integrable representation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">(</span><span class="s2">&quot;A1~&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">=</span><span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">V</span><span class="o">.</span><span class="n">branch</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">15</span><span class="p">)];</span> <span class="n">r</span>
<span class="go">[1, 3, 4, 7, 13, 19, 29, 43, 62, 90, 126, 174, 239, 325, 435, 580]</span>
<span class="gp">sage: </span><span class="n">oeis</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>                                                        <span class="c1"># optional -- internet</span>
<span class="go">0: A029552: Expansion of phi(x) / f(-x) in powers of x where phi(), f() are Ramanujan theta functions.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.cartan_type">
<span class="sig-name descname"><span class="pre">cartan_type</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.cartan_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Cartan type of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">cartan_type</span><span class="p">()</span>
<span class="go">[&#39;F&#39;, 4, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.coxeter_number">
<span class="sig-name descname"><span class="pre">coxeter_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.coxeter_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Coxeter number of the Cartan type of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The Coxeter number is defined in <a class="reference internal" href="../../../../references/index.html#ka1990" id="id5"><span>[Ka1990]</span></a> Chapter 6, and commonly
denoted <span class="math notranslate nohighlight">\(h\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">coxeter_number</span><span class="p">()</span>
<span class="go">12</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.dominant_maximal_weights">
<span class="sig-name descname"><span class="pre">dominant_maximal_weights</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.dominant_maximal_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dominant maximal weights of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>A weight <span class="math notranslate nohighlight">\(\mu\)</span> is <em>maximal</em> if it has nonzero multiplicity but
<span class="math notranslate nohighlight">\(\mu + \delta\)</span> has multiplicity zero. There are a finite number
of dominant maximal weights. Indeed, <a class="reference internal" href="../../../../references/index.html#ka1990" id="id6"><span>[Ka1990]</span></a> Proposition 12.6
shows that the dominant maximal weights are in bijection with
the classical weights in <span class="math notranslate nohighlight">\(k \cdot F\)</span> where <span class="math notranslate nohighlight">\(F\)</span> is the fundamental
alcove and <span class="math notranslate nohighlight">\(k\)</span> is the level. The construction used in this
method is based on that Proposition.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">dominant_maximal_weights</span><span class="p">()</span>
<span class="go">(2*Lambda[0],</span>
<span class="go"> Lambda[0] + Lambda[2] - delta,</span>
<span class="go"> 2*Lambda[1] - delta,</span>
<span class="go"> Lambda[1] + Lambda[3] - 2*delta,</span>
<span class="go"> 2*Lambda[2] - 2*delta,</span>
<span class="go"> 2*Lambda[3] - 3*delta)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.dual_coxeter_number">
<span class="sig-name descname"><span class="pre">dual_coxeter_number</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.dual_coxeter_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual Coxeter number of the Cartan type of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The dual Coxeter number is defined in <a class="reference internal" href="../../../../references/index.html#ka1990" id="id7"><span>[Ka1990]</span></a> Chapter 6, and commonly
denoted <span class="math notranslate nohighlight">\(h^{\vee}\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">dual_coxeter_number</span><span class="p">()</span>
<span class="go">9</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.from_weight">
<span class="sig-name descname"><span class="pre">from_weight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.from_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the tuple <span class="math notranslate nohighlight">\((n_0, n_1, ...)\)</span> such that <code class="docutils literal notranslate"><span class="pre">mu</span></code> equals
<span class="math notranslate nohighlight">\(\Lambda - \sum_{i \in I} n_i \alpha_i\)</span> in <code class="docutils literal notranslate"><span class="pre">self</span></code>, where <span class="math notranslate nohighlight">\(\Lambda\)</span>
is the highest weight of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">to_weight</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">-2*Lambda[0] + Lambda[1] + 3*Lambda[2] - delta</span>
<span class="gp">sage: </span><span class="n">delta</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">()</span><span class="o">.</span><span class="n">null_root</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">from_weight</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">delta</span><span class="p">)</span>
<span class="go">(1, 0, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.highest_weight">
<span class="sig-name descname"><span class="pre">highest_weight</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.highest_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the highest weight of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;D&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">highest_weight</span><span class="p">()</span>
<span class="go">Lambda[0] + 2*Lambda[2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.level">
<span class="sig-name descname"><span class="pre">level</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.level" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The level of a highest weight representation <span class="math notranslate nohighlight">\(V_{\Lambda}\)</span> is
defined as <span class="math notranslate nohighlight">\((\Lambda | \delta)\)</span> See <a class="reference internal" href="../../../../references/index.html#ka1990" id="id8"><span>[Ka1990]</span></a> section 12.4.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;G&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">level</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
<span class="go">[1, 1, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.m">
<span class="sig-name descname"><span class="pre">m</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.m" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the multiplicity of the weight <span class="math notranslate nohighlight">\(\mu\)</span> in <code class="docutils literal notranslate"><span class="pre">self</span></code>, where
<span class="math notranslate nohighlight">\(\mu = \Lambda - \sum_i n_i \alpha_i\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a tuple representing a weight <span class="math notranslate nohighlight">\(\mu\)</span>.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;E&#39;</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">u</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">highest_weight</span><span class="p">()</span> <span class="o">-</span> <span class="n">V</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">()</span><span class="o">.</span><span class="n">null_root</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">from_weight</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="go">(1, 1, 2, 2, 3, 2, 1)</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">m</span><span class="p">(</span><span class="n">V</span><span class="o">.</span><span class="n">from_weight</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.modular_characteristic">
<span class="sig-name descname"><span class="pre">modular_characteristic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.modular_characteristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the modular characteristic of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>The modular characteristic is a rational number introduced
by Kac and Peterson <a class="reference internal" href="#kacpeterson" id="id9"><span>[KacPeterson]</span></a>, required to interpret the
string functions as Fourier coefficients of modular forms. See
<a class="reference internal" href="../../../../references/index.html#ka1990" id="id10"><span>[Ka1990]</span></a> Section 12.7. Let <span class="math notranslate nohighlight">\(k\)</span> be the level, and let <span class="math notranslate nohighlight">\(h^\vee\)</span>
be the dual Coxeter number. Then</p>
<div class="math notranslate nohighlight">
\[m_\Lambda = \frac{|\Lambda+\rho|^2}{2(k+h^\vee)}
- \frac{|\rho|^2}{2h^\vee}\]</div>
<p>If <span class="math notranslate nohighlight">\(\mu\)</span> is a weight, then</p>
<div class="math notranslate nohighlight">
\[m_{\Lambda,\mu} = m_\Lambda - \frac{|\mu|^2}{2k}.\]</div>
<p>OPTIONAL:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mu</span></code> – a weight; or alternatively:</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a tuple representing a weight <span class="math notranslate nohighlight">\(\mu\)</span>.</p></li>
</ul>
<p>If no optional parameter is specified, this returns <span class="math notranslate nohighlight">\(m_\Lambda\)</span>.
If <code class="docutils literal notranslate"><span class="pre">mu</span></code> is specified, it returns <span class="math notranslate nohighlight">\(m_{\Lambda,\mu}\)</span>. You may
use the tuple <code class="docutils literal notranslate"><span class="pre">n</span></code> to specify <span class="math notranslate nohighlight">\(\mu\)</span>. If you do this, <span class="math notranslate nohighlight">\(\mu\)</span> is
<span class="math notranslate nohighlight">\(\Lambda - \sum_i n_i \alpha_i\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">V</span><span class="o">.</span><span class="n">modular_characteristic</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">V</span><span class="o">.</span><span class="n">dominant_maximal_weights</span><span class="p">()]</span>
<span class="go">[11/56, -1/280, 111/280]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.mult">
<span class="sig-name descname"><span class="pre">mult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.mult" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the weight multiplicity of <code class="docutils literal notranslate"><span class="pre">mu</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mu</span></code> – an element of the weight lattice</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">(</span><span class="s2">&quot;B3~&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">delta</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">null_root</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">weyl_group</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">s0</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">s3</span><span class="p">]</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">simple_reflections</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">mult</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">delta</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">mult</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span><span class="o">.</span><span class="n">action</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">delta</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">s0</span><span class="o">*</span><span class="n">s1</span><span class="o">*</span><span class="n">s2</span><span class="o">*</span><span class="n">s3</span><span class="p">]]</span>
<span class="gp">sage: </span><span class="n">weights</span>
<span class="go">[-Lambda[1] + Lambda[2] - 4*delta,</span>
<span class="go">Lambda[1] - 4*delta,</span>
<span class="go">-Lambda[1] + Lambda[2] - 4*delta]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">V</span><span class="o">.</span><span class="n">mult</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">]</span>
<span class="go">[35, 35, 35]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.print_strings">
<span class="sig-name descname"><span class="pre">print_strings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.print_strings" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the strings of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.strings" title="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.strings"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strings()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">print_strings</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="go">2*Lambda[0]: 1 1 3 5 10 16 28 43 70 105 161 236 350 501 722 1016 1431 1981 2741 3740 5096 6868 9233 12306 16357</span>
<span class="go">2*Lambda[1] - delta: 1 2 4 7 13 21 35 55 86 130 196 287 420 602 858 1206 1687 2331 3206 4368 5922 7967 10670 14193 18803</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.root_lattice">
<span class="sig-name descname"><span class="pre">root_lattice</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.root_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the root lattice associated to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span><span class="o">=</span><span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;F&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weight</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">root_lattice</span><span class="p">()</span>
<span class="go">Root lattice of the Root system of type [&#39;F&#39;, 4, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.s">
<span class="sig-name descname"><span class="pre">s</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.s" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the action of the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th simple reflection on the
internal representation of weights by tuples <code class="docutils literal notranslate"><span class="pre">n</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weight</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">V</span><span class="o">.</span><span class="n">s</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">V</span><span class="o">.</span><span class="n">_index_set</span><span class="p">]</span>
<span class="go">[(1, 0, 0), (0, 0, 0), (0, 0, 0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.string">
<span class="sig-name descname"><span class="pre">string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of multiplicities <span class="math notranslate nohighlight">\(m(\Lambda - k \delta)\)</span> in
<code class="docutils literal notranslate"><span class="pre">self</span></code>, where <span class="math notranslate nohighlight">\(\Lambda\)</span> is <code class="docutils literal notranslate"><span class="pre">max_weight</span></code> and <span class="math notranslate nohighlight">\(k\)</span> runs from <span class="math notranslate nohighlight">\(0\)</span>
to <code class="docutils literal notranslate"><span class="pre">depth</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_weight</span></code> – a dominant maximal weight</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">depth</span></code> – (default: 12) the maximum value of <span class="math notranslate nohighlight">\(k\)</span></p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">string</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[1, 2, 8, 20, 52, 116, 256, 522, 1045, 1996, 3736, 6780]</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">string</span><span class="p">(</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">Lambda</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="go">[0, 1, 4, 12, 32, 77, 172, 365, 740, 1445, 2736, 5041]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.strings">
<span class="sig-name descname"><span class="pre">strings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.strings" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set of dominant maximal weights of <code class="docutils literal notranslate"><span class="pre">self</span></code>, together
with the string coefficients for each.</p>
<p>OPTIONAL:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">depth</span></code> – (default: 12) a parameter indicating how far
to push computations</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">strings</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">S</span><span class="p">[</span><span class="n">k</span><span class="p">])))</span>
<span class="go">2*Lambda[0]: 1 1 3 5 10 16 28 43 70 105 161 236 350 501 722 1016 1431 1981 2741 3740 5096 6868 9233 12306 16357</span>
<span class="go">2*Lambda[1] - delta: 1 2 4 7 13 21 35 55 86 130 196 287 420 602 858 1206 1687 2331 3206 4368 5922 7967 10670 14193 18803</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.to_dominant">
<span class="sig-name descname"><span class="pre">to_dominant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.to_dominant" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dominant weight in <code class="docutils literal notranslate"><span class="pre">self</span></code> equivalent to <code class="docutils literal notranslate"><span class="pre">n</span></code>
under the affine Weyl group.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">n</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">to_dominant</span><span class="p">((</span><span class="mi">13</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">7</span><span class="p">));</span> <span class="n">n</span>
<span class="go">(4, 3, 3)</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">to_weight</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">Lambda[0] + Lambda[1] + Lambda[2] - 4*delta</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.to_weight">
<span class="sig-name descname"><span class="pre">to_weight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.to_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the weight associated to the tuple <code class="docutils literal notranslate"><span class="pre">n</span></code> in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">n</span></code> is the tuple <span class="math notranslate nohighlight">\((n_1, n_2, \ldots)\)</span>, then the associated
weight is <span class="math notranslate nohighlight">\(\Lambda - \sum_i n_i \alpha_i\)</span>, where <span class="math notranslate nohighlight">\(\Lambda\)</span>
is the weight of the representation.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – a tuple representing a weight</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Lambda</span> <span class="o">=</span> <span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weights</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">V</span> <span class="o">=</span> <span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Lambda</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">to_weight</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">-2*Lambda[0] + Lambda[1] + 3*Lambda[2] - delta</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.combinat.root_system.integrable_representations.IntegrableRepresentation.weight_lattice">
<span class="sig-name descname"><span class="pre">weight_lattice</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.combinat.root_system.integrable_representations.IntegrableRepresentation.weight_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the weight lattice associated to <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">V</span><span class="o">=</span><span class="n">IntegrableRepresentation</span><span class="p">(</span><span class="n">RootSystem</span><span class="p">([</span><span class="s1">&#39;E&#39;</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">(</span><span class="n">extended</span><span class="o">=</span><span class="n">true</span><span class="p">)</span><span class="o">.</span><span class="n">fundamental_weight</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">V</span><span class="o">.</span><span class="n">weight_lattice</span><span class="p">()</span>
<span class="go">Extended weight lattice of the Root system of type [&#39;E&#39;, 6, 1]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="hecke_algebra_representation.html"
                          title="previous chapter">Hecke algebra representations</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="non_symmetric_macdonald_polynomials.html"
                          title="next chapter">Nonsymmetric Macdonald polynomials</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/sage/combinat/root_system/integrable_representations.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="non_symmetric_macdonald_polynomials.html" title="Nonsymmetric Macdonald polynomials"
             >next</a> |</li>
        <li class="right" >
          <a href="hecke_algebra_representation.html" title="Hecke algebra representations"
             >previous</a> |</li>
  <li class="nav-item nav-item-0">
    <a href="http://www.sagemath.org"><img src="../../../../_static/logo_sagemath_black.svg" class="sage-logo" title="Sage Logo"></a>
    
      <a href="../../../../../index.html">Sage 9.6 Documentation</a> &#187;
      
      <a href="../../../../index.html">Reference Manual</a> &#187;
      
      <a href="../../../index.html">Combinatorics</a> &#187;
    
  </li>

          <li class="nav-item nav-item-1"><a href="../../../module_list.html" >Comprehensive Module List</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Integrable Representations of Affine Lie Algebras</a></li> 
      </ul>
    </div>
  
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2022, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
  </script>
  <script type="text/javascript">
/* detex the document title by removing "\(", "\)", "\", "$" */
document.title = document.title.replace(/\\\(/g, '').replace(/\\\)/g, '').replace(/\\/g, '').replace(/\$/g, '');
  </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>