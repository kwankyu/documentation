
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Unique Representation &#8212; Sage Reference Manual v8.9: Parents and Elements</title>
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Factory for cached representations" href="factory.html" />
    <link rel="prev" title="Cython-like rich comparisons in Python" href="richcmp.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="factory.html" title="Factory for cached representations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="richcmp.html" title="Cython-like rich comparisons in Python"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Parents and Elements</a> &#187;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="unique-representation">
<span id="sage-structure-unique-representation"></span><h1>Unique Representation<a class="headerlink" href="#unique-representation" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.structure.unique_representation"></span><p>Abstract classes for cached and unique representation behavior.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="factory.html#sage.structure.factory.UniqueFactory" title="sage.structure.factory.UniqueFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.factory.UniqueFactory</span></code></a></p>
</div>
<p>AUTHORS:</p>
<ul class="simple">
<li>Nicolas M. Thiery (2008): Original version.</li>
<li>Simon A. King (2013-02): Separate cached and unique representation.</li>
<li>Simon A. King (2013-08): Extended documentation.</li>
</ul>
<div class="section" id="what-is-a-cached-representation">
<h2>What is a cached representation?<a class="headerlink" href="#what-is-a-cached-representation" title="Permalink to this headline">¶</a></h2>
<p>Instances of a class have a <em>cached representation behavior</em> when several
instances constructed with the same arguments share the same memory
representation. For example, calling twice:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">H</span> <span class="o">=</span> <span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>to create the symmetric group on six elements gives back the same
object:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="ow">is</span> <span class="n">H</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This is a standard design pattern. Besides saving memory, it allows for
sharing cached data (say representation theoretical information about a
group). And of course a look-up in the cache is faster than the creation of a
new object.</p>
<div class="section" id="implementing-a-cached-representation">
<h3>Implementing a cached representation<a class="headerlink" href="#implementing-a-cached-representation" title="Permalink to this headline">¶</a></h3>
<p>Sage provides two standard ways to create a cached representation:
<a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a> and
<a class="reference internal" href="factory.html#sage.structure.factory.UniqueFactory" title="sage.structure.factory.UniqueFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueFactory</span></code></a>. Note that, in spite of its
name, <a class="reference internal" href="factory.html#sage.structure.factory.UniqueFactory" title="sage.structure.factory.UniqueFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueFactory</span></code></a> does not ensure <em>unique</em>
representation behaviour, which will be explained below.</p>
<div class="section" id="using-cachedrepresentation">
<h4>Using <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a><a class="headerlink" href="#using-cachedrepresentation" title="Permalink to this headline">¶</a></h4>
<p>It is often very easy to use <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a>: One simply writes
a Python class and adds <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a> to the list of base
classes. If one does so, then the arguments used to create an instance of this
class will by default also be used as keys for the cache:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.structure.unique_representation</span> <span class="kn">import</span> <span class="n">CachedRepresentation</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="s2">&quot;C(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In addition, pickling just works, provided that Python is able to look up the
class. Hence, in the following two lines, we explicitly put the class into the
<code class="docutils literal notranslate"><span class="pre">__main__</span></code> module. This is needed in doctests, but not in an interactive
session:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">C</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Often, this very easy approach is sufficient for applications. However, there
are some pitfalls. Since the arguments are used for caching, all arguments
must be hashable, i.e., must be valid as dictionary keys:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="go">C((1, 2), 0)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: unhashable type: &#39;list&#39;</span>
</pre></div>
</div>
<p>In addition, equivalent ways of providing the arguments are <em>not</em>
automatically normalised when forming the cache key, and hence different but
equivalent arguments may yield distinct instances:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">repr</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="nb">repr</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It should also be noted that the arguments are compared by equality, not by
identity. This is often desired, but can imply subtle problems. For example,
since <code class="docutils literal notranslate"><span class="pre">C(1)</span></code> already is in the cache, and since the unit elements in
different finite fields are all equal to the integer one, we find:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">)(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">1</span><span class="p">))</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">)(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But <code class="docutils literal notranslate"><span class="pre">C(2)</span></code> is not in the cache, and the number two is not equal in different
finite fields (i. e., <code class="docutils literal notranslate"><span class="pre">GF(5)(2)</span> <span class="pre">==</span> <span class="pre">GF(3)(2)</span></code> returns as <code class="docutils literal notranslate"><span class="pre">False</span></code>), even
though it is equal to the number two in the ring of integers (
<code class="docutils literal notranslate"><span class="pre">GF(5)(2)</span> <span class="pre">==</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">GF(3)(2)</span></code> returns as <code class="docutils literal notranslate"><span class="pre">True</span></code>; equality is not transitive
when comparing elements of <em>distinct</em> algebraic structures!!). Hence, we
have:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">)(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">2</span><span class="p">))</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">)(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="section" id="normalising-the-arguments">
<h5>Normalising the arguments<a class="headerlink" href="#normalising-the-arguments" title="Permalink to this headline">¶</a></h5>
<p><a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a> uses the metaclass
<a class="reference external" href="../../../misc/sage/misc/classcall_metaclass.html#sage.misc.classcall_metaclass.ClasscallMetaclass" title="(in Sage Reference Manual: Utilities v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClasscallMetaclass</span></code></a>. Its
<code class="docutils literal notranslate"><span class="pre">__classcall__</span></code> method is a
<a class="reference external" href="../../../misc/sage/misc/cachefunc.html#sage.misc.cachefunc.WeakCachedFunction" title="(in Sage Reference Manual: Utilities v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">WeakCachedFunction</span></code></a>.  This function creates an
instance of the given class using the given arguments, unless it finds the
result in the cache. This has the following implications:</p>
<ul class="simple">
<li>The arguments must be valid dictionary keys (i.e., they must be hashable;
see above).</li>
<li>It is a weak cache, hence, if the user does not keep a reference to the
resulting instance, then it may be removed from the cache during garbage
collection.</li>
<li>It is possible to preprocess the input arguments by implementing a
<code class="docutils literal notranslate"><span class="pre">__classcall__</span></code> or a <code class="docutils literal notranslate"><span class="pre">__classcall_private__</span></code> method, but in order to
benefit from caching, <code class="xref py py-meth docutils literal notranslate"><span class="pre">CachedRepresentation.__classcall__()</span></code> should at
some point be called.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>For technical reasons, it is needed that <code class="docutils literal notranslate"><span class="pre">__classcall__</span></code> respectively
<code class="docutils literal notranslate"><span class="pre">__classcall_private__</span></code> are “static methods”, i.e., they are callable
objects that do not bind to an instance or class. For example, a
<code class="xref py py-class docutils literal notranslate"><span class="pre">cached_function</span></code> can be used here, because it
is callable, but does not bind to an instance or class, because it has no
<code class="docutils literal notranslate"><span class="pre">__get__()</span></code> method. A usual Python function, however, has a
<code class="docutils literal notranslate"><span class="pre">__get__()</span></code> method and would thus under normal circumstances bind to an
instance or class, and thus the instance or class would be passed to the
function as the first argument. To prevent a callable object from being
bound to the instance or class, one can prepend the <code class="docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code>
decorator to the definition; see <code class="xref py py-class docutils literal notranslate"><span class="pre">staticmethod</span></code>.</p>
<p class="last">For more on Python’s <code class="docutils literal notranslate"><span class="pre">__get__()</span></code> method, see:
<a class="reference external" href="https://docs.python.org/2/howto/descriptor.html">https://docs.python.org/2/howto/descriptor.html</a></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If there is preprocessing, then the preprocessed arguments
passed to <code class="xref py py-meth docutils literal notranslate"><span class="pre">CachedRepresentation.__classcall__()</span></code> must be invariant
under the preprocessing. That is to say, preprocessing the input
arguments twice must have the same effect as preprocessing the input
arguments only once. That is to say, the preprocessing must be idempotent.</p>
</div>
<p>The reason for this warning lies in the way pickling is implemented. If the
preprocessed arguments are passed to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">CachedRepresentation.__classcall__()</span></code>, then the resulting instance will
store the <em>preprocessed</em> arguments in some attribute, and will use them for
pickling. If the pickle is unpickled, then preprocessing is applied to the
preprocessed arguments—and this second round of preprocessing must not
change the arguments further, since otherwise a different instance would be
created.</p>
<p>We illustrate the warning by an example. Imagine that one has instances that
are created with an integer-valued argument, but only depend on the <em>square</em>
of the argument. It would be a mistake to square the given argument during
preprocessing:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">WrongUsage</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nd">@staticmethod</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">WrongUsage</span><span class="p">,</span><span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="s2">&quot;Something(</span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="k">self</span>.n
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">WrongUsage</span> <span class="o">=</span> <span class="n">WrongUsage</span> <span class="c1"># This is only needed in doctests</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">WrongUsage</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">w</span>
<span class="go">Something(9)</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">_reduction</span>
<span class="go">(&lt;class &#39;__main__.WrongUsage&#39;&gt;, (9,), {})</span>
</pre></div>
</div>
<p>Indeed, the reduction data are obtained from the preprocessed argument. By
consequence, if the resulting instance is pickled and unpickled, the argument
gets squared <em>again</em>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
<span class="go">Something(81)</span>
</pre></div>
</div>
<p>Instead, the preprocessing should only take the absolute value of the given
argument, while the squaring should happen inside of the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method,
where it won’t mess with the cache:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">BetterUsage</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nd">@staticmethod</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">BetterUsage</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">^</span><span class="mi">2</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="s2">&quot;SomethingElse(</span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="k">self</span>.n
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">BetterUsage</span> <span class="o">=</span> <span class="n">BetterUsage</span> <span class="c1"># This is only needed in doctests</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BetterUsage</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">b</span>
<span class="go">SomethingElse(9)</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="ow">is</span> <span class="n">BetterUsage</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In our next example, we create a cached representation class <code class="docutils literal notranslate"><span class="pre">C</span></code> that
returns an instance of a sub-class <code class="docutils literal notranslate"><span class="pre">C1</span></code> or <code class="docutils literal notranslate"><span class="pre">C2</span></code> depending on the given
arguments. This is implemented in a static <code class="docutils literal notranslate"><span class="pre">__classcall_private__</span></code> method of
<code class="docutils literal notranslate"><span class="pre">C</span></code>, letting it choose the sub-class according to the given arguments. Since
a <code class="docutils literal notranslate"><span class="pre">__classcall_private__</span></code> method will be ignored on sub-classes, the caching
of <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a> is available to both <code class="docutils literal notranslate"><span class="pre">C1</span></code> and <code class="docutils literal notranslate"><span class="pre">C2</span></code>. But
for illustration, we overload the static <code class="docutils literal notranslate"><span class="pre">__classcall__</span></code> method on <code class="docutils literal notranslate"><span class="pre">C2</span></code>,
doing some argument preprocessing. We also create a sub-class <code class="docutils literal notranslate"><span class="pre">C2b</span></code> of
<code class="docutils literal notranslate"><span class="pre">C2</span></code>, demonstrating that the <code class="docutils literal notranslate"><span class="pre">__classcall__</span></code> method is used on the
sub-class (in contrast to a <code class="docutils literal notranslate"><span class="pre">__classcall_private__</span></code> method!).</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nd">@staticmethod</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">__classcall_private__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">implementation</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">implementation</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="n">C1</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">implementation</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="n">C2</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">implementation</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="s2">&quot;C(</span><span class="si">%d</span><span class="s2">, 0)&quot;</span><span class="o">%</span><span class="k">self</span>.n
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">C1</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="s2">&quot;C1(</span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="k">self</span>.n
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">C2</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nd">@staticmethod</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="n">implementation</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">C2</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,)</span><span class="o">*</span><span class="n">implementation</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">C2</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="s2">&quot;C2(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="k">repr</span>(self.t)
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">C2b</span><span class="p">(</span><span class="n">C2</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="s2">&quot;C2b(</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="o">%</span><span class="k">repr</span>(self.t)
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">C2</span> <span class="o">=</span> <span class="n">C2</span>      <span class="c1"># not needed in an interactive session</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">C2b</span> <span class="o">=</span> <span class="n">C2b</span>
</pre></div>
</div>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">C</span></code> drops the argument <code class="docutils literal notranslate"><span class="pre">implementation</span></code> if it
evaluates to <code class="docutils literal notranslate"><span class="pre">False</span></code>, and since the cached <code class="docutils literal notranslate"><span class="pre">__classcall__</span></code> is called in
this case, we have:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">C(1, 0)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,[])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>(Note that we were able to bypass the issue of arguments having to be
hashable by catching the empty list <code class="docutils literal notranslate"><span class="pre">[]</span></code> during preprocessing in the
<code class="docutils literal notranslate"><span class="pre">__classcall_private__</span></code> method. Similarly, unhashable arguments can
be made hashable – e. g., lists normalized to tuples – in the
<code class="docutils literal notranslate"><span class="pre">__classcall_private__</span></code> method before they are further delegated to
<code class="docutils literal notranslate"><span class="pre">__classcall__</span></code>. See
<a class="reference external" href="../../../combinat/sage/combinat/crystals/elementary_crystals.html#sage.combinat.crystals.elementary_crystals.TCrystal" title="(in Sage Reference Manual: Combinatorics v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">TCrystal</span></code></a> for an
example.)</p>
<p>If we call <code class="docutils literal notranslate"><span class="pre">C1</span></code> directly or if we provide <code class="docutils literal notranslate"><span class="pre">implementation=1</span></code> to <code class="docutils literal notranslate"><span class="pre">C</span></code>, we
obtain an instance of <code class="docutils literal notranslate"><span class="pre">C1</span></code>. Since it uses the <code class="docutils literal notranslate"><span class="pre">__classcall__</span></code> method
inherited from <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a>, the resulting instances are
cached:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C1</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">C1(2)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">C1(2)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C1</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The class <code class="docutils literal notranslate"><span class="pre">C2</span></code> preprocesses the input arguments. Instances can, again, be
obtained directly or by calling <code class="docutils literal notranslate"><span class="pre">C</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">C2((1, 1, 1))</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">implementation</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="ow">is</span> <span class="n">C2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The argument preprocessing of <code class="docutils literal notranslate"><span class="pre">C2</span></code> is inherited by <code class="docutils literal notranslate"><span class="pre">C2b</span></code>, since
<code class="docutils literal notranslate"><span class="pre">__classcall__</span></code> and not <code class="docutils literal notranslate"><span class="pre">__classcall_private__</span></code> is used. Pickling works,
since the preprocessing of arguments is idempotent:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">c2b</span> <span class="o">=</span> <span class="n">C2b</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="n">c2b</span>
<span class="go">C2b((2, 2, 2))</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">c2b</span><span class="p">))</span> <span class="ow">is</span> <span class="n">c2b</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="using-uniquefactory">
<h4>Using <a class="reference internal" href="factory.html#sage.structure.factory.UniqueFactory" title="sage.structure.factory.UniqueFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueFactory</span></code></a><a class="headerlink" href="#using-uniquefactory" title="Permalink to this headline">¶</a></h4>
<p>For creating a cached representation using a factory, one has to</p>
<ul class="simple">
<li>create a class <em>separately</em> from the factory. This class <strong>must</strong> inherit
from <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code>. Its instances <strong>must</strong> allow attribute assignment.</li>
<li>write a method <code class="docutils literal notranslate"><span class="pre">create_key</span></code> (or <code class="docutils literal notranslate"><span class="pre">create_key_and_extra_args</span></code>) that
creates the cache key from the given arguments.</li>
<li>write a method <code class="docutils literal notranslate"><span class="pre">create_object</span></code> that creates an instance of the class
from a given cache key.</li>
<li>create an instance of the factory with a name that allows to conclude where
it is defined.</li>
</ul>
<p>An example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="s2">&quot;C</span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="k">repr</span>(self.t)
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.structure.factory</span> <span class="kn">import</span> <span class="n">UniqueFactory</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyFactory</span><span class="p">(</span><span class="n">UniqueFactory</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">create_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span><span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="n">m</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="p">(</span><span class="n">n</span><span class="p">,)</span><span class="o">*</span><span class="n">m</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">create_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_args</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="c1"># We ignore version and extra_args</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="n">C</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">....:</span>
</pre></div>
</div>
<p>Now, we define an instance of the factory, stating that it can be found under
the name <code class="docutils literal notranslate"><span class="pre">&quot;F&quot;</span></code> in the <code class="docutils literal notranslate"><span class="pre">__main__</span></code> module. By consequence, pickling works:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">MyFactory</span><span class="p">(</span><span class="s2">&quot;__main__.F&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="n">F</span>                <span class="c1"># not needed in an interactive session</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">F</span><span class="p">))</span> <span class="ow">is</span> <span class="n">F</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can now create <em>cached</em> instances of <code class="docutils literal notranslate"><span class="pre">C</span></code> by calling the factory. The
cache only takes into account the key computed with the method <code class="docutils literal notranslate"><span class="pre">create_key</span></code>
that we provided. Hence, different given arguments may result in the same
instance. Note that, again, the cache is weak, hence, the instance might be
removed from the cache during garbage collection, unless an external reference
is preserved.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="n">a</span>
<span class="go">C(1, 1)</span>
<span class="gp">sage: </span><span class="n">a</span> <span class="ow">is</span> <span class="n">F</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p><strong>If</strong> the class of the returned instances is a sub-class of <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code>,
and <strong>if</strong> the resulting instance allows attribute assignment, then pickling
of the resulting instances is automatically provided for, and respects the
cache.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This is because an attribute is stored that explains how the instance was
created:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a</span><span class="o">.</span><span class="n">_factory_data</span>
<span class="go">(&lt;__main__.MyFactory object at ...&gt;, (...), (1, 1), {})</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If a class is used that does not inherit from <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code> then unique
pickling is <em>not</em> provided.</p>
</div>
<p>Caching is only available if the factory is called. If an instance of the
class is directly created, then the cache is not used:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">C(1, 1)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">False</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="comparing-the-two-ways-of-implementing-a-cached-representation">
<h3>Comparing the two ways of implementing a cached representation<a class="headerlink" href="#comparing-the-two-ways-of-implementing-a-cached-representation" title="Permalink to this headline">¶</a></h3>
<p>In this sub-section, we discuss advantages and disadvantages of the two ways
of implementing a cached representation, depending on the type of application.</p>
<div class="section" id="simplicity-and-transparency">
<h4>Simplicity and transparency<a class="headerlink" href="#simplicity-and-transparency" title="Permalink to this headline">¶</a></h4>
<p>In many cases, turning a class into a cached representation requires nothing
more than adding <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a> to the list of base classes of
this class. This is, of course, a very easy and convenient way. Writing a
factory would involve a lot more work.</p>
<p>If preprocessing of the arguments is needed, then we have seen how to do this
by a <code class="docutils literal notranslate"><span class="pre">__classcall_private__</span></code> or <code class="docutils literal notranslate"><span class="pre">__classcall__</span></code> method. But these are
double underscore methods and hence, for example, invisible in the
automatically created reference manual. Moreover, preprocessing <em>and</em> caching
are implemented in the same method, which might be confusing. In a unique
factory, these two tasks are cleanly implemented in two separate methods.
With a factory, it is possible to create the resulting instance by arguments
that are different from the key used for caching. This is significantly
restricted with CachedRepresentation due to the requirement that argument
preprocessing be idempotent.</p>
<p>Hence, if advanced preprocessing is needed, then
<a class="reference internal" href="factory.html#sage.structure.factory.UniqueFactory" title="sage.structure.factory.UniqueFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueFactory</span></code></a> might be easier and more
transparent to use than <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a>.</p>
</div>
<div class="section" id="class-inheritance">
<h4>Class inheritance<a class="headerlink" href="#class-inheritance" title="Permalink to this headline">¶</a></h4>
<p>Using <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a> has the advantage that one has a class and
creates cached instances of this class by the usual Python syntax:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">SymmetricGroup</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">unique_representation</span><span class="o">.</span><span class="n">CachedRepresentation</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">SymmetricGroup</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In contrast, a factory is just a callable object that returns something that
has absolutely nothing to do with the factory, and may in fact return
instances of quite different classes:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">GF</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">UniqueFactory</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K5</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">K5</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.rings.finite_rings.finite_field_prime_modn.FiniteField_prime_modn_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">K25</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">K25</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.rings.finite_rings.finite_field_givaro.FiniteField_givaro_with_category&#39;&gt;</span>
<span class="gp">sage: </span><span class="n">Kp</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="n">next_prime_power</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">Kp</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.rings.finite_rings.finite_field_pari_ffelt.FiniteField_pari_ffelt_with_category&#39;&gt;</span>
</pre></div>
</div>
<p>This can be confusing to the user. Namely, the user might determine the class
of an instance and try to create further instances by calling the class rather
than the factory—which is a mistake since it works around the cache (and
also since the class might be more restrictive than the factory – i. e., the
type of <code class="docutils literal notranslate"><span class="pre">K5</span></code> in the above doctest cannot be called on a prime power which
is not a prime). This mistake can more easily be avoided by using
<a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a>.</p>
<p>We have seen above that one can easily create new cached-representation
classes by subclassing an existing cached-representation class, even making
use of an existing argument preprocess. This would be much more complicated
with a factory. Namely, one would need to rewrite old factories making them
aware of the new classes, and/or write new factories for the new classes.</p>
</div>
<div class="section" id="python-versus-extension-classes">
<h4>Python versus extension classes<a class="headerlink" href="#python-versus-extension-classes" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a> uses a metaclass, namely
<a class="reference external" href="../../../misc/sage/misc/classcall_metaclass.html#sage.misc.classcall_metaclass.ClasscallMetaclass" title="(in Sage Reference Manual: Utilities v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClasscallMetaclass</span></code></a>. Hence, it can
currently not be a Cython extension class. Moreover, it is supposed to be used
by providing it as a base class. But in typical applications, one also has
another base class, say, <a class="reference internal" href="parent.html#sage.structure.parent.Parent" title="sage.structure.parent.Parent"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parent</span></code></a>. Hence, one
would like to create a class with at least two base classes, which is
currently impossible in Cython extension classes.</p>
<p>In other words, when using <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a>, one must work with
Python classes. These can be defined in Cython code (<code class="docutils literal notranslate"><span class="pre">.pyx</span></code> files) and can
thus benefit from Cython’s speed inside of their methods, but they must not be
<code class="docutils literal notranslate"><span class="pre">cdef</span> <span class="pre">class</span></code> and can thus not use <code class="docutils literal notranslate"><span class="pre">cdef</span></code> attributes or methods.</p>
<p>Such restrictions do not exist when using a factory. However, if attribute
assignment does not work, then the automatic pickling provided by
<a class="reference internal" href="factory.html#sage.structure.factory.UniqueFactory" title="sage.structure.factory.UniqueFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueFactory</span></code></a> will not be available.</p>
</div>
</div>
</div>
<div class="section" id="what-is-a-unique-representation">
<h2>What is a unique representation?<a class="headerlink" href="#what-is-a-unique-representation" title="Permalink to this headline">¶</a></h2>
<p>Instances of a class have a <em>unique instance behavior</em> when instances of this
class evaluate equal if and only if they are identical. Sage provides the base
class <a class="reference external" href="../../../misc/sage/misc/fast_methods.html#sage.misc.fast_methods.WithEqualityById" title="(in Sage Reference Manual: Utilities v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">WithEqualityById</span></code></a>, which provides
comparison by identity and a hash that is determined by the memory address of
the instance. Both the equality test and the hash are implemented in Cython
and are very fast, even when one has a Python class inheriting from
<a class="reference external" href="../../../misc/sage/misc/fast_methods.html#sage.misc.fast_methods.WithEqualityById" title="(in Sage Reference Manual: Utilities v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">WithEqualityById</span></code></a>.</p>
<p>In many applications, one wants to combine unique instance and cached
representation behaviour. This is called <em>unique representation</em> behaviour.
We have seen above that symmetric groups have a <em>cached</em> representation
behaviour. However, they do not show the <em>unique</em> representation behaviour,
since they are equal to groups created in a totally different way, namely to
subgroups:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">SymmetricGroup</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G3</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgroup</span><span class="p">([</span><span class="n">G</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)),</span><span class="n">G</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))])</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="ow">is</span> <span class="n">G3</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">G3</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">==</span> <span class="n">G3</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The unique representation behaviour can conveniently be implemented with a
class that inherits from <a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a>: By adding
<a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a> to the base classes, the class will
simultaneously inherit from <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a> and from
<a class="reference external" href="../../../misc/sage/misc/fast_methods.html#sage.misc.fast_methods.WithEqualityById" title="(in Sage Reference Manual: Utilities v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">WithEqualityById</span></code></a>.</p>
<p>For example, a symmetric function algebra is uniquely determined by the base
ring. Thus, it is reasonable to use <a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a> in this
case:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">CC</span><span class="p">),</span> <span class="n">SymmetricFunctions</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">,</span> <span class="n">UniqueRepresentation</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p><a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a> differs from <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a> only
by adding <a class="reference external" href="../../../misc/sage/misc/fast_methods.html#sage.misc.fast_methods.WithEqualityById" title="(in Sage Reference Manual: Utilities v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">WithEqualityById</span></code></a> as a base
class. Hence, the above examples of argument preprocessing work for
<a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a> as well.</p>
<p>Note that a cached representation created with
<a class="reference internal" href="factory.html#sage.structure.factory.UniqueFactory" title="sage.structure.factory.UniqueFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueFactory</span></code></a> does <em>not</em> automatically
provide unique representation behaviour, in spite of its name! Hence, for
unique representation behaviour, one has to implement hash and equality test
accordingly, for example by inheriting from
<a class="reference external" href="../../../misc/sage/misc/fast_methods.html#sage.misc.fast_methods.WithEqualityById" title="(in Sage Reference Manual: Utilities v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">WithEqualityById</span></code></a>.</p>
<dl class="class">
<dt id="sage.structure.unique_representation.CachedRepresentation">
<em class="property">class </em><code class="descclassname">sage.structure.unique_representation.</code><code class="descname">CachedRepresentation</code><a class="headerlink" href="#sage.structure.unique_representation.CachedRepresentation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Classes derived from CachedRepresentation inherit a weak cache for their
instances.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If this class is used as a base class, then instances are (weakly)
cached, according to the arguments used to create the instance.
Pickling is provided, of course by using the cache.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Using this class, one can have arbitrary hash and comparison.
Hence, <em>unique</em> representation behaviour is <em>not</em> provided.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a>, <a class="reference internal" href="#module-sage.structure.unique_representation" title="sage.structure.unique_representation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unique_representation</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<p>Providing a class with a weak cache for the instances is easy: Just
inherit from <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.structure.unique_representation</span> <span class="kn">import</span> <span class="n">CachedRepresentation</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="c1"># all the rest as usual</span>
<span class="gp">....: </span>    <span class="k">pass</span>
</pre></div>
</div>
<p>We start with a simple class whose constructor takes a single
value as argument (TODO: find a more meaningful example):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="bp">False</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
</pre></div>
</div>
<p>Two coexisting instances of <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> created with the same argument data
are guaranteed to share the same identity. Since <a class="reference external" href="https://trac.sagemath.org/12215">trac ticket #12215</a>, this is
only the case if there is some strong reference to the returned instance,
since otherwise it may be garbage collected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">is</span> <span class="n">y</span>               <span class="c1"># There is a strong reference</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">is</span> <span class="n">z</span>
<span class="go">False</span>
</pre></div>
</div>
<p>In particular, modifying any one of them modifies the other
(reference effect):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">value</span>
<span class="go">(3, 3)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">value</span>
<span class="go">(1, 1)</span>
</pre></div>
</div>
<p>The arguments can consist of any combination of positional or keyword
arguments, as taken by a usual <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__init__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__</span></code></a>
function. However, all values passed in should be hashable:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">MyClass</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: unhashable type: &#39;list&#39;</span>
</pre></div>
</div>
<p class="rubric">Argument preprocessing</p>
<p>Sometimes, one wants to do some preprocessing on the arguments, to
put them in some canonical form. The following example illustrates
how to achieve this; it takes as argument any iterable, and
canonicalizes it into a tuple (which is hashable!):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass2</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nd">@staticmethod</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">t</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MyClass2</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="gp">....:</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass2</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">MyClass2</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">MyClass2</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">value</span>
<span class="go">(1, 2, 3)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">is</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="ow">is</span> <span class="n">z</span>
<span class="go">(True, True)</span>
</pre></div>
</div>
<p>A similar situation arises when the constructor accepts default
values for some of its parameters. Alas, the obvious
implementation does not work:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass3</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="n">MyClass3</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="ow">is</span> <span class="n">MyClass3</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Instead, one should do:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass3</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nd">@staticmethod</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">3</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MyClass3</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">....:</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="n">MyClass3</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="ow">is</span> <span class="n">MyClass3</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A bit of explanation is in order. First, the call <code class="docutils literal notranslate"><span class="pre">MyClass2([1,2,3])</span></code>
triggers a call to <code class="docutils literal notranslate"><span class="pre">MyClass2.__classcall__(MyClass2,</span> <span class="pre">[1,2,3])</span></code>. This is
an extension of the standard Python behavior, needed by
<a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a>, and implemented by the
<a class="reference external" href="../../../misc/sage/misc/classcall_metaclass.html#sage.misc.classcall_metaclass.ClasscallMetaclass" title="(in Sage Reference Manual: Utilities v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClasscallMetaclass</span></code></a>. Then,
<code class="docutils literal notranslate"><span class="pre">MyClass2.__classcall__</span></code> does the desired transformations on the
arguments. Finally, it uses <code class="docutils literal notranslate"><span class="pre">super</span></code> to call the default implementation
of <code class="docutils literal notranslate"><span class="pre">__classcall__</span></code> provided by <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a>. This one
in turn handles the caching and, if needed, constructs and initializes a
new object in the class using <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__new__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__</span></code></a> and
<a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__init__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__</span></code></a> as usual.</p>
<p>Constraints:</p>
<ul class="simple">
<li><code class="xref py py-meth docutils literal notranslate"><span class="pre">__classcall__()</span></code> is a staticmethod (like, implicitly,
<a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__new__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__</span></code></a>)</li>
<li>the preprocessing on the arguments should be idempotent. That is, if
<code class="docutils literal notranslate"><span class="pre">MyClass2.__classcall__(&lt;arguments&gt;)</span></code> calls
<code class="docutils literal notranslate"><span class="pre">CachedRepresentation.__classcall__(&lt;preprocessed_arguments&gt;)</span></code>, then
<code class="docutils literal notranslate"><span class="pre">MyClass2.__classcall__(&lt;preprocessed_arguments&gt;)</span></code> should also result
in a call to <code class="docutils literal notranslate"><span class="pre">CachedRepresentation.__classcall__(&lt;preprocessed_arguments&gt;)</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">MyClass2.__classcall__</span></code> should return the result of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">CachedRepresentation.__classcall__()</span></code> without modifying it.</li>
</ul>
<p>Other than that <code class="docutils literal notranslate"><span class="pre">MyClass2.__classcall__</span></code> may play any tricks, like
acting as a factory and returning objects from other classes.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It is possible, but strongly discouraged, to let the <code class="docutils literal notranslate"><span class="pre">__classcall__</span></code>
method of a class <code class="docutils literal notranslate"><span class="pre">C</span></code> return objects that are not instances of
<code class="docutils literal notranslate"><span class="pre">C</span></code>. Of course, instances of a <em>subclass</em> of <code class="docutils literal notranslate"><span class="pre">C</span></code> are fine. Compare
the examples in <a class="reference internal" href="#module-sage.structure.unique_representation" title="sage.structure.unique_representation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unique_representation</span></code></a>.</p>
</div>
<p>We illustrate what is meant by an “idempotent” preprocessing. Imagine
that one has instances that are created with an integer-valued argument,
but only depend on the <em>square</em> of the argument. It would be a mistake to
square the given argument during preprocessing:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">WrongUsage</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nd">@staticmethod</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">WrongUsage</span><span class="p">,</span><span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="s2">&quot;Something(</span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="k">self</span>.n
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">WrongUsage</span> <span class="o">=</span> <span class="n">WrongUsage</span> <span class="c1"># This is only needed in doctests</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">WrongUsage</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">w</span>
<span class="go">Something(9)</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">_reduction</span>
<span class="go">(&lt;class &#39;__main__.WrongUsage&#39;&gt;, (9,), {})</span>
</pre></div>
</div>
<p>Indeed, the reduction data are obtained from the preprocessed
arguments. By consequence, if the resulting instance is pickled and
unpickled, the argument gets squared <em>again</em>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
<span class="go">Something(81)</span>
</pre></div>
</div>
<p>Instead, the preprocessing should only take the absolute value of the
given argument, while the squaring should happen inside of the
<code class="docutils literal notranslate"><span class="pre">__init__</span></code> method, where it won’t mess with the cache:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">BetterUsage</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nd">@staticmethod</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">BetterUsage</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__classcall__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">^</span><span class="mi">2</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="s2">&quot;SomethingElse(</span><span class="si">%d</span><span class="s2">)&quot;</span><span class="o">%</span><span class="k">self</span>.n
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">BetterUsage</span> <span class="o">=</span> <span class="n">BetterUsage</span> <span class="c1"># This is only needed in doctests</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="o">=</span> <span class="n">BetterUsage</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">b</span>
<span class="go">SomethingElse(9)</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="ow">is</span> <span class="n">b</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">b</span> <span class="ow">is</span> <span class="n">BetterUsage</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">Cached representation and mutability</p>
<p><a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a> is primarily intended for implementing
objects which are (at least semantically) immutable. This is in
particular assumed by the default implementations of <code class="docutils literal notranslate"><span class="pre">copy</span></code> and
<code class="docutils literal notranslate"><span class="pre">deepcopy</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="gp">sage: </span><span class="n">deepcopy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
<p>However, in contrast to <a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a>, using
<a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a> allows for a comparison that is not by
identity:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">t</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code> are non-identical, but equal:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">z</span><span class="o">.</span><span class="n">value</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="o">==</span> <span class="n">z</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">t</span> <span class="ow">is</span> <span class="n">z</span>
<span class="go">False</span>
</pre></div>
</div>
<p class="rubric">More on cached representation and identity</p>
<p><a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a> is implemented by means of a cache.
This cache uses weak references in general, but strong references to
the most recently created objects. Hence, when all other references
to, say, <code class="docutils literal notranslate"><span class="pre">MyClass(1)</span></code> have been deleted, the instance is
eventually deleted from memory (after enough other objects have been
created to remove the strong reference to <code class="docutils literal notranslate"><span class="pre">MyClass(1)</span></code>). A later
call to <code class="docutils literal notranslate"><span class="pre">MyClass(1)</span></code> reconstructs the instance from scratch:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">SomeClass</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;creating new instance for argument </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">i</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;deleting instance for argument </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">OtherClass</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">pass</span>
<span class="gp">sage: </span><span class="n">O</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">creating new instance for argument 1</span>
<span class="gp">sage: </span><span class="n">O</span> <span class="ow">is</span> <span class="n">SomeClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">O</span> <span class="ow">is</span> <span class="n">SomeClass</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">creating new instance for argument 2</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">OtherClass</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">)]</span>
<span class="go">deleting instance for argument 2</span>
<span class="gp">sage: </span><span class="k">del</span> <span class="n">O</span>
<span class="go">deleting instance for argument 1</span>
<span class="gp">sage: </span><span class="n">O</span> <span class="o">=</span> <span class="n">SomeClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">creating new instance for argument 1</span>
<span class="gp">sage: </span><span class="k">del</span> <span class="n">O</span>
<span class="gp">sage: </span><span class="k">del</span> <span class="n">L</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="n">OtherClass</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">200</span><span class="p">)]</span>
<span class="go">deleting instance for argument 1</span>
</pre></div>
</div>
<p class="rubric">Cached representation and pickling</p>
<p>The default Python pickling implementation (by reconstructing an object
from its class and dictionary, see “The pickle protocol” in the Python
Library Reference) does not preserve cached representation, as Python has
no chance to know whether and where the same object already exists.</p>
<p><a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a> tries to ensure appropriate pickling by
implementing a <a class="reference external" href="https://docs.python.org/library/pickle.html#object.__reduce__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__</span></code></a> method returning the
arguments passed to the constructor:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span>             <span class="c1"># Fake MyClass being defined in a python module</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyClass</span> <span class="o">=</span> <span class="n">MyClass</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
<p><a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a> uses the <a class="reference external" href="https://docs.python.org/library/pickle.html#object.__reduce__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__</span></code></a> pickle protocol rather than <a class="reference external" href="https://docs.python.org/library/pickle.html#object.__getnewargs__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs__</span></code></a> because the latter does not handle keyword
arguments:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">()</span>
<span class="go">(&lt;function unreduce at ...&gt;, (&lt;class &#39;__main__.MyClass&#39;&gt;, (), {&#39;value&#39;: 1}))</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">is</span> <span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The default implementation of <a class="reference external" href="https://docs.python.org/library/pickle.html#object.__reduce__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__</span></code></a>
in <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a> requires to store the constructor’s
arguments in the instance dictionary upon construction:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">{&#39;_reduction&#39;: (&lt;class &#39;__main__.MyClass&#39;&gt;, (), {&#39;value&#39;: 1}), &#39;value&#39;: 1}</span>
</pre></div>
</div>
<p>It is often easy in a derived subclass to reconstruct the constructor’s
arguments from the instance data structure. When this is the case,
<a class="reference external" href="https://docs.python.org/library/pickle.html#object.__reduce__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__</span></code></a> should be overridden; automagically
the arguments won’t be stored anymore:</p>
<div class="last highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass3</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">....:</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="p">(</span><span class="n">MyClass3</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,))</span>
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span><span class="p">;</span> <span class="n">__main__</span><span class="o">.</span><span class="n">MyClass3</span> <span class="o">=</span> <span class="n">MyClass3</span>  <span class="c1"># Fake MyClass3 being defined in a python module</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass3</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="go">{&#39;value&#39;: 1}</span>
</pre></div>
</div>
</div>
<p class="rubric">Migrating classes to <code class="docutils literal notranslate"><span class="pre">CachedRepresentation</span></code> and unpickling</p>
<p>We check that, when migrating a class to <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a>,
older pickles can still be reasonably unpickled. Let us create a
(new style) class, and pickle one of its instances:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass4</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">....:</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span><span class="p">;</span> <span class="n">__main__</span><span class="o">.</span><span class="n">MyClass4</span> <span class="o">=</span> <span class="n">MyClass4</span>  <span class="c1"># Fake MyClass4 being defined in a python module</span>
<span class="gp">sage: </span><span class="n">pickle</span> <span class="o">=</span> <span class="n">dumps</span><span class="p">(</span><span class="n">MyClass4</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>It can be unpickled:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">value</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Now, we upgrade the class to derive from <a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a>,
which inherits from <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass4</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="nb">object</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span><span class="p">;</span> <span class="n">__main__</span><span class="o">.</span><span class="n">MyClass4</span> <span class="o">=</span> <span class="n">MyClass4</span>  <span class="c1"># Fake MyClass4 being defined in a python module</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyClass4</span> <span class="o">=</span> <span class="n">MyClass4</span>
</pre></div>
</div>
<p>The pickle can still be unpickled:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">value</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Note however that, for the reasons explained above, unique
representation is not guaranteed in this case:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">y</span> <span class="ow">is</span> <span class="n">MyClass4</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Illustrate how this can be fixed on a case by case basis.</p>
</div>
<p>Now, we redo the same test for a class deriving from SageObject:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass4</span><span class="p">(</span><span class="n">SageObject</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span><span class="p">;</span> <span class="n">__main__</span><span class="o">.</span><span class="n">MyClass4</span> <span class="o">=</span> <span class="n">MyClass4</span>  <span class="c1"># Fake MyClass4 being defined in a python module</span>
<span class="gp">sage: </span><span class="n">pickle</span> <span class="o">=</span> <span class="n">dumps</span><span class="p">(</span><span class="n">MyClass4</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass4</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">SageObject</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyClass4</span> <span class="o">=</span> <span class="n">MyClass4</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">value</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Caveat: unpickling instances of a formerly old-style class is not supported yet by default:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass4</span><span class="p">:</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span><span class="p">;</span> <span class="n">__main__</span><span class="o">.</span><span class="n">MyClass4</span> <span class="o">=</span> <span class="n">MyClass4</span>  <span class="c1"># Fake MyClass4 being defined in a python module</span>
<span class="gp">sage: </span><span class="n">pickle</span> <span class="o">=</span> <span class="n">dumps</span><span class="p">(</span><span class="n">MyClass4</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

<span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass4</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">SageObject</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">MyClass4</span> <span class="o">=</span> <span class="n">MyClass4</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="p">)</span>  <span class="c1"># todo: not implemented</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">value</span>            <span class="c1"># todo: not implemented</span>
<span class="go">1</span>
</pre></div>
</div>
<p class="rubric">Rationale for the current implementation</p>
<p><a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a> and derived classes use the
<a class="reference external" href="../../../misc/sage/misc/classcall_metaclass.html#sage.misc.classcall_metaclass.ClasscallMetaclass" title="(in Sage Reference Manual: Utilities v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClasscallMetaclass</span></code></a>
of the standard Python type. The following example explains why.</p>
<p>We define a variant of <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> where the calls to
<a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__init__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__</span></code></a> are traced:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">CachedRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;initializing object&quot;</span><span class="p">)</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">....:</span>
</pre></div>
</div>
<p>Let us create an object twice:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">initializing object</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>As desired the <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__init__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__</span></code></a> method was only called
the first time, which is an important feature.</p>
<p>As far as we can tell, this is not achievable while just using
<a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__new__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__</span></code></a> and <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__init__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__</span></code></a> (as
defined by type; see Section <a class="reference external" href="https://docs.python.org/release/2.7.15/reference/datamodel.html#basic-customization">Basic Customization</a> in the Python Reference
Manual). Indeed, <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__init__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__</span></code></a> is called
systematically on the result of <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__new__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__</span></code></a> whenever
the result is an instance of the class.</p>
<p>Another difficulty is that argument preprocessing (as in the example
above) cannot be handled by <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__new__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__</span></code></a>, since the
unprocessed arguments will be passed down to
<a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__init__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__</span></code></a>.</p>
</dd></dl>

<dl class="class">
<dt id="sage.structure.unique_representation.UniqueRepresentation">
<em class="property">class </em><code class="descclassname">sage.structure.unique_representation.</code><code class="descname">UniqueRepresentation</code><a class="headerlink" href="#sage.structure.unique_representation.UniqueRepresentation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.unique_representation.CachedRepresentation</span></code></a>, <a class="reference external" href="../../../misc/sage/misc/fast_methods.html#sage.misc.fast_methods.WithEqualityById" title="(in Sage Reference Manual: Utilities v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.misc.fast_methods.WithEqualityById</span></code></a></p>
<p>Classes derived from UniqueRepresentation inherit a unique
representation behavior for their instances.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#module-sage.structure.unique_representation" title="sage.structure.unique_representation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unique_representation</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<p>The short story: to construct a class whose instances have a
unique representation behavior one just has to do:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="c1"># all the rest as usual</span>
<span class="gp">....: </span>    <span class="k">pass</span>
</pre></div>
</div>
<p>Everything below is for the curious or for advanced usage.</p>
<p class="rubric">What is unique representation?</p>
<p>Instances of a class have a <em>unique representation behavior</em> when
instances evaluate equal if and only if they are identical (i.e., share
the same memory representation), if and only if they were created using
equal arguments. For example, calling twice:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
</pre></div>
</div>
<p>to create the symmetric function algebra over <span class="math notranslate nohighlight">\(\QQ\)</span> actually gives back the
same object:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">==</span> <span class="n">g</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="ow">is</span> <span class="n">g</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This is a standard design pattern. It allows for sharing cached data (say
representation theoretical information about a group) as well as for very
fast hashing and equality testing. This behaviour is typically desirable
for parents and categories. It can also be useful for intensive
computations where one wants to cache all the operations on a small set of
elements (say the multiplication table of a small group), and access this
cache as quickly as possible.</p>
<p><a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a> is very easy to use: a class just needs to
derive from it, or make sure some of its super classes does. Also, it
groups together the class and the factory in a single gadget:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">(</span><span class="n">CC</span><span class="p">),</span> <span class="n">SymmetricFunctions</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">SymmetricFunctions</span><span class="p">,</span> <span class="n">UniqueRepresentation</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This nice behaviour is not available when one just uses a factory:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">GF</span><span class="p">)</span>  <span class="c1"># py2</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: isinstance() arg 2 must be a class, type, or tuple of classes and types</span>
<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">GF</span><span class="p">)</span>  <span class="c1"># py3</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: isinstance() arg 2 must be a type or tuple of types</span>

<span class="gp">sage: </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">GF</span><span class="p">,</span> <span class="n">sage</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">UniqueFactory</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>In addition, <a class="reference internal" href="factory.html#sage.structure.factory.UniqueFactory" title="sage.structure.factory.UniqueFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueFactory</span></code></a> only provides
the <em>cached</em> representation behaviour, but not the <em>unique</em> representation
behaviour—the examples in <a class="reference internal" href="#module-sage.structure.unique_representation" title="sage.structure.unique_representation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unique_representation</span></code></a>
explain this difference.</p>
<p>On the other hand, the <a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a> class is more
intrusive, as it imposes a behavior (and a metaclass) on all the
subclasses. In particular, the unique representation behaviour is imposed
on <em>all</em> subclasses (unless the <code class="docutils literal notranslate"><span class="pre">__classcall__</span></code> method is overloaded and
not called in the subclass, which is not recommended). Its implementation
is also more technical, which leads to some subtleties.</p>
<p>EXAMPLES:</p>
<p>We start with a simple class whose constructor takes a single value as
argument. This pattern is similar to what is done in
<a class="reference external" href="../../../combinat/sage/combinat/sf/sf.html#sage.combinat.sf.sf.SymmetricFunctions" title="(in Sage Reference Manual: Combinatorics v8.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.sf.sf.SymmetricFunctions</span></code></a>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
</pre></div>
</div>
<p>Two coexisting instances of <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> created with the same argument
data are guaranteed to share the same identity. Since <a class="reference external" href="https://trac.sagemath.org/12215">trac ticket #12215</a>, this
is only the case if there is some strong reference to the returned
instance, since otherwise it may be garbage collected:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">is</span> <span class="n">y</span>               <span class="c1"># There is a strong reference</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">is</span> <span class="n">z</span>
<span class="go">False</span>
</pre></div>
</div>
<p>In particular, modifying any one of them modifies the other
(reference effect):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">value</span>
<span class="go">(3, 3)</span>
<span class="gp">sage: </span><span class="n">y</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">value</span>
<span class="go">(1, 1)</span>
</pre></div>
</div>
<p>When comparing two instances of a unique representation with <code class="docutils literal notranslate"><span class="pre">==</span></code>
or <code class="docutils literal notranslate"><span class="pre">!=</span></code> comparison by identity is used:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">is</span> <span class="n">y</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">z</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">==</span> <span class="n">z</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="ow">is</span> <span class="n">z</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">!=</span> <span class="n">z</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A hash function equivalent to <a class="reference external" href="https://docs.python.org/reference/datamodel.html#object.__hash__" title="(in Python v2.7)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__hash__()</span></code></a> is used, which is
compatible with comparison by identity. However this means that the hash
function may change in between Sage sessions, or even within the same Sage
session.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">hash</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It is possible to inherit from
<a class="reference internal" href="#sage.structure.unique_representation.UniqueRepresentation" title="sage.structure.unique_representation.UniqueRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueRepresentation</span></code></a>
and then overload comparison in a way that destroys the unique
representation property. We strongly recommend against it!  You should
use <a class="reference internal" href="#sage.structure.unique_representation.CachedRepresentation" title="sage.structure.unique_representation.CachedRepresentation"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a>
instead.</p>
</div>
<p class="rubric">Mixing super types and super classes</p>
</dd></dl>

<dl class="function">
<dt id="sage.structure.unique_representation.unreduce">
<code class="descclassname">sage.structure.unique_representation.</code><code class="descname">unreduce</code><span class="sig-paren">(</span><em>cls</em>, <em>args</em>, <em>keywords</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.structure.unique_representation.unreduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls a class on the given arguments:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sage</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">unique_representation</span><span class="o">.</span><span class="n">unreduce</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="p">{})</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">should reuse something preexisting …</p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Unique Representation</a><ul>
<li><a class="reference internal" href="#what-is-a-cached-representation">What is a cached representation?</a><ul>
<li><a class="reference internal" href="#implementing-a-cached-representation">Implementing a cached representation</a><ul>
<li><a class="reference internal" href="#using-cachedrepresentation">Using <code class="docutils literal notranslate"><span class="pre">CachedRepresentation</span></code></a><ul>
<li><a class="reference internal" href="#normalising-the-arguments">Normalising the arguments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-uniquefactory">Using <code class="docutils literal notranslate"><span class="pre">UniqueFactory</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#comparing-the-two-ways-of-implementing-a-cached-representation">Comparing the two ways of implementing a cached representation</a><ul>
<li><a class="reference internal" href="#simplicity-and-transparency">Simplicity and transparency</a></li>
<li><a class="reference internal" href="#class-inheritance">Class inheritance</a></li>
<li><a class="reference internal" href="#python-versus-extension-classes">Python versus extension classes</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#what-is-a-unique-representation">What is a unique representation?</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="richcmp.html"
                        title="previous chapter">Cython-like rich comparisons in Python</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="factory.html"
                        title="next chapter">Factory for cached representations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/structure/unique_representation.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="factory.html" title="Factory for cached representations"
             >next</a> |</li>
        <li class="right" >
          <a href="richcmp.html" title="Cython-like rich comparisons in Python"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Parents and Elements</a> &#187;</li>
 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2019, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>