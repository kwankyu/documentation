
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="viewport" content="width=600, initial-scale=1">
    <title>Recursively enumerated set &#8212; Sage 9.3 Reference Manual: Sets</title>
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script async="async" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Maps between finite sets" href="finite_set_maps.html" />
    <link rel="prev" title="Finite Enumerated Sets" href="finite_enumerated_set.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="finite_set_maps.html" title="Maps between finite sets"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="finite_enumerated_set.html" title="Finite Enumerated Sets"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.3 Reference Manual: Sets</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Recursively enumerated set</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="recursively-enumerated-set">
<span id="sage-sets-recursively-enumerated-set"></span><h1>Recursively enumerated set<a class="headerlink" href="#recursively-enumerated-set" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.sets.recursively_enumerated_set"></span><p>A set <span class="math notranslate nohighlight">\(S\)</span> is called recursively enumerable if there is an algorithm that
enumerates the members of <span class="math notranslate nohighlight">\(S\)</span>. We consider here the recursively enumerated
sets that are described by some <code class="docutils literal notranslate"><span class="pre">seeds</span></code> and a successor function
<code class="docutils literal notranslate"><span class="pre">successors</span></code>.  The successor function may have some structure (symmetric,
graded, forest) or not. The elements of a set having a symmetric, graded or
forest structure can be enumerated uniquely without keeping all of them in
memory. Many kinds of iterators are provided in this module: depth first
search, breadth first search or elements of given depth.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Recursively_enumerable_set">Wikipedia article Recursively_enumerable_set</a>.</p>
<p>See documentation of <a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet"><code class="xref py py-func docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet()</span></code></a> below for the
description of the inputs.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Sébastien Labbé, April 2014, at Sage Days 57, Cernay-la-ville</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="section" id="no-hypothesis-on-the-structure">
<h2>No hypothesis on the structure<a class="headerlink" href="#no-hypothesis-on-the-structure" title="Permalink to this headline">¶</a></h2>
<p>What we mean by “no hypothesis” is that the set is not known
to be a forest, symmetric, or graded. However, it may have other
structure, like not containing an oriented cycle, that does not
help with the enumeration.</p>
<p>In this example, the seed is 0 and the successor function is either <code class="docutils literal notranslate"><span class="pre">+2</span></code>
or <code class="docutils literal notranslate"><span class="pre">+3</span></code>. This is the set of non negative linear combinations of 2 and 3:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">succ</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:[</span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">succ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">A recursively enumerated set (breadth first search)</span>
</pre></div>
</div>
<p>Breadth first search:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[0, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
</pre></div>
</div>
<p>Depth first search:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">depth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]</span>
</pre></div>
</div>
</div>
<div class="section" id="symmetric-structure">
<h2>Symmetric structure<a class="headerlink" href="#symmetric-structure" title="Permalink to this headline">¶</a></h2>
<p>The origin <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code> as seed and the upper, lower, left and right lattice
point as successor function. This function is symmetric since <span class="math notranslate nohighlight">\(p\)</span> is a
successor of <span class="math notranslate nohighlight">\(q\)</span> if and only if <span class="math notranslate nohighlight">\(q\)</span> is a successor or <span class="math notranslate nohighlight">\(p\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">succ</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">seeds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">(</span><span class="n">seeds</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">enumeration</span><span class="o">=</span><span class="s1">&#39;depth&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">A recursively enumerated set with a symmetric structure (depth first search)</span>
</pre></div>
</div>
<p>In this case, depth first search is the default enumeration for iteration:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it_depth</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it_depth</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8), (0, 9)]</span>
</pre></div>
</div>
<p>Breadth first search:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it_breadth</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it_breadth</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">13</span><span class="p">)]</span>
<span class="go">[(0, 0),</span>
<span class="go"> (-1, 0), (0, -1), (1, 0), (0, 1),</span>
<span class="go"> (-2, 0), (-1, -1), (-1, 1), (0, -2), (1, -1), (2, 0), (1, 1), (0, 2)]</span>
</pre></div>
</div>
<p>Levels (elements of given depth):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[(0, 0)]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[(-1, 0), (0, -1), (0, 1), (1, 0)]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[(-2, 0), (-1, -1), (-1, 1), (0, -2), (0, 2), (1, -1), (1, 1), (2, 0)]</span>
</pre></div>
</div>
</div>
<div class="section" id="graded-structure">
<h2>Graded structure<a class="headerlink" href="#graded-structure" title="Permalink to this headline">¶</a></h2>
<p>Identity permutation as seed and <code class="docutils literal notranslate"><span class="pre">permutohedron_succ</span></code> as successor
function:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">succ</span> <span class="o">=</span> <span class="n">attrcall</span><span class="p">(</span><span class="s2">&quot;permutohedron_succ&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">seed</span> <span class="o">=</span> <span class="p">[</span><span class="n">Permutation</span><span class="p">([</span><span class="mf">1.</span><span class="o">.</span><span class="mi">5</span><span class="p">])]</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span>
<span class="go">A recursively enumerated set with a graded structure (breadth first search)</span>
</pre></div>
</div>
<p>Depth first search iterator:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it_depth</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">depth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it_depth</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="go">[[1, 2, 3, 4, 5],</span>
<span class="go"> [1, 2, 3, 5, 4],</span>
<span class="go"> [1, 2, 5, 3, 4],</span>
<span class="go"> [1, 2, 5, 4, 3],</span>
<span class="go"> [1, 5, 2, 4, 3]]</span>
</pre></div>
</div>
<p>Breadth first search iterator:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it_breadth</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it_breadth</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="go">[[1, 2, 3, 4, 5],</span>
<span class="go"> [2, 1, 3, 4, 5],</span>
<span class="go"> [1, 3, 2, 4, 5],</span>
<span class="go"> [1, 2, 4, 3, 5],</span>
<span class="go"> [1, 2, 3, 5, 4]]</span>
</pre></div>
</div>
<p>Elements of given depth iterator:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="go">[[4, 5, 3, 2, 1], [5, 3, 4, 2, 1], [5, 4, 2, 3, 1], [5, 4, 3, 1, 2]]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[[5, 4, 3, 2, 1]]</span>
</pre></div>
</div>
<p>Graded components (set of elements of the same depth):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[[1, 2, 3, 4, 5]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1, 2, 3, 5, 4], [1, 2, 4, 3, 5], [1, 3, 2, 4, 5], [2, 1, 3, 4, 5]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span>
<span class="go">[[4, 5, 3, 2, 1], [5, 3, 4, 2, 1], [5, 4, 2, 3, 1], [5, 4, 3, 1, 2]]</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[[5, 4, 3, 2, 1]]</span>
</pre></div>
</div>
</div>
<div class="section" id="forest-structure">
<h2>Forest structure<a class="headerlink" href="#forest-structure" title="Permalink to this headline">¶</a></h2>
<p>The set of words over the alphabet <span class="math notranslate nohighlight">\(\{a,b\}\)</span> can be generated from the
empty word by appending letter <span class="math notranslate nohighlight">\(a\)</span> or <span class="math notranslate nohighlight">\(b\)</span> as a successor function. This set
has a forest structure:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">seeds</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">succ</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="p">[</span><span class="n">w</span><span class="o">+</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">w</span><span class="o">+</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">(</span><span class="n">seeds</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;forest&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">An enumerated set with a forest structure</span>
</pre></div>
</div>
<p>Depth first search iterator:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">depth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
<span class="go">[&#39;&#39;, &#39;a&#39;, &#39;aa&#39;, &#39;aaa&#39;, &#39;aaaa&#39;, &#39;aaaaa&#39;]</span>
</pre></div>
</div>
<p>Breadth first search iterator:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)]</span>
<span class="go">[&#39;&#39;, &#39;a&#39;, &#39;b&#39;, &#39;aa&#39;, &#39;ab&#39;, &#39;ba&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="example-forest-structure">
<h2>Example: Forest structure<a class="headerlink" href="#example-forest-structure" title="Permalink to this headline">¶</a></h2>
<p>This example was provided by Florent Hivert.</p>
<p>How to define a set using those classes?</p>
<p>Only two things are necessary to define a set using a
<a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet</span></code></a> object (the other
classes being very similar):</p>
<div class="math notranslate nohighlight">
\[\begin{picture}(-300,0)(600,0)
% Root
\put(0,0){\circle*{7}}
\put(0,10){\makebox(0,10){``\ ''}}
% First Children
\put(-150,-60){\makebox(0,10){``a''}}
\put(0,-60){\makebox(0,10){``b''}}
\put(150,-60){\makebox(0,10){``c''}}
\multiput(-150,-70)(150,0){3}{\circle*{7}}
% Second children
\put(-200,-130){\makebox(0,10){``aa''}}
\put(-150,-130){\makebox(0,10){``ab''}}
\put(-100,-130){\makebox(0,10){``ac''}}
\put(-50,-130){\makebox(0,10){``ba''}}
\put(0,-130){\makebox(0,10){``bb''}}
\put(50,-130){\makebox(0,10){``bc''}}
\put(100,-130){\makebox(0,10){``ca''}}
\put(150,-130){\makebox(0,10){``cb''}}
\put(200,-130){\makebox(0,10){``cc''}}
\multiput(-200,-140)(50,0){9}{\circle*{7}}
% Legend
\put(100,-5){\makebox(0,10)[l]{1) An initial element}}
\put(-250,-5){\makebox(0,10)[l]{2) A function of an element enumerating}}
\put(-235,-20){\makebox(0,10)[l]{its children (if any)}}
% Arrows
\thicklines
\put(0,-10){\vector(0,-1){30}}
\put(-15,-5){\vector(-2,-1){110}}
\put(15,-5){\vector(2,-1){110}}
\multiput(-150,-80)(150,0){3}{\vector(0,-1){30}}
\multiput(-160,-80)(150,0){3}{\vector(-1,-1){30}}
\multiput(-140,-80)(150,0){3}{\vector(1,-1){30}}
\put(90,0){\vector(-1,0){70}}
\put(-215,-30){\vector(1,-1){40}}
\end{picture}\]</div>
<p>For the previous example, the two necessary pieces of information are:</p>
<ul>
<li><p>the initial element <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>;</p></li>
<li><p>the function:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">lambda x: [x + letter for letter in [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
</li>
</ul>
<p>This would actually describe an <strong>infinite</strong> set, as such rules describes
“all words” on 3 letters. Hence, it is a good idea to replace the function by:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="go">lambda x: [x + letter for letter in [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] if len(x) &lt; 2 else []</span>
</pre></div>
</div>
<p>or even:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
<span class="gp">....: </span>        <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]:</span>
<span class="gp">....: </span>            <span class="k">yield</span> <span class="n">x</span><span class="o">+</span><span class="n">letter</span>
</pre></div>
</div>
<p>We can then create the <a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet</span></code></a> object with either:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="p">],</span>
<span class="gp">....: </span>    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="n">letter</span> <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]]</span>
<span class="gp">....: </span>              <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="p">[],</span>
<span class="gp">....: </span>    <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;forest&#39;</span><span class="p">,</span> <span class="n">enumeration</span><span class="o">=</span><span class="s1">&#39;depth&#39;</span><span class="p">,</span>
<span class="gp">....: </span>    <span class="n">category</span><span class="o">=</span><span class="n">FiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[&#39;&#39;, &#39;a&#39;, &#39;aa&#39;, &#39;ab&#39;, &#39;ac&#39;, &#39;b&#39;, &#39;ba&#39;, &#39;bb&#39;, &#39;bc&#39;, &#39;c&#39;, &#39;ca&#39;, &#39;cb&#39;, &#39;cc&#39;]</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="p">],</span> <span class="n">children</span><span class="p">,</span>
<span class="gp">....: </span>    <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;forest&#39;</span><span class="p">,</span> <span class="n">enumeration</span><span class="o">=</span><span class="s1">&#39;depth&#39;</span><span class="p">,</span>
<span class="gp">....: </span>    <span class="n">category</span><span class="o">=</span><span class="n">FiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[&#39;&#39;, &#39;a&#39;, &#39;aa&#39;, &#39;ab&#39;, &#39;ac&#39;, &#39;b&#39;, &#39;ba&#39;, &#39;bb&#39;, &#39;bc&#39;, &#39;c&#39;, &#39;ca&#39;, &#39;cb&#39;, &#39;cc&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="example-forest-structure-2">
<h2>Example: Forest structure 2<a class="headerlink" href="#example-forest-structure-2" title="Permalink to this headline">¶</a></h2>
<p>This example was provided by Florent Hivert.</p>
<p>Here is a little more involved example. We want to iterate through all
permutations of a given set <span class="math notranslate nohighlight">\(S\)</span>. One solution is to take elements of <span class="math notranslate nohighlight">\(S\)</span> one
by one an insert them at every positions. So a node of the generating tree
contains two pieces of information:</p>
<ul class="simple">
<li><p>the list <code class="docutils literal notranslate"><span class="pre">lst</span></code> of already inserted element;</p></li>
<li><p>the set <code class="docutils literal notranslate"><span class="pre">st</span></code> of the yet to be inserted element.</p></li>
</ul>
<p>We want to generate a permutation only if <code class="docutils literal notranslate"><span class="pre">st</span></code> is empty (leaves on the
tree). Also suppose for the sake of the example, that instead of list we want
to generate tuples. This selection of some nodes and final mapping of a
function to the element is done by the <code class="docutils literal notranslate"><span class="pre">post_process</span> <span class="pre">=</span> <span class="pre">f</span></code> argument. The
convention is that the generated elements are the <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">:=</span> <span class="pre">f(n)</span></code>, except when
<code class="docutils literal notranslate"><span class="pre">s</span></code> not <code class="docutils literal notranslate"><span class="pre">None</span></code> when no element is generated at all. Here is the code:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">st</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span>
<span class="gp">....: </span>    <span class="n">st</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="c1"># make a copy</span>
<span class="gp">....: </span>    <span class="k">if</span> <span class="n">st</span><span class="p">:</span>
<span class="gp">....: </span>       <span class="n">el</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="gp">....: </span>       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">....: </span>           <span class="k">yield</span> <span class="p">(</span><span class="n">lst</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">el</span><span class="p">]</span><span class="o">+</span><span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">:],</span> <span class="n">st</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">children</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">})))</span>
<span class="go">[([9, 1, 2], {3, 7}), ([1, 9, 2], {3, 7}), ([1, 2, 9], {3, 7})]</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">post_process</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span> <span class="k">else</span> <span class="bp">None</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">(</span> <span class="p">[([],</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">})],</span>
<span class="gp">....: </span>    <span class="n">children</span><span class="p">,</span> <span class="n">post_process</span><span class="o">=</span><span class="n">post_process</span><span class="p">,</span>
<span class="gp">....: </span>    <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;forest&#39;</span><span class="p">,</span> <span class="n">enumeration</span><span class="o">=</span><span class="s1">&#39;depth&#39;</span><span class="p">,</span>
<span class="gp">....: </span>    <span class="n">category</span><span class="o">=</span><span class="n">FiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[(6, 3, 1, 8), (3, 6, 1, 8), (3, 1, 6, 8), (3, 1, 8, 6), (6, 1, 3, 8),</span>
<span class="go"> (1, 6, 3, 8), (1, 3, 6, 8), (1, 3, 8, 6), (6, 1, 8, 3), (1, 6, 8, 3),</span>
<span class="go"> (1, 8, 6, 3), (1, 8, 3, 6), (6, 3, 8, 1), (3, 6, 8, 1), (3, 8, 6, 1),</span>
<span class="go"> (3, 8, 1, 6), (6, 8, 3, 1), (8, 6, 3, 1), (8, 3, 6, 1), (8, 3, 1, 6),</span>
<span class="go"> (6, 8, 1, 3), (8, 6, 1, 3), (8, 1, 6, 3), (8, 1, 3, 6)]</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">24</span>
</pre></div>
</div>
<dl class="py function">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet">
<code class="sig-prename descclassname">sage.sets.recursively_enumerated_set.</code><code class="sig-name descname">RecursivelyEnumeratedSet</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seeds</span></em>, <em class="sig-param"><span class="n">successors</span></em>, <em class="sig-param"><span class="n">structure</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">enumeration</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_depth</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">post_process</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">facade</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">category</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a recursively enumerated set.</p>
<p>A set <span class="math notranslate nohighlight">\(S\)</span> is called recursively enumerable if there is an algorithm that
enumerates the members of <span class="math notranslate nohighlight">\(S\)</span>. We consider here the recursively
enumerated set that are described by some <code class="docutils literal notranslate"><span class="pre">seeds</span></code> and a successor
function <code class="docutils literal notranslate"><span class="pre">successors</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(U\)</span> be a set and <code class="docutils literal notranslate"><span class="pre">successors</span></code> <span class="math notranslate nohighlight">\(:U \to 2^U\)</span> be a successor function
associating to each element of <span class="math notranslate nohighlight">\(U\)</span> a subset of <span class="math notranslate nohighlight">\(U\)</span>. Let <code class="docutils literal notranslate"><span class="pre">seeds</span></code> be a
subset of <span class="math notranslate nohighlight">\(U\)</span>. Let <span class="math notranslate nohighlight">\(S\subseteq U\)</span> be the set of elements of <span class="math notranslate nohighlight">\(U\)</span> that
can be reached from a seed by applying recursively the <code class="docutils literal notranslate"><span class="pre">successors</span></code>
function. This class provides different kinds of iterators (breadth first,
depth first, elements of given depth, etc.) for the elements of <span class="math notranslate nohighlight">\(S\)</span>.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Recursively_enumerable_set">Wikipedia article Recursively_enumerable_set</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">seeds</span></code> – list (or iterable) of hashable objects</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">successors</span></code> – function (or callable) returning a list (or iterable) of
hashable objects</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">structure</span></code> – string (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>), structure of the
set, possible values are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> – nothing is known about the structure of the set.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'forest'</span></code> – if the <code class="docutils literal notranslate"><span class="pre">successors</span></code> function generates a <em>forest</em>, that
is, each element can be reached uniquely from a seed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'graded'</span></code> – if the <code class="docutils literal notranslate"><span class="pre">successors</span></code> function is <em>graded</em>, that is, all
paths from a seed to a given element have equal length.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'symmetric'</span></code> – if the relation is <em>symmetric</em>, that is,
<code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">in</span> <span class="pre">successors(x)</span></code> if and only if <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">successors(y)</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">enumeration</span></code> – <code class="docutils literal notranslate"><span class="pre">'depth'</span></code>, <code class="docutils literal notranslate"><span class="pre">'breadth'</span></code>, <code class="docutils literal notranslate"><span class="pre">'naive'</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code>
(optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>). The default enumeration for the
<code class="docutils literal notranslate"><span class="pre">__iter__</span></code> function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_depth</span></code> – integer (optional, default: <code class="docutils literal notranslate"><span class="pre">float(&quot;inf&quot;)</span></code>), limit
the search to a certain depth, currently works only for breadth first
search</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">post_process</span></code> – (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>), for forest only</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">facade</span></code> – (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">category</span></code> – (optional, default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<p>A recursive set with no other information:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">A recursively enumerated set (breadth first search)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[0, 3, 5, 6, 8, 10, 9, 11, 13, 15]</span>
</pre></div>
</div>
<p>A recursive set with a forest structure:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;forest&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">An enumerated set with a forest structure</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">depth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[1, 2, 4, 8, 16, 32, 64]</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[1, 2, 3, 4, 5, 6, 7]</span>
</pre></div>
</div>
<p>A recursive set given by a symmetric relation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">A recursively enumerated set with a symmetric structure (breadth first search)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[10, 15, 9, 11, 14, 16, 8]</span>
</pre></div>
</div>
<p>A recursive set given by a graded relation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">I</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">A recursively enumerated set with a graded structure (breadth first search)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[0, 1, I, 2, I + 1, 2*I, 3]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If you do not set the good structure, you might obtain bad results,
like elements generated twice:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[0, -1, 1, -2, 0, 2, -3]</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="py class">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest">
<em class="property">class </em><code class="sig-prename descclassname">sage.sets.recursively_enumerated_set.</code><code class="sig-name descname">RecursivelyEnumeratedSet_forest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">roots</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">children</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">post_process</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">algorithm</span><span class="o">=</span><span class="default_value">'depth'</span></em>, <em class="sig-param"><span class="n">facade</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">category</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage 9.3 Reference Manual: Parents and Elements v9.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>The enumerated set of the nodes of the forest having the given
<code class="docutils literal notranslate"><span class="pre">roots</span></code>, and where <code class="docutils literal notranslate"><span class="pre">children(x)</span></code> returns the children of the
node <code class="docutils literal notranslate"><span class="pre">x</span></code> of the forest.</p>
<p>See also <a class="reference external" href="../../../combinat/sage/combinat/backtrack.html#sage.combinat.backtrack.GenericBacktracker" title="(in Sage 9.3 Reference Manual: Combinatorics v9.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.combinat.backtrack.GenericBacktracker</span></code></a>,
<a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet_graded</span></code></a>, and
<a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet_symmetric</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">roots</span></code> – a list (or iterable)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">children</span></code> – a function returning a list (or iterable, or iterator)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">post_process</span></code> – a function defined over the nodes of the
forest (default: no post processing)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – <code class="docutils literal notranslate"><span class="pre">'depth'</span></code> or <code class="docutils literal notranslate"><span class="pre">'breadth'</span></code> (default: <code class="docutils literal notranslate"><span class="pre">'depth'</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">category</span></code> – a category (default: <a class="reference external" href="../../../categories/sage/categories/enumerated_sets.html#sage.categories.enumerated_sets.EnumeratedSets" title="(in Sage 9.3 Reference Manual: Category Framework v9.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">EnumeratedSets</span></code></a>)</p></li>
</ul>
<p>The option <code class="docutils literal notranslate"><span class="pre">post_process</span></code> allows for customizing the nodes that
are actually produced. Furthermore, if <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> returns <code class="docutils literal notranslate"><span class="pre">None</span></code>,
then <code class="docutils literal notranslate"><span class="pre">x</span></code> won’t be output at all.</p>
<p>EXAMPLES:</p>
<p>We construct the set of all binary sequences of length at most
three, and list them:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">(</span> <span class="p">[[]],</span>
<span class="gp">....: </span>    <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">[],</span>
<span class="gp">....: </span>    <span class="n">category</span><span class="o">=</span><span class="n">FiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
<span class="go">[[],</span>
<span class="go"> [0], [0, 0], [0, 0, 0], [0, 0, 1], [0, 1], [0, 1, 0], [0, 1, 1],</span>
<span class="go"> [1], [1, 0], [1, 0, 0], [1, 0, 1], [1, 1], [1, 1, 0], [1, 1, 1]]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet_forest</span></code> needs to be explicitly told that the set is
finite for the following to work:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of finite enumerated sets</span>
<span class="gp">sage: </span><span class="n">S</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">15</span>
</pre></div>
</div>
<p>We proceed with the set of all lists of letters in <code class="docutils literal notranslate"><span class="pre">0,1,2</span></code>
without repetitions, ordered by increasing length (i.e. using a
breadth first search through the tree):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="n">tb</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">(</span> <span class="p">[[]],</span>
<span class="gp">....: </span>      <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">l</span><span class="p">],</span>
<span class="gp">....: </span>      <span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;breadth&#39;</span><span class="p">,</span>
<span class="gp">....: </span>      <span class="n">category</span><span class="o">=</span><span class="n">FiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">tb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">tb</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">16</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
<span class="go">[[],</span>
<span class="go"> [0], [1], [2],</span>
<span class="go"> [0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1],</span>
<span class="go"> [0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]</span>
</pre></div>
</div>
<p>For infinite sets, this option should be set carefully to ensure
that all elements are actually generated. The following example
builds the set of all ordered pairs <span class="math notranslate nohighlight">\((i,j)\)</span> of nonnegative
integers such that <span class="math notranslate nohighlight">\(j\leq 1\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span>
<span class="gp">....: </span>                 <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)]</span>
<span class="gp">....: </span>                           <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
</pre></div>
</div>
<p>With a depth first search, only the elements of the form <span class="math notranslate nohighlight">\((i,0)\)</span>
are generated:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">depth_search</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">depth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">depth_search</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)]</span>
</pre></div>
</div>
<p>Using instead breadth first search gives the usual anti-diagonal
iterator:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">breadth_search</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">breadth_search</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">)]</span>
<span class="go">[(0, 0),</span>
<span class="go"> (1, 0), (0, 1),</span>
<span class="go"> (2, 0), (1, 1), (0, 2),</span>
<span class="go"> (3, 0), (2, 1), (1, 2), (0, 3),</span>
<span class="go"> (4, 0), (3, 1), (2, 2), (1, 3), (0, 4)]</span>
</pre></div>
</div>
<p class="rubric">Deriving subclasses</p>
<p>The class of a parent <span class="math notranslate nohighlight">\(A\)</span> may derive from <a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet_forest</span></code></a> so
that <span class="math notranslate nohighlight">\(A\)</span> can benefit from enumeration tools. As a running example,
we consider the problem of enumerating integers whose binary
expansion have at most three nonzero digits. For example, <span class="math notranslate nohighlight">\(3 =
2^1 + 2^0\)</span> has two nonzero digits. <span class="math notranslate nohighlight">\(15 = 2^3 + 2^2 + 2^1 + 2^0\)</span>
has four nonzero digits. In fact, <span class="math notranslate nohighlight">\(15\)</span> is the smallest integer
which is not in the enumerated set.</p>
<p>To achieve this, we use <code class="docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet_forest</span></code> to enumerate binary tuples
with at most three nonzero digits, apply a post processing to
recover the corresponding integers, and discard tuples finishing
by zero.</p>
<p>A first approach is to pass the <code class="docutils literal notranslate"><span class="pre">roots</span></code> and <code class="docutils literal notranslate"><span class="pre">children</span></code>
functions as arguments to <code class="xref py py-meth docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet_forest.__init__()</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">RecursivelyEnumeratedSet_forest</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[()],</span>
<span class="gp">....: </span>            <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">x</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,)]</span> <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">[],</span>
<span class="gp">....: </span>            <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">^</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span> <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">None</span><span class="p">,</span>
<span class="gp">....: </span>            <span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;breadth&#39;</span><span class="p">,</span>
<span class="gp">....: </span>            <span class="n">category</span><span class="o">=</span><span class="n">InfiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">MyForest</span> <span class="o">=</span> <span class="n">A</span><span class="p">();</span> <span class="n">MyForest</span>
<span class="go">An enumerated set with a forest structure</span>
<span class="gp">sage: </span><span class="n">MyForest</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of infinite enumerated sets</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">MyForest</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">)]</span>
<span class="go">[1, 2, 3, 4, 6, 5, 7, 8, 12, 10, 14, 9, 13, 11, 16, 24, 20, 28, 18, 26, 22, 17, 25, 21, 19, 32, 48, 40, 56, 36]</span>
</pre></div>
</div>
<p>An alternative approach is to implement <code class="docutils literal notranslate"><span class="pre">roots</span></code> and <code class="docutils literal notranslate"><span class="pre">children</span></code>
as methods of the subclass (in fact they could also be attributes
of <span class="math notranslate nohighlight">\(A\)</span>). Namely, <code class="docutils literal notranslate"><span class="pre">A.roots()</span></code> must return an iterable containing
the enumeration generators, and <code class="docutils literal notranslate"><span class="pre">A.children(x)</span></code> must return an
iterable over the children of <span class="math notranslate nohighlight">\(x\)</span>. Optionally, <span class="math notranslate nohighlight">\(A\)</span> can have a
method or attribute such that <code class="docutils literal notranslate"><span class="pre">A.post_process(x)</span></code> returns the
desired output for the node <code class="docutils literal notranslate"><span class="pre">x</span></code> of the tree:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">UniqueRepresentation</span><span class="p">,</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="n">RecursivelyEnumeratedSet_forest</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="s1">&#39;breadth&#39;</span><span class="p">,</span>
<span class="gp">....: </span>                              <span class="n">category</span><span class="o">=</span><span class="n">InfiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">....:</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">return</span> <span class="p">[()]</span>
<span class="gp">....:</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">x</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,)]</span>
<span class="gp">....: </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="p">[]</span>
<span class="gp">....:</span>
<span class="gp">....: </span>    <span class="k">def</span> <span class="nf">post_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">....: </span>        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="bp">None</span>
<span class="gp">....: </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">....: </span>            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">^</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="gp">sage: </span><span class="n">MyForest</span> <span class="o">=</span> <span class="n">A</span><span class="p">();</span> <span class="n">MyForest</span>
<span class="go">An enumerated set with a forest structure</span>
<span class="gp">sage: </span><span class="n">MyForest</span><span class="o">.</span><span class="n">category</span><span class="p">()</span>
<span class="go">Category of infinite enumerated sets</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">MyForest</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">)]</span>
<span class="go">[1, 2, 3, 4, 6, 5, 7, 8, 12, 10, 14, 9, 13, 11, 16, 24, 20, 28, 18, 26, 22, 17, 25, 21, 19, 32, 48, 40, 56, 36]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>A <a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest"><code class="xref py py-class docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet_forest</span></code></a> instance is picklable if and only if
the input functions are themselves picklable. This excludes
anonymous or interactively defined functions:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">children</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">InfiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">dumps</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">PicklingError: Can&#39;t pickle &lt;...function...&gt;: attribute lookup ... failed</span>
</pre></div>
</div>
<p>Let us now fake <code class="docutils literal notranslate"><span class="pre">children</span></code> being defined in a Python module:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">import</span> <span class="nn">__main__</span>
<span class="gp">sage: </span><span class="n">__main__</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">children</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">(</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">children</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">InfiniteEnumeratedSets</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">loads</span><span class="p">(</span><span class="n">dumps</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
<span class="go">An enumerated set with a forest structure</span>
</pre></div>
</div>
</div>
<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.breadth_first_search_iterator">
<code class="sig-name descname">breadth_first_search_iterator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.breadth_first_search_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a breadth first search iterator over the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code></p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">([[]],</span>
<span class="gp">....: </span>                 <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">[])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">())</span>
<span class="go">[[], [0], [1], [0, 0], [0, 1], [1, 0], [1, 1], [0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1]]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span>
<span class="gp">....: </span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">[(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)],</span>
<span class="gp">....: </span><span class="n">post_process</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="p">((</span><span class="n">is_prime</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="ow">and</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span> <span class="k">else</span> <span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
<span class="go">[(5, 3), (7, 5), (13, 11), (19, 17), (31, 29), (43, 41), (61, 59)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.children">
<code class="sig-name descname">children</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.children" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the children of the element <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
<p>The result can be a list, an iterable, an iterator, or even a
generator.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">children</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))]</span>
<span class="go">[(1, 0), (0, 1)]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">children</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))]</span>
<span class="go">[(2, 0), (1, 1)]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">children</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))]</span>
<span class="go">[(1, 2)]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">children</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))]</span>
<span class="go">[(4, 2)]</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">children</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">))]</span>
<span class="go">[(5, 0), (4, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.depth_first_search_iterator">
<code class="sig-name descname">depth_first_search_iterator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.depth_first_search_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a depth first search iterator over the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code></p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">([[]],</span>
<span class="gp">....: </span>                 <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">[])</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">depth_first_search_iterator</span><span class="p">())</span>
<span class="go">[[], [0], [0, 0], [0, 0, 0], [0, 0, 1], [0, 1], [0, 1, 0], [0, 1, 1], [1], [1, 0], [1, 0, 0], [1, 0, 1], [1, 1], [1, 1, 0], [1, 1, 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.elements_of_depth_iterator">
<code class="sig-name descname">elements_of_depth_iterator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">depth</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.elements_of_depth_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator over the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> of given depth.
An element of depth <span class="math notranslate nohighlight">\(n\)</span> can be obtained applying <span class="math notranslate nohighlight">\(n\)</span> times the
children function from a root.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span> <span class="p">,</span>
<span class="gp">....: </span>       <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">[(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)],</span>
<span class="gp">....: </span>       <span class="n">post_process</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="p">((</span><span class="n">is_prime</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">....: </span>                                       <span class="ow">and</span> <span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span> <span class="k">else</span> <span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">(5, 3)</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">(</span><span class="n">NN</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">[],</span>
<span class="gp">....: </span>                     <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_prime</span><span class="p">()</span> <span class="k">else</span> <span class="bp">None</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
<span class="go">[4, 9, 25, 49, 121]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.map_reduce">
<code class="sig-name descname">map_reduce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">map_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reduce_function</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">reduce_init</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.map_reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a Map/Reduce algorithm on <code class="docutils literal notranslate"><span class="pre">self</span></code></p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">map_function</span></code> – a function from the element of <code class="docutils literal notranslate"><span class="pre">self</span></code> to some
set with a reduce operation (e.g.: a monoid). The default value is
the constant function <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reduce_function</span></code> – the reduce function (e.g.: the addition of a
monoid). The default value is <code class="docutils literal notranslate"><span class="pre">+</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reduce_init</span></code> – the initialisation of the reduction (e.g.: the
neutral element of the monoid). The default value is <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the effect of the default values is to compute the cardinality
of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">seeds</span> <span class="o">=</span> <span class="p">[([</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">succ</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="nb">list</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">t</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="p">[(</span><span class="nb">list</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">sum</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">last</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">(</span><span class="n">seeds</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span>
<span class="gp">....: </span>                      <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;forest&#39;</span><span class="p">,</span> <span class="n">enumeration</span><span class="o">=</span><span class="s1">&#39;depth&#39;</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">y</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">def</span> <span class="nf">map_function</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">li</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">t</span>
<span class="gp">....: </span>    <span class="k">return</span> <span class="n">y</span> <span class="o">^</span> <span class="nb">sum</span>
<span class="gp">sage: </span><span class="n">reduce_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">map_reduce</span><span class="p">(</span><span class="n">map_function</span><span class="p">,</span> <span class="n">reduce_function</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">y^45 + y^44 + y^43 + 2*y^42 + 2*y^41 + 3*y^40 + 4*y^39 + 5*y^38 + 6*y^37 + 8*y^36 + 9*y^35 + 10*y^34 + 12*y^33 + 13*y^32 + 15*y^31 + 17*y^30 + 18*y^29 + 19*y^28 + 21*y^27 + 21*y^26 + 22*y^25 + 23*y^24 + 23*y^23 + 23*y^22 + 23*y^21 + 22*y^20 + 21*y^19 + 21*y^18 + 19*y^17 + 18*y^16 + 17*y^15 + 15*y^14 + 13*y^13 + 12*y^12 + 10*y^11 + 9*y^10 + 8*y^9 + 6*y^8 + 5*y^7 + 4*y^6 + 3*y^5 + 2*y^4 + 2*y^3 + y^2 + y</span>
</pre></div>
</div>
<p>Here is an example with the default values:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">map_reduce</span><span class="p">()</span>
<span class="go">511</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="../../../parallel/sage/parallel/map_reduce.html#module-sage.parallel.map_reduce" title="(in Sage 9.3 Reference Manual: Parallel Computing v9.3)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sage.parallel.map_reduce</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.roots">
<code class="sig-name descname">roots</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_forest.roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterable over the roots of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">RecursivelyEnumeratedSet_forest</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">roots</span><span class="p">()]</span>
<span class="go">[(0, 0)]</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet_forest</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">roots</span><span class="p">()]</span>
<span class="go">[(0, 0), (1, 1)]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic">
<em class="property">class </em><code class="sig-prename descclassname">sage.sets.recursively_enumerated_set.</code><code class="sig-name descname">RecursivelyEnumeratedSet_generic</code><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage 9.3 Reference Manual: Parents and Elements v9.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>A generic recursively enumerated set.</p>
<p>For more information, see <a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet"><code class="xref py py-func docutils literal notranslate"><span class="pre">RecursivelyEnumeratedSet()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Different structure for the sets:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="go">A recursively enumerated set (breadth first search)</span>
<span class="gp">sage: </span><span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">)</span>
<span class="go">A recursively enumerated set with a graded structure (breadth first search)</span>
<span class="gp">sage: </span><span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="go">A recursively enumerated set with a symmetric structure (breadth first search)</span>
<span class="gp">sage: </span><span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;forest&#39;</span><span class="p">)</span>
<span class="go">An enumerated set with a forest structure</span>
</pre></div>
</div>
<p>Different default enumeration algorithms:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">enumeration</span><span class="o">=</span><span class="s1">&#39;breadth&#39;</span><span class="p">)</span>
<span class="go">A recursively enumerated set (breadth first search)</span>
<span class="gp">sage: </span><span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">enumeration</span><span class="o">=</span><span class="s1">&#39;naive&#39;</span><span class="p">)</span>
<span class="go">A recursively enumerated set (naive search)</span>
<span class="gp">sage: </span><span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">enumeration</span><span class="o">=</span><span class="s1">&#39;depth&#39;</span><span class="p">)</span>
<span class="go">A recursively enumerated set (depth first search)</span>
</pre></div>
</div>
<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.breadth_first_search_iterator">
<code class="sig-name descname">breadth_first_search_iterator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_depth</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.breadth_first_search_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate on the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> (breadth first).</p>
<p>This code remembers every element generated.</p>
<p>The elements are guaranteed to be enumerated in the order in which they
are first visited (left-to-right traversal).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_depth</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">self._max_depth</span></code>) specifies the
maximal depth to which elements are computed</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[0, 3, 5, 6, 8, 10, 9, 11, 13, 15]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.depth_first_search_iterator">
<code class="sig-name descname">depth_first_search_iterator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.depth_first_search_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate on the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> (depth first).</p>
<p>This code remembers every elements generated.</p>
<p>The elements are traversed right-to-left, so the last element returned
by the successor function is visited first.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Depth-first_search">Wikipedia article Depth-first_search</a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">depth_first_search_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[0, 5, 10, 15, 20, 25, 30, 35, 40, 45]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.elements_of_depth_iterator">
<code class="sig-name descname">elements_of_depth_iterator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">depth</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.elements_of_depth_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> of given depth.</p>
<p>An element of depth <span class="math notranslate nohighlight">\(n\)</span> can be obtained applying <span class="math notranslate nohighlight">\(n\)</span> times the
successor function to a seed.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">depth</span></code> – integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>An iterator.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">elements_of_depth_iterator</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">sorted</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="go">[3, 7, 8, 12]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.graded_component">
<code class="sig-name descname">graded_component</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">depth</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.graded_component" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the graded component of given depth.</p>
<p>This method caches each lower graded component.</p>
<p>A graded component is a set of elements of the same depth where the
depth of an element is its minimal distance to a root.</p>
<p>It is currently implemented only for graded or symmetric structure.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">depth</span></code> – integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>A set.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">NotImplementedError: graded_component_iterator method currently implemented only for graded or symmetric structure</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.graded_component_iterator">
<code class="sig-name descname">graded_component_iterator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.graded_component_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the graded components of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>A graded component is a set of elements of the same depth.</p>
<p>It is currently implemented only for graded or symmetric structure.</p>
<p>OUTPUT:</p>
<p>An iterator of sets.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">graded_component_iterator</span><span class="p">()</span>    <span class="c1"># todo: not implemented</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.naive_search_iterator">
<code class="sig-name descname">naive_search_iterator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.naive_search_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate on the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> (in no particular order).</p>
<p>This code remembers every elements generated.</p>
</dd></dl>

<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.seeds">
<code class="sig-name descname">seeds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.seeds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterable over the seeds of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">seeds</span><span class="p">()</span>
<span class="go">[1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.successors">
<code class="sig-name descname">successors</code><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.successors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.to_digraph">
<code class="sig-name descname">to_digraph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_depth</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">loops</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">multiedges</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic.to_digraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the directed graph of the recursively enumerated set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_depth</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">self._max_depth</span></code>) specifies the
maximal depth for which outgoing edges of elements are computed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">loops</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) option for the digraph</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">multiedges</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) option of the digraph</p></li>
</ul>
<p>OUTPUT:</p>
<p>A directed graph</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If the set is infinite, this will loop forever unless <code class="docutils literal notranslate"><span class="pre">max_depth</span></code>
is finite.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">child</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">child</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">to_digraph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 10 vertices</span>
</pre></div>
</div>
<p>Digraph of an recursively enumerated set with a symmetric structure of
infinite cardinality using <code class="docutils literal notranslate"><span class="pre">max_depth</span></code> argument:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">succ</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">seeds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">(</span><span class="n">seeds</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">to_digraph</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Looped multi-digraph on 41 vertices</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">max_depth</span></code> argument can be given at the creation of the set:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">(</span><span class="n">seeds</span><span class="p">,</span> <span class="n">succ</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">to_digraph</span><span class="p">()</span>
<span class="go">Looped multi-digraph on 25 vertices</span>
</pre></div>
</div>
<p>Digraph of an recursively enumerated set with a graded structure:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">I</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">to_digraph</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Looped multi-digraph on 21 vertices</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded">
<em class="property">class </em><code class="sig-prename descclassname">sage.sets.recursively_enumerated_set.</code><code class="sig-name descname">RecursivelyEnumeratedSet_graded</code><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic</span></code></a></p>
<p>Generic tool for constructing ideals of a graded relation.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">seeds</span></code> – list (or iterable) of hashable objects</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">successors</span></code> – function (or callable) returning a list (or iterable)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enumeration</span></code> – <code class="docutils literal notranslate"><span class="pre">'depth'</span></code>, <code class="docutils literal notranslate"><span class="pre">'breadth'</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_depth</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">float(&quot;inf&quot;)</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">A recursively enumerated set with a graded structure (breadth first</span>
<span class="go">search) with max_depth=3</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="go">[(0, 0),</span>
<span class="go"> (1, 0), (0, 1),</span>
<span class="go"> (2, 0), (1, 1), (0, 2),</span>
<span class="go"> (3, 0), (2, 1), (1, 2), (0, 3)]</span>
</pre></div>
</div>
<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded.breadth_first_search_iterator">
<code class="sig-name descname">breadth_first_search_iterator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_depth</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded.breadth_first_search_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate on the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> (breadth first).</p>
<p>This iterator makes use of the graded structure by remembering only
the elements of the current depth.</p>
<p>The elements are guaranteed to be enumerated in the order in which they
are first visited (left-to-right traversal).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_depth</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">self._max_depth</span></code>) specifies the
maximal depth to which elements are computed</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[(0, 0),</span>
<span class="go"> (1, 0), (0, 1),</span>
<span class="go"> (2, 0), (1, 1), (0, 2),</span>
<span class="go"> (3, 0), (2, 1), (1, 2), (0, 3)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded.graded_component">
<code class="sig-name descname">graded_component</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">depth</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded.graded_component" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the graded component of given depth.</p>
<p>This method caches each lower graded component. See
<a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded.graded_component_iterator" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded.graded_component_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graded_component_iterator()</span></code></a> to generate each graded component
without caching the previous ones.</p>
<p>A graded component is a set of elements of the same depth where the
depth of an element is its minimal distance to a root.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">depth</span></code> – integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>A set.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">I</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="go">[0]</span>
<span class="go">[I, 1]</span>
<span class="go">[2*I, I + 1, 2]</span>
<span class="go">[3*I, 2*I + 1, I + 2, 3]</span>
<span class="go">[4*I, 3*I + 1, 2*I + 2, I + 3, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded.graded_component_iterator">
<code class="sig-name descname">graded_component_iterator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_graded.graded_component_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the graded components of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>A graded component is a set of elements of the same depth.</p>
<p>The algorithm remembers only the current graded component generated
since the structure is graded.</p>
<p>OUTPUT:</p>
<p>An iterator of sets.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;graded&#39;</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">graded_component_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
<span class="go">[(0, 0)]</span>
<span class="go">[(0, 1), (1, 0)]</span>
<span class="go">[(0, 2), (1, 1), (2, 0)]</span>
<span class="go">[(0, 3), (1, 2), (2, 1), (3, 0)]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric">
<em class="property">class </em><code class="sig-prename descclassname">sage.sets.recursively_enumerated_set.</code><code class="sig-name descname">RecursivelyEnumeratedSet_symmetric</code><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_generic</span></code></a></p>
<p>Generic tool for constructing ideals of a symmetric relation.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">seeds</span></code> – list (or iterable) of hashable objects</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">successors</span></code> – function (or callable) returning a list (or iterable)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enumeration</span></code> – <code class="docutils literal notranslate"><span class="pre">'depth'</span></code>, <code class="docutils literal notranslate"><span class="pre">'breadth'</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default: <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_depth</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">float(&quot;inf&quot;)</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span>
<span class="go">A recursively enumerated set with a symmetric structure (breadth first search)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[0, -1, 1, -2, 2, -3, 3]</span>
</pre></div>
</div>
<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric.breadth_first_search_iterator">
<code class="sig-name descname">breadth_first_search_iterator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_depth</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric.breadth_first_search_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate on the elements of <code class="docutils literal notranslate"><span class="pre">self</span></code> (breadth first).</p>
<p>This iterator makes use of the graded structure by remembering only
the last two graded components since the structure is symmetric.</p>
<p>The elements are guaranteed to be enumerated in the order in which they
are first visited (left-to-right traversal).</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_depth</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">self._max_depth</span></code>) specifies the
maximal depth to which elements are computed</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">breadth_first_search_iterator</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">2</span><span class="p">));</span> <span class="n">s</span>
<span class="go">[(0, 0),</span>
<span class="go"> (-1, 0), (0, -1), (1, 0), (0, 1),</span>
<span class="go"> (-2, 0), (-1, -1), (-1, 1), (0, -2), (1, -1), (2, 0), (1, 1), (0, 2)]</span>
</pre></div>
</div>
<p>This iterator is used by default for symmetric structure:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">==</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">13</span><span class="p">)]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric.graded_component">
<code class="sig-name descname">graded_component</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">depth</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric.graded_component" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the graded component of given depth.</p>
<p>This method caches each lower graded component. See
<a class="reference internal" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric.graded_component_iterator" title="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric.graded_component_iterator"><code class="xref py py-meth docutils literal notranslate"><span class="pre">graded_component_iterator()</span></code></a> to generate each graded component
without caching the previous ones.</p>
<p>A graded component is a set of elements of the same depth where the
depth of an element is its minimal distance to a root.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">depth</span></code> – integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>A set.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">graded_component</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="go">[10, 15]</span>
<span class="go">[9, 11, 14, 16]</span>
<span class="go">[8, 12, 13, 17]</span>
<span class="go">[7, 18]</span>
<span class="go">[6, 19]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric.graded_component_iterator">
<code class="sig-name descname">graded_component_iterator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.RecursivelyEnumeratedSet_symmetric.graded_component_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over the graded components of <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>A graded component is a set of elements of the same depth.</p>
<p>The enumeration remembers only the last two graded components
generated since the structure is symmetric.</p>
<p>OUTPUT:</p>
<p>An iterator of sets.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">10</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">graded_component_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="go">[[10], [9, 11], [8, 12], [7, 13], [6, 14]]</span>
</pre></div>
</div>
<p>Starting with two generators:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">graded_component_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="go">[[5, 10], [4, 6, 9, 11], [3, 7, 8, 12], [2, 13], [1, 14]]</span>
</pre></div>
</div>
<p>Gaussian integers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">I</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S</span> <span class="o">=</span> <span class="n">RecursivelyEnumeratedSet</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">graded_component_iterator</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)]</span>
<span class="go">[[0],</span>
<span class="go"> [I, 1],</span>
<span class="go"> [2*I, I + 1, 2],</span>
<span class="go"> [3*I, 2*I + 1, I + 2, 3],</span>
<span class="go"> [4*I, 3*I + 1, 2*I + 2, I + 3, 4],</span>
<span class="go"> [5*I, 4*I + 1, 3*I + 2, 2*I + 3, I + 4, 5],</span>
<span class="go"> [6*I, 5*I + 1, 4*I + 2, 3*I + 3, 2*I + 4, I + 5, 6]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="sage.sets.recursively_enumerated_set.search_forest_iterator">
<code class="sig-prename descclassname">sage.sets.recursively_enumerated_set.</code><code class="sig-name descname">search_forest_iterator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">roots</span></em>, <em class="sig-param"><span class="n">children</span></em>, <em class="sig-param"><span class="n">algorithm</span><span class="o">=</span><span class="default_value">'depth'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.sets.recursively_enumerated_set.search_forest_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator on the nodes of the forest having the given
roots, and where <code class="docutils literal notranslate"><span class="pre">children(x)</span></code> returns the children of the node <code class="docutils literal notranslate"><span class="pre">x</span></code>
of the forest.  Note that every node of the tree is returned,
not simply the leaves.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">roots</span></code> – a list (or iterable)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">children</span></code> – a function returning a list (or iterable)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">algorithm</span></code> – <code class="docutils literal notranslate"><span class="pre">'depth'</span></code> or <code class="docutils literal notranslate"><span class="pre">'breadth'</span></code> (default: <code class="docutils literal notranslate"><span class="pre">'depth'</span></code>)</p></li>
</ul>
<p>EXAMPLES:</p>
<p>We construct the prefix tree of binary sequences of length at most
three, and enumerate its nodes:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.sets.recursively_enumerated_set</span> <span class="kn">import</span> <span class="n">search_forest_iterator</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">search_forest_iterator</span><span class="p">([[]],</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">....: </span>                                  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">[]))</span>
<span class="go">[[], [0], [0, 0], [0, 0, 0], [0, 0, 1], [0, 1], [0, 1, 0],</span>
<span class="go"> [0, 1, 1], [1], [1, 0], [1, 0, 0], [1, 0, 1], [1, 1], [1, 1, 0], [1, 1, 1]]</span>
</pre></div>
</div>
<p>By default, the nodes are iterated through by depth first search.
We can instead use a breadth first search (increasing depth):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">search_forest_iterator</span><span class="p">([[]],</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">....: </span>                                  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="p">[],</span>
<span class="gp">....: </span>                            <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;breadth&#39;</span><span class="p">))</span>
<span class="go">[[],</span>
<span class="go"> [0], [1],</span>
<span class="go"> [0, 0], [0, 1], [1, 0], [1, 1],</span>
<span class="go"> [0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1],</span>
<span class="go"> [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1]]</span>
</pre></div>
</div>
<p>This allows for iterating trough trees of infinite depth:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">it</span> <span class="o">=</span> <span class="n">search_forest_iterator</span><span class="p">([[]],</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="o">+</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;breadth&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="p">[</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="p">]</span>
<span class="go">[[],</span>
<span class="go"> [0], [1], [0, 0], [0, 1], [1, 0], [1, 1],</span>
<span class="go"> [0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1],</span>
<span class="go"> [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1],</span>
<span class="go"> [0, 0, 0, 0]]</span>
</pre></div>
</div>
<p>Here is an iterator through the prefix tree of sequences of
letters in <span class="math notranslate nohighlight">\(0,1,2\)</span> without repetitions, sorted by length; the
leaves are therefore permutations:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">search_forest_iterator</span><span class="p">([[]],</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">l</span><span class="p">],</span>
<span class="gp">....: </span>                            <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;breadth&#39;</span><span class="p">))</span>
<span class="go">[[],</span>
<span class="go"> [0], [1], [2],</span>
<span class="go"> [0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1],</span>
<span class="go"> [0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Recursively enumerated set</a><ul>
<li><a class="reference internal" href="#no-hypothesis-on-the-structure">No hypothesis on the structure</a></li>
<li><a class="reference internal" href="#symmetric-structure">Symmetric structure</a></li>
<li><a class="reference internal" href="#graded-structure">Graded structure</a></li>
<li><a class="reference internal" href="#forest-structure">Forest structure</a></li>
<li><a class="reference internal" href="#example-forest-structure">Example: Forest structure</a></li>
<li><a class="reference internal" href="#example-forest-structure-2">Example: Forest structure 2</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="finite_enumerated_set.html"
                        title="previous chapter">Finite Enumerated Sets</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="finite_set_maps.html"
                        title="next chapter">Maps between finite sets</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/sets/recursively_enumerated_set.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="finite_set_maps.html" title="Maps between finite sets"
             >next</a> |</li>
        <li class="right" >
          <a href="finite_enumerated_set.html" title="Finite Enumerated Sets"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.3 Reference Manual: Sets</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Recursively enumerated set</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2021, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>