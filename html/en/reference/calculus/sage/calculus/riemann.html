
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="viewport" content="width=600, initial-scale=1">
    <title>Riemann Mapping &#8212; Sage 9.2 Reference Manual: Symbolic Calculus</title>
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script async="async" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Real Interpolation using GSL" href="interpolation.html" />
    <link rel="prev" title="Numerical Integration" href="integration.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="interpolation.html" title="Real Interpolation using GSL"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="integration.html" title="Numerical Integration"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.2 Reference Manual: Symbolic Calculus</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Riemann Mapping</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="riemann-mapping">
<span id="sage-calculus-riemann"></span><h1>Riemann Mapping<a class="headerlink" href="#riemann-mapping" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.calculus.riemann"></span><p>AUTHORS:</p>
<ul class="simple">
<li><p>Ethan Van Andel (2009-2011): initial version and upgrades</p></li>
<li><p>Robert Bradshaw (2009): his “complex_plot” was adapted for plot_colored</p></li>
</ul>
<p>Development supported by NSF award No. 0702939.</p>
<dl class="py class">
<dt id="sage.calculus.riemann.Riemann_Map">
<em class="property">class </em><code class="sig-prename descclassname">sage.calculus.riemann.</code><code class="sig-name descname">Riemann_Map</code><a class="headerlink" href="#sage.calculus.riemann.Riemann_Map" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">Riemann_Map</span></code> class computes an interior or exterior Riemann map,
or an Ahlfors map of a region given by the supplied boundary curve(s)
and center point. The class also provides various methods to
evaluate, visualize, or extract data from the map.</p>
<p>A Riemann map conformally maps a simply connected region in
the complex plane to the unit disc. The Ahlfors map does the same thing
for multiply connected regions.</p>
<p>Note that all the methods are numerical. As a result all answers have
some imprecision. Moreover, maps computed with small number of
collocation points, or for unusually shaped regions, may be very
inaccurate. Error computations for the ellipse can be found in the
documentation for <a class="reference internal" href="#sage.calculus.riemann.analytic_boundary" title="sage.calculus.riemann.analytic_boundary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">analytic_boundary()</span></code></a> and <a class="reference internal" href="#sage.calculus.riemann.analytic_interior" title="sage.calculus.riemann.analytic_interior"><code class="xref py py-meth docutils literal notranslate"><span class="pre">analytic_interior()</span></code></a>.</p>
<p><a class="reference internal" href="../../../references/index.html#bsv2010" id="id1"><span>[BSV2010]</span></a> provides an overview of the Riemann map and discusses the research
that lead to the creation of this module.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fs</span></code> – A list of the boundaries of the region, given as
complex-valued functions with domain <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(2*pi\)</span>. Note that the
outer boundary must be parameterized counter clockwise
(i.e. <code class="docutils literal notranslate"><span class="pre">e^(I*t)</span></code>) while the inner boundaries must be clockwise
(i.e. <code class="docutils literal notranslate"><span class="pre">e^(-I*t)</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fprimes</span></code> – A list of the derivatives of the boundary functions.
Must be in the same order as <code class="docutils literal notranslate"><span class="pre">fs</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">a</span></code> – Complex, the center of the Riemann map. Will be mapped to
the origin of the unit disc. Note that <code class="docutils literal notranslate"><span class="pre">a</span></code> MUST be within
the region in order for the results to be mathematically valid.</p></li>
</ul>
<p>The following inputs may be passed in as named parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">N</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">500</span></code>), the number of collocation points
used to compute the map. More points will give more accurate results,
especially near the boundaries, but will take longer to compute.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exterior</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>), if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the
exterior map will be computed, mapping the exterior of the region to the
exterior of the unit circle.</p></li>
</ul>
<p>The following inputs may be passed as named parameters in unusual
circumstances:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ncorners</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">4</span></code>), if mapping a figure with
(equally t-spaced) corners – corners that make a significant change in
the direction of the boundary – better results may be sometimes obtained by
accurately giving this parameter. Used to add the proper constant to
the theta correspondence function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">opp</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>), set to <code class="docutils literal notranslate"><span class="pre">True</span></code> in very rare
cases where the theta correspondence function is off by <code class="docutils literal notranslate"><span class="pre">pi</span></code>, that
is, if red is mapped left of the origin in the color plot.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>The unit circle identity map:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="n">fprime</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># long time (4 sec)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">plot_colored</span><span class="p">()</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">plot_spiderweb</span><span class="p">()</span>  <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 22 graphics primitives</span>
</pre></div>
</div>
<p>The exterior map for the unit circle:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="n">fprime</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">exterior</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># long time (4 sec)</span>
<span class="gp">sage: </span><span class="c1">#spiderwebs are not supported for exterior maps</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">plot_colored</span><span class="p">()</span> <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 1 graphics primitive</span>
</pre></div>
</div>
<p>The unit circle with a small hole:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">hf</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">hfprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*-</span><span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">,</span> <span class="n">hf</span><span class="p">],</span> <span class="p">[</span><span class="n">fprime</span><span class="p">,</span> <span class="n">hfprime</span><span class="p">],</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>
<span class="gp">sage: </span><span class="c1">#spiderweb and color plots cannot be added for multiply</span>
<span class="gp">sage: </span><span class="c1">#connected regions. Instead we do this.</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">plot_spiderweb</span><span class="p">(</span><span class="n">withcolor</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>  <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 3 graphics primitives</span>
</pre></div>
</div>
<p>A square:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ps</span> <span class="o">=</span> <span class="n">polygon_spline</span><span class="p">([(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ps</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">fprime</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ps</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="n">fprime</span><span class="p">],</span> <span class="mf">0.25</span><span class="p">,</span> <span class="n">ncorners</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">plot_colored</span><span class="p">()</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">plot_spiderweb</span><span class="p">()</span>  <span class="c1"># long time</span>
<span class="go">Graphics object consisting of 22 graphics primitives</span>
</pre></div>
</div>
<p>Compute rough error for this map:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.75</span>  <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;error = {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">inverse_riemann_map</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">riemann_map</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span>  <span class="c1"># long time</span>
<span class="go">error = (-0.000...+0.0016...j)</span>
</pre></div>
</div>
<p>A fun, complex region for demonstration purposes:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fp</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ef1</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="o">.</span><span class="mi">2</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+.</span><span class="mi">4</span><span class="o">+.</span><span class="mi">4</span><span class="o">*</span><span class="n">I</span>
<span class="gp">sage: </span><span class="n">ef1p</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">I</span><span class="o">*.</span><span class="mi">2</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">ef2</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="o">.</span><span class="mi">2</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-.</span><span class="mi">4</span><span class="o">+.</span><span class="mi">4</span><span class="o">*</span><span class="n">I</span>
<span class="gp">sage: </span><span class="n">ef2p</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">I</span><span class="o">*.</span><span class="mi">2</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pts</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span><span class="o">-.</span><span class="mi">15</span><span class="o">-</span><span class="mi">20</span><span class="o">/</span><span class="mi">1000</span><span class="p">),(</span><span class="o">-.</span><span class="mi">6</span><span class="p">,</span><span class="o">-.</span><span class="mi">27</span><span class="o">-</span><span class="mi">10</span><span class="o">/</span><span class="mi">1000</span><span class="p">),(</span><span class="o">-.</span><span class="mi">45</span><span class="p">,</span><span class="o">-.</span><span class="mi">45</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="o">-.</span><span class="mi">65</span><span class="o">+</span><span class="mi">10</span><span class="o">/</span><span class="mi">1000</span><span class="p">),(</span><span class="o">.</span><span class="mi">45</span><span class="p">,</span><span class="o">-.</span><span class="mi">45</span><span class="p">),(</span><span class="o">.</span><span class="mi">6</span><span class="p">,</span><span class="o">-.</span><span class="mi">27</span><span class="o">-</span><span class="mi">10</span><span class="o">/</span><span class="mi">1000</span><span class="p">),(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">-.</span><span class="mi">15</span><span class="o">-</span><span class="mi">10</span><span class="o">/</span><span class="mi">1000</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="o">-.</span><span class="mi">43</span><span class="o">+</span><span class="mi">10</span><span class="o">/</span><span class="mi">1000</span><span class="p">)]</span>
<span class="gp">sage: </span><span class="n">pts</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">cs</span> <span class="o">=</span> <span class="n">complex_cubic_spline</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">cs</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">mfprime</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cs</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">,</span><span class="n">ef1</span><span class="p">,</span><span class="n">ef2</span><span class="p">,</span><span class="n">mf</span><span class="p">],[</span><span class="n">fp</span><span class="p">,</span><span class="n">ef1p</span><span class="p">,</span><span class="n">ef2p</span><span class="p">,</span><span class="n">mfprime</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span> <span class="o">=</span> <span class="mi">400</span><span class="p">)</span> <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">plot_colored</span><span class="p">(</span><span class="n">plot_points</span> <span class="o">=</span> <span class="mi">400</span><span class="p">)</span> <span class="c1"># long time</span>
</pre></div>
</div>
<p>ALGORITHM:</p>
<p>This class computes the Riemann Map via the Szego kernel using an
adaptation of the method described by <a class="reference internal" href="../../../references/index.html#kt1986" id="id2"><span>[KT1986]</span></a>.</p>
<dl class="py method">
<dt id="sage.calculus.riemann.Riemann_Map.compute_on_grid">
<code class="sig-name descname">compute_on_grid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">plot_range</span></em>, <em class="sig-param"><span class="n">x_points</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.calculus.riemann.Riemann_Map.compute_on_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Riemann map on a grid of points. Note that these points
are complex of the form z = x + y*i.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">plot_range</span></code> – a tuple of the form <code class="docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax]</span></code>.
If the value is <code class="docutils literal notranslate"><span class="pre">[]</span></code>, the default plotting window of the map will
be used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x_points</span></code> – int, the size of the grid in the x direction
The number of points in the y_direction is scaled accordingly</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>a tuple containing <code class="docutils literal notranslate"><span class="pre">[z_values,</span> <span class="pre">xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax]</span></code>
where <code class="docutils literal notranslate"><span class="pre">z_values</span></code> is the evaluation of the map on the specified grid.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>General usage:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="n">fprime</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">data</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">compute_on_grid</span><span class="p">([],</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">(-0.0879...+0.9709...j)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.calculus.riemann.Riemann_Map.get_szego">
<code class="sig-name descname">get_szego</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">boundary</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">absolute_value</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.calculus.riemann.Riemann_Map.get_szego" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a discretized version of the Szego kernel for each boundary
function.</p>
<p>INPUT:</p>
<p>The following inputs may be passed in as named parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">boundary</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">-1</span></code>) if &lt; 0,
<a class="reference internal" href="#sage.calculus.riemann.Riemann_Map.get_theta_points" title="sage.calculus.riemann.Riemann_Map.get_theta_points"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_theta_points()</span></code></a> will return the points for all boundaries.
If &gt;= 0, <a class="reference internal" href="#sage.calculus.riemann.Riemann_Map.get_theta_points" title="sage.calculus.riemann.Riemann_Map.get_theta_points"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_theta_points()</span></code></a> will return only the points for
the boundary specified.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">absolute_value</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) if <code class="docutils literal notranslate"><span class="pre">True</span></code>, will
return the absolute value of the (complex valued) Szego kernel
instead of the kernel itself. Useful for plotting.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of points of the form
<code class="docutils literal notranslate"><span class="pre">[t</span> <span class="pre">value,</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">Szego</span> <span class="pre">kernel</span> <span class="pre">at</span> <span class="pre">that</span> <span class="pre">t]</span></code>.</p>
<p>EXAMPLES:</p>
<p>Generic use:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="n">fprime</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sz</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_szego</span><span class="p">(</span><span class="n">boundary</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">points</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_szego</span><span class="p">(</span><span class="n">absolute_value</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">list_plot</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="go">Graphics object consisting of 1 graphics primitive</span>
</pre></div>
</div>
<p>Extending the points by a spline:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">spline</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">0.0012158...</span>
<span class="gp">sage: </span><span class="n">plot</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span> <span class="c1"># plot the kernel</span>
<span class="go">Graphics object consisting of 1 graphics primitive</span>
</pre></div>
</div>
<p>The unit circle with a small hole:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">hf</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">hfprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*-</span><span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">,</span> <span class="n">hf</span><span class="p">],</span> <span class="p">[</span><span class="n">fprime</span><span class="p">,</span> <span class="n">hfprime</span><span class="p">],</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
<p>Getting the szego for a specific boundary:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">sz0</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_szego</span><span class="p">(</span><span class="n">boundary</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sz1</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_szego</span><span class="p">(</span><span class="n">boundary</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.calculus.riemann.Riemann_Map.get_theta_points">
<code class="sig-name descname">get_theta_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">boundary</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.calculus.riemann.Riemann_Map.get_theta_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of points of the form
<code class="docutils literal notranslate"><span class="pre">[t</span> <span class="pre">value,</span> <span class="pre">theta</span> <span class="pre">in</span> <span class="pre">e^(I*theta)]</span></code>, that is, a discretized version
of the theta/boundary correspondence function. In other words, a point
in this array [t1, t2] represents that the boundary point given by f(t1)
is mapped to a point on the boundary of the unit circle given by e^(I*t2).</p>
<p>For multiply connected domains, <code class="docutils literal notranslate"><span class="pre">get_theta_points</span></code> will list the
points for each boundary in the order that they were supplied.</p>
<p>INPUT:</p>
<p>The following input must all be passed in as named parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">boundary</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">-1</span></code>) if &lt; 0,
<code class="docutils literal notranslate"><span class="pre">get_theta_points()</span></code> will return the points for all boundaries.
If &gt;= 0, <code class="docutils literal notranslate"><span class="pre">get_theta_points()</span></code> will return only the points for
the boundary specified.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of points of the form <code class="docutils literal notranslate"><span class="pre">[t</span> <span class="pre">value,</span> <span class="pre">theta</span> <span class="pre">in</span> <span class="pre">e^(I*theta)]</span></code>.</p>
<p>EXAMPLES:</p>
<p>Getting the list of points, extending it via a spline, getting the
points for only the outside of a multiply connected domain:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="n">fprime</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">points</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_theta_points</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">list_plot</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="go">Graphics object consisting of 1 graphics primitive</span>
</pre></div>
</div>
<p>Extending the points by a spline:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">spline</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">1.627660...</span>
</pre></div>
</div>
<p>The unit circle with a small hole:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">hf</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">hfprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*-</span><span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">,</span> <span class="n">hf</span><span class="p">],</span> <span class="p">[</span><span class="n">hf</span><span class="p">,</span> <span class="n">hfprime</span><span class="p">],</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>
</pre></div>
</div>
<p>Getting the boundary correspondence for a specific boundary:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">tp0</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_theta_points</span><span class="p">(</span><span class="n">boundary</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">tp1</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get_theta_points</span><span class="p">(</span><span class="n">boundary</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.calculus.riemann.Riemann_Map.inverse_riemann_map">
<code class="sig-name descname">inverse_riemann_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pt</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.calculus.riemann.Riemann_Map.inverse_riemann_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inverse Riemann mapping of a point.</p>
<p>That is, given <code class="docutils literal notranslate"><span class="pre">pt</span></code> on the interior of the unit disc,
<code class="docutils literal notranslate"><span class="pre">inverse_riemann_map()</span></code> will return the point on the
original region that would be Riemann mapped to <code class="docutils literal notranslate"><span class="pre">pt</span></code>. Note
that this method does not work for multiply connected domains.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pt</span></code> – A complex number (usually with absolute value &lt;= 1)
representing the point to be inverse mapped.</p></li>
</ul>
<p>OUTPUT:</p>
<p>The point on the region that Riemann maps to the input point.</p>
<p>EXAMPLES:</p>
<p>Can work for different types of complex numbers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="n">fprime</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">inverse_riemann_map</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span>
<span class="go">(0.406880...+0.3614702...j)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">inverse_riemann_map</span><span class="p">(</span><span class="mf">0.95</span><span class="p">)</span>
<span class="go">(0.486319...-4.90019052...j)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">inverse_riemann_map</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">-</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>
<span class="go">(0.1653244...-0.180936...j)</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">inverse_riemann_map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="go">(-0.156280...+0.321819...j)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.calculus.riemann.Riemann_Map.plot_boundaries">
<code class="sig-name descname">plot_boundaries</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">plotjoined</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">rgbcolor</span><span class="o">=</span><span class="default_value">[0, 0, 0]</span></em>, <em class="sig-param"><span class="n">thickness</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.calculus.riemann.Riemann_Map.plot_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the boundaries of the region for the Riemann map. Note that
this method DOES work for multiply connected domains.</p>
<p>INPUT:</p>
<p>The following inputs may be passed in as named parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">plotjoined</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) If <code class="docutils literal notranslate"><span class="pre">False</span></code>,
discrete points will be drawn; otherwise they will be connected
by lines. In this case, if <code class="docutils literal notranslate"><span class="pre">plotjoined=False</span></code>, the points shown
will be the original collocation points used to generate the
Riemann map.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgbcolor</span></code> – float array (default: <code class="docutils literal notranslate"><span class="pre">[0,0,0]</span></code>) the
red-green-blue color of the boundary.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> – positive float (default: <code class="docutils literal notranslate"><span class="pre">1</span></code>) the thickness of
the lines or points in the boundary.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>General usage:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="n">fprime</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Default plot:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">plot_boundaries</span><span class="p">()</span>
<span class="go">Graphics object consisting of 1 graphics primitive</span>
</pre></div>
</div>
<p>Big blue collocation points:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">plot_boundaries</span><span class="p">(</span><span class="n">plotjoined</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rgbcolor</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">thickness</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">Graphics object consisting of 1 graphics primitive</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.calculus.riemann.Riemann_Map.plot_colored">
<code class="sig-name descname">plot_colored</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">plot_range</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">plot_points</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">interpolation</span><span class="o">=</span><span class="default_value">'catrom'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.calculus.riemann.Riemann_Map.plot_colored" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a colored plot of the Riemann map. A red point on the
colored plot corresponds to a red point on the unit disc.</p>
<p>INPUT:</p>
<p>The following inputs may be passed in as named parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">plot_range</span></code> – (default: <code class="docutils literal notranslate"><span class="pre">[]</span></code>) list of 4 values
<code class="docutils literal notranslate"><span class="pre">(xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax)</span></code>. Declare if you do not want the plot
to use the default range for the figure.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">plot_points</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">100</span></code>), number of points to
plot in the x direction. Points in the y direction are scaled
accordingly. Note that very large values can cause this function to
run slowly.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Given a Riemann map m, general usage:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="n">fprime</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">plot_colored</span><span class="p">()</span>
<span class="go">Graphics object consisting of 1 graphics primitive</span>
</pre></div>
</div>
<p>Plot zoomed in on a specific spot:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">plot_colored</span><span class="p">(</span><span class="n">plot_range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">.</span><span class="mi">25</span><span class="p">,</span><span class="o">.</span><span class="mi">75</span><span class="p">])</span>
<span class="go">Graphics object consisting of 1 graphics primitive</span>
</pre></div>
</div>
<p>High resolution plot:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">plot_colored</span><span class="p">(</span><span class="n">plot_points</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>  <span class="c1"># long time (29s on sage.math, 2012)</span>
<span class="go">Graphics object consisting of 1 graphics primitive</span>
</pre></div>
</div>
<p>To generate the unit circle map, it’s helpful to see what the
colors correspond to:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="n">fprime</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">plot_colored</span><span class="p">()</span>
<span class="go">Graphics object consisting of 1 graphics primitive</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.calculus.riemann.Riemann_Map.plot_spiderweb">
<code class="sig-name descname">plot_spiderweb</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spokes</span><span class="o">=</span><span class="default_value">16</span></em>, <em class="sig-param"><span class="n">circles</span><span class="o">=</span><span class="default_value">4</span></em>, <em class="sig-param"><span class="n">pts</span><span class="o">=</span><span class="default_value">32</span></em>, <em class="sig-param"><span class="n">linescale</span><span class="o">=</span><span class="default_value">0.99</span></em>, <em class="sig-param"><span class="n">rgbcolor</span><span class="o">=</span><span class="default_value">[0, 0, 0]</span></em>, <em class="sig-param"><span class="n">thickness</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">plotjoined</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">withcolor</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">plot_points</span><span class="o">=</span><span class="default_value">200</span></em>, <em class="sig-param"><span class="n">min_mag</span><span class="o">=</span><span class="default_value">0.001</span></em>, <em class="sig-param"><span class="n">interpolation</span><span class="o">=</span><span class="default_value">'catrom'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">options</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.calculus.riemann.Riemann_Map.plot_spiderweb" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a traditional “spiderweb plot” of the Riemann map. Shows
what concentric circles and radial lines map to. The radial lines
may exhibit erratic behavior near the boundary; if this occurs,
decreasing <code class="docutils literal notranslate"><span class="pre">linescale</span></code> may mitigate the problem.</p>
<p>For multiply connected domains the spiderweb is by necessity
generated using the forward mapping. This method is more
computationally intensive. In addition, these spiderwebs cannot
be <code class="docutils literal notranslate"><span class="pre">added</span></code> to color plots. Instead the <code class="docutils literal notranslate"><span class="pre">withcolor</span></code> option
must be used.</p>
<p>In addition, spiderweb plots are not currently supported for
exterior maps.</p>
<p>INPUT:</p>
<p>The following inputs may be passed in as named parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">spokes</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">16</span></code>) the number of equally
spaced radial lines to plot.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">circles</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">4</span></code>) the number of equally
spaced circles about the center to plot.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pts</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">32</span></code>) the number of points to
plot. Each radial line is made by <code class="docutils literal notranslate"><span class="pre">1*pts</span></code> points, each circle
has <code class="docutils literal notranslate"><span class="pre">2*pts</span></code> points. Note that high values may cause erratic
behavior of the radial lines near the boundaries.
- only for simply connected domains</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">linescale</span></code> – float between 0 and 1. Shrinks the radial lines
away from the boundary to reduce erratic behavior.
- only for simply connected domains</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgbcolor</span></code> – float array (default: <code class="docutils literal notranslate"><span class="pre">[0,0,0]</span></code>) the
red-green-blue color of the spiderweb.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> – positive float (default: <code class="docutils literal notranslate"><span class="pre">1</span></code>) the thickness of
the lines or points in the spiderweb.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">plotjoined</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>) If <code class="docutils literal notranslate"><span class="pre">False</span></code>,
discrete points will be drawn; otherwise they will be connected
by lines.
- only for simply connected domains</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">withcolor</span></code> – boolean (default: <code class="docutils literal notranslate"><span class="pre">False</span></code>) If <code class="docutils literal notranslate"><span class="pre">True</span></code>,
The spiderweb will be overlaid on the basic color plot.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">plot_points</span></code> – integer (default: <code class="docutils literal notranslate"><span class="pre">200</span></code>) the size of the grid in the x direction
The number of points in the y_direction is scaled accordingly.
Note that very large values can cause this function to run slowly.
- only for multiply connected domains</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">min_mag</span></code> – float (default: <code class="docutils literal notranslate"><span class="pre">0.001</span></code>) The magnitude cutoff
below which spiderweb points are not drawn. This only applies
to multiply connected domains and is designed to prevent
“fuzz” at the edge of the domain. Some complicated multiply
connected domains (particularly those with corners) may
require a larger value to look clean outside.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>General usage:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="n">fprime</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Default plot:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">plot_spiderweb</span><span class="p">()</span>
<span class="go">Graphics object consisting of 21 graphics primitives</span>
</pre></div>
</div>
<p>Simplified plot with many discrete points:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">plot_spiderweb</span><span class="p">(</span><span class="n">spokes</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">circles</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pts</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">linescale</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">plotjoined</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">Graphics object consisting of 6 graphics primitives</span>
</pre></div>
</div>
<p>Plot with thick, red lines:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">plot_spiderweb</span><span class="p">(</span><span class="n">rgbcolor</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">thickness</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Graphics object consisting of 21 graphics primitives</span>
</pre></div>
</div>
<p>To generate the unit circle map, it’s helpful to see what the
original spiderweb looks like:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="n">fprime</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">plot_spiderweb</span><span class="p">()</span>
<span class="go">Graphics object consisting of 21 graphics primitives</span>
</pre></div>
</div>
<p>A multiply connected region with corners. We set <code class="docutils literal notranslate"><span class="pre">min_mag</span></code> higher
to remove “fuzz” outside the domain:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">ps</span> <span class="o">=</span> <span class="n">polygon_spline</span><span class="p">([(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="gp">sage: </span><span class="n">z1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ps</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="n">z1p</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">ps</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">z2</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">+</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">);</span> <span class="n">z2p</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">z3</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="o">+</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">);</span> <span class="n">z3p</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">z1</span><span class="p">,</span><span class="n">z2</span><span class="p">,</span><span class="n">z3</span><span class="p">],[</span><span class="n">z1p</span><span class="p">,</span><span class="n">z2p</span><span class="p">,</span><span class="n">z3p</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="n">ncorners</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># long time</span>
<span class="gp">sage: </span><span class="n">p</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">plot_spiderweb</span><span class="p">(</span><span class="n">withcolor</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">plot_points</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">thickness</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">min_mag</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span> <span class="c1"># long time</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.calculus.riemann.Riemann_Map.riemann_map">
<code class="sig-name descname">riemann_map</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pt</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.calculus.riemann.Riemann_Map.riemann_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Riemann mapping of a point.</p>
<p>That is, given <code class="docutils literal notranslate"><span class="pre">pt</span></code> on the interior of the mapped region,
<code class="docutils literal notranslate"><span class="pre">riemann_map</span></code> will return the point on the unit disk that
<code class="docutils literal notranslate"><span class="pre">pt</span></code> maps to. Note that this method only works for interior
points; accuracy breaks down very close to the boundary. To
get boundary correspondance, use <a class="reference internal" href="#sage.calculus.riemann.Riemann_Map.get_theta_points" title="sage.calculus.riemann.Riemann_Map.get_theta_points"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_theta_points()</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pt</span></code> – A complex number representing the point to be
inverse mapped.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A complex number representing the point on the unit circle that
the input point maps to.</p>
<p>EXAMPLES:</p>
<p>Can work for different types of complex numbers:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="n">fprime</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">riemann_map</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">))</span>
<span class="go">(0.137514...+0.876696...j)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">CDF</span><span class="o">.</span><span class="n">gen</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">riemann_map</span><span class="p">(</span><span class="mf">1.3</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>
<span class="go">(-1.56...e-05+0.989694...j)</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">riemann_map</span><span class="p">(</span><span class="mf">0.4</span><span class="p">)</span>
<span class="go">(0.73324...+3.2...e-06j)</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">sage: </span><span class="n">m</span><span class="o">.</span><span class="n">riemann_map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">))</span>
<span class="go">(1.405757...e-05+8.06...e-10j)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="sage.calculus.riemann.analytic_boundary">
<code class="sig-prename descclassname">sage.calculus.riemann.</code><code class="sig-name descname">analytic_boundary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">epsilon</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.calculus.riemann.analytic_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides an exact (for n = infinity) Riemann boundary
correspondence for the ellipse with axes 1 + epsilon and 1 - epsilon. The
boundary is therefore given by e^(I*t)+epsilon*e^(-I*t). It is primarily
useful for testing the accuracy of the numerical <a class="reference internal" href="#sage.calculus.riemann.Riemann_Map" title="sage.calculus.riemann.Riemann_Map"><code class="xref py py-class docutils literal notranslate"><span class="pre">Riemann_Map</span></code></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – The boundary parameter, from 0 to 2*pi</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – integer - the number of terms to include.
10 is fairly accurate, 20 is very accurate.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">epsilon</span></code> – float - the skew of the ellipse (0 is circular)</p></li>
</ul>
<p>OUTPUT:</p>
<p>A theta value from 0 to 2*pi, corresponding to the point on the
circle e^(I*theta)</p>
</dd></dl>

<dl class="py function">
<dt id="sage.calculus.riemann.analytic_interior">
<code class="sig-prename descclassname">sage.calculus.riemann.</code><code class="sig-name descname">analytic_interior</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">epsilon</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.calculus.riemann.analytic_interior" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a nearly exact computation of the Riemann Map of an interior
point of the ellipse with axes 1 + epsilon and 1 - epsilon. It is
primarily useful for testing the accuracy of the numerical Riemann Map.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">z</span></code> – complex - the point to be mapped.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – integer - the number of terms to include.
10 is fairly accurate, 20 is very accurate.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt id="sage.calculus.riemann.cauchy_kernel">
<code class="sig-prename descclassname">sage.calculus.riemann.</code><code class="sig-name descname">cauchy_kernel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.calculus.riemann.cauchy_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Intermediate function for the integration in <code class="xref py py-meth docutils literal notranslate"><span class="pre">analytic_interior()</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code> – The boundary parameter, meant to be integrated over</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">args</span></code> – a tuple containing:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">epsilon</span></code> – float - the skew of the ellipse (0 is circular)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">z</span></code> – complex - the point to be mapped.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – integer - the number of terms to include.
10 is fairly accurate, 20 is very accurate.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">part</span></code> – will return the real (‘r’), imaginary (‘i’) or
complex (‘c’) value of the kernel</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py function">
<dt id="sage.calculus.riemann.complex_to_rgb">
<code class="sig-prename descclassname">sage.calculus.riemann.</code><code class="sig-name descname">complex_to_rgb</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">z_values</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.calculus.riemann.complex_to_rgb" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a (Numpy) array of complex numbers to its corresponding
matrix of RGB values.  For internal use of <a class="reference internal" href="#sage.calculus.riemann.Riemann_Map.plot_colored" title="sage.calculus.riemann.Riemann_Map.plot_colored"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_colored()</span></code></a>
only.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">z_values</span></code> – A Numpy array of complex numbers.</p></li>
</ul>
<p>OUTPUT:</p>
<p>An <span class="math notranslate nohighlight">\(N \times M \times 3\)</span> floating point Numpy array <code class="docutils literal notranslate"><span class="pre">X</span></code>, where
<code class="docutils literal notranslate"><span class="pre">X[i,j]</span></code> is an (r,g,b) tuple.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.calculus.riemann</span> <span class="kn">import</span> <span class="n">complex_to_rgb</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">sage: </span><span class="n">complex_to_rgb</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">]],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex128</span><span class="p">))</span>
<span class="go">array([[[1.        , 1.        , 1.        ],</span>
<span class="go">        [1.        , 0.05558355, 0.05558355],</span>
<span class="go">        [0.17301243, 0.        , 0.        ]]])</span>

<span class="gp">sage: </span><span class="n">complex_to_rgb</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1j</span><span class="p">,</span> <span class="mi">1000j</span><span class="p">]],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex128</span><span class="p">))</span>
<span class="go">array([[[1.        , 1.        , 1.        ],</span>
<span class="go">        [0.52779177, 1.        , 0.05558355],</span>
<span class="go">        [0.08650622, 0.17301243, 0.        ]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sage.calculus.riemann.complex_to_spiderweb">
<code class="sig-prename descclassname">sage.calculus.riemann.</code><code class="sig-name descname">complex_to_spiderweb</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">z_values</span></em>, <em class="sig-param"><span class="n">dr</span></em>, <em class="sig-param"><span class="n">dtheta</span></em>, <em class="sig-param"><span class="n">spokes</span></em>, <em class="sig-param"><span class="n">circles</span></em>, <em class="sig-param"><span class="n">rgbcolor</span></em>, <em class="sig-param"><span class="n">thickness</span></em>, <em class="sig-param"><span class="n">withcolor</span></em>, <em class="sig-param"><span class="n">min_mag</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.calculus.riemann.complex_to_spiderweb" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a grid of complex numbers into a matrix containing rgb data
for the Riemann spiderweb plot.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">z_values</span></code> – A grid of complex numbers, as a list of lists.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dr</span></code> – grid of floats, the r derivative of <code class="docutils literal notranslate"><span class="pre">z_values</span></code>.
Used to determine precision.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dtheta</span></code> – grid of floats, the theta derivative of <code class="docutils literal notranslate"><span class="pre">z_values</span></code>.
Used to determine precision.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">spokes</span></code> – integer - the number of equally spaced radial lines to plot.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">circles</span></code> – integer - the number of equally spaced circles about the
center to plot.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgbcolor</span></code> – float array - the red-green-blue color of the
lines of the spiderweb.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> – positive float - the thickness of the lines or points
in the spiderweb.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">withcolor</span></code> – boolean - If <code class="docutils literal notranslate"><span class="pre">True</span></code> the spiderweb will be overlaid
on the basic color plot.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">min_mag</span></code> – float - The magnitude cutoff below which spiderweb
points are not drawn. This only applies to multiply connected
domains and is designed to prevent “fuzz” at the edge of the
domain. Some complicated multiply connected domains (particularly
those with corners) may require a larger value to look clean
outside.</p></li>
</ul>
<p>OUTPUT:</p>
<p>An <span class="math notranslate nohighlight">\(N x M x 3\)</span> floating point Numpy array <code class="docutils literal notranslate"><span class="pre">X</span></code>, where
<code class="docutils literal notranslate"><span class="pre">X[i,j]</span></code> is an (r,g,b) tuple.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.calculus.riemann</span> <span class="kn">import</span> <span class="n">complex_to_spiderweb</span>
<span class="gp">sage: </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">sage: </span><span class="n">zval</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">],[</span><span class="o">.</span><span class="mi">2</span><span class="o">+.</span><span class="mi">3j</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-.</span><span class="mi">3j</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">deriv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">.</span><span class="mi">1</span><span class="p">]],</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">complex_to_spiderweb</span><span class="p">(</span><span class="n">zval</span><span class="p">,</span> <span class="n">deriv</span><span class="p">,</span><span class="n">deriv</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="bp">False</span><span class="p">,</span><span class="mf">0.001</span><span class="p">)</span>
<span class="go">array([[[1., 1., 1.],</span>
<span class="go">        [1., 1., 1.],</span>
<span class="go">        [1., 1., 1.]],</span>

<span class="go">       [[1., 1., 1.],</span>
<span class="go">        [0., 0., 0.],</span>
<span class="go">        [1., 1., 1.]],</span>

<span class="go">       [[1., 1., 1.],</span>
<span class="go">        [1., 1., 1.],</span>
<span class="go">        [1., 1., 1.]]])</span>

<span class="gp">sage: </span><span class="n">complex_to_spiderweb</span><span class="p">(</span><span class="n">zval</span><span class="p">,</span> <span class="n">deriv</span><span class="p">,</span><span class="n">deriv</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="bp">True</span><span class="p">,</span><span class="mf">0.001</span><span class="p">)</span>
<span class="go">array([[[1.        , 1.        , 1.        ],</span>
<span class="go">        [1.        , 0.05558355, 0.05558355],</span>
<span class="go">        [0.17301243, 0.        , 0.        ]],</span>

<span class="go">       [[1.        , 0.96804683, 0.48044583],</span>
<span class="go">        [0.        , 0.        , 0.        ],</span>
<span class="go">        [0.77351965, 0.5470393 , 1.        ]],</span>

<span class="go">       [[1.        , 1.        , 1.        ],</span>
<span class="go">        [1.        , 1.        , 1.        ],</span>
<span class="go">        [1.        , 1.        , 1.        ]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sage.calculus.riemann.get_derivatives">
<code class="sig-prename descclassname">sage.calculus.riemann.</code><code class="sig-name descname">get_derivatives</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">z_values</span></em>, <em class="sig-param"><span class="n">xstep</span></em>, <em class="sig-param"><span class="n">ystep</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.calculus.riemann.get_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the r*e^(I*theta) form of derivatives from the grid of points. The
derivatives are computed using quick-and-dirty taylor expansion and
assuming analyticity. As such <code class="docutils literal notranslate"><span class="pre">get_derivatives</span></code> is primarily intended
to be used for comparisons in <code class="docutils literal notranslate"><span class="pre">plot_spiderweb</span></code> and not for
applications that require great precision.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">z_values</span></code> – The values for a complex function evaluated on a grid
in the complex plane, usually from <code class="docutils literal notranslate"><span class="pre">compute_on_grid</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xstep</span></code> – float, the spacing of the grid points in the real direction</p></li>
</ul>
<p>OUTPUT:</p>
<ul class="simple">
<li><p>A tuple of arrays, [<code class="docutils literal notranslate"><span class="pre">dr</span></code>, <code class="docutils literal notranslate"><span class="pre">dtheta</span></code>], with each array 2 less in both
dimensions than <code class="docutils literal notranslate"><span class="pre">z_values</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">dr</span></code> - the abs of the derivative of the function in the +r direction</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dtheta</span></code> - the rate of accumulation of angle in the +theta direction</p></li>
</ul>
</li>
</ul>
<p>EXAMPLES:</p>
<p>Standard usage with compute_on_grid:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.calculus.riemann</span> <span class="kn">import</span> <span class="n">get_derivatives</span>
<span class="gp">sage: </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">fprime</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">m</span> <span class="o">=</span> <span class="n">Riemann_Map</span><span class="p">([</span><span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="n">fprime</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">data</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">compute_on_grid</span><span class="p">([],</span><span class="mi">19</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">xstep</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">19</span>
<span class="gp">sage: </span><span class="n">ystep</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">/</span><span class="mi">19</span>
<span class="gp">sage: </span><span class="n">dr</span><span class="p">,</span> <span class="n">dtheta</span> <span class="o">=</span> <span class="n">get_derivatives</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">xstep</span><span class="p">,</span><span class="n">ystep</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">dr</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="go">0.241...</span>
<span class="gp">sage: </span><span class="n">dtheta</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="go">5.907...</span>
</pre></div>
</div>
</dd></dl>

</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="integration.html"
                        title="previous chapter">Numerical Integration</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="interpolation.html"
                        title="next chapter">Real Interpolation using GSL</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/calculus/riemann.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="interpolation.html" title="Real Interpolation using GSL"
             >next</a> |</li>
        <li class="right" >
          <a href="integration.html" title="Numerical Integration"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.2 Reference Manual: Symbolic Calculus</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Riemann Mapping</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2020, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>