
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="viewport" content="width=600, initial-scale=1">
    <title>Class file for computing sums over zeros of motivic L-functions. &#8212; Sage 9.2 Reference Manual: L-Functions</title>
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script async="async" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="prev" title="Dokchitser’s L-functions Calculator" href="dokchitser.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dokchitser.html" title="Dokchitser’s L-functions Calculator"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.2 Reference Manual: L-Functions</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Class file for computing sums over zeros of motivic L-functions.</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="class-file-for-computing-sums-over-zeros-of-motivic-l-functions">
<span id="sage-lfunctions-zero-sums"></span><h1>Class file for computing sums over zeros of motivic L-functions.<a class="headerlink" href="#class-file-for-computing-sums-over-zeros-of-motivic-l-functions" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.lfunctions.zero_sums"></span><p>All computations are done to double precision.</p>
<p>AUTHORS:</p>
<ul class="simple">
<li><p>Simon Spicer (2014-10): first version</p></li>
</ul>
<dl class="py function">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum">
<code class="sig-prename descclassname">sage.lfunctions.zero_sums.</code><code class="sig-name descname">LFunctionZeroSum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for the LFunctionZeroSum class.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">X</span></code> – A motivic object. Currently only implemented for X = an elliptic curve
over the rational numbers.</p></li>
</ul>
<p>OUTPUT:</p>
<p>An LFunctionZeroSum object.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;389a&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">);</span> <span class="n">Z</span>
<span class="go">Zero sum estimator for L-function attached to Elliptic Curve defined by y^2 + y = x^3 + x^2 - 2*x over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve">
<em class="property">class </em><code class="sig-prename descclassname">sage.lfunctions.zero_sums.</code><code class="sig-name descname">LFunctionZeroSum_EllipticCurve</code><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract" title="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.lfunctions.zero_sums.LFunctionZeroSum_abstract</span></code></a></p>
<p>Subclass for computing certain sums over zeros of an elliptic curve L-function
without having to determine the zeros themselves.</p>
<dl class="py method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.analytic_rank_upper_bound">
<code class="sig-name descname">analytic_rank_upper_bound</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_Delta</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">adaptive</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">root_number</span><span class="o">=</span><span class="default_value">'compute'</span></em>, <em class="sig-param"><span class="n">bad_primes</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ncpus</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.analytic_rank_upper_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an upper bound for the analytic rank of the L-function
<span class="math notranslate nohighlight">\(L_E(s)\)</span> attached to self, conditional on the Generalized Riemann
Hypothesis, via computing the zero sum <span class="math notranslate nohighlight">\(\sum_{\gamma} f(\Delta\gamma)\)</span>,
where <span class="math notranslate nohighlight">\(\gamma\)</span> ranges over the imaginary parts of the zeros of <span class="math notranslate nohighlight">\(L(E,s)\)</span>
along the critical strip, <span class="math notranslate nohighlight">\(f(x) = \left(\frac{\sin(\pi x)}{\pi x}\right)^2\)</span>,
and <span class="math notranslate nohighlight">\(\Delta\)</span> is the tightness parameter whose maximum value is
specified by max_Delta. This computation can be run on curves with
very large conductor (so long as the conductor is known or quickly
computable) when Delta is not too large (see below).</p>
<p>Uses Bober’s rank bounding method as described in <a class="reference internal" href="../../../references/index.html#bob2013" id="id1"><span>[Bob2013]</span></a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_Delta</span></code> – (default: None) If not None, a positive real value
specifying the maximum Delta value used in the zero sum; larger
values of Delta yield better bounds - but runtime is exponential in
Delta. If left as None, Delta is set
to <span class="math notranslate nohighlight">\(\min\left\{\frac{1}{\pi}\left(\log(N+1000)/2-\log(2\pi)-\eta\right), 2.5\right\}\)</span>,
where <span class="math notranslate nohighlight">\(N\)</span> is the conductor of the curve attached to self, and <span class="math notranslate nohighlight">\(\eta\)</span>
is the Euler-Mascheroni constant <span class="math notranslate nohighlight">\(= 0.5772...\)</span>; the crossover
point is at conductor ~8.3*10^8. For the former value, empirical
results show that for about 99.7% of all curves the returned value
is the actual analytic rank.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">adaptive</span></code> – (default: True) Boolean</p>
<ul>
<li><p>If True, the computation is first run with small and then
successively larger Delta values up to max_Delta. If at any
point the computed bound is 0 (or 1 when root_number is -1
or True), the computation halts and that value is returned;
otherwise the minimum of the computed bounds is returned.</p></li>
<li><p>If False, the computation is run a single time with
Delta=max_Delta, and the resulting bound returned.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">root_number</span></code> – (default: “compute”) String or integer</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;compute&quot;</span></code> – the root number of self is computed and used to
(possibly) lower ther analytic rank estimate by 1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;ignore&quot;</span></code> – the above step is omitted</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code> – this value is assumed to be the root number of
self. This is passable so that rank estimation can be done for
curves whose root number has been precomputed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code> – this value is assumed to be the root number of
self. This is passable so that rank estimation can be done for
curves whose root number has been precomputed.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">bad_primes</span></code> – (default: None) If not None, a list of the primes
of bad reduction for the curve attached to self. This is passable
so that rank estimation can be done for curves of large conductor
whose bad primes have been precomputed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ncpus</span></code> – (default: None) If not None, a positive integer
defining the maximum number of CPUs to be used for the computation.
If left as None, the maximum available number of CPUs will be used.
Note: Multiple processors will only be used for Delta values &gt;= 1.75.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Output will be incorrect if the incorrect root number is specified.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Zero sum computation time is exponential in the tightness parameter
<span class="math notranslate nohighlight">\(\Delta\)</span>, roughly doubling for every increase of 0.1 thereof.
Using <span class="math notranslate nohighlight">\(\Delta=1\)</span> (and adaptive=False) will yield a runtime of a few
milliseconds; <span class="math notranslate nohighlight">\(\Delta=2\)</span> takes a few seconds, and <span class="math notranslate nohighlight">\(\Delta=3\)</span> may
take upwards of an hour. Increase beyond this at your own risk!</p>
</div>
<p>OUTPUT:</p>
<p>A non-negative integer greater than or equal to the analytic rank of
self. If the returned value is 0 or 1 (the latter if parity is not
False), then this is the true analytic rank of self.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you use set_verbose(1), extra information about the computation
will be printed.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.lfunctions.zero_sums.LFunctionZeroSum" title="sage.lfunctions.zero_sums.LFunctionZeroSum"><code class="xref py py-func docutils literal notranslate"><span class="pre">LFunctionZeroSum()</span></code></a>
<code class="xref py py-meth docutils literal notranslate"><span class="pre">EllipticCurve.root_number()</span></code>
<a class="reference external" href="../../../misc/sage/misc/verbose.html#sage.misc.verbose.set_verbose" title="(in Sage 9.2 Reference Manual: Utilities v9.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_verbose()</span></code></a></p>
</div>
<p>EXAMPLES:</p>
<p>For most elliptic curves with small conductor the central zero(s)
of <span class="math notranslate nohighlight">\(L_E(s)\)</span> are fairly isolated, so small values of <span class="math notranslate nohighlight">\(\Delta\)</span>
will yield tight rank estimates.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;11a&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">ncpus</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0</span>

<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="o">-</span><span class="mi">39</span><span class="p">,</span><span class="mi">123</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>This is especially true for elliptic curves with large rank.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
<span class="gp">....: </span>    <span class="n">E</span> <span class="o">=</span> <span class="n">elliptic_curves</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">....: </span>    <span class="k">print</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">E</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">....: </span>    <span class="n">adaptive</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">root_number</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)))</span>
<span class="gp">....:</span>
<span class="go">(0, 0)</span>
<span class="go">(1, 1)</span>
<span class="go">(2, 2)</span>
<span class="go">(3, 3)</span>
<span class="go">(4, 4)</span>
<span class="go">(5, 5)</span>
<span class="go">(6, 6)</span>
<span class="go">(7, 7)</span>
<span class="go">(8, 8)</span>
</pre></div>
</div>
<p>However, some curves have <span class="math notranslate nohighlight">\(L\)</span>-functions with low-lying zeroes, and for these
larger values of <span class="math notranslate nohighlight">\(\Delta\)</span> must be used to get tight estimates.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;974b1&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">rank</span><span class="p">();</span> <span class="n">r</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">root_number</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mf">1.3</span><span class="p">,</span><span class="n">root_number</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Knowing the root number of E allows us to use smaller Delta values
to get tight bounds, thus speeding up runtime considerably.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span><span class="n">root_number</span><span class="o">=</span><span class="s2">&quot;compute&quot;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The are a small number of curves which have pathologically low-lying
zeroes. For these curves, this method will produce a bound that is
strictly larger than the analytic rank, unless very large values of
Delta are used. The following curve (“256944c1” in the Cremona tables)
is a rank 0 curve with a zero at 0.0256…; the smallest Delta value
for which the zero sum is strictly less than 2 is ~2.815.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">7460362000712</span><span class="p">,</span> <span class="o">-</span><span class="mi">7842981500851012704</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">N</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">conductor</span><span class="p">(),</span><span class="n">E</span><span class="o">.</span><span class="n">analytic_rank</span><span class="p">();</span> <span class="n">N</span><span class="p">,</span> <span class="n">r</span>
<span class="go">(256944, 0)</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">adaptive</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">adaptive</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>This method is can be called on curves with large conductor.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="o">-</span><span class="mi">2934</span><span class="p">,</span><span class="mi">19238</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
<p>And it can bound rank on curves with <em>very</em> large conductor, so long as
you know beforehand/can easily compute the conductor and primes of bad
reduction less than <span class="math notranslate nohighlight">\(e^{2\pi\Delta}\)</span>. The example below is of the rank
28 curve discovered by Elkies that is the elliptic curve of (currently)
largest known rank.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">a4</span> <span class="o">=</span> <span class="o">-</span><span class="mi">20067762415575526585033208209338542750930230312178956502</span>
<span class="gp">sage: </span><span class="n">a6</span> <span class="o">=</span> <span class="mi">34481611795030556467032985690390720374855944359319180361266008296291939448732243429</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">a4</span><span class="p">,</span><span class="n">a6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">bad_primes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">48463</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">N</span> <span class="o">=</span> <span class="mi">3455601108357547341532253864901605231198511505793733138900595189472144724781456635380154149870961231592352897621963802238155192936274322687070</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">analytic_rank_upper_bound</span><span class="p">(</span><span class="n">max_Delta</span><span class="o">=</span><span class="mf">2.37</span><span class="p">,</span><span class="n">adaptive</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="c1"># long time</span>
<span class="gp">....: </span><span class="n">root_number</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">bad_primes</span><span class="o">=</span><span class="n">bad_primes</span><span class="p">,</span><span class="n">ncpus</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>               <span class="c1"># long time</span>
<span class="go">32</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.cn">
<code class="sig-name descname">cn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.cn" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the nth Dirichlet coefficient of the logarithmic
derivative of the L-function attached to self, shifted so that
the critical line lies on the imaginary axis. The returned value is
zero if <span class="math notranslate nohighlight">\(n\)</span> is not a perfect prime power;
when <span class="math notranslate nohighlight">\(n=p^e\)</span> for <span class="math notranslate nohighlight">\(p\)</span> a prime of bad reduction it is <span class="math notranslate nohighlight">\(-a_p^e log(p)/p^e\)</span>,
where <span class="math notranslate nohighlight">\(a_p\)</span> is <span class="math notranslate nohighlight">\(+1, -1\)</span> or <span class="math notranslate nohighlight">\(0\)</span> according to the reduction type of <span class="math notranslate nohighlight">\(p\)</span>;
and when <span class="math notranslate nohighlight">\(n=p^e\)</span> for a prime <span class="math notranslate nohighlight">\(p\)</span> of good reduction, the value
is <span class="math notranslate nohighlight">\(-(\alpha_p^e + \beta_p^e) \log(p)/p^e\)</span>, where <span class="math notranslate nohighlight">\(\alpha_p\)</span>
and <span class="math notranslate nohighlight">\(\beta_p\)</span> are the two complex roots of the characteristic equation
of Frobenius at <span class="math notranslate nohighlight">\(p\)</span> on <span class="math notranslate nohighlight">\(E\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – non-negative integer</p></li>
</ul>
<p>OUTPUT:</p>
<p>A real number which (by Hasse’s Theorem) is at
most <span class="math notranslate nohighlight">\(2\frac{log(n)}{\sqrt{n}}\)</span> in magnitude.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;11a&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">):</span> <span class="k">print</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">Z</span><span class="o">.</span><span class="n">cn</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(0, 0.0)</span>
<span class="go">(1, 0.0)</span>
<span class="go">(2, 0.6931471805599453)</span>
<span class="go">(3, 0.3662040962227033)</span>
<span class="go">(4, 0.0)</span>
<span class="go">(5, -0.32188758248682003)</span>
<span class="go">(6, 0.0)</span>
<span class="go">(7, 0.555974328301518)</span>
<span class="go">(8, -0.34657359027997264)</span>
<span class="go">(9, 0.6103401603711721)</span>
<span class="go">(10, 0.0)</span>
<span class="go">(11, -0.21799047934530644)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.elliptic_curve">
<code class="sig-name descname">elliptic_curve</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.elliptic_curve" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the elliptic curve associated with self.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="mi">23</span><span class="p">,</span><span class="mi">100</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">elliptic_curve</span><span class="p">()</span>
<span class="go">Elliptic Curve defined by y^2 = x^3 + 23*x + 100 over Rational Field</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.lseries">
<code class="sig-name descname">lseries</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.lseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(L\)</span>-series associated with self.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="mi">23</span><span class="p">,</span><span class="mi">100</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">lseries</span><span class="p">()</span>
<span class="go">Complex L-series of the Elliptic Curve defined by y^2 = x^3 + 23*x + 100 over Rational Field</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract">
<em class="property">class </em><code class="sig-prename descclassname">sage.lfunctions.zero_sums.</code><code class="sig-name descname">LFunctionZeroSum_abstract</code><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage 9.2 Reference Manual: Parents and Elements v9.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.sage_object.SageObject</span></code></a></p>
<p>Abstract class for computing certain sums over zeros of a motivic L-function
without having to determine the zeros themselves.</p>
<dl class="py method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.C0">
<code class="sig-name descname">C0</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">include_euler_gamma</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.C0" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the constant term of the logarithmic derivative of the
completed <span class="math notranslate nohighlight">\(L\)</span>-function attached to self. This is equal to
<span class="math notranslate nohighlight">\(-\eta + \log(N)/2 - \log(2\pi)\)</span>, where <span class="math notranslate nohighlight">\(\eta\)</span> is the
Euler-Mascheroni constant <span class="math notranslate nohighlight">\(= 0.5772...\)</span>
and <span class="math notranslate nohighlight">\(N\)</span> is the level of the form attached to self.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">include_euler_gamma</span></code> – bool (default: True); if set to
False, return the constant <span class="math notranslate nohighlight">\(\log(N)/2 - \log(2\pi)\)</span>, i.e., do
not subtract off the Euler-Mascheroni constant.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;389a&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">C0</span><span class="p">()</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">0.5666969404983447</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">C0</span><span class="p">(</span><span class="n">include_euler_gamma</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">1.1439126053998776</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.cnlist">
<code class="sig-name descname">cnlist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">python_floats</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.cnlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of Dirichlet coefficient of the logarithmic
derivative of the <span class="math notranslate nohighlight">\(L\)</span>-function attached to self, shifted so that
the critical line lies on the imaginary axis, up to and
including n. The i-th element of the return list is a[i].</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> – non-negative integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">python_floats</span></code> – bool (default: False); if True return a list of
Python floats instead of Sage Real Double Field elements.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A list of real numbers</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.cn" title="sage.lfunctions.zero_sums.LFunctionZeroSum_EllipticCurve.cn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cn()</span></code></a></p>
</div>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<p>Speed this up; make more efficient</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;11a&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">cnlist</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">cnlist</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">):</span> <span class="k">print</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">cnlist</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(0, 0.0)</span>
<span class="go">(1, 0.0)</span>
<span class="go">(2, 0.6931471805599453)</span>
<span class="go">(3, 0.3662040962227033)</span>
<span class="go">(4, 0.0)</span>
<span class="go">(5, -0.32188758248682003)</span>
<span class="go">(6, 0.0)</span>
<span class="go">(7, 0.555974328301518)</span>
<span class="go">(8, -0.34657359027997264)</span>
<span class="go">(9, 0.6103401603711721)</span>
<span class="go">(10, 0.0)</span>
<span class="go">(11, -0.21799047934530644)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.completed_logarithmic_derivative">
<code class="sig-name descname">completed_logarithmic_derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">num_terms</span><span class="o">=</span><span class="default_value">10000</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.completed_logarithmic_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value of the completed logarithmic derivative
<span class="math notranslate nohighlight">\(\frac{\Lambda^{\prime}}{\Lambda}\)</span> at the point s to <em>low</em>
precision, where <span class="math notranslate nohighlight">\(\Lambda = N^{s/2}(2\pi)^s \Gamma(s) L(s)\)</span>
and <span class="math notranslate nohighlight">\(L\)</span> is the <span class="math notranslate nohighlight">\(L\)</span>-function attached to self.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is computed naively by evaluating the Dirichlet series
for <span class="math notranslate nohighlight">\(\frac{L^{\prime}}{L}\)</span>; the convergence thereof is
controlled by the distance of s from the critical strip
<span class="math notranslate nohighlight">\(0.5&lt;=\Re(s)&lt;=1.5\)</span>.
You may use this method to attempt to compute values inside the
critical strip; however, results are then <em>not</em> guaranteed
to be correct to any number of digits.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> – Real or complex value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_terms</span></code> – (default: 10000) the maximum number of terms
summed in the Dirichlet series.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A tuple (z,err), where z is the computed value, and err is an
upper bound on the truncation error in this value introduced
by truncating the Dirichlet sum.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the default term cap of 10000, a value accurate to all 53
bits of a double precision floating point number is only
guaranteed when <span class="math notranslate nohighlight">\(|\Re(s-1)|&gt;4.58\)</span>, although in practice inputs
closer to the critical strip will still yield computed values
close to the true value.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">logarithmic_derivative()</span></code></p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="mi">23</span><span class="p">,</span><span class="mi">100</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">completed_logarithmic_derivative</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(6.64372066048195, 6.584671359095225e-06)</span>
</pre></div>
</div>
<p>Complex values are handled. The function is odd about s=1, so
the value at 2-s should be minus the value at s.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">completed_logarithmic_derivative</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mf">2.2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(-6.898080633125154 + 0.22557015394248361*I, 5.623853049808912e-11)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">completed_logarithmic_derivative</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="mf">4.2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(6.898080633125154 - 0.22557015394248361*I, 5.623853049808912e-11)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.digamma">
<code class="sig-name descname">digamma</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">include_constant_term</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.digamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the digamma function <span class="math notranslate nohighlight">\(\digamma(s)\)</span> on the complex input s, given by
<span class="math notranslate nohighlight">\(\digamma(s) = -\eta + \sum_{k=1}^{\infty} \frac{s-1}{k(k+s-1)}\)</span>,
where <span class="math notranslate nohighlight">\(\eta\)</span> is the Euler-Mascheroni constant <span class="math notranslate nohighlight">\(=0.5772156649\ldots\)</span>.
This function is needed in the computing the logarithmic derivative
of the <span class="math notranslate nohighlight">\(L\)</span>-function attached to self.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> – A complex number</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">include_constant_term</span></code> – (default: True) boolean; if set False,
only the value of the sum over <span class="math notranslate nohighlight">\(k\)</span> is returned without subtracting
off the Euler-Mascheroni constant, i.e. the returned value is
equal to <span class="math notranslate nohighlight">\(\sum_{k=1}^{\infty} \frac{s-1}{k(k+s-1)}\)</span>.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A real double precision number if the input is real and not a negative
integer; Infinity if the input is a negative integer, and a complex
number otherwise.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;37a&quot;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="mf">3.2</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">0.9988388912865993</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="mf">3.2</span><span class="p">,</span><span class="n">include_constant_term</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">1.576054556188132</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">I</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">0.09465032062247625 + 1.076674047468581*I</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">+Infinity</span>
</pre></div>
</div>
<p>Evaluating the sum without the constant term at the positive integers n
returns the (n-1)th harmonic number.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">include_constant_term</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">1.5</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">digamma</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="n">include_constant_term</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">2.283333333333333</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.level">
<code class="sig-name descname">level</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.level" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level of the form attached to self. If self was constructed
from an elliptic curve, then this is equal to the conductor of <span class="math notranslate nohighlight">\(E\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;389a&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">level</span><span class="p">()</span>
<span class="go">389</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.logarithmic_derivative">
<code class="sig-name descname">logarithmic_derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">num_terms</span><span class="o">=</span><span class="default_value">10000</span></em>, <em class="sig-param"><span class="n">as_interval</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.logarithmic_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value of the logarithmic derivative
<span class="math notranslate nohighlight">\(\frac{L^{\prime}}{L}\)</span> at the point s to <em>low</em> precision, where <span class="math notranslate nohighlight">\(L\)</span>
is the <span class="math notranslate nohighlight">\(L\)</span>-function attached to self.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The value is computed naively by evaluating the Dirichlet series
for <span class="math notranslate nohighlight">\(\frac{L^{\prime}}{L}\)</span>; convergence is controlled by the
distance of s from the critical strip <span class="math notranslate nohighlight">\(0.5&lt;=\Re(s)&lt;=1.5\)</span>.
You may use this method to attempt to compute values inside the
critical strip; however, results are then <em>not</em> guaranteed
to be correct to any number of digits.</p>
</div>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> – Real or complex value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num_terms</span></code> – (default: 10000) the maximum number of terms
summed in the Dirichlet series.</p></li>
</ul>
<p>OUTPUT:</p>
<p>A tuple (z,err), where z is the computed value, and err is an
upper bound on the truncation error in this value introduced
by truncating the Dirichlet sum.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For the default term cap of 10000, a value accurate to all 53
bits of a double precision floating point number is only
guaranteed when <span class="math notranslate nohighlight">\(|\Re(s-1)|&gt;4.58\)</span>, although in practice inputs
closer to the critical strip will still yield computed values
close to the true value.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="mi">23</span><span class="p">,</span><span class="mi">100</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">logarithmic_derivative</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(5.648066742632698e-05, 1.0974102859764345e-34)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">logarithmic_derivative</span><span class="p">(</span><span class="mf">2.2</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(0.5751257063594758, 0.024087912696974387)</span>
</pre></div>
</div>
<p>Increasing the number of terms should see the truncation error
decrease.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">logarithmic_derivative</span><span class="p">(</span><span class="mf">2.2</span><span class="p">,</span><span class="n">num_terms</span><span class="o">=</span><span class="mi">50000</span><span class="p">)</span> <span class="c1"># long time # rel tol 1.0e-14</span>
<span class="go">(0.5751579645060139, 0.008988775519160675)</span>
</pre></div>
</div>
<p>Attempting to compute values inside the critical strip
gives infinite error.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">logarithmic_derivative</span><span class="p">(</span><span class="mf">1.3</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(5.442994413920786, +Infinity)</span>
</pre></div>
</div>
<p>Complex inputs and inputs to the left of the critical strip
are allowed.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">logarithmic_derivative</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(0.04764548578052381 + 0.16513832809989326*I, 6.584671359095225e-06)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">logarithmic_derivative</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mf">1.1</span><span class="p">))</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(-13.908452173241546 + 2.591443099074753*I, 2.7131584736258447e-14)</span>
</pre></div>
</div>
<p>The logarithmic derivative has poles at the negative integers.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">logarithmic_derivative</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">(-Infinity, 2.7131584736258447e-14)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.ncpus">
<code class="sig-name descname">ncpus</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.ncpus" title="Permalink to this definition">¶</a></dt>
<dd><p>Set or return the number of CPUs to be used in parallel computations.
If called with no input, the number of CPUs currently set is returned;
else this value is set to n. If n is 0 then the number of CPUs is set
to the max available.</p>
<p>INPUT:</p>
<p><code class="docutils literal notranslate"><span class="pre">n</span></code> – (default: None) If not None, a nonnegative integer</p>
<p>OUTPUT:</p>
<p>If n is not None, returns a positive integer</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;389a&quot;</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">ncpus</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">ncpus</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">ncpus</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The following output will depend on the system that Sage is running on.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">ncpus</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">ncpus</span><span class="p">()</span>            <span class="c1"># random</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.weight">
<code class="sig-name descname">weight</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the weight of the form attached to self. If self was constructed
from an elliptic curve, then this is 2.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;389a&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">weight</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.zerosum">
<code class="sig-name descname">zerosum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Delta</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">tau</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">function</span><span class="o">=</span><span class="default_value">'sincsquared_fast'</span></em>, <em class="sig-param"><span class="n">ncpus</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.lfunctions.zero_sums.LFunctionZeroSum_abstract.zerosum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bound from above the analytic rank of the form attached to self
by computing <span class="math notranslate nohighlight">\(\sum_{\gamma} f(\Delta(\gamma-\tau))\)</span>, where
<span class="math notranslate nohighlight">\(\gamma\)</span> ranges over the imaginary parts of the zeros of <span class="math notranslate nohighlight">\(L_E(s)\)</span>
along the critical strip, and <span class="math notranslate nohighlight">\(f(x)\)</span> is an appropriate even continuous
<span class="math notranslate nohighlight">\(L_2\)</span> function such that <span class="math notranslate nohighlight">\(f(0)=1\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(\tau=0\)</span>, then as <span class="math notranslate nohighlight">\(\Delta\)</span> increases this sum converges from above to
the analytic rank of the <span class="math notranslate nohighlight">\(L\)</span>-function, as <span class="math notranslate nohighlight">\(f(0) = 1\)</span> is counted with
multiplicity <span class="math notranslate nohighlight">\(r\)</span>, and the other terms all go to 0 uniformly.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Delta</span></code> – positive real number (default: 1) parameter denoting the
tightness of the zero sum.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tau</span></code> – real parameter (default: 0) denoting the offset of the sum
to be computed. When <span class="math notranslate nohighlight">\(\tau=0\)</span> the sum will converge to the analytic rank
of the <span class="math notranslate nohighlight">\(L\)</span>-function as <span class="math notranslate nohighlight">\(\Delta\)</span> is increased. If <span class="math notranslate nohighlight">\(\tau\)</span> is the value
of the imaginary part of a noncentral zero, the limit will be 1
(assuming the zero is simple); otherwise, the limit will be 0.
Currently only implemented for the sincsquared and cauchy functions;
otherwise ignored.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">function</span></code> – string (default: “sincsquared_fast”) - the function
<span class="math notranslate nohighlight">\(f(x)\)</span> as described above. Currently implemented options for <span class="math notranslate nohighlight">\(f\)</span> are</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">sincsquared</span></code> – <span class="math notranslate nohighlight">\(f(x) = \left(\frac{\sin(\pi x)}{\pi x}\right)^2\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gaussian</span></code>   – <span class="math notranslate nohighlight">\(f(x) = e^{-x^2}\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sincsquared_fast</span></code> – Same as “sincsquared”, but implementation
optimized for elliptic curve <span class="math notranslate nohighlight">\(L\)</span>-functions, and tau must be 0. self
must be attached to an elliptic curve over <span class="math notranslate nohighlight">\(\QQ\)</span> given by its global
minimal model, otherwise the returned result will be incorrect.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sincsquared_parallel</span></code> – Same as “sincsquared_fast”, but optimized
for parallel computation with large (&gt;2.0) <span class="math notranslate nohighlight">\(\Delta\)</span> values. self must
be attached to an elliptic curve over <span class="math notranslate nohighlight">\(\QQ\)</span> given by its global minimal
model, otherwise the returned result will be incorrect.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cauchy</span></code> – <span class="math notranslate nohighlight">\(f(x) = \frac{1}{1+x^2}\)</span>; this is only computable to
low precision, and only when <span class="math notranslate nohighlight">\(\Delta &lt; 2\)</span>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ncpus</span></code> - (default: None) If not None, a positive integer
defining the number of CPUs to be used for the computation. If left as
None, the maximum available number of CPUs will be used.
Only implemented for algorithm=”sincsquared_parallel”; ignored
otherwise.</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Computation time is exponential in <span class="math notranslate nohighlight">\(\Delta\)</span>, roughly doubling for
every increase of 0.1 thereof. Using <span class="math notranslate nohighlight">\(\Delta=1\)</span> will yield a
computation time of a few milliseconds; <span class="math notranslate nohighlight">\(\Delta=2\)</span> takes a few
seconds, and <span class="math notranslate nohighlight">\(\Delta=3\)</span> takes upwards of an hour. Increase at your
own risk beyond this!</p>
</div>
<p>OUTPUT:</p>
<p>A positive real number that bounds from above the number of zeros with
imaginary part equal to <span class="math notranslate nohighlight">\(\tau\)</span>. When <span class="math notranslate nohighlight">\(\tau=0\)</span> this is an upper bound for
the <span class="math notranslate nohighlight">\(L\)</span>-function’s analytic rank.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">analytic_rank_bound()</span></code>
for more documentation and examples on calling this method on elliptic curve
<span class="math notranslate nohighlight">\(L\)</span>-functions.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="s2">&quot;389a&quot;</span><span class="p">);</span> <span class="n">E</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">LFunctionZeroSum</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">lseries</span><span class="p">()</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[0.000000000, 0.000000000, 2.87609907]</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">function</span><span class="o">=</span><span class="s2">&quot;sincsquared_fast&quot;</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">2.037500084595065</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">function</span><span class="o">=</span><span class="s2">&quot;sincsquared_parallel&quot;</span><span class="p">)</span> <span class="c1"># tol 1.0e-11</span>
<span class="go">2.037500084595065</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">function</span><span class="o">=</span><span class="s2">&quot;sincsquared&quot;</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">2.0375000845950644</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mf">2.876</span><span class="p">,</span><span class="n">function</span><span class="o">=</span><span class="s2">&quot;sincsquared&quot;</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">1.075551295651154</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">tau</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span><span class="n">function</span><span class="o">=</span><span class="s2">&quot;sincsquared&quot;</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">0.10831555377490683</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">Delta</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">function</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">)</span> <span class="c1"># tol 1.0e-13</span>
<span class="go">2.056890425029435</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="dokchitser.html"
                        title="previous chapter">Dokchitser’s L-functions Calculator</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/lfunctions/zero_sums.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dokchitser.html" title="Dokchitser’s L-functions Calculator"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Sage 9.2 Reference Manual: L-Functions</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Class file for computing sums over zeros of motivic L-functions.</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2020, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>