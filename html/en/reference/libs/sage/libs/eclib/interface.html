
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Sage interface to Cremona’s eclib library (also known as mwrank) &#8212; Sage 9.5 Reference Manual: C/C++ Library Interfaces</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sage.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script async="async" src="../../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Cython interface to Cremona’s eclib library (also known as mwrank)" href="mwrank.html" />
    <link rel="prev" title="Library interface to Embeddable Common Lisp (ECL)" href="../ecl.html" />
    <link rel="icon" href="../../../../_static/sageicon.png" type="image/x-icon" />

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="mwrank.html" title="Cython interface to Cremona’s eclib library (also known as mwrank)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../ecl.html" title="Library interface to Embeddable Common Lisp (ECL)"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Sage 9.5 Reference Manual: C/C++ Library Interfaces</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Sage interface to Cremona’s <code class="docutils literal notranslate"><span class="pre">eclib</span></code> library (also known as <code class="docutils literal notranslate"><span class="pre">mwrank</span></code>)</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="sage-interface-to-cremona-s-eclib-library-also-known-as-mwrank">
<span id="sage-libs-eclib-interface"></span><h1>Sage interface to Cremona’s <code class="docutils literal notranslate"><span class="pre">eclib</span></code> library (also known as <code class="docutils literal notranslate"><span class="pre">mwrank</span></code>)<a class="headerlink" href="#sage-interface-to-cremona-s-eclib-library-also-known-as-mwrank" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.libs.eclib.interface"></span><p>This is the Sage interface to John Cremona’s <code class="docutils literal notranslate"><span class="pre">eclib</span></code> C++ library for
arithmetic on elliptic curves.  The classes defined in this module
give Sage interpreter-level access to some of the functionality of
<code class="docutils literal notranslate"><span class="pre">eclib</span></code>.  For most purposes, it is not necessary to directly use these
classes. Instead, one can create an
<code class="xref py py-class docutils literal notranslate"><span class="pre">EllipticCurve</span></code>
and call methods that are implemented using this module.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This interface is a direct library-level interface to <code class="docutils literal notranslate"><span class="pre">eclib</span></code>,
including the 2-descent program <code class="docutils literal notranslate"><span class="pre">mwrank</span></code>.</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_EllipticCurve">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.libs.eclib.interface.</span></span><span class="sig-name descname"><span class="pre">mwrank_EllipticCurve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ainvs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_EllipticCurve" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage 9.5 Reference Manual: Parents and Elements v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.sage_object.SageObject</span></code></a></p>
<p>The <a class="reference internal" href="#sage.libs.eclib.interface.mwrank_EllipticCurve" title="sage.libs.eclib.interface.mwrank_EllipticCurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">mwrank_EllipticCurve</span></code></a> class represents an elliptic
curve using the <code class="docutils literal notranslate"><span class="pre">Curvedata</span></code> class from <code class="docutils literal notranslate"><span class="pre">eclib</span></code>, called here an ‘mwrank
elliptic curve’.</p>
<p>Create the mwrank elliptic curve with invariants
<code class="docutils literal notranslate"><span class="pre">ainvs</span></code>, which is a list of 5 or less <em>integers</em> <span class="math notranslate nohighlight">\(a_1\)</span>,
<span class="math notranslate nohighlight">\(a_2\)</span>, <span class="math notranslate nohighlight">\(a_3\)</span>, <span class="math notranslate nohighlight">\(a_4\)</span>, and <span class="math notranslate nohighlight">\(a_5\)</span>.</p>
<p>If strictly less than 5 invariants are given, then the <em>first</em>
ones are set to 0, so, e.g., <code class="docutils literal notranslate"><span class="pre">[3,4]</span></code> means <span class="math notranslate nohighlight">\(a_1=a_2=a_3=0\)</span> and
<span class="math notranslate nohighlight">\(a_4=3\)</span>, <span class="math notranslate nohighlight">\(a_5=4\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ainvs</span></code> (list or tuple) – a list of 5 or less integers, the
coefficients of a nonsingular Weierstrass equation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> (bool, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – verbosity flag.  If <code class="docutils literal notranslate"><span class="pre">True</span></code>,
then all Selmer group computations will be verbose.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>We create the elliptic curve <span class="math notranslate nohighlight">\(y^2 + y = x^3 + x^2 - 2x\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ainvs</span><span class="p">()</span>
<span class="go">[0, 1, 1, -2, 0]</span>
</pre></div>
</div>
<p>This example illustrates that omitted <span class="math notranslate nohighlight">\(a\)</span>-invariants default to <span class="math notranslate nohighlight">\(0\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">e</span>
<span class="go">y^2 = x^3 + 3 x - 4</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">ainvs</span><span class="p">()</span>
<span class="go">[0, 0, 0, 3, -4]</span>
</pre></div>
</div>
<p>The entries of the input list are coerced to <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>.
If this is impossible, then an error is raised:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">4.8</span><span class="p">]);</span> <span class="n">e</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">TypeError: ainvs must be a list or tuple of integers.</span>
</pre></div>
</div>
<p>When you enter a singular model you get an exception:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">Traceback (most recent call last):</span>
<span class="go">...</span>
<span class="go">ArithmeticError: Invariants (= 0,0,0,0,0) do not describe an elliptic curve.</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_EllipticCurve.CPS_height_bound">
<span class="sig-name descname"><span class="pre">CPS_height_bound</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.CPS_height_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Cremona-Prickett-Siksek height bound.  This is a
floating point number <span class="math notranslate nohighlight">\(B\)</span> such that if <span class="math notranslate nohighlight">\(P\)</span> is a point on the
curve, then the naive logarithmic height <span class="math notranslate nohighlight">\(h(P)\)</span> is less than
<span class="math notranslate nohighlight">\(B+\hat{h}(P)\)</span>, where <span class="math notranslate nohighlight">\(\hat{h}(P)\)</span> is the canonical height of
<span class="math notranslate nohighlight">\(P\)</span>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>We assume the model is minimal!</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1002231243161</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">CPS_height_bound</span><span class="p">()</span>
<span class="go">14.163198527061496</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">CPS_height_bound</span><span class="p">()</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_EllipticCurve.ainvs">
<span class="sig-name descname"><span class="pre">ainvs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.ainvs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <span class="math notranslate nohighlight">\(a\)</span>-invariants of this mwrank elliptic curve.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">ainvs</span><span class="p">()</span>
<span class="go">[0, 0, 1, -1, 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_EllipticCurve.certain">
<span class="sig-name descname"><span class="pre">certain</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.certain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the last <a class="reference internal" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.two_descent" title="sage.libs.eclib.interface.mwrank_EllipticCurve.two_descent"><code class="xref py py-meth docutils literal notranslate"><span class="pre">two_descent()</span></code></a> call provably correctly
computed the rank.  If <a class="reference internal" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.two_descent" title="sage.libs.eclib.interface.mwrank_EllipticCurve.two_descent"><code class="xref py py-meth docutils literal notranslate"><span class="pre">two_descent()</span></code></a> hasn’t been
called, then it is first called by <a class="reference internal" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.certain" title="sage.libs.eclib.interface.mwrank_EllipticCurve.certain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">certain()</span></code></a>
using the default parameters.</p>
<p>The result is <code class="docutils literal notranslate"><span class="pre">True</span></code> if and only if the results of the methods
<a class="reference internal" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.rank" title="sage.libs.eclib.interface.mwrank_EllipticCurve.rank"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rank()</span></code></a> and <a class="reference internal" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.rank_bound" title="sage.libs.eclib.interface.mwrank_EllipticCurve.rank_bound"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rank_bound()</span></code></a> are equal.</p>
<p>EXAMPLES:</p>
<p>A 2-descent does not determine <span class="math notranslate nohighlight">\(E(\QQ)\)</span> with certainty
for the curve <span class="math notranslate nohighlight">\(y^2 + y = x^3 - x^2 - 120x - 2183\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span> <span class="o">-</span><span class="mi">2183</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">two_descent</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="go">...</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">certain</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The previous value is only a lower bound; the upper bound is greater:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank_bound</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>In fact the rank of <span class="math notranslate nohighlight">\(E\)</span> is actually 0 (as one could see by
computing the <span class="math notranslate nohighlight">\(L\)</span>-function), but Sha has order 4 and the
2-torsion is trivial, so mwrank cannot conclusively
determine the rank in this case.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_EllipticCurve.conductor">
<span class="sig-name descname"><span class="pre">conductor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.conductor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the conductor of this curve, computed using Cremona’s
implementation of Tate’s algorithm.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is independent of PARI’s.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">6958</span><span class="p">,</span> <span class="o">-</span><span class="mi">224588</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">conductor</span><span class="p">()</span>
<span class="go">2310</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_EllipticCurve.gens">
<span class="sig-name descname"><span class="pre">gens</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.gens" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the generators for the Mordell-Weil group.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="go">[[0, -1, 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_EllipticCurve.isogeny_class">
<span class="sig-name descname"><span class="pre">isogeny_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.isogeny_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the isogeny class of this mwrank elliptic curve.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">isogeny_class</span><span class="p">()</span>
<span class="go">([[0, -1, 1, 0, 0], [0, -1, 1, -10, -20], [0, -1, 1, -7820, -263580]], [[0, 5, 0], [5, 0, 5], [0, 5, 0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_EllipticCurve.rank">
<span class="sig-name descname"><span class="pre">rank</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rank of this curve, computed using <a class="reference internal" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.two_descent" title="sage.libs.eclib.interface.mwrank_EllipticCurve.two_descent"><code class="xref py py-meth docutils literal notranslate"><span class="pre">two_descent()</span></code></a>.</p>
<p>In general this may only be a lower bound for the rank; an
upper bound may be obtained using the function <a class="reference internal" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.rank_bound" title="sage.libs.eclib.interface.mwrank_EllipticCurve.rank_bound"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rank_bound()</span></code></a>.
To test whether the value has been proved to be correct, use
the method <a class="reference internal" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.certain" title="sage.libs.eclib.interface.mwrank_EllipticCurve.certain"><code class="xref py py-meth docutils literal notranslate"><span class="pre">certain()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">900</span><span class="p">,</span> <span class="o">-</span><span class="mi">10098</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">certain</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">929</span><span class="p">,</span> <span class="o">-</span><span class="mi">10595</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">certain</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_EllipticCurve.rank_bound">
<span class="sig-name descname"><span class="pre">rank_bound</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.rank_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an upper bound for the rank of this curve, computed
using <a class="reference internal" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.two_descent" title="sage.libs.eclib.interface.mwrank_EllipticCurve.two_descent"><code class="xref py py-meth docutils literal notranslate"><span class="pre">two_descent()</span></code></a>.</p>
<p>If the curve has no 2-torsion, this is equal to the 2-Selmer
rank.  If the curve has 2-torsion, the upper bound may be
smaller than the bound obtained from the 2-Selmer rank minus
the 2-rank of the torsion, since more information is gained
from the 2-isogenous curve or curves.</p>
<p>EXAMPLES:</p>
<p>The following is the curve 960D1, which has rank 0,
but Sha of order 4:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">900</span><span class="p">,</span> <span class="o">-</span><span class="mi">10098</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank_bound</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>In this case the rank was computed using a second descent,
which is able to determine (by considering a 2-isogenous
curve) that Sha is nontrivial.  If we deliberately stop the
second descent, the rank bound is larger:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">900</span><span class="p">,</span> <span class="o">-</span><span class="mi">10098</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">two_descent</span><span class="p">(</span><span class="n">second_descent</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank_bound</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>In contrast, for the curve 571A, also with rank 0 and Sha
of order 4, we only obtain an upper bound of 2:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">929</span><span class="p">,</span> <span class="o">-</span><span class="mi">10595</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank_bound</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>In this case the value returned by <a class="reference internal" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.rank" title="sage.libs.eclib.interface.mwrank_EllipticCurve.rank"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rank()</span></code></a> is only a
lower bound in general (though this is correct):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">certain</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_EllipticCurve.regulator">
<span class="sig-name descname"><span class="pre">regulator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.regulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the regulator of the saturated Mordell-Weil group.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">regulator</span><span class="p">()</span>
<span class="go">0.05111140823996884</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_EllipticCurve.saturate">
<span class="sig-name descname"><span class="pre">saturate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.saturate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the saturation of the Mordell-Weil group.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bound</span></code> (int, default -1) – If <span class="math notranslate nohighlight">\(-1\)</span>, saturate at <em>all</em>
primes by computing a bound on the saturation index,
otherwise saturate at all primes up to the minimum of
<code class="docutils literal notranslate"><span class="pre">bound</span></code> and the saturation index bound.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lower</span></code> (int, default 2) – Only saturate at primes not
less than this.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>Since the 2-descent automatically saturates at primes up to
20, further saturation often has no effect:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1002231243161</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="go">[[-1001107, -4004428, 1]]</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">saturate</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="go">[[-1001107, -4004428, 1]]</span>
</pre></div>
</div>
<p>Check that <a class="reference external" href="https://trac.sagemath.org/18031">trac ticket #18031</a> is fixed:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">266</span><span class="p">,</span><span class="mi">968</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Q1</span> <span class="o">=</span> <span class="n">E</span><span class="p">([</span><span class="o">-</span><span class="mi">1995</span><span class="p">,</span><span class="mi">3674</span><span class="p">,</span><span class="mi">125</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Q2</span> <span class="o">=</span> <span class="n">E</span><span class="p">([</span><span class="mi">157</span><span class="p">,</span><span class="mi">1950</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">saturation</span><span class="p">([</span><span class="n">Q1</span><span class="p">,</span><span class="n">Q2</span><span class="p">])</span>
<span class="go">([(1 : -27 : 1), (157 : 1950 : 1)], 3, 0.801588644684981)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_EllipticCurve.selmer_rank">
<span class="sig-name descname"><span class="pre">selmer_rank</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.selmer_rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rank of the 2-Selmer group of the curve.</p>
<p>EXAMPLES:</p>
<p>The following is the curve 960D1, which has rank 0, but Sha of
order 4.  The 2-torsion has rank 2, and the Selmer rank is 3:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">900</span><span class="p">,</span> <span class="o">-</span><span class="mi">10098</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">selmer_rank</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Nevertheless, we can obtain a tight upper bound on the rank
since a second descent is performed which establishes the
2-rank of Sha:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank_bound</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>To show that this was resolved using a second descent, we do
the computation again but turn off <code class="docutils literal notranslate"><span class="pre">second_descent</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">900</span><span class="p">,</span> <span class="o">-</span><span class="mi">10098</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">two_descent</span><span class="p">(</span><span class="n">second_descent</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank_bound</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>For the curve 571A, also with rank 0 and Sha of order 4,
but with no 2-torsion, the Selmer rank is strictly greater
than the rank:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">929</span><span class="p">,</span> <span class="o">-</span><span class="mi">10595</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">selmer_rank</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank_bound</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>In cases like this with no 2-torsion, the rank upper bound is
always equal to the 2-Selmer rank.  If we ask for the rank,
all we get is a lower bound:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">certain</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_EllipticCurve.set_verbose">
<span class="sig-name descname"><span class="pre">set_verbose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.set_verbose" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the verbosity of printing of output by the <a class="reference internal" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.two_descent" title="sage.libs.eclib.interface.mwrank_EllipticCurve.two_descent"><code class="xref py py-meth docutils literal notranslate"><span class="pre">two_descent()</span></code></a> and
other functions.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> (int) – if positive, print lots of output when
doing 2-descent.</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">saturate</span><span class="p">()</span> <span class="c1"># no output</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="go">[[0, -1, 1]]</span>

<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">set_verbose</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">saturate</span><span class="p">()</span> <span class="c1"># tol 1e-10</span>
<span class="go">Basic pair: I=48, J=-432</span>
<span class="go">disc=255744</span>
<span class="go">2-adic index bound = 2</span>
<span class="go">By Lemma 5.1(a), 2-adic index = 1</span>
<span class="go">2-adic index = 1</span>
<span class="go">One (I,J) pair</span>
<span class="go">Looking for quartics with I = 48, J = -432</span>
<span class="go">Looking for Type 2 quartics:</span>
<span class="go">Trying positive a from 1 up to 1 (square a first...)</span>
<span class="go">(1,0,-6,4,1)        --trivial</span>
<span class="go">Trying positive a from 1 up to 1 (...then non-square a)</span>
<span class="go">Finished looking for Type 2 quartics.</span>
<span class="go">Looking for Type 1 quartics:</span>
<span class="go">Trying positive a from 1 up to 2 (square a first...)</span>
<span class="go">(1,0,0,4,4) --nontrivial...(x:y:z) = (1 : 1 : 0)</span>
<span class="go">Point = [0:0:1]</span>
<span class="go">    height = 0.0511114082399688402358</span>
<span class="go">Rank of B=im(eps) increases to 1 (The previous point is on the egg)</span>
<span class="go">Exiting search for Type 1 quartics after finding one which is globally soluble.</span>
<span class="go">Mordell rank contribution from B=im(eps) = 1</span>
<span class="go">Selmer  rank contribution from B=im(eps) = 1</span>
<span class="go">Sha     rank contribution from B=im(eps) = 0</span>
<span class="go">Mordell rank contribution from A=ker(eps) = 0</span>
<span class="go">Selmer  rank contribution from A=ker(eps) = 0</span>
<span class="go">Sha     rank contribution from A=ker(eps) = 0</span>
<span class="go">Searching for points (bound = 8)...done:</span>
<span class="go">  found points which generate a subgroup of rank 1</span>
<span class="go">  and regulator 0.0511114082399688402358</span>
<span class="go">Processing points found during 2-descent...done:</span>
<span class="go">  now regulator = 0.0511114082399688402358</span>
<span class="go">Saturating (with bound = -1)...done:</span>
<span class="go">  points were already saturated.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_EllipticCurve.silverman_bound">
<span class="sig-name descname"><span class="pre">silverman_bound</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.silverman_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Silverman height bound.  This is a floating point
number <span class="math notranslate nohighlight">\(B\)</span> such that if <span class="math notranslate nohighlight">\(P\)</span> is a point on the curve, then the
naive logarithmic height <span class="math notranslate nohighlight">\(h(P)\)</span> is less than <span class="math notranslate nohighlight">\(B+\hat{h}(P)\)</span>,
where <span class="math notranslate nohighlight">\(\hat{h}(P)\)</span> is the canonical height of <span class="math notranslate nohighlight">\(P\)</span>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>We assume the model is minimal!</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1002231243161</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">silverman_bound</span><span class="p">()</span>
<span class="go">18.29545210468247</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">silverman_bound</span><span class="p">()</span>
<span class="go">6.284833369972403</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_EllipticCurve.two_descent">
<span class="sig-name descname"><span class="pre">two_descent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selmer_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">first_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_aux</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_descent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_EllipticCurve.two_descent" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute 2-descent data for this curve.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> (bool, default <code class="docutils literal notranslate"><span class="pre">True</span></code>) –  print what mwrank is doing.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">selmer_only</span></code> (bool, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – <code class="docutils literal notranslate"><span class="pre">selmer_only</span></code> switch.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">first_limit</span></code> (int, default 20) – bound on <span class="math notranslate nohighlight">\(|x|+|z|\)</span> in
quartic point search.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">second_limit</span></code> (int, default 8) – bound on
<span class="math notranslate nohighlight">\(\log \max(|x|,|z|)\)</span>, i.e. logarithmic.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n_aux</span></code> (int, default -1) – (only relevant for general
2-descent when 2-torsion trivial) number of primes used for
quartic search.  <code class="docutils literal notranslate"><span class="pre">n_aux=-1</span></code> causes default (8) to be used.
Increase for curves of higher rank.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">second_descent</span></code> (bool, default <code class="docutils literal notranslate"><span class="pre">True</span></code>) – (only relevant
for curves with 2-torsion, where mwrank uses descent via
2-isogeny) flag determining whether or not to do second
descent.  <em>Default strongly recommended.</em></p></li>
</ul>
<p>OUTPUT:</p>
<p>Nothing – nothing is returned.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_MordellWeil">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sage.libs.eclib.interface.</span></span><span class="sig-name descname"><span class="pre">mwrank_MordellWeil</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">curve</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">999</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_MordellWeil" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage 9.5 Reference Manual: Parents and Elements v9.5)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.sage_object.SageObject</span></code></a></p>
<p>The <a class="reference internal" href="#sage.libs.eclib.interface.mwrank_MordellWeil" title="sage.libs.eclib.interface.mwrank_MordellWeil"><code class="xref py py-class docutils literal notranslate"><span class="pre">mwrank_MordellWeil</span></code></a> class represents a subgroup of a
Mordell-Weil group.  Use this class to saturate a specified list
of points on an <a class="reference internal" href="#sage.libs.eclib.interface.mwrank_EllipticCurve" title="sage.libs.eclib.interface.mwrank_EllipticCurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">mwrank_EllipticCurve</span></code></a>, or to search for
points up to some bound.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">curve</span></code> (<a class="reference internal" href="#sage.libs.eclib.interface.mwrank_EllipticCurve" title="sage.libs.eclib.interface.mwrank_EllipticCurve"><code class="xref py py-class docutils literal notranslate"><span class="pre">mwrank_EllipticCurve</span></code></a>) – the underlying
elliptic curve.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> (bool, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – verbosity flag (controls
amount of output produced in point searches).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pp</span></code> (int, default 1) – process points flag (if nonzero,
the points found are processed, so that at all times only a
<span class="math notranslate nohighlight">\(\ZZ\)</span>-basis for the subgroup generated by the points found
so far is stored; if zero, no processing is done and all
points found are stored).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maxr</span></code> (int, default 999) – maximum rank (quit point
searching once the points found generate a subgroup of this
rank; useful if an upper bound for the rank is already
known).</p></li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">EQ</span> <span class="o">=</span> <span class="n">mwrank_MordellWeil</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">EQ</span>
<span class="go">Subgroup of Mordell-Weil group: []</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">P1 = [0:1:0]     is torsion point, order 1</span>
<span class="go">P1 = [1:-1:1]    is torsion point, order 2</span>
<span class="go">P1 = [2:2:1]     is torsion point, order 3</span>
<span class="go">P1 = [9:23:1]    is torsion point, order 6</span>

<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">EQ</span> <span class="o">=</span> <span class="n">mwrank_MordellWeil</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">P1 = [0:1:0]     is torsion point, order 1</span>
<span class="go">P1 = [-3:0:1]     is generator number 1</span>
<span class="go">...</span>
<span class="go">P4 = [-91:804:343]       = -2*P1 + 2*P2 + 1*P3 (mod torsion)</span>
<span class="gp">sage: </span><span class="n">EQ</span>
<span class="go">Subgroup of Mordell-Weil group: [[1:-1:1], [-2:3:1], [-14:25:8]]</span>
</pre></div>
</div>
<p>Example to illustrate the verbose parameter:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">EQ</span> <span class="o">=</span> <span class="n">mwrank_MordellWeil</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">EQ</span>
<span class="go">Subgroup of Mordell-Weil group: [[1:-1:1], [-2:3:1], [-14:25:8]]</span>

<span class="gp">sage: </span><span class="n">EQ</span> <span class="o">=</span> <span class="n">mwrank_MordellWeil</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">P1 = [0:1:0]     is torsion point, order 1</span>
<span class="go">P1 = [-3:0:1]     is generator number 1</span>
<span class="go">saturating up to 20...Saturation index bound (for points of good reduction)  = 3</span>
<span class="go">Reducing saturation bound from given value 20 to computed index bound 3</span>
<span class="go">Checking saturation at [ 2 3 ]</span>
<span class="go">Checking 2-saturation </span>
<span class="go">Points were proved 2-saturated (max q used = 7)</span>
<span class="go">Checking 3-saturation </span>
<span class="go">Points were proved 3-saturated (max q used = 7)</span>
<span class="go">done</span>
<span class="go">P2 = [-2:3:1]     is generator number 2</span>
<span class="go">saturating up to 20...Saturation index bound (for points of good reduction)  = 4</span>
<span class="go">Reducing saturation bound from given value 20 to computed index bound 4</span>
<span class="go">Checking saturation at [ 2 3 ]</span>
<span class="go">Checking 2-saturation </span>
<span class="go">possible kernel vector = [1,1]</span>
<span class="go">This point may be in 2E(Q): [14:-52:1]</span>
<span class="go">...and it is! </span>
<span class="go">Replacing old generator #1 with new generator [1:-1:1]</span>
<span class="go">Reducing index bound from 4 to 2</span>
<span class="go">Points have successfully been 2-saturated (max q used = 7)</span>
<span class="go">Index gain = 2^1</span>
<span class="go">done, index = 2.</span>
<span class="go">Gained index 2, new generators = [ [1:-1:1] [-2:3:1] ]</span>
<span class="go">P3 = [-14:25:8]   is generator number 3</span>
<span class="go">saturating up to 20...Saturation index bound (for points of good reduction)  = 3</span>
<span class="go">Reducing saturation bound from given value 20 to computed index bound 3</span>
<span class="go">Checking saturation at [ 2 3 ]</span>
<span class="go">Checking 2-saturation </span>
<span class="go">Points were proved 2-saturated (max q used = 11)</span>
<span class="go">Checking 3-saturation </span>
<span class="go">Points were proved 3-saturated (max q used = 13)</span>
<span class="go">done, index = 1.</span>
<span class="go">P4 = [-1:3:1]    = -1*P1 + -1*P2 + -1*P3 (mod torsion)</span>
<span class="go">P4 = [0:2:1]     = 2*P1 + 0*P2 + 1*P3 (mod torsion)</span>
<span class="go">P4 = [2:13:8]    = -3*P1 + 1*P2 + -1*P3 (mod torsion)</span>
<span class="go">P4 = [1:0:1]     = -1*P1 + 0*P2 + 0*P3 (mod torsion)</span>
<span class="go">P4 = [2:0:1]     = -1*P1 + 1*P2 + 0*P3 (mod torsion)</span>
<span class="go">P4 = [18:7:8]    = -2*P1 + -1*P2 + -1*P3 (mod torsion)</span>
<span class="go">P4 = [3:3:1]     = 1*P1 + 0*P2 + 1*P3 (mod torsion)</span>
<span class="go">P4 = [4:6:1]     = 0*P1 + -1*P2 + -1*P3 (mod torsion)</span>
<span class="go">P4 = [36:69:64]  = 1*P1 + -2*P2 + 0*P3 (mod torsion)</span>
<span class="go">P4 = [68:-25:64]         = -2*P1 + -1*P2 + -2*P3 (mod torsion)</span>
<span class="go">P4 = [12:35:27]  = 1*P1 + -1*P2 + -1*P3 (mod torsion)</span>
<span class="gp">sage: </span><span class="n">EQ</span>
<span class="go">Subgroup of Mordell-Weil group: [[1:-1:1], [-2:3:1], [-14:25:8]]</span>
</pre></div>
</div>
<p>Example to illustrate the process points (<code class="docutils literal notranslate"><span class="pre">pp</span></code>) parameter:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">EQ</span> <span class="o">=</span> <span class="n">mwrank_MordellWeil</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pp</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">EQ</span> <span class="c1"># generators only</span>
<span class="go">Subgroup of Mordell-Weil group: [[1:-1:1], [-2:3:1], [-14:25:8]]</span>
<span class="gp">sage: </span><span class="n">EQ</span> <span class="o">=</span> <span class="n">mwrank_MordellWeil</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">EQ</span> <span class="c1"># all points found</span>
<span class="go">Subgroup of Mordell-Weil group: [[-3:0:1], [-2:3:1], [-14:25:8], [-1:3:1], [0:2:1], [2:13:8], [1:0:1], [2:0:1], [18:7:8], [3:3:1], [4:6:1], [36:69:64], [68:-25:64], [12:35:27]]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_MordellWeil.points">
<span class="sig-name descname"><span class="pre">points</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_MordellWeil.points" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the generating points in this Mordell-Weil
group.</p>
<p>OUTPUT:</p>
<p>(list) A list of lists of length 3, each holding the
primitive integer coordinates <span class="math notranslate nohighlight">\([x,y,z]\)</span> of a generating
point.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">EQ</span> <span class="o">=</span> <span class="n">mwrank_MordellWeil</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">P1 = [0:1:0]         is torsion point, order 1</span>
<span class="go">P1 = [-3:0:1]         is generator number 1</span>
<span class="go">...</span>
<span class="go">P4 = [12:35:27]      = 1*P1 + -1*P2 + -1*P3 (mod torsion)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">points</span><span class="p">()</span>
<span class="go">[[1, -1, 1], [-2, 3, 1], [-14, 25, 8]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_MordellWeil.process">
<span class="sig-name descname"><span class="pre">process</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saturation_bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_MordellWeil.process" title="Permalink to this definition">¶</a></dt>
<dd><p>Process points in the list <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<p>This function allows one to add points to a <a class="reference internal" href="#sage.libs.eclib.interface.mwrank_MordellWeil" title="sage.libs.eclib.interface.mwrank_MordellWeil"><code class="xref py py-class docutils literal notranslate"><span class="pre">mwrank_MordellWeil</span></code></a> object.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">v</span></code> (list of 3-tuples or lists of ints or Integers) – a
list of triples of integers, which define points on the
curve.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">saturation_bound</span></code> (int, default 0) – saturate at primes up to
<code class="docutils literal notranslate"><span class="pre">saturation_bound</span></code>, or at <em>all</em> primes if <code class="docutils literal notranslate"><span class="pre">saturation_bound</span></code> is -1; when <code class="docutils literal notranslate"><span class="pre">saturation_bound</span></code>
is 0 (the default), do no saturation..</p></li>
</ul>
<p>OUTPUT:</p>
<p>None.  But note that if the <code class="docutils literal notranslate"><span class="pre">verbose</span></code> flag is set, then there
will be some output as a side-effect.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="go">[[1, -1, 1], [-2, 3, 1], [-14, 25, 8]]</span>
<span class="gp">sage: </span><span class="n">EQ</span> <span class="o">=</span> <span class="n">mwrank_MordellWeil</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">process</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">14</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="go">P1 = [1:-1:1]         is generator number 1</span>
<span class="go">P2 = [-2:3:1]         is generator number 2</span>
<span class="go">P3 = [-14:25:8]       is generator number 3</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">points</span><span class="p">()</span>
<span class="go">[[1, -1, 1], [-2, 3, 1], [-14, 25, 8]]</span>
</pre></div>
</div>
<p>Example to illustrate the saturation parameter <code class="docutils literal notranslate"><span class="pre">saturation_bound</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">EQ</span> <span class="o">=</span> <span class="n">mwrank_MordellWeil</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">process</span><span class="p">([[</span><span class="mi">1547</span><span class="p">,</span> <span class="o">-</span><span class="mi">2967</span><span class="p">,</span> <span class="mi">343</span><span class="p">],</span> <span class="p">[</span><span class="mi">2707496766203306</span><span class="p">,</span> <span class="mi">864581029138191</span><span class="p">,</span> <span class="mi">2969715140223272</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">13422227300</span><span class="p">,</span> <span class="o">-</span><span class="mi">49322830557</span><span class="p">,</span> <span class="mi">12167000000</span><span class="p">]],</span> <span class="n">saturation_bound</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="go">P1 = [1547:-2967:343]         is generator number 1</span>
<span class="go">...</span>
<span class="go">Gained index 5, new generators = [ [-2:3:1] [-14:25:8] [1:-1:1] ]</span>

<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">points</span><span class="p">()</span>
<span class="go">[[-2, 3, 1], [-14, 25, 8], [1, -1, 1]]</span>
</pre></div>
</div>
<p>Here the processing was followed by saturation at primes up to
20.  Now we prevent this initial saturation:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">EQ</span> <span class="o">=</span> <span class="n">mwrank_MordellWeil</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">process</span><span class="p">([[</span><span class="mi">1547</span><span class="p">,</span> <span class="o">-</span><span class="mi">2967</span><span class="p">,</span> <span class="mi">343</span><span class="p">],</span> <span class="p">[</span><span class="mi">2707496766203306</span><span class="p">,</span> <span class="mi">864581029138191</span><span class="p">,</span> <span class="mi">2969715140223272</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">13422227300</span><span class="p">,</span> <span class="o">-</span><span class="mi">49322830557</span><span class="p">,</span> <span class="mi">12167000000</span><span class="p">]],</span> <span class="n">saturation_bound</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">P1 = [1547:-2967:343]         is generator number 1</span>
<span class="go">P2 = [2707496766203306:864581029138191:2969715140223272]      is generator number 2</span>
<span class="go">P3 = [-13422227300:-49322830557:12167000000]          is generator number 3</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">points</span><span class="p">()</span>
<span class="go">[[1547, -2967, 343], [2707496766203306, 864581029138191, 2969715140223272], [-13422227300, -49322830557, 12167000000]]</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">regulator</span><span class="p">()</span>
<span class="go">375.42920288254555</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">saturate</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># points were not 2-saturated</span>
<span class="go">saturating basis...Saturation index bound (for points of good reduction)  = 93</span>
<span class="go">Only p-saturating for p up to given value 2.</span>
<span class="go">The resulting points may not be p-saturated for p between this and the computed index bound 93</span>
<span class="go">Checking saturation at [ 2 ]</span>
<span class="go">Checking 2-saturation </span>
<span class="go">possible kernel vector = [1,0,0]</span>
<span class="go">This point may be in 2E(Q): [1547:-2967:343]</span>
<span class="go">...and it is! </span>
<span class="go">Replacing old generator #1 with new generator [-2:3:1]</span>
<span class="go">Reducing index bound from 93 to 46</span>
<span class="go">Points have successfully been 2-saturated (max q used = 11)</span>
<span class="go">Index gain = 2^1</span>
<span class="go">done</span>
<span class="go">Gained index 2</span>
<span class="go">New regulator =  93.85730072</span>
<span class="go">(True, 2, &#39;[ ]&#39;)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">points</span><span class="p">()</span>
<span class="go">[[-2, 3, 1], [2707496766203306, 864581029138191, 2969715140223272], [-13422227300, -49322830557, 12167000000]]</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">regulator</span><span class="p">()</span>
<span class="go">93.85730072063639</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">saturate</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># points were not 3-saturated</span>
<span class="go">saturating basis...Saturation index bound (for points of good reduction)  = 46</span>
<span class="go">Only p-saturating for p up to given value 3.</span>
<span class="go">The resulting points may not be p-saturated for p between this and the computed index bound 46</span>
<span class="go">Checking saturation at [ 2 3 ]</span>
<span class="go">Checking 2-saturation </span>
<span class="go">Points were proved 2-saturated (max q used = 11)</span>
<span class="go">Checking 3-saturation </span>
<span class="go">possible kernel vector = [0,1,0]</span>
<span class="go">This point may be in 3E(Q): [2707496766203306:864581029138191:2969715140223272]</span>
<span class="go">...and it is! </span>
<span class="go">Replacing old generator #2 with new generator [-14:25:8]</span>
<span class="go">Reducing index bound from 46 to 15</span>
<span class="go">Points have successfully been 3-saturated (max q used = 13)</span>
<span class="go">Index gain = 3^1</span>
<span class="go">done</span>
<span class="go">Gained index 3</span>
<span class="go">New regulator =  10.42858897</span>
<span class="go">(True, 3, &#39;[ ]&#39;)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">points</span><span class="p">()</span>
<span class="go">[[-2, 3, 1], [-14, 25, 8], [-13422227300, -49322830557, 12167000000]]</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">regulator</span><span class="p">()</span>
<span class="go">10.4285889689596</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">saturate</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># points were not 5-saturated</span>
<span class="go">saturating basis...Saturation index bound (for points of good reduction)  = 15</span>
<span class="go">Only p-saturating for p up to given value 5.</span>
<span class="go">The resulting points may not be p-saturated for p between this and the computed index bound 15</span>
<span class="go">Checking saturation at [ 2 3 5 ]</span>
<span class="go">Checking 2-saturation </span>
<span class="go">Points were proved 2-saturated (max q used = 11)</span>
<span class="go">Checking 3-saturation </span>
<span class="go">Points were proved 3-saturated (max q used = 13)</span>
<span class="go">Checking 5-saturation </span>
<span class="go">possible kernel vector = [0,0,1]</span>
<span class="go">This point may be in 5E(Q): [-13422227300:-49322830557:12167000000]</span>
<span class="go">...and it is! </span>
<span class="go">Replacing old generator #3 with new generator [1:-1:1]</span>
<span class="go">Reducing index bound from 15 to 3</span>
<span class="go">Points have successfully been 5-saturated (max q used = 71)</span>
<span class="go">Index gain = 5^1</span>
<span class="go">done</span>
<span class="go">Gained index 5</span>
<span class="go">New regulator =  0.4171435588</span>
<span class="go">(True, 5, &#39;[ ]&#39;)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">points</span><span class="p">()</span>
<span class="go">[[-2, 3, 1], [-14, 25, 8], [1, -1, 1]]</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">regulator</span><span class="p">()</span>
<span class="go">0.417143558758384</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">saturate</span><span class="p">()</span>   <span class="c1"># points are now saturated</span>
<span class="go">saturating basis...Saturation index bound (for points of good reduction)  = 3</span>
<span class="go">Tamagawa index primes are [ ]</span>
<span class="go">Checking saturation at [ 2 3 ]</span>
<span class="go">Checking 2-saturation </span>
<span class="go">Points were proved 2-saturated (max q used = 11)</span>
<span class="go">Checking 3-saturation </span>
<span class="go">Points were proved 3-saturated (max q used = 13)</span>
<span class="go">done</span>
<span class="go">(True, 1, &#39;[ ]&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_MordellWeil.rank">
<span class="sig-name descname"><span class="pre">rank</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_MordellWeil.rank" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the rank of this subgroup of the Mordell-Weil group.</p>
<p>OUTPUT:</p>
<p>(int) The rank of this subgroup of the Mordell-Weil group.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>A rank 3 example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">EQ</span> <span class="o">=</span> <span class="n">mwrank_MordellWeil</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">regulator</span><span class="p">()</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>The preceding output is correct, since we have not yet tried
to find any points on the curve either by searching or
2-descent:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">EQ</span>
<span class="go">Subgroup of Mordell-Weil group: []</span>
</pre></div>
</div>
<p>Now we do a very small search:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">P1 = [0:1:0]         is torsion point, order 1</span>
<span class="go">P1 = [-3:0:1]         is generator number 1</span>
<span class="go">saturating up to 20...Checking 2-saturation</span>
<span class="go">...</span>
<span class="go">P4 = [12:35:27]      = 1*P1 + -1*P2 + -1*P3 (mod torsion)</span>
<span class="gp">sage: </span><span class="n">EQ</span>
<span class="go">Subgroup of Mordell-Weil group: [[1:-1:1], [-2:3:1], [-14:25:8]]</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">regulator</span><span class="p">()</span>
<span class="go">0.417143558758384</span>
</pre></div>
</div>
<p>We do in fact now have a full Mordell-Weil basis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_MordellWeil.regulator">
<span class="sig-name descname"><span class="pre">regulator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_MordellWeil.regulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the regulator of the points in this subgroup of
the Mordell-Weil group.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">eclib</span></code> can compute the regulator to arbitrary precision,
but the interface currently returns the output as a <code class="docutils literal notranslate"><span class="pre">float</span></code>.</p>
</div>
<p>OUTPUT:</p>
<p>(float) The regulator of the points in this subgroup.</p>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">regulator</span><span class="p">()</span>
<span class="go">1.0</span>

<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">regulator</span><span class="p">()</span>
<span class="go">0.417143558758384</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_MordellWeil.saturate">
<span class="sig-name descname"><span class="pre">saturate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_prime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_prime</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_MordellWeil.saturate" title="Permalink to this definition">¶</a></dt>
<dd><p>Saturate this subgroup of the Mordell-Weil group.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">max_prime</span></code> (int, default -1) – If <span class="math notranslate nohighlight">\(-1\)</span> (the default), an
upper bound is computed for the primes at which the subgroup
may not be saturated, and saturation is performed for all
primes up to this bound.  Otherwise, the bound used is the
minimum of <code class="docutils literal notranslate"><span class="pre">max_prime</span></code> and the computed bound.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">min_prime</span></code> (int, default 2) – only do saturation at
primes no less than this.  (For example, if the points have
been found via <code class="xref py py-meth docutils literal notranslate"><span class="pre">two_descent()</span></code> they should already be
2-saturated so a value of 3 is appropriate.)</p></li>
</ul>
<p>OUTPUT:</p>
<p>(3-tuple) (<code class="docutils literal notranslate"><span class="pre">ok</span></code>, <code class="docutils literal notranslate"><span class="pre">index</span></code>, <code class="docutils literal notranslate"><span class="pre">unsatlist</span></code>) where:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ok</span></code> (bool) – <code class="docutils literal notranslate"><span class="pre">True</span></code> if and only if the saturation was
provably successful at all primes attempted.  If the default
was used for <code class="docutils literal notranslate"><span class="pre">max_prime</span></code>, then <code class="docutils literal notranslate"><span class="pre">True</span></code> indicates that the
subgroup is saturated at <em>all</em> primes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">index</span></code> (int) – the index of the group generated by the
original points in their saturation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unsatlist</span></code> (list of ints) – list of primes at which
saturation could not be proved or achieved.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In versions up to v20190909, <code class="docutils literal notranslate"><span class="pre">eclib</span></code> used floating point
methods based on elliptic logarithms to divide points, and
did not compute the precision necessary, which could cause
failures. Since v20210310, <code class="docutils literal notranslate"><span class="pre">eclib</span></code> uses exact method based
on division polynomials, which should mean that such
failures does not happen.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We emphasize that if this function returns <code class="docutils literal notranslate"><span class="pre">True</span></code> as the
first return argument (<code class="docutils literal notranslate"><span class="pre">ok</span></code>), and if the default was used
for the parameter <code class="docutils literal notranslate"><span class="pre">max_prime</span></code>, then the points in the
basis after calling this function are saturated at <em>all</em>
primes, i.e., saturating at the primes up to <code class="docutils literal notranslate"><span class="pre">max_prime</span></code>
are sufficient to saturate at all primes.  Note that the
function computes an upper bound for the index of
saturation, and does no work for primes greater than this
even if <code class="docutils literal notranslate"><span class="pre">max_prime</span></code> is larger.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">EQ</span> <span class="o">=</span> <span class="n">mwrank_MordellWeil</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
</pre></div>
</div>
<p>We initialise with three points which happen to be 2, 3 and 5
times the generators of this rank 3 curve.  To prevent
automatic saturation at this stage we set the parameter
<code class="docutils literal notranslate"><span class="pre">sat</span></code> to 0 (which is in fact the default):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">process</span><span class="p">([[</span><span class="mi">1547</span><span class="p">,</span> <span class="o">-</span><span class="mi">2967</span><span class="p">,</span> <span class="mi">343</span><span class="p">],</span> <span class="p">[</span><span class="mi">2707496766203306</span><span class="p">,</span> <span class="mi">864581029138191</span><span class="p">,</span> <span class="mi">2969715140223272</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">13422227300</span><span class="p">,</span> <span class="o">-</span><span class="mi">49322830557</span><span class="p">,</span> <span class="mi">12167000000</span><span class="p">]],</span> <span class="n">saturation_bound</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">P1 = [1547:-2967:343]         is generator number 1</span>
<span class="go">P2 = [2707496766203306:864581029138191:2969715140223272]      is generator number 2</span>
<span class="go">P3 = [-13422227300:-49322830557:12167000000]          is generator number 3</span>
<span class="gp">sage: </span><span class="n">EQ</span>
<span class="go">Subgroup of Mordell-Weil group: [[1547:-2967:343], [2707496766203306:864581029138191:2969715140223272], [-13422227300:-49322830557:12167000000]]</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">regulator</span><span class="p">()</span>
<span class="go">375.42920288254555</span>
</pre></div>
</div>
<p>Now we saturate at <span class="math notranslate nohighlight">\(p=2\)</span>, and gain index 2:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">saturate</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># points were not 2-saturated</span>
<span class="go">saturating basis...Saturation index bound (for points of good reduction) = 93</span>
<span class="go">Only p-saturating for p up to given value 2.</span>
<span class="go">...</span>
<span class="go">Gained index 2</span>
<span class="go">New regulator =  93.857...</span>
<span class="go">(True, 2, &#39;[ ]&#39;)</span>
<span class="gp">sage: </span><span class="n">EQ</span>
<span class="go">Subgroup of Mordell-Weil group: [[-2:3:1], [2707496766203306:864581029138191:2969715140223272], [-13422227300:-49322830557:12167000000]]</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">regulator</span><span class="p">()</span>
<span class="go">93.85730072063639</span>
</pre></div>
</div>
<p>Now we saturate at <span class="math notranslate nohighlight">\(p=3\)</span>, and gain index 3:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">saturate</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># points were not 3-saturated</span>
<span class="go">saturating basis...Saturation index bound (for points of good reduction) = 46</span>
<span class="go">Only p-saturating for p up to given value 3.</span>
<span class="go">...</span>
<span class="go">Gained index 3</span>
<span class="go">New regulator =  10.428...</span>
<span class="go">(True, 3, &#39;[ ]&#39;)</span>
<span class="gp">sage: </span><span class="n">EQ</span>
<span class="go">Subgroup of Mordell-Weil group: [[-2:3:1], [-14:25:8], [-13422227300:-49322830557:12167000000]]</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">regulator</span><span class="p">()</span>
<span class="go">10.4285889689596</span>
</pre></div>
</div>
<p>Now we saturate at <span class="math notranslate nohighlight">\(p=5\)</span>, and gain index 5:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">saturate</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># points were not 5-saturated</span>
<span class="go">saturating basis...Saturation index bound (for points of good reduction) = 15</span>
<span class="go">Only p-saturating for p up to given value 5.</span>
<span class="go">...</span>
<span class="go">Gained index 5</span>
<span class="go">New regulator =  0.417...</span>
<span class="go">(True, 5, &#39;[ ]&#39;)</span>
<span class="gp">sage: </span><span class="n">EQ</span>
<span class="go">Subgroup of Mordell-Weil group: [[-2:3:1], [-14:25:8], [1:-1:1]]</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">regulator</span><span class="p">()</span>
<span class="go">0.417143558758384</span>
</pre></div>
</div>
<p>Finally we finish the saturation.  The output here shows that
the points are now provably saturated at all primes:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">saturate</span><span class="p">()</span>   <span class="c1"># points are now saturated</span>
<span class="go">saturating basis...Saturation index bound (for points of good reduction) = 3</span>
<span class="go">Tamagawa index primes are [ ]</span>
<span class="go">Checking saturation at [ 2 3 ]</span>
<span class="go">Checking 2-saturation</span>
<span class="go">Points were proved 2-saturated (max q used = 11)</span>
<span class="go">Checking 3-saturation</span>
<span class="go">Points were proved 3-saturated (max q used = 13)</span>
<span class="go">done</span>
<span class="go">(True, 1, &#39;[ ]&#39;)</span>
</pre></div>
</div>
<p>Of course, the <a class="reference internal" href="#sage.libs.eclib.interface.mwrank_MordellWeil.process" title="sage.libs.eclib.interface.mwrank_MordellWeil.process"><code class="xref py py-meth docutils literal notranslate"><span class="pre">process()</span></code></a> function would have done all this
automatically for us:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">EQ</span> <span class="o">=</span> <span class="n">mwrank_MordellWeil</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">process</span><span class="p">([[</span><span class="mi">1547</span><span class="p">,</span> <span class="o">-</span><span class="mi">2967</span><span class="p">,</span> <span class="mi">343</span><span class="p">],</span> <span class="p">[</span><span class="mi">2707496766203306</span><span class="p">,</span> <span class="mi">864581029138191</span><span class="p">,</span> <span class="mi">2969715140223272</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">13422227300</span><span class="p">,</span> <span class="o">-</span><span class="mi">49322830557</span><span class="p">,</span> <span class="mi">12167000000</span><span class="p">]],</span> <span class="n">saturation_bound</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">P1 = [1547:-2967:343]         is generator number 1</span>
<span class="go">...</span>
<span class="go">Gained index 5, new generators = [ [-2:3:1] [-14:25:8] [1:-1:1] ]</span>
<span class="gp">sage: </span><span class="n">EQ</span>
<span class="go">Subgroup of Mordell-Weil group: [[-2:3:1], [-14:25:8], [1:-1:1]]</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">regulator</span><span class="p">()</span>
<span class="go">0.417143558758384</span>
</pre></div>
</div>
<p>But we would still need to use the <a class="reference internal" href="#sage.libs.eclib.interface.mwrank_MordellWeil.saturate" title="sage.libs.eclib.interface.mwrank_MordellWeil.saturate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">saturate()</span></code></a> function to
verify that full saturation has been done:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">saturate</span><span class="p">()</span>
<span class="go">saturating basis...Saturation index bound (for points of good reduction) = 3</span>
<span class="go">Tamagawa index primes are [ ]</span>
<span class="go">Checking saturation at [ 2 3 ]</span>
<span class="go">Checking 2-saturation</span>
<span class="go">Points were proved 2-saturated (max q used = 11)</span>
<span class="go">Checking 3-saturation</span>
<span class="go">Points were proved 3-saturated (max q used = 13)</span>
<span class="go">done</span>
<span class="go">(True, 1, &#39;[ ]&#39;)</span>
</pre></div>
</div>
<p>Note the output of the preceding command: it proves that the
index of the points in their saturation is at most 3, then
proves saturation at 2 and at 3, by reducing the points modulo
all primes of good reduction up to 11, respectively 13.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sage.libs.eclib.interface.mwrank_MordellWeil.search">
<span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">height_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">18</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sage.libs.eclib.interface.mwrank_MordellWeil.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for new points, and add them to this subgroup of the
Mordell-Weil group.</p>
<p>INPUT:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">height_limit</span></code> (float, default: 18) – search up to this
logarithmic height.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On 32-bit machines, this <em>must</em> be &lt; 21.48 (<span class="math notranslate nohighlight">\(31\log(2)\)</span>) else
<span class="math notranslate nohighlight">\(\exp(h_{\text{lim}}) &gt; 2^{31}\)</span> and overflows.  On 64-bit machines, it
must be <em>at most</em> 43.668  (<span class="math notranslate nohighlight">\(63\log(2)\)</span>) .  However, this bound is a logarithmic
bound and increasing it by just 1 increases the running time
by (roughly) <span class="math notranslate nohighlight">\(\exp(1.5)=4.5\)</span>, so searching up to even 20
takes a very long time.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The search is carried out with a quadratic sieve, using
code adapted from a version of Michael Stoll’s
<code class="docutils literal notranslate"><span class="pre">ratpoints</span></code> program.  It would be preferable to use a
newer version of <code class="docutils literal notranslate"><span class="pre">ratpoints</span></code>.</p>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code> (bool, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – turn verbose operation on
or off.</p></li>
</ul>
<p>EXAMPLES:</p>
<p>A rank 3 example, where a very small search is sufficient to
find a Mordell-Weil basis:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">EQ</span> <span class="o">=</span> <span class="n">mwrank_MordellWeil</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">P1 = [0:1:0]         is torsion point, order 1</span>
<span class="go">P1 = [-3:0:1]         is generator number 1</span>
<span class="go">...</span>
<span class="go">P4 = [12:35:27]      = 1*P1 + -1*P2 + -1*P3 (mod torsion)</span>
<span class="gp">sage: </span><span class="n">EQ</span>
<span class="go">Subgroup of Mordell-Weil group: [[1:-1:1], [-2:3:1], [-14:25:8]]</span>
</pre></div>
</div>
<p>In the next example, a search bound of 12 is needed to find a
non-torsion point:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">mwrank_EllipticCurve</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">18392</span><span class="p">,</span> <span class="o">-</span><span class="mi">1186248</span><span class="p">])</span> <span class="c1">#1056g4</span>
<span class="gp">sage: </span><span class="n">EQ</span> <span class="o">=</span> <span class="n">mwrank_MordellWeil</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span> <span class="n">EQ</span>
<span class="go">P1 = [0:1:0]         is torsion point, order 1</span>
<span class="go">P1 = [161:0:1]       is torsion point, order 2</span>
<span class="go">Subgroup of Mordell-Weil group: []</span>
<span class="gp">sage: </span><span class="n">EQ</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span> <span class="n">EQ</span>
<span class="go">P1 = [0:1:0]         is torsion point, order 1</span>
<span class="go">P1 = [161:0:1]       is torsion point, order 2</span>
<span class="go">P1 = [4413270:10381877:27000]         is generator number 1</span>
<span class="go">...</span>
<span class="go">Subgroup of Mordell-Weil group: [[4413270:10381877:27000]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="../ecl.html"
                        title="previous chapter">Library interface to Embeddable Common Lisp (ECL)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="mwrank.html"
                        title="next chapter">Cython interface to Cremona’s <code class="docutils literal notranslate"><span class="pre">eclib</span></code> library (also known as <code class="docutils literal notranslate"><span class="pre">mwrank</span></code>)</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/sage/libs/eclib/interface.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="mwrank.html" title="Cython interface to Cremona’s eclib library (also known as mwrank)"
             >next</a> |</li>
        <li class="right" >
          <a href="../ecl.html" title="Library interface to Embeddable Common Lisp (ECL)"
             >previous</a> |</li>
  
    
      <a href="../../../../../index.html"><img src="../../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../../index.html">Sage 9.5 Reference Manual: C/C++ Library Interfaces</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Sage interface to Cremona’s <code class="docutils literal notranslate"><span class="pre">eclib</span></code> library (also known as <code class="docutils literal notranslate"><span class="pre">mwrank</span></code>)</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2022, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>