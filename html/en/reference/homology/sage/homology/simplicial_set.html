
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=600, initial-scale=1">
    <title>Simplicial sets &#8212; Sage Reference Manual v8.6: Cell complexes and their homology</title>
    <link rel="stylesheet" href="../../../_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <script type="text/javascript" src="../../../_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Methods of constructing simplicial sets" href="simplicial_set_constructions.html" />
    <link rel="prev" title="Finite cubical complexes" href="cubical_complex.html" />
    <link rel="icon" href="../../../_static/sageicon.png" type="image/x-icon" />
    <script src="../../../_static/thebe.js" type="text/javascript"></script>
    <script src="../../../_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="simplicial_set_constructions.html" title="Methods of constructing simplicial sets"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cubical_complex.html" title="Finite cubical complexes"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Cell complexes and their homology</a> &#187;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="simplicial-sets">
<span id="sage-homology-simplicial-set"></span><h1>Simplicial sets<a class="headerlink" href="#simplicial-sets" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sage.homology.simplicial_set"></span><p>AUTHORS:</p>
<ul class="simple">
<li>John H. Palmieri (2016-07)</li>
</ul>
<p>This module implements simplicial sets.</p>
<p>A <em>simplicial set</em> <span class="math notranslate nohighlight">\(X\)</span> is a collection of sets <span class="math notranslate nohighlight">\(X_n\)</span> indexed by the
non-negative integers; the set <span class="math notranslate nohighlight">\(X_n\)</span> is called the set of
<span class="math notranslate nohighlight">\(n\)</span>-simplices. These sets are connected by maps</p>
<div class="math notranslate nohighlight">
\[\begin{split}d_i: X_n \to X_{n-1}, \ \ 0 \leq i \leq n \ \  \text{(face maps)} \\
s_j: X_n \to X_{n+1}, \ \ 0 \leq j \leq n \ \  \text{(degeneracy maps)}\end{split}\]</div>
<p>satisfying the <em>simplicial identities</em>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}d_i d_j &amp;= d_{j-1} d_i \ \  \text{if } i&lt;j \\
d_i s_j &amp;= s_{j-1} d_i \ \  \text{if } i&lt;j \\
d_j s_j &amp;= 1 = d_{j+1} s_j \\
d_i s_j &amp;= s_{j} d_{i-1} \ \  \text{if } i&gt;j+1 \\
s_i s_j &amp;= s_{j+1} s_{i} \ \  \text{if } i&lt;j+1\end{split}\]</div>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Simplicial_set">Wikipedia article Simplicial_set</a>, Peter May’s seminal book <a class="reference internal" href="../../../references/index.html#may1967" id="id1">[May1967]</a>, or
Greg Friedman’s “Illustrated introduction” <a class="reference external" href="https://arxiv.org/abs/0809.4221">Arxiv 0809.4221</a> for more
information.</p>
<p>Several simplicial sets are predefined, and users can construct others
either by hand (using <a class="reference internal" href="#sage.homology.simplicial_set.SimplicialSet_finite" title="sage.homology.simplicial_set.SimplicialSet_finite"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimplicialSet_finite</span></code></a>) or from existing
ones using pushouts, pullbacks, etc.</p>
<p>EXAMPLES:</p>
<p>Some of the predefined simplicial sets:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="go">Torus</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">RP^7</span>
<span class="gp">sage: </span><span class="n">S5</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S5</span>
<span class="go">S^5</span>
<span class="gp">sage: </span><span class="n">S5</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[v_0, sigma_5]</span>
</pre></div>
</div>
<p>One class of infinite simplicial sets is available: classifying spaces
of groups, or more generally, nerves of finite monoids:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Sigma4</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">permutation</span><span class="o">.</span><span class="n">Symmetric</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Sigma4</span><span class="o">.</span><span class="n">nerve</span><span class="p">()</span>
<span class="go">Nerve of Symmetric group of order 4! as a permutation group</span>
</pre></div>
</div>
<p>The same simplicial set (albeit with a different name) can also be
constructed as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">Sigma4</span><span class="p">)</span>
<span class="go">Classifying space of Symmetric group of order 4! as a permutation group</span>
</pre></div>
</div>
<p>Type <code class="docutils literal notranslate"><span class="pre">simplicial_sets.</span></code> and hit the <code class="docutils literal notranslate"><span class="pre">TAB</span></code> key to get a full list
of the predefined simplicial sets.</p>
<p>You can construct new simplicial sets from old by taking quotients,
subsimplicial sets, disjoint unions, wedges (if they are pointed),
smash products (if they are pointed and finite), products, pushouts,
pullbacks, cones, and suspensions, most of which also have maps
associated with them. Wedges, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span> <span class="ow">and</span> <span class="n">S3</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span>
<span class="go">Wedge: (Torus v S^3)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span> <span class="o">==</span> <span class="n">T</span><span class="o">.</span><span class="n">coproduct</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
<span class="go">Torus</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">projection_map</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span>
<span class="go">Quotient: (Wedge: (Torus v S^3)/Simplicial set with 6 non-degenerate simplices)</span>
</pre></div>
</div>
<p>If the <span class="math notranslate nohighlight">\(1\)</span>-sphere were not already available via
<code class="docutils literal notranslate"><span class="pre">simplicial_sets.Sphere(1)</span></code>, you could construct it as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">pt</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">edge</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">cone</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">quotient</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">S1</span>
<span class="go">Quotient: (Cone of 0-simplex/Simplicial set with 2 non-degenerate simplices)</span>
</pre></div>
</div>
<p>At this point, <code class="docutils literal notranslate"><span class="pre">S1</span></code> is pointed: every quotient is automatically
given a base point, namely the image of the subcomplex. So its
suspension is the reduced suspension, and therefore is small:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S5</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">suspension</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S5</span>
<span class="go">Sigma^4(Quotient: (Cone of 0-simplex/Simplicial set with 2 non-degenerate simplices))</span>
<span class="gp">sage: </span><span class="n">S5</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 0, 0, 0, 0, 1]</span>
</pre></div>
</div>
<p>If we forget about the base point in <code class="docutils literal notranslate"><span class="pre">S1</span></code>, we would get the
unreduced suspension instead:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z1</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">unset_base_point</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Z1</span><span class="o">.</span><span class="n">suspension</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[2, 2, 2, 2, 1, 1]</span>
</pre></div>
</div>
<p>The cone on a pointed simplicial set is the reduced cone. The
<span class="math notranslate nohighlight">\(n\)</span>-simplex in Sage is not pointed, but the simplicial set <code class="docutils literal notranslate"><span class="pre">Point</span></code>
is.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cone</span><span class="p">()</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[2, 1]</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Point</span><span class="p">()</span><span class="o">.</span><span class="n">cone</span><span class="p">()</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1]</span>
</pre></div>
</div>
<p>For most simplicial sets (the <code class="docutils literal notranslate"><span class="pre">Point</span></code> is the main exception), each
time it is constructed, it gives a distinct copy, and two distinct
simplicial sets are never equal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">==</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">==</span> <span class="n">T</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span> <span class="o">==</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Point</span><span class="p">()</span> <span class="o">==</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Point</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>You can construct subsimplicial sets by specifying a list of simplices,
and then you can define the quotient simplicial set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">g</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">subsimplicial_set</span><span class="p">([</span><span class="n">e</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">quotient</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
<p>Or equivalently:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">quotient</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span>
<span class="go">Quotient: (2-simplex/Simplicial set with 6 non-degenerate simplices)</span>
</pre></div>
</div>
<p>Note that subsimplicial sets and quotients come equipped with
inclusion and quotient morphisms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">inc</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">inc</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="o">==</span> <span class="n">Y</span> <span class="ow">and</span> <span class="n">inc</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="o">==</span> <span class="n">X</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">quo</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">quotient_map</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">quo</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
<span class="go">2-simplex</span>
<span class="gp">sage: </span><span class="n">quo</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="o">==</span> <span class="n">Z</span>
<span class="go">True</span>
</pre></div>
</div>
<p>You can compute homology groups and the fundamental group of
any simplicial set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">eight</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">eight</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">()</span>
<span class="go">Finitely presented group &lt; e0, e1 | &gt;</span>

<span class="gp">sage: </span><span class="n">Sigma3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">permutation</span><span class="o">.</span><span class="n">Symmetric</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BSigma3</span> <span class="o">=</span> <span class="n">Sigma3</span><span class="o">.</span><span class="n">nerve</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">pi</span> <span class="o">=</span> <span class="n">BSigma3</span><span class="o">.</span><span class="n">fundamental_group</span><span class="p">();</span> <span class="n">pi</span>
<span class="go">Finitely presented group &lt; e0, e1 | e0^2, e1^3, (e0*e1^-1)^2 &gt;</span>
<span class="gp">sage: </span><span class="n">pi</span><span class="o">.</span><span class="n">order</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">sage: </span><span class="n">pi</span><span class="o">.</span><span class="n">is_abelian</span><span class="p">()</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">RP6</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RP6</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">{0: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 1: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 2: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 3: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 4: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 5: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 6: Vector space of dimension 1 over Finite Field of size 2}</span>
<span class="gp">sage: </span><span class="n">RP6</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">{0: Vector space of dimension 1 over Rational Field,</span>
<span class="go"> 1: Vector space of dimension 0 over Rational Field,</span>
<span class="go"> 2: Vector space of dimension 0 over Rational Field,</span>
<span class="go"> 3: Vector space of dimension 0 over Rational Field,</span>
<span class="go"> 4: Vector space of dimension 0 over Rational Field,</span>
<span class="go"> 5: Vector space of dimension 0 over Rational Field,</span>
<span class="go"> 6: Vector space of dimension 0 over Rational Field}</span>
</pre></div>
</div>
<p>When infinite simplicial sets are involved, most computations are done
by taking an <span class="math notranslate nohighlight">\(n\)</span>-skeleton for an appropriate <span class="math notranslate nohighlight">\(n\)</span>, either implicitly or
explicitly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">B3</span><span class="p">)</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Disjoint union: (Simplicial set with 15 non-degenerate simplices u Simplicial set with 15 non-degenerate simplices)</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">{0: 0, 1: Z x C3, 2: C3, 3: C3}</span>
</pre></div>
</div>
<p>Without the <code class="docutils literal notranslate"><span class="pre">range</span></code> argument, this would raise an error, since
<code class="docutils literal notranslate"><span class="pre">B3</span></code> is infinite:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B3</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">this simplicial set may be infinite, so specify dimensions when computing homology</span>
</pre></div>
</div>
<p>It should be easy to construct many simplicial sets from the
predefined ones using pushouts, pullbacks, etc., but they can also be
constructed “by hand”: first define some simplices, then define a
simplicial set by specifying their faces:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">),</span> <span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">)})</span>
</pre></div>
</div>
<p>Now <span class="math notranslate nohighlight">\(e\)</span> is an edge from <span class="math notranslate nohighlight">\(v\)</span> to <span class="math notranslate nohighlight">\(w\)</span> and <span class="math notranslate nohighlight">\(f\)</span> is an edge starting and
ending at <span class="math notranslate nohighlight">\(w\)</span>. Therefore the first homology group of <span class="math notranslate nohighlight">\(X\)</span> should be a
copy of the integers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Z</span>
</pre></div>
</div>
<dl class="function">
<dt id="sage.homology.simplicial_set.AbstractSimplex">
<code class="descclassname">sage.homology.simplicial_set.</code><code class="descname">AbstractSimplex</code><span class="sig-paren">(</span><em>dim</em>, <em>degeneracies=()</em>, <em>underlying=None</em>, <em>name=None</em>, <em>latex_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.AbstractSimplex" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract simplex, a building block of a simplicial set.</p>
<p>In a simplicial set, a simplex either is non-degenerate or is
obtained by applying degeneracy maps to a non-degenerate simplex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">dim</span></code> – a non-negative integer, the dimension of the
underlying non-degenerate simplex.</li>
<li><code class="docutils literal notranslate"><span class="pre">degeneracies</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – a list or tuple of
non-negative integers, the degeneracies to be applied.</li>
<li><code class="docutils literal notranslate"><span class="pre">underlying</span></code> (optional) – a non-degenerate simplex to which
the degeneracies are being applied.</li>
<li><code class="docutils literal notranslate"><span class="pre">name</span></code> (optional) – string, a name for this simplex.</li>
<li><code class="docutils literal notranslate"><span class="pre">latex_name</span></code> (optional) – string, a name for this simplex to
use in the LaTeX representation.</li>
</ul>
<p>So to define a simplex formed by applying the degeneracy maps <span class="math notranslate nohighlight">\(s_2
s_1\)</span> to a 1-simplex, call <code class="docutils literal notranslate"><span class="pre">AbstractSimplex(1,</span> <span class="pre">(2,</span> <span class="pre">1))</span></code>.</p>
<p>Specify <code class="docutils literal notranslate"><span class="pre">underlying</span></code> if you need to keep explicit track of the
underlying non-degenerate simplex, for example when computing
faces of another simplex. This is mainly for use by the method
<a class="reference internal" href="#sage.homology.simplicial_set.AbstractSimplex_class.apply_degeneracies" title="sage.homology.simplicial_set.AbstractSimplex_class.apply_degeneracies"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AbstractSimplex_class.apply_degeneracies()</span></code></a>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">s_3 s_1 Delta^3</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
<span class="go">Delta^3</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Delta^3</span>
</pre></div>
</div>
<p>Simplices may be named (or renamed), affecting how they are printed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Delta^0</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span>
<span class="go">v</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;w_0&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span>
<span class="go">w_0</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">w_0</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">latex_name</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">sigma&#39;</span><span class="p">))</span>
<span class="go">\sigma</span>
</pre></div>
</div>
<p>The simplicial identities are used to put the degeneracies in
standard decreasing form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">x</span>
<span class="go">s_2 s_1 s_0 Delta^0</span>
<span class="gp">sage: </span><span class="n">x</span><span class="o">.</span><span class="n">degeneracies</span><span class="p">()</span>
<span class="go">[2, 1, 0]</span>
</pre></div>
</div>
<p>Use of the <code class="docutils literal notranslate"><span class="pre">underlying</span></code> argument:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">underlying</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span>
<span class="go">s_0 v</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">()</span> <span class="ow">is</span> <span class="n">v</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">is_degenerate</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Distinct non-degenerate simplices are never equal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="o">==</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,)))</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,)))</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">==</span> <span class="n">f</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">()</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>This means that if, when defining a simplicial set, you specify
the faces of a 2-simplex as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<p>then the faces are the same degenerate vertex, but if you specify
the faces as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,))),</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,))),</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,))))</span>
</pre></div>
</div>
<p>then the faces are three different degenerate vertices.</p>
<p>View a command like <code class="docutils literal notranslate"><span class="pre">AbstractSimplex(0,</span> <span class="pre">(2,1,0))</span></code> as first
constructing <code class="docutils literal notranslate"><span class="pre">AbstractSimplex(0)</span></code> and then applying degeneracies
to it, and you always get distinct simplices from different calls
to <code class="docutils literal notranslate"><span class="pre">AbstractSimplex(0)</span></code>. On the other hand, if you apply
degeneracies to the same non-degenerate simplex, the resulting
simplices are equal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">underlying</span><span class="o">=</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">underlying</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="sage.homology.simplicial_set.AbstractSimplex_class">
<em class="property">class </em><code class="descclassname">sage.homology.simplicial_set.</code><code class="descname">AbstractSimplex_class</code><span class="sig-paren">(</span><em>dim</em>, <em>degeneracies=()</em>, <em>underlying=None</em>, <em>name=None</em>, <em>latex_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.AbstractSimplex_class" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/sage_object.html#sage.structure.sage_object.SageObject" title="(in Sage Reference Manual: Parents and Elements v8.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.sage_object.SageObject</span></code></a></p>
<p>A simplex of dimension <code class="docutils literal notranslate"><span class="pre">dim</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">dim</span></code> – integer, the dimension</li>
<li><code class="docutils literal notranslate"><span class="pre">degeneracies</span></code> (optional) – iterable, the indices of the
degeneracy maps</li>
<li><code class="docutils literal notranslate"><span class="pre">underlying</span></code> (optional) – a non-degenerate simplex</li>
<li><code class="docutils literal notranslate"><span class="pre">name</span></code> (optional) – string</li>
<li><code class="docutils literal notranslate"><span class="pre">latex_name</span></code> (optional) – string</li>
</ul>
<p>Users should not call this directly, but instead use
<a class="reference internal" href="#sage.homology.simplicial_set.AbstractSimplex" title="sage.homology.simplicial_set.AbstractSimplex"><code class="xref py py-func docutils literal notranslate"><span class="pre">AbstractSimplex()</span></code></a>. See that function for more documentation.</p>
<dl class="method">
<dt id="sage.homology.simplicial_set.AbstractSimplex_class.apply_degeneracies">
<code class="descname">apply_degeneracies</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.AbstractSimplex_class.apply_degeneracies" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the degeneracies given by the arguments <code class="docutils literal notranslate"><span class="pre">args</span></code> to this simplex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">args</span></code> – integers</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">()</span> <span class="o">==</span> <span class="n">v</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span>
<span class="go">s_1 s_0 Delta^0</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">degeneracies</span><span class="p">()</span>
<span class="go">[1, 0]</span>
<span class="gp">sage: </span><span class="n">f</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">()</span> <span class="o">==</span> <span class="n">v</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">s_1 s_0 Delta^0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.AbstractSimplex_class.degeneracies">
<code class="descname">degeneracies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.AbstractSimplex_class.degeneracies" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of indices for the degeneracy maps for this
simplex.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">degeneracies</span><span class="p">()</span>
<span class="go">[2, 1, 0]</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">degeneracies</span><span class="p">()</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.AbstractSimplex_class.dimension">
<code class="descname">dimension</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.AbstractSimplex_class.dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>The dimension of this simplex.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.AbstractSimplex_class.is_degenerate">
<code class="descname">is_degenerate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.AbstractSimplex_class.is_degenerate" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this simplex is degenerate.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">is_degenerate</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">is_degenerate</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.AbstractSimplex_class.is_nondegenerate">
<code class="descname">is_nondegenerate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.AbstractSimplex_class.is_nondegenerate" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this simplex is non-degenerate.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">is_nondegenerate</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">is_nondegenerate</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">is_nondegenerate</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.AbstractSimplex_class.nondegenerate">
<code class="descname">nondegenerate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.AbstractSimplex_class.nondegenerate" title="Permalink to this definition">¶</a></dt>
<dd><p>The non-degenerate simplex underlying this one.</p>
<p>Therefore return itself if this simplex is non-degenerate.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sigma</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">()</span>
<span class="go">v</span>
<span class="gp">sage: </span><span class="n">tau</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">tau</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">();</span> <span class="n">x</span>
<span class="go">Delta^1</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">==</span> <span class="n">tau</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">()</span>
<span class="go">True</span>

<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
<span class="go">Delta^1</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="o">==</span> <span class="n">tau</span><span class="o">.</span><span class="n">nondegenerate</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.homology.simplicial_set.NonDegenerateSimplex">
<em class="property">class </em><code class="descclassname">sage.homology.simplicial_set.</code><code class="descname">NonDegenerateSimplex</code><span class="sig-paren">(</span><em>dim</em>, <em>name=None</em>, <em>latex_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.NonDegenerateSimplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.homology.simplicial_set.AbstractSimplex_class" title="sage.homology.simplicial_set.AbstractSimplex_class"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.homology.simplicial_set.AbstractSimplex_class</span></code></a>, <a class="reference external" href="../../../misc/sage/misc/fast_methods.html#sage.misc.fast_methods.WithEqualityById" title="(in Sage Reference Manual: Utilities v8.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.misc.fast_methods.WithEqualityById</span></code></a></p>
<p>A nondegenerate simplex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">dim</span></code> – non-negative integer, the dimension</li>
<li><code class="docutils literal notranslate"><span class="pre">name</span></code> (optional) – string, a name for this simplex.</li>
<li><code class="docutils literal notranslate"><span class="pre">latex_name</span></code> (optional) – string, a name for this simplex to
use in the LaTeX representation.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span>
<span class="go">v</span>
<span class="gp">sage: </span><span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="go">&lt;class &#39;sage.homology.simplicial_set.NonDegenerateSimplex&#39;&gt;</span>
</pre></div>
</div>
<p>Distinct non-degenerate simplices should never be equal, even
if they have the same starting data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v</span> <span class="o">==</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">NonDegenerateSimplex</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">=</span> <span class="n">NonDegenerateSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">x</span> <span class="o">==</span> <span class="n">NonDegenerateSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="sage.homology.simplicial_set.SimplicialSet">
<code class="descclassname">sage.homology.simplicial_set.</code><code class="descname">SimplicialSet</code><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#sage.homology.simplicial_set.SimplicialSet_finite" title="sage.homology.simplicial_set.SimplicialSet_finite"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimplicialSet_finite</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary">
<em class="property">class </em><code class="descclassname">sage.homology.simplicial_set.</code><code class="descname">SimplicialSet_arbitrary</code><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="../../../structure/sage/structure/parent.html#sage.structure.parent.Parent" title="(in Sage Reference Manual: Parents and Elements v8.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.structure.parent.Parent</span></code></a></p>
<p>A simplicial set.</p>
<p>A simplicial set <span class="math notranslate nohighlight">\(X\)</span> is a collection of sets <span class="math notranslate nohighlight">\(X_n\)</span>, the
<em>n-simplices</em>, indexed by the non-negative integers, together with
maps</p>
<div class="math notranslate nohighlight">
\[\begin{split}d_i: X_n \to X_{n-1}, \ \ 0 \leq i \leq n \ \  \text{(face maps)} \\
s_j: X_n \to X_{n+1}, \ \ 0 \leq j \leq n \ \  \text{(degeneracy maps)}\end{split}\]</div>
<p>satisfying the <em>simplicial identities</em>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}d_i d_j &amp;= d_{j-1} d_i \ \  \text{if } i&lt;j \\
d_i s_j &amp;= s_{j-1} d_i \ \  \text{if } i&lt;j \\
d_j s_j &amp;= 1 = d_{j+1} s_j \\
d_i s_j &amp;= s_{j} d_{i-1} \ \  \text{if } i&gt;j+1 \\
s_i s_j &amp;= s_{j+1} s_{i} \ \  \text{if } i&lt;j+1\end{split}\]</div>
<p>This class is not fully implemented and is not intended to be
called directly by users. It is intended instead to be used by
other classes which inherit from this one. See
<a class="reference internal" href="#sage.homology.simplicial_set.SimplicialSet_finite" title="sage.homology.simplicial_set.SimplicialSet_finite"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimplicialSet_finite</span></code></a> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Nerve</span></code> for two
examples. In particular, any such class must implement a method
<code class="docutils literal notranslate"><span class="pre">n_skeleton</span></code> – without this, most computations will be
impossible. It must also implement an <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method which
should also set the category, so that methods defined at the
category level, like <code class="docutils literal notranslate"><span class="pre">is_pointed</span></code> and <code class="docutils literal notranslate"><span class="pre">is_finite</span></code>, work
correctly.</p>
<p>Note that the method <a class="reference internal" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.subsimplicial_set" title="sage.homology.simplicial_set.SimplicialSet_arbitrary.subsimplicial_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subsimplicial_set()</span></code></a> calls
<code class="xref py py-meth docutils literal notranslate"><span class="pre">n_skeleton()</span></code>, so to avoid circularity, the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">n_skeleton()</span></code> method should call
<a class="reference internal" href="simplicial_set_constructions.html#sage.homology.simplicial_set_constructions.SubSimplicialSet" title="sage.homology.simplicial_set_constructions.SubSimplicialSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">simplicial_set_constructions.SubSimplicialSet</span></code></a> directly,
not <a class="reference internal" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.subsimplicial_set" title="sage.homology.simplicial_set.SimplicialSet_arbitrary.subsimplicial_set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subsimplicial_set()</span></code></a>.</p>
<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.alexander_whitney">
<code class="descname">alexander_whitney</code><span class="sig-paren">(</span><em>simplex</em>, <em>dim_left</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.alexander_whitney" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ‘subdivision’ of <code class="docutils literal notranslate"><span class="pre">simplex</span></code> in this simplicial set
into a pair of simplices.</p>
<p>The left factor should have dimension <code class="docutils literal notranslate"><span class="pre">dim_left</span></code>, so the
right factor should have dimension <code class="docutils literal notranslate"><span class="pre">dim</span> <span class="pre">-</span> <span class="pre">dim_left</span></code>, if
<code class="docutils literal notranslate"><span class="pre">dim</span></code> is the dimension of the starting simplex. The results
are obtained by applying iterated face maps to
<code class="docutils literal notranslate"><span class="pre">simplex</span></code>. Writing <span class="math notranslate nohighlight">\(d\)</span> for <code class="docutils literal notranslate"><span class="pre">dim</span></code> and <span class="math notranslate nohighlight">\(j\)</span> for <code class="docutils literal notranslate"><span class="pre">dim_left</span></code>:
apply <span class="math notranslate nohighlight">\(d_{j+1} d_{j+2} ... d_{d}\)</span> to get the left factor,
<span class="math notranslate nohighlight">\(d_0 ... d_0\)</span> to get the right factor.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">dim_left</span></code> – integer, the dimension of the left-hand factor</li>
</ul>
<p>OUTPUT: a list containing the triple <code class="docutils literal notranslate"><span class="pre">(c,</span> <span class="pre">left,</span> <span class="pre">right)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code> are the two simplices described
above. If either <code class="docutils literal notranslate"><span class="pre">left</span></code> or <code class="docutils literal notranslate"><span class="pre">right</span></code> is degenerate, <code class="docutils literal notranslate"><span class="pre">c</span></code> is
0; otherwise, <code class="docutils literal notranslate"><span class="pre">c</span></code> is 1. This is so that, when used to
compute cup products, it is easy to ignore terms which have
degenerate factors.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">alexander_whitney</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">[(1, v_0, sigma_2)]</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">alexander_whitney</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[(0, s_0 v_0, s_0 v_0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.all_n_simplices">
<code class="descname">all_n_simplices</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.all_n_simplices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of all simplices, non-degenerate and degenerate, in dimension <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">degen</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">tau</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;tau&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">tau</span><span class="p">:</span> <span class="p">(</span><span class="n">degen</span><span class="p">,</span> <span class="n">degen</span><span class="p">,</span> <span class="n">degen</span><span class="p">),</span> <span class="n">w</span><span class="p">:</span> <span class="bp">None</span><span class="p">})</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Y</span></code> is the disjoint union of a 2-sphere, with vertex <code class="docutils literal notranslate"><span class="pre">v</span></code>
and non-degenerate 2-simplex <code class="docutils literal notranslate"><span class="pre">tau</span></code>, and a point <code class="docutils literal notranslate"><span class="pre">w</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">all_n_simplices</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[v, w]</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">all_n_simplices</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[s_0 v, s_0 w]</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">all_n_simplices</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[tau, s_1 s_0 v, s_1 s_0 w]</span>
</pre></div>
</div>
<p>An example involving an infinite simplicial set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">BC3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">all_n_simplices</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[f * f,</span>
<span class="go"> f * f^2,</span>
<span class="go"> f^2 * f,</span>
<span class="go"> f^2 * f^2, s_0 f, s_0 f^2, s_1 f, s_1 f^2, s_1 s_0 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.betti">
<code class="descname">betti</code><span class="sig-paren">(</span><em>dim=None</em>, <em>subcomplex=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.betti" title="Permalink to this definition">¶</a></dt>
<dd><p>The Betti numbers of this simplicial complex as a dictionary
(or a single Betti number, if only one dimension is given):
the ith Betti number is the rank of the ith homology group.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">dim</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code> – If <code class="docutils literal notranslate"><span class="pre">None</span></code>, then
return the homology in every dimension.  If <code class="docutils literal notranslate"><span class="pre">dim</span></code> is an
integer or list, return the homology in the given
dimensions.  (Actually, if <code class="docutils literal notranslate"><span class="pre">dim</span></code> is a list, return the
homology in the range from <code class="docutils literal notranslate"><span class="pre">min(dim)</span></code> to <code class="docutils literal notranslate"><span class="pre">max(dim)</span></code>.)</li>
<li><dl class="first docutils">
<dt><code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – a subcomplex</dt>
<dd>of this cell complex.  Compute the Betti numbers of the
homology relative to this subcomplex.</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If this simplicial set is not finite, you must specify
dimensions in which to compute Betti numbers via the
argument <code class="docutils literal notranslate"><span class="pre">dim</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<p>Build the two-sphere as a three-fold join of a
two-point space with itself:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">betti</span><span class="p">()</span>
<span class="go">{0: 1, 1: 0, 2: 0, 3: 0, 4: 0, 5: 1}</span>

<span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">BC3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">betti</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">{0: 1, 1: 0, 2: 0, 3: 0}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.cartesian_product">
<code class="descname">cartesian_product</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.cartesian_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of this simplicial set with <code class="docutils literal notranslate"><span class="pre">others</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">others</span></code> – one or several simplicial sets</li>
</ul>
<p>If <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are simplicial sets, then their product <span class="math notranslate nohighlight">\(X
\times Y\)</span> is defined to be the simplicial set with
<span class="math notranslate nohighlight">\(n\)</span>-simplices <span class="math notranslate nohighlight">\(X_n \times Y_n\)</span>. See
<a class="reference internal" href="simplicial_set_constructions.html#sage.homology.simplicial_set_constructions.ProductOfSimplicialSets" title="sage.homology.simplicial_set_constructions.ProductOfSimplicialSets"><code class="xref py py-class docutils literal notranslate"><span class="pre">simplicial_set_constructions.ProductOfSimplicialSets</span></code></a>
for more information.</p>
<p>If a simplicial set is constructed as a product, the factors
are recorded and are accessible via the method
<a class="reference internal" href="simplicial_set_constructions.html#sage.homology.simplicial_set_constructions.Factors.factors" title="sage.homology.simplicial_set_constructions.Factors.factors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">simplicial_set_constructions.Factors.factors()</span></code></a>.
If each factor is finite, then you can also construct the
projection maps onto each factor, the wedge as a subcomplex,
and the fat wedge as a subcomplex.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">square</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">square</span></code> is now the standard triangulation of the square: 4
vertices, 5 edges (the four on the border and the diagonal), 2
triangles:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">square</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[4, 5, 2]</span>

<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">{0: Z, 1: Z x Z, 2: Z}</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">S1</span></code> is pointed, so is <code class="docutils literal notranslate"><span class="pre">T</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">v_0</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">(v_0, v_0)</span>

<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2xS3</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">{0: Z, 1: 0, 2: Z, 3: Z, 4: 0, 5: Z}</span>

<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">factors</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">S2</span><span class="p">,</span> <span class="n">S3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">factors</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">S3</span><span class="p">,</span> <span class="n">S2</span><span class="p">)</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">2</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;RP^oo&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">S2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span>
<span class="go">RP^oo x RP^oo x S^2</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">factor</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">RP^oo</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">factors</span><span class="p">()</span>
<span class="go">(RP^oo, RP^oo, S^2)</span>
</pre></div>
</div>
<p>Projection maps and wedges:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">projection_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^2 x S^3</span>
<span class="go">  To:   S^2</span>
<span class="go">  Defn: ...</span>
<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">wedge_as_subset</span><span class="p">()</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: 0, 2: Z, 3: Z}</span>
</pre></div>
</div>
<p>In the case of pointed simplicial sets, there is an inclusion
of each factor into the product. These are not automatically
defined in Sage, but they are easy to construct using identity
maps and constant maps and the universal property of the
product:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">one</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">const</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">constant_map</span><span class="p">(</span><span class="n">codomain</span><span class="o">=</span><span class="n">S3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">universal_property</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">const</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^2</span>
<span class="go">  To:   S^2 x S^3</span>
<span class="go">  Defn: [v_0, sigma_2] --&gt; [(v_0, v_0), (sigma_2, s_1 s_0 v_0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.cells">
<code class="descname">cells</code><span class="sig-paren">(</span><em>subcomplex=None</em>, <em>max_dim=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary of all non-degenerate simplices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> (optional) – a subsimplicial set of this
simplicial set. If <code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> is specified, then return the
simplices in the quotient by the subcomplex.</li>
<li><code class="docutils literal notranslate"><span class="pre">max_dim</span></code> – optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>. If specified,
return the non-degenerate simplices of this dimension or
smaller. This argument is required if this simplicial set is
infinite.</li>
</ul>
<p>Each key is a dimension, and the corresponding value is the
list of simplices in that dimension.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="bp">None</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">cells</span><span class="p">()</span>
<span class="go">{0: [Delta^0, Delta^0]}</span>

<span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">cells</span><span class="p">()</span>
<span class="go">{0: [v, w]}</span>

<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">cells</span><span class="p">()</span>
<span class="go">{0: [v], 1: [e]}</span>

<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">cells</span><span class="p">(</span><span class="n">S0</span><span class="o">.</span><span class="n">subsimplicial_set</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">]))</span>
<span class="go">{0: [*]}</span>

<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">cells</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">subsimplicial_set</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">]))</span>
<span class="go">{0: [*], 1: [e]}</span>
</pre></div>
</div>
<p>Test an infinite example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">BC3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">cells</span><span class="p">(</span><span class="n">max_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">{0: [1], 1: [f, f^2], 2: [f * f, f * f^2, f^2 * f, f^2 * f^2]}</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">cells</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">this simplicial set may be infinite, so specify max_dim</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.chain_complex">
<code class="descname">chain_complex</code><span class="sig-paren">(</span><em>dimensions=None</em>, <em>base_ring=Integer Ring</em>, <em>augmented=False</em>, <em>cochain=False</em>, <em>verbose=False</em>, <em>subcomplex=None</em>, <em>check=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.chain_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normalized chain complex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">dimensions</span></code> – if <code class="docutils literal notranslate"><span class="pre">None</span></code>, compute the chain complex in all
dimensions.  If a list or tuple of integers, compute the
chain complex in those dimensions, setting the chain groups
in all other dimensions to zero.</li>
<li><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>) – commutative ring</li>
<li><code class="docutils literal notranslate"><span class="pre">augmented</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>,
return the augmented chain complex (that is, include a class
in dimension <span class="math notranslate nohighlight">\(-1\)</span> corresponding to the empty cell).</li>
<li><code class="docutils literal notranslate"><span class="pre">cochain</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>,
return the cochain complex (that is, the dual of the chain
complex).</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – ignored.</li>
<li><code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – if present,
compute the chain complex relative to this subcomplex.</li>
<li><code class="docutils literal notranslate"><span class="pre">check</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, make
sure that the chain complex is actually a chain complex:
the differentials are composable and their product is zero.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If this simplicial set is not finite, you must specify
dimensions in which to compute its chain complex via the
argument <code class="docutils literal notranslate"><span class="pre">dimensions</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">()</span>
<span class="go">Chain complex with at most 3 nonzero terms over Integer Ring</span>

<span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">BC3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">Chain complex with at most 4 nonzero terms over Finite Field of size 3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.cohomology">
<code class="descname">cohomology</code><span class="sig-paren">(</span><em>dim=None</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.cohomology" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cohomology of this simplicial set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">dim</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code> – If <code class="docutils literal notranslate"><span class="pre">None</span></code>, then
return the homology in every dimension.  If <code class="docutils literal notranslate"><span class="pre">dim</span></code> is an
integer or list, return the homology in the given
dimensions.  (Actually, if <code class="docutils literal notranslate"><span class="pre">dim</span></code> is a list, return the
homology in the range from <code class="docutils literal notranslate"><span class="pre">min(dim)</span></code> to <code class="docutils literal notranslate"><span class="pre">max(dim)</span></code>.)</li>
<li><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>) – commutative
ring, must be <code class="docutils literal notranslate"><span class="pre">ZZ</span></code> or a field.</li>
</ul>
<p>Other arguments are also allowed, the same as for the
<a class="reference internal" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.homology" title="sage.homology.simplicial_set.SimplicialSet_arbitrary.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology()</span></code></a> method – see
<a class="reference internal" href="cell_complex.html#sage.homology.cell_complex.GenericCellComplex.homology" title="sage.homology.cell_complex.GenericCellComplex.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cell_complex.GenericCellComplex.homology()</span></code></a> for complete
documentation – except that <a class="reference internal" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.homology" title="sage.homology.simplicial_set.SimplicialSet_arbitrary.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology()</span></code></a> accepts a
<code class="docutils literal notranslate"><span class="pre">cohomology</span></code> key word, while this function does not:
<code class="docutils literal notranslate"><span class="pre">cohomology</span></code> is automatically true here.  Indeed, this
function just calls <a class="reference internal" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.homology" title="sage.homology.simplicial_set.SimplicialSet_arbitrary.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homology()</span></code></a> with argument
<code class="docutils literal notranslate"><span class="pre">cohomology=True</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If this simplicial set is not finite, you must specify
dimensions in which to compute homology via the argument
<code class="docutils literal notranslate"><span class="pre">dim</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Z x C2</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Z</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">cohomology</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">C2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.cone">
<code class="descname">cone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.cone" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the (reduced) cone on this simplicial set.</p>
<p>If this simplicial set <span class="math notranslate nohighlight">\(X\)</span> is not pointed, construct the
ordinary cone: add a point <span class="math notranslate nohighlight">\(v\)</span> (which will become the base
point) and for each simplex <span class="math notranslate nohighlight">\(\sigma\)</span> in <span class="math notranslate nohighlight">\(X\)</span>, add both <span class="math notranslate nohighlight">\(\sigma\)</span>
and a simplex made up of <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> (topologically, form
the join of <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span>).</p>
<p>If this simplicial set is pointed, then construct the reduced
cone: take the quotient of the unreduced cone by the 1-simplex
connecting the old base point to the new one.</p>
<p>In either case, as long as the simplicial set is finite, it
comes equipped in Sage with a map from it into the cone.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">CX</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">cone</span><span class="p">()</span>  <span class="c1"># unreduced cone, since X not pointed</span>
<span class="gp">sage: </span><span class="n">CX</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[*, v, (v,*), e, (e,*)]</span>
<span class="gp">sage: </span><span class="n">CX</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">*</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(X\)</span> as a subset of the cone, and also the map from <span class="math notranslate nohighlight">\(X\)</span>, in the
unreduced case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">CX</span><span class="o">.</span><span class="n">base_as_subset</span><span class="p">()</span>
<span class="go">Simplicial set with 2 non-degenerate simplices</span>
<span class="gp">sage: </span><span class="n">CX</span><span class="o">.</span><span class="n">map_from_base</span><span class="p">()</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">From: Simplicial set with 2 non-degenerate simplices</span>
<span class="go">  To:   Cone of Simplicial set with 2 non-degenerate simplices</span>
<span class="go">  Defn: [v, e] --&gt; [v, e]</span>
</pre></div>
</div>
<p>In the reduced case, only the map from <span class="math notranslate nohighlight">\(X\)</span> is available:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">set_base_point</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">CX</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">cone</span><span class="p">()</span>  <span class="c1"># reduced cone</span>
<span class="gp">sage: </span><span class="n">CX</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[*, e, (e,*)]</span>
<span class="gp">sage: </span><span class="n">CX</span><span class="o">.</span><span class="n">map_from_base</span><span class="p">()</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: Simplicial set with 2 non-degenerate simplices</span>
<span class="go">  To:   Reduced cone of Simplicial set with 2 non-degenerate simplices</span>
<span class="go">  Defn: [v, e] --&gt; [*, e]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.constant_map">
<code class="descname">constant_map</code><span class="sig-paren">(</span><em>codomain=None</em>, <em>point=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.constant_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a constant map with this simplicial set as its domain.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">codomain</span></code> – optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
codomain is the standard one-point space constructed by
<code class="xref py py-func docutils literal notranslate"><span class="pre">Point()</span></code>. Otherwise, either the codomain must be a
pointed simplicial set, in which case the map is constant at
the base point, or <code class="docutils literal notranslate"><span class="pre">point</span></code> must be specified.</li>
<li><code class="docutils literal notranslate"><span class="pre">point</span></code> – optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>. If specified, it
must be a 0-simplex in the codomain, and it will be the
target of the constant map.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S4</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S4</span><span class="o">.</span><span class="n">constant_map</span><span class="p">()</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^4</span>
<span class="go">  To:   Point</span>
<span class="go">  Defn: Constant map at *</span>
<span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S4</span><span class="o">.</span><span class="n">constant_map</span><span class="p">(</span><span class="n">codomain</span><span class="o">=</span><span class="n">S0</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^4</span>
<span class="go">  To:   S^0</span>
<span class="go">  Defn: Constant map at v_0</span>

<span class="gp">sage: </span><span class="n">Sigma3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">permutation</span><span class="o">.</span><span class="n">Symmetric</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Sigma3</span><span class="o">.</span><span class="n">nerve</span><span class="p">()</span><span class="o">.</span><span class="n">constant_map</span><span class="p">()</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: Nerve of Symmetric group of order 3! as a permutation group</span>
<span class="go">  To:   Point</span>
<span class="go">  Defn: Constant map at *</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.coproduct">
<code class="descname">coproduct</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.coproduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coproduct of this simplicial set with <code class="docutils literal notranslate"><span class="pre">others</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">others</span></code> – one or several simplicial sets</li>
</ul>
<p>If these simplicial sets are pointed, return their wedge sum;
if they are not, return their disjoint union. If some are
pointed and some are not, raise an error: it is not clear in
which category to work.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">unset_base_point</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">unset_base_point</span><span class="p">()</span>

<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">coproduct</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">coproduct</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="go">Wedge: (S^2 v Klein bottle)</span>
<span class="gp">sage: </span><span class="n">D3</span><span class="o">.</span><span class="n">coproduct</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">D3</span><span class="o">.</span><span class="n">coproduct</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
<span class="go">Disjoint union: (3-simplex u Simplicial set with 2 non-degenerate simplices u Simplicial set with 6 non-degenerate simplices)</span>
</pre></div>
</div>
<p>The coproduct comes equipped with an inclusion map from each
summand, as long as the summands are all finite:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">coproduct</span><span class="p">(</span><span class="n">K</span><span class="p">)</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^2</span>
<span class="go">  To:   Wedge: (S^2 v Klein bottle)</span>
<span class="go">  Defn: [v_0, sigma_2] --&gt; [*, sigma_2]</span>
<span class="gp">sage: </span><span class="n">D3</span><span class="o">.</span><span class="n">coproduct</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: Simplicial set with 6 non-degenerate simplices</span>
<span class="go">  To:   Disjoint union: (3-simplex u Simplicial set with 2 non-degenerate simplices u Simplicial set with 6 non-degenerate simplices)</span>
<span class="go">  Defn: [Delta_{0,0}, Delta_{1,0}, Delta_{1,1}, Delta_{1,2}, Delta_{2,0}, Delta_{2,1}] --&gt; [Delta_{0,0}, Delta_{1,0}, Delta_{1,1}, Delta_{1,2}, Delta_{2,0}, Delta_{2,1}]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.disjoint_union">
<code class="descname">disjoint_union</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.disjoint_union" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the disjoint union of this simplicial set with <code class="docutils literal notranslate"><span class="pre">others</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">others</span></code> – one or several simplicial sets</li>
</ul>
<p>As long as the factors are all finite, the inclusion map from
each factor is available. Any factors which are empty are
ignored completely: they do not appear in the list of factors,
etc.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> have simplices in common, Sage uses a
copy of <code class="docutils literal notranslate"><span class="pre">Y</span></code> when constructing the disjoint union. Note the
name conflict in the list of simplices: <code class="docutils literal notranslate"><span class="pre">v</span></code> appears twice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[v, v, w, e, f]</span>
</pre></div>
</div>
<p>Factors and inclusion maps:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">A</span><span class="o">.</span><span class="n">factors</span><span class="p">()</span>
<span class="go">(Torus, S^2)</span>
<span class="gp">sage: </span><span class="n">i</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">i</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
<span class="go">Torus</span>
<span class="gp">sage: </span><span class="n">i</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span>
<span class="go">Disjoint union: (Torus u S^2)</span>
</pre></div>
</div>
<p>Empty factors are ignored:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set_examples</span> <span class="kn">import</span> <span class="n">Empty</span>
<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">S2</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">S2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">==</span> <span class="n">S2</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">S2</span><span class="p">,</span> <span class="n">S2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">factors</span><span class="p">()</span>
<span class="go">(S^2, S^2, S^2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.face">
<code class="descname">face</code><span class="sig-paren">(</span><em>simplex</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.face" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(i\)</span>-th face of <code class="docutils literal notranslate"><span class="pre">simplex</span></code> in this simplicial set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">simplex</span></code> – a simplex in this simplicial set</li>
<li><code class="docutils literal notranslate"><span class="pre">i</span></code> – integer</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">v_0</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">face</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">s_0 v_0</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">face</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">v_0</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">face</span><span class="p">(</span><span class="n">S2</span><span class="o">.</span><span class="n">face</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">v_0</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.faces">
<code class="descname">faces</code><span class="sig-paren">(</span><em>simplex</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of faces of <code class="docutils literal notranslate"><span class="pre">simplex</span></code> in this simplicial set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">simplex</span></code> – a simplex in this simplicial set, either
degenerate or not</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
<span class="go">(s_0 v_0, s_0 v_0, s_0 v_0)</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">sigma</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">[sigma_2, sigma_2, s_1 s_0 v_0, s_1 s_0 v_0]</span>

<span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">BC3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f2</span> <span class="o">=</span> <span class="n">BC3</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span> <span class="n">f2</span>
<span class="go">f^2</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">faces</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span>
<span class="go">(1, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.graph">
<code class="descname">graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the 1-skeleton of this simplicial set, as a graph.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Delta3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">Delta3</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
<span class="go">[((0,), (1,), (0, 1)),</span>
<span class="go"> ((0,), (2,), (0, 2)),</span>
<span class="go"> ((0,), (3,), (0, 3)),</span>
<span class="go"> ((1,), (2,), (1, 2)),</span>
<span class="go"> ((1,), (3,), (1, 3)),</span>
<span class="go"> ((2,), (3,), (2, 3))]</span>

<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="go">Looped multi-graph on 1 vertex</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
<span class="go">3</span>

<span class="gp">sage: </span><span class="n">CP3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ComplexProjectiveSpace</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">G</span> <span class="o">=</span> <span class="n">CP3</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">vertices</span><span class="p">())</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
<span class="go">0</span>

<span class="gp">sage: </span><span class="n">Sigma3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">permutation</span><span class="o">.</span><span class="n">Symmetric</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Sigma3</span><span class="o">.</span><span class="n">nerve</span><span class="p">()</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.homology">
<code class="descname">homology</code><span class="sig-paren">(</span><em>dim=None</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.homology" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the (reduced) homology of this simplicial set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">dim</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code> – If <code class="docutils literal notranslate"><span class="pre">None</span></code>, then
return the homology in every dimension.  If <code class="docutils literal notranslate"><span class="pre">dim</span></code> is an
integer or list, return the homology in the given
dimensions.  (Actually, if <code class="docutils literal notranslate"><span class="pre">dim</span></code> is a list, return the
homology in the range from <code class="docutils literal notranslate"><span class="pre">min(dim)</span></code> to <code class="docutils literal notranslate"><span class="pre">max(dim)</span></code>.)</li>
<li><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>) – commutative
ring, must be <code class="docutils literal notranslate"><span class="pre">ZZ</span></code> or a field.</li>
</ul>
<p>Other arguments are also allowed: see the documentation for
<a class="reference internal" href="cell_complex.html#sage.homology.cell_complex.GenericCellComplex.homology" title="sage.homology.cell_complex.GenericCellComplex.homology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cell_complex.GenericCellComplex.homology()</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If this simplicial set is not finite, you must specify
dimensions in which to compute homology via the argument
<code class="docutils literal notranslate"><span class="pre">dim</span></code>.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: Z}</span>

<span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">BC3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">{0: Vector space of dimension 0 over Finite Field of size 3,</span>
<span class="go"> 1: Vector space of dimension 1 over Finite Field of size 3,</span>
<span class="go"> 2: Vector space of dimension 1 over Finite Field of size 3,</span>
<span class="go"> 3: Vector space of dimension 1 over Finite Field of size 3}</span>

<span class="gp">sage: </span><span class="n">BC2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">2</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">BK</span> <span class="o">=</span> <span class="n">BC2</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">BC2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BK</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">{0: 0, 1: C2 x C2, 2: C2, 3: C2 x C2 x C2}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.identity">
<code class="descname">identity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the identity map on this simplicial set.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S3</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>
<span class="go">Simplicial set endomorphism of S^3</span>
<span class="go">  Defn: Identity map</span>

<span class="gp">sage: </span><span class="n">BC3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">one</span> <span class="o">=</span> <span class="n">BC3</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>
<span class="gp">sage: </span><span class="p">[(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">one</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span> <span class="k">for</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">BC3</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[(f * f, f * f),</span>
<span class="go"> (f * f^2, f * f^2),</span>
<span class="go"> (f^2 * f, f^2 * f),</span>
<span class="go"> (f^2 * f^2, f^2 * f^2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.is_connected">
<code class="descname">is_connected</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.is_connected" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if this simplicial set is connected.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">disjoint_union</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_connected</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.is_reduced">
<code class="descname">is_reduced</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.is_reduced" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if this simplicial set has only one vertex.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">is_reduced</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">is_reduced</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.join" title="Permalink to this definition">¶</a></dt>
<dd><p>The join of this simplicial set with <code class="docutils literal notranslate"><span class="pre">others</span></code>.</p>
<p>Not implemented. See
<a class="reference external" href="https://ncatlab.org/nlab/show/join+of+simplicial+sets">https://ncatlab.org/nlab/show/join+of+simplicial+sets</a> for a
few descriptions, for anyone interested in implementing
this. See also P. J. Ehlers and Tim Porter, Joins for
(Augmented) Simplicial Sets, Jour. Pure Applied Algebra, 145
(2000) 37-44 <a class="reference external" href="https://arxiv.org/abs/9904039">Arxiv 9904039</a>.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">others</span></code> – one or several simplicial sets</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">joins are not implemented for simplicial sets</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.n_cells">
<code class="descname">n_cells</code><span class="sig-paren">(</span><em>n</em>, <em>subcomplex=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.n_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of cells of dimension <code class="docutils literal notranslate"><span class="pre">n</span></code> of this cell complex.
If the optional argument <code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> is present, then
return the <code class="docutils literal notranslate"><span class="pre">n</span></code>-dimensional faces in the quotient by this
subcomplex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code> – the dimension</li>
<li><code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – a subcomplex
of this cell complex. Return the cells which are in the
quotient by this subcomplex.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[sigma_3]</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">sage: </span><span class="n">C2</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">BC2</span> <span class="o">=</span> <span class="n">C2</span><span class="o">.</span><span class="n">nerve</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">BC2</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[f * f * f]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.n_chains">
<code class="descname">n_chains</code><span class="sig-paren">(</span><em>n</em>, <em>base_ring=Integer Ring</em>, <em>cochains=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.n_chains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the free module of (normalized) chains in degree <code class="docutils literal notranslate"><span class="pre">n</span></code>
over <code class="docutils literal notranslate"><span class="pre">base_ring</span></code>.</p>
<p>This is the free module on the nondegenerate simplices in the
given dimension.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code> – integer</li>
<li><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> – ring (optional, default <span class="math notranslate nohighlight">\(\ZZ\)</span>)</li>
<li><code class="docutils literal notranslate"><span class="pre">cochains</span></code> – boolean (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>); if
<code class="docutils literal notranslate"><span class="pre">True</span></code>, return cochains instead</li>
</ul>
<p>The only difference between chains and cochains is notation:
the generator corresponding to the dual of a simplex
<code class="docutils literal notranslate"><span class="pre">sigma</span></code> is written as <code class="docutils literal notranslate"><span class="pre">&quot;\chi_sigma&quot;</span></code> in the group of
cochains.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">S3</span><span class="o">.</span><span class="n">n_chains</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">cochains</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">basis</span><span class="p">())</span>
<span class="go">[\chi_sigma_3]</span>
<span class="gp">sage: </span><span class="n">Sigma3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">permutation</span><span class="o">.</span><span class="n">Symmetric</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BSigma3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">Sigma3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">BSigma3</span><span class="o">.</span><span class="n">n_chains</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">basis</span><span class="p">())</span>
<span class="go">[(1,2), (1,2,3), (1,3), (1,3,2), (2,3)]</span>
<span class="gp">sage: </span><span class="nb">list</span><span class="p">(</span><span class="n">BSigma3</span><span class="o">.</span><span class="n">n_chains</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cochains</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">basis</span><span class="p">())</span>
<span class="go">[\chi_(1,2), \chi_(1,2,3), \chi_(1,3), \chi_(1,3,2), \chi_(2,3)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.nondegenerate_simplices">
<code class="descname">nondegenerate_simplices</code><span class="sig-paren">(</span><em>max_dim=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.nondegenerate_simplices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sorted list of non-degenerate simplices in this simplicial set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">max_dim</span></code> – optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>. If specified,
return the non-degenerate simplices of this dimension or
smaller. This argument is required if this simplicial set is
infinite.</li>
</ul>
<p>The sorting is in increasing order of dimension, and within
each dimension, by the name (if present) of each simplex.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The sorting is done when the simplicial set is
constructed, so changing the name of a simplex after
construction will not affect the ordering.</p>
</div>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="bp">None</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[Delta^0, Delta^0]</span>
</pre></div>
</div>
<p>Name the vertices and reconstruct the simplicial set: they
should be ordered alphabetically:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="bp">None</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[v, w]</span>
</pre></div>
</div>
<p>Rename but do not reconstruct the set; the ordering does not
take the new names into account:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">v</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span> <span class="c1"># old ordering is used</span>
<span class="go">[z, w]</span>

<span class="gp">sage: </span><span class="n">X0</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="bp">None</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">X0</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span> <span class="c1"># new ordering is used</span>
<span class="go">[w, z]</span>
</pre></div>
</div>
<p>Test an infinite example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">C3</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">BC3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[1, f, f^2, f * f, f * f^2, f^2 * f, f^2 * f^2]</span>
<span class="gp">sage: </span><span class="n">BC3</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>: <span class="n">this simplicial set may be infinite, so specify max_dim</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.product">
<code class="descname">product</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of this simplicial set with <code class="docutils literal notranslate"><span class="pre">others</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">others</span></code> – one or several simplicial sets</li>
</ul>
<p>If <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are simplicial sets, then their product <span class="math notranslate nohighlight">\(X
\times Y\)</span> is defined to be the simplicial set with
<span class="math notranslate nohighlight">\(n\)</span>-simplices <span class="math notranslate nohighlight">\(X_n \times Y_n\)</span>. See
<a class="reference internal" href="simplicial_set_constructions.html#sage.homology.simplicial_set_constructions.ProductOfSimplicialSets" title="sage.homology.simplicial_set_constructions.ProductOfSimplicialSets"><code class="xref py py-class docutils literal notranslate"><span class="pre">simplicial_set_constructions.ProductOfSimplicialSets</span></code></a>
for more information.</p>
<p>If a simplicial set is constructed as a product, the factors
are recorded and are accessible via the method
<a class="reference internal" href="simplicial_set_constructions.html#sage.homology.simplicial_set_constructions.Factors.factors" title="sage.homology.simplicial_set_constructions.Factors.factors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">simplicial_set_constructions.Factors.factors()</span></code></a>.
If each factor is finite, then you can also construct the
projection maps onto each factor, the wedge as a subcomplex,
and the fat wedge as a subcomplex.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">square</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">square</span></code> is now the standard triangulation of the square: 4
vertices, 5 edges (the four on the border and the diagonal), 2
triangles:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">square</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[4, 5, 2]</span>

<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">{0: Z, 1: Z x Z, 2: Z}</span>
</pre></div>
</div>
<p>Since <code class="docutils literal notranslate"><span class="pre">S1</span></code> is pointed, so is <code class="docutils literal notranslate"><span class="pre">T</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">v_0</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">T</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">(v_0, v_0)</span>

<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2xS3</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">{0: Z, 1: 0, 2: Z, 3: Z, 4: 0, 5: Z}</span>

<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">factors</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">S2</span><span class="p">,</span> <span class="n">S3</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">factors</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">S3</span><span class="p">,</span> <span class="n">S2</span><span class="p">)</span>
<span class="go">False</span>

<span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">2</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">B</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;RP^oo&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">S2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span>
<span class="go">RP^oo x RP^oo x S^2</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">factor</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">RP^oo</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">factors</span><span class="p">()</span>
<span class="go">(RP^oo, RP^oo, S^2)</span>
</pre></div>
</div>
<p>Projection maps and wedges:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">projection_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^2 x S^3</span>
<span class="go">  To:   S^2</span>
<span class="go">  Defn: ...</span>
<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">wedge_as_subset</span><span class="p">()</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: 0, 2: Z, 3: Z}</span>
</pre></div>
</div>
<p>In the case of pointed simplicial sets, there is an inclusion
of each factor into the product. These are not automatically
defined in Sage, but they are easy to construct using identity
maps and constant maps and the universal property of the
product:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">one</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">const</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">constant_map</span><span class="p">(</span><span class="n">codomain</span><span class="o">=</span><span class="n">S3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2xS3</span><span class="o">.</span><span class="n">universal_property</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">const</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^2</span>
<span class="go">  To:   S^2 x S^3</span>
<span class="go">  Defn: [v_0, sigma_2] --&gt; [(v_0, v_0), (sigma_2, s_1 s_0 v_0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.pullback">
<code class="descname">pullback</code><span class="sig-paren">(</span><em>*maps</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.pullback" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pullback obtained from given <code class="docutils literal notranslate"><span class="pre">maps</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">maps</span></code> – several maps of simplicial sets, each of which
has this simplicial set as its codomain</li>
</ul>
<p>If only a single map <span class="math notranslate nohighlight">\(f: X \to Y\)</span> is given, then return
<span class="math notranslate nohighlight">\(X\)</span>. If more than one map is given, say <span class="math notranslate nohighlight">\(f_i: X_i \to Y\)</span> for
<span class="math notranslate nohighlight">\(0 \leq i \leq m\)</span>, then return the pullback defined by those
maps. If no maps are given, return the one-point simplicial
set.</p>
<p>In addition to the defining maps <span class="math notranslate nohighlight">\(f_i\)</span> used to construct the
pullback <span class="math notranslate nohighlight">\(P\)</span>, there are also maps <span class="math notranslate nohighlight">\(\bar{f}_i: P \to X_i\)</span>,
which we refer to as <em>structure maps</em> or <em>projection
maps</em>. The pullback also has a universal property: given maps
<span class="math notranslate nohighlight">\(g_i: Z \to X_i\)</span> such that <span class="math notranslate nohighlight">\(f_i g_i = f_j g_j\)</span> for all <span class="math notranslate nohighlight">\(i\)</span>,
<span class="math notranslate nohighlight">\(j\)</span>, then there is a unique map <span class="math notranslate nohighlight">\(g: Z \to P\)</span> making the
appropriate diagram commute: that is, <span class="math notranslate nohighlight">\(\bar{f}_i g = g_i\)</span> for
all <span class="math notranslate nohighlight">\(i\)</span>. For example, given maps <span class="math notranslate nohighlight">\(f: X \to Y\)</span> and <span class="math notranslate nohighlight">\(g: X \to
Z\)</span>, there is an induced map <span class="math notranslate nohighlight">\(g: X \to Y \times Z\)</span>.</p>
<p>In Sage, a pullback is equipped with its defining maps, and as
long as the simplicial sets involved are finite, you can also
access the structure maps and the universal property.</p>
<p>EXAMPLES:</p>
<p>Construct a product as a pullback:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">pt</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Point</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">pullback</span><span class="p">(</span><span class="n">S2</span><span class="o">.</span><span class="n">constant_map</span><span class="p">(),</span> <span class="n">S2</span><span class="o">.</span><span class="n">constant_map</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Z x Z</span>
</pre></div>
</div>
<p>If the pullback is defined via maps <span class="math notranslate nohighlight">\(f_i: X_i \to Y\)</span>, then
there are structure maps <span class="math notranslate nohighlight">\(\bar{f}_i: Y_i \to P\)</span>. The structure
maps are only available in Sage when all of the maps involved
have finite domains.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">one</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">Hom</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">pullback</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">one</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: 0, 2: Z}</span>

<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">defining_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">one</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">structure_map</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: Pullback of maps:</span>
<span class="go">  Simplicial set endomorphism of S^2</span>
<span class="go">    Defn: Identity map</span>
<span class="go">  Simplicial set endomorphism of S^2</span>
<span class="go">    Defn: Identity map</span>
<span class="go">  To:   S^2</span>
<span class="go">  Defn: [(v_0, v_0), (sigma_2, sigma_2)] --&gt; [v_0, sigma_2]</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">structure_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">P</span><span class="o">.</span><span class="n">structure_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="o">==</span> <span class="n">S2</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The universal property:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">factor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">as_subset</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">Hom</span><span class="p">(</span><span class="n">T</span><span class="p">)({</span><span class="n">S1</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span><span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S1</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span><span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]})</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">cone</span><span class="p">()</span>      <span class="c1"># the cone C(S^1)</span>
<span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">map_from_base</span><span class="p">()</span> <span class="c1"># map from S^1 to C(S^1)</span>
<span class="gp">sage: </span><span class="n">P</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">universal_property</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="o">==</span> <span class="n">S1</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">h</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="o">==</span> <span class="n">P</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.pushout">
<code class="descname">pushout</code><span class="sig-paren">(</span><em>*maps</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.pushout" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pushout obtained from given <code class="docutils literal notranslate"><span class="pre">maps</span></code>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">maps</span></code> – several maps of simplicial sets, each of which
has this simplicial set as its domain</li>
</ul>
<p>If only a single map <span class="math notranslate nohighlight">\(f: X \to Y\)</span> is given, then return
<span class="math notranslate nohighlight">\(Y\)</span>. If more than one map is given, say <span class="math notranslate nohighlight">\(f_i: X \to Y_i\)</span> for
<span class="math notranslate nohighlight">\(0 \leq i \leq m\)</span>, then return the pushout defined by those
maps. If no maps are given, return the empty simplicial set.</p>
<p>In addition to the defining maps <span class="math notranslate nohighlight">\(f_i\)</span> used to construct the
pushout <span class="math notranslate nohighlight">\(P\)</span>, there are also maps <span class="math notranslate nohighlight">\(\bar{f}_i: Y_i \to P\)</span>, which
we refer to as <em>structure maps</em>. The pushout also has a
universal property: given maps <span class="math notranslate nohighlight">\(g_i: Y_i \to Z\)</span> such that <span class="math notranslate nohighlight">\(g_i
f_i = g_j f_j\)</span> for all <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(j\)</span>, then there is a unique map
<span class="math notranslate nohighlight">\(g: P \to Z\)</span> making the appropriate diagram commute: that is,
<span class="math notranslate nohighlight">\(g \bar{f}_i = g_i\)</span> for all <span class="math notranslate nohighlight">\(i\)</span>.</p>
<p>In Sage, a pushout is equipped with its defining maps, and as
long as the simplicial sets involved are finite, you can also
access the structure maps and the universal property.</p>
<p>EXAMPLES:</p>
<p>Construct the 4-sphere as a quotient of a 4-simplex:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S4</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">pushout</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">constant_map</span><span class="p">(),</span> <span class="n">L</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">S4</span>
<span class="go">Pushout of maps:</span>
<span class="go">  Simplicial set morphism:</span>
<span class="go">    From: Simplicial set with 30 non-degenerate simplices</span>
<span class="go">    To:   Point</span>
<span class="go">    Defn: Constant map at *</span>
<span class="go">  Simplicial set morphism:</span>
<span class="go">    From: Simplicial set with 30 non-degenerate simplices</span>
<span class="go">    To:   4-simplex</span>
<span class="go">    Defn: [(0,), (1,), (2,), (3,), (4,), (0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4), (0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4), (0, 3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4), (0, 1, 2, 3), (0, 1, 2, 4), (0, 1, 3, 4), (0, 2, 3, 4), (1, 2, 3, 4)] --&gt; [(0,), (1,), (2,), (3,), (4,), (0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4), (0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4), (0, 3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4), (0, 1, 2, 3), (0, 1, 2, 4), (0, 1, 3, 4), (0, 2, 3, 4), (1, 2, 3, 4)]</span>
<span class="gp">sage: </span><span class="nb">len</span><span class="p">(</span><span class="n">S4</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">())</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">S4</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Z</span>
</pre></div>
</div>
<p>The associated maps:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">factor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">as_subset</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="c1"># wedge, constructed as a pushout</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">defining_map</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: Point</span>
<span class="go">  To:   S^1 x S^1</span>
<span class="go">  Defn: Constant map at (v_0, v_0)</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">structure_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^1</span>
<span class="go">  To:   Wedge: (S^1 v S^1 x S^1)</span>
<span class="go">  Defn: [v_0, sigma_1] --&gt; [*, sigma_1]</span>

<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">Hom</span><span class="p">(</span><span class="n">T</span><span class="p">)({</span><span class="n">S1</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span><span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S1</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span><span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]})</span>
</pre></div>
</div>
<p>The maps <span class="math notranslate nohighlight">\(f: S^1 \to T\)</span> and <span class="math notranslate nohighlight">\(1: T \to T\)</span> induce a map <span class="math notranslate nohighlight">\(S^1 \vee T \to T\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">g</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">universal_property</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Hom</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">identity</span><span class="p">())</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span> <span class="o">==</span> <span class="n">W</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">g</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span> <span class="o">==</span> <span class="n">T</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.quotient">
<code class="descname">quotient</code><span class="sig-paren">(</span><em>subcomplex</em>, <em>vertex_name='*'</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.quotient" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the quotient of this simplicial set by <code class="docutils literal notranslate"><span class="pre">subcomplex</span></code>.</p>
<p>That is, <code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> is replaced by a vertex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> – subsimplicial set of this simplicial set,
or a list, tuple, or set of simplices defining a
subsimplicial set.</li>
<li><code class="docutils literal notranslate"><span class="pre">vertex_name</span></code> (optional) – string, name to be given to the new
vertex. By default, use <code class="docutils literal notranslate"><span class="pre">'*'</span></code>.</li>
</ul>
<p>In Sage, from a quotient simplicial set, you can recover the
ambient space, the subcomplex, and (if the ambient space is
finite) the quotient map.</p>
<p>Base points: if the original simplicial set has a base point
not contained in <code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> and if the original simplicial
set is finite, then use its image as the base point for the
quotient. In all other cases, <code class="docutils literal notranslate"><span class="pre">*</span></code> is the base point.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">quotient</span><span class="p">([</span><span class="n">f</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[*, e]</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Z</span>

<span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">quotient</span><span class="p">([</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[*, e]</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Z</span>

<span class="gp">sage: </span><span class="n">F</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">quotient</span><span class="p">([</span><span class="n">v</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[*, w, e]</span>
<span class="gp">sage: </span><span class="n">F</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">*</span>

<span class="gp">sage: </span><span class="n">RP5</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RP2</span> <span class="o">=</span> <span class="n">RP5</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RP5_2</span> <span class="o">=</span> <span class="n">RP5</span><span class="o">.</span><span class="n">quotient</span><span class="p">(</span><span class="n">RP2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RP5_2</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">base_ring</span><span class="o">=</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">{0: Vector space of dimension 0 over Finite Field of size 2,</span>
<span class="go"> 1: Vector space of dimension 0 over Finite Field of size 2,</span>
<span class="go"> 2: Vector space of dimension 0 over Finite Field of size 2,</span>
<span class="go"> 3: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 4: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 5: Vector space of dimension 1 over Finite Field of size 2}</span>

<span class="gp">sage: </span><span class="n">RP5_2</span><span class="o">.</span><span class="n">ambient</span><span class="p">()</span>
<span class="go">RP^5</span>
<span class="gp">sage: </span><span class="n">RP5_2</span><span class="o">.</span><span class="n">subcomplex</span><span class="p">()</span>
<span class="go">Simplicial set with 3 non-degenerate simplices</span>
<span class="gp">sage: </span><span class="n">RP5_2</span><span class="o">.</span><span class="n">quotient_map</span><span class="p">()</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: RP^5</span>
<span class="go">  To:   Quotient: (RP^5/Simplicial set with 3 non-degenerate simplices)</span>
<span class="go">  Defn: [1, f, f * f, f * f * f, f * f * f * f, f * f * f * f * f] --&gt; [*, s_0 *, s_1 s_0 *, f * f * f, f * f * f * f, f * f * f * f * f]</span>
</pre></div>
</div>
<p>Behavior of base points:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_pointed</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">subsimplicial_set</span><span class="p">([</span><span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[(2,), (3,), (2, 3)]</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">quotient</span><span class="p">([</span><span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">*</span>

<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">set_base_point</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">(0,)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">subsimplicial_set</span><span class="p">([</span><span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">sage: </span><span class="n">L</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[(2,), (3,), (2, 3)]</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">quotient</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="o">.</span><span class="n">base_point</span><span class="p">()</span>
<span class="go">(0,)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.reduce">
<code class="descname">reduce</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce this simplicial set.</p>
<p>That is, take the quotient by a spanning tree of the
1-skeleton, so that the resulting simplicial set has only one
vertex. This only makes sense if the simplicial set is
connected, so raise an error if not. If already reduced,
return itself.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">is_reduced</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">is_reduced</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">X</span></code> is reduced, so calling <code class="docutils literal notranslate"><span class="pre">reduce</span></code> on it again
returns <code class="docutils literal notranslate"><span class="pre">X</span></code> itself:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="ow">is</span> <span class="n">X</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="ow">is</span> <span class="n">K</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Raise an error for disconnected simplicial sets:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">reduce</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">this simplicial set is not connected</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.rename_latex">
<code class="descname">rename_latex</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.rename_latex" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename or set the LaTeX name for this simplicial set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">s</span></code> – string, the LaTeX representation. Or <code class="docutils literal notranslate"><span class="pre">s</span></code> can be
<code class="docutils literal notranslate"><span class="pre">None</span></code>, in which case the LaTeX name is unset.</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="bp">None</span><span class="p">},</span> <span class="n">latex_name</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">*</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">rename_latex</span><span class="p">(</span><span class="s1">&#39;x_0&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">latex</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">x_0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.subsimplicial_set">
<code class="descname">subsimplicial_set</code><span class="sig-paren">(</span><em>simplices</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.subsimplicial_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sub-simplicial set of this simplicial set
determined by <code class="docutils literal notranslate"><span class="pre">simplices</span></code>, a set of nondegenerate simplices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">simplices</span></code> – set, list, or tuple of nondegenerate
simplices in this simplicial set, or a simplicial
complex – see below.</li>
</ul>
<p>Each sub-simplicial set comes equipped with an inclusion map
to its ambient space, and you can easily recover its ambient
space.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">simplices</span></code> is a simplicial complex, then the original
simplicial set should itself have been converted from a
simplicial complex, and <code class="docutils literal notranslate"><span class="pre">simplices</span></code> should be a subcomplex
of that.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>

<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">subsimplicial_set</span><span class="p">([</span><span class="n">e</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">Y</span>
<span class="go">Simplicial set with 3 non-degenerate simplices</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[v, w, e]</span>

<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">tau</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">tau</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>
<span class="go">3</span>
<span class="gp">sage: </span><span class="n">K</span><span class="o">.</span><span class="n">subsimplicial_set</span><span class="p">([</span><span class="n">tau</span><span class="p">])</span>
<span class="go">Simplicial set with 15 non-degenerate simplices</span>
</pre></div>
</div>
<p>A subsimplicial set knows about its ambient space and the
inclusion map into it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RP4</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">RP4</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span>
<span class="go">Simplicial set with 3 non-degenerate simplices</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">ambient_space</span><span class="p">()</span>
<span class="go">RP^4</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">()</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: Simplicial set with 3 non-degenerate simplices</span>
<span class="go">  To:   RP^4</span>
<span class="go">  Defn: [1, f, f * f] --&gt; [1, f, f * f]</span>
</pre></div>
</div>
<p>An infinite ambient simplicial set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">B</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">ClassifyingSpace</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">MultiplicativeAbelian</span><span class="p">([</span><span class="mi">2</span><span class="p">]))</span>
<span class="gp">sage: </span><span class="n">BxB</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">BxB</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">5</span><span class="p">:]</span>
<span class="go">[(s_0 f, s_1 f), (s_1 f, f * f), (s_1 f, s_0 f), (s_1 s_0 1, f * f)]</span>
<span class="gp">sage: </span><span class="n">BxB</span><span class="o">.</span><span class="n">subsimplicial_set</span><span class="p">(</span><span class="n">BxB</span><span class="o">.</span><span class="n">n_cells</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">5</span><span class="p">:])</span>
<span class="go">Simplicial set with 8 non-degenerate simplices</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.suspension">
<code class="descname">suspension</code><span class="sig-paren">(</span><em>n=1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.suspension" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the (reduced) <span class="math notranslate nohighlight">\(n\)</span>-th suspension of this simplicial set.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code> (optional, default 1) – integer, suspend this many
times.</li>
</ul>
<p>If this simplicial set <span class="math notranslate nohighlight">\(X\)</span> is not pointed, return the
suspension: the quotient <span class="math notranslate nohighlight">\(CX/X\)</span>, where <span class="math notranslate nohighlight">\(CX\)</span> is the (ordinary,
unreduced) cone on <span class="math notranslate nohighlight">\(X\)</span>. If <span class="math notranslate nohighlight">\(X\)</span> is pointed, then use the
reduced cone instead, and so return the reduced suspension.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RP4</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SigmaRP4</span> <span class="o">=</span> <span class="n">RP4</span><span class="o">.</span><span class="n">suspension</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">S1_smash_RP4</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">smash_product</span><span class="p">(</span><span class="n">RP4</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">SigmaRP4</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span> <span class="o">==</span> <span class="n">S1_smash_RP4</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The version of the suspension obtained by the smash product is
typically less efficient than the reduced suspension produced
here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">SigmaRP4</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 0, 1, 1, 1, 1]</span>
<span class="gp">sage: </span><span class="n">S1_smash_RP4</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 1, 4, 6, 8, 5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_arbitrary.wedge">
<code class="descname">wedge</code><span class="sig-paren">(</span><em>*others</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary.wedge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the wedge sum of this pointed simplicial set with <code class="docutils literal notranslate"><span class="pre">others</span></code>.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">others</span></code> – one or several simplicial sets</li>
</ul>
<p>This constructs the quotient of the disjoint union in which
the base points of all of the simplicial sets have been
identified. This is the coproduct in the category of pointed
simplicial sets.</p>
<p>This raises an error if any of the factors is not pointed.</p>
<p>From the wedge, you can access the factors, and if the
simplicial sets involved are all finite, you can also access
the inclusion map of each factor into the wedge, as well as
the projection map onto each factor.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)},</span> <span class="n">base_point</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="p">)},</span> <span class="n">base_point</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[*, e, f]</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: Z x Z}</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">(</span><span class="n">reduced</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">{0: Z, 1: Z, 2: Z}</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[*, e, e]</span>

<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">W</span> <span class="o">=</span> <span class="n">S2</span><span class="o">.</span><span class="n">wedge</span><span class="p">(</span><span class="n">S3</span><span class="p">,</span> <span class="n">S2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: S^2</span>
<span class="go">  To:   Wedge: (S^2 v S^3 v S^2)</span>
<span class="go">  Defn: [v_0, sigma_2] --&gt; [*, sigma_2]</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">projection_map</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Simplicial set morphism:</span>
<span class="go">  From: Wedge: (S^2 v S^3 v S^2)</span>
<span class="go">  To:   Quotient: (Wedge: (S^2 v S^3 v S^2)/Simplicial set with 3 non-degenerate simplices)</span>
<span class="go">  Defn: [*, sigma_2, sigma_2, sigma_3] --&gt; [*, s_1 s_0 *, s_1 s_0 *, sigma_3]</span>
</pre></div>
</div>
<p>Note that the codomain of the projection map is not identical
to the original <code class="docutils literal notranslate"><span class="pre">S2</span></code>, but is instead a quotient of the wedge
which is isomorphic to <code class="docutils literal notranslate"><span class="pre">S2</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 0, 1]</span>
<span class="gp">sage: </span><span class="n">W</span><span class="o">.</span><span class="n">projection_map</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">codomain</span><span class="p">()</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 0, 1]</span>
<span class="gp">sage: </span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">projection_map</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">W</span><span class="o">.</span><span class="n">inclusion_map</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">is_bijective</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="sage.homology.simplicial_set.SimplicialSet_finite">
<em class="property">class </em><code class="descclassname">sage.homology.simplicial_set.</code><code class="descname">SimplicialSet_finite</code><span class="sig-paren">(</span><em>data</em>, <em>base_point=None</em>, <em>name=None</em>, <em>check=True</em>, <em>category=None</em>, <em>latex_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_finite" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#sage.homology.simplicial_set.SimplicialSet_arbitrary" title="sage.homology.simplicial_set.SimplicialSet_arbitrary"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.homology.simplicial_set.SimplicialSet_arbitrary</span></code></a>, <a class="reference internal" href="cell_complex.html#sage.homology.cell_complex.GenericCellComplex" title="sage.homology.cell_complex.GenericCellComplex"><code class="xref py py-class docutils literal notranslate"><span class="pre">sage.homology.cell_complex.GenericCellComplex</span></code></a></p>
<p>A finite simplicial set.</p>
<p>A simplicial set <span class="math notranslate nohighlight">\(X\)</span> is a collection of sets <span class="math notranslate nohighlight">\(X_n\)</span>, the
<em>n-simplices</em>, indexed by the non-negative integers, together with
face maps <span class="math notranslate nohighlight">\(d_i\)</span> and degeneracy maps <span class="math notranslate nohighlight">\(s_j\)</span>.  A simplex is
<em>degenerate</em> if it is in the image of some <span class="math notranslate nohighlight">\(s_j\)</span>, and a simplicial
set is <em>finite</em> if there are only finitely many non-degenerate
simplices.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">data</span></code> – the data defining the simplicial set. See below for
details.</li>
<li><code class="docutils literal notranslate"><span class="pre">base_point</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – 0-simplex in this
simplicial set, its base point</li>
<li><code class="docutils literal notranslate"><span class="pre">name</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – string, the name of the
simplicial set</li>
<li><code class="docutils literal notranslate"><span class="pre">check</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">True</span></code>) – boolean. If <code class="docutils literal notranslate"><span class="pre">True</span></code>,
check the simplicial identity on the face maps when defining the
simplicial set.</li>
<li><code class="docutils literal notranslate"><span class="pre">category</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – the category in
which to define this simplicial set. The default is either
finite simplicial sets or finite pointed simplicial sets,
depending on whether a base point is defined.</li>
<li><code class="docutils literal notranslate"><span class="pre">latex_name</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – string, the LaTeX
representation of the simplicial set.</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">data</span></code> should have one of the following forms: it could be a
simplicial complex or <span class="math notranslate nohighlight">\(\Delta\)</span>-complex, in case it is converted to
a simplicial set. Alternatively, it could be a dictionary. The
keys are the nondegenerate simplices of the simplicial set, and
the value corresponding to a simplex <span class="math notranslate nohighlight">\(\sigma\)</span> is a tuple listing
the faces of <span class="math notranslate nohighlight">\(\sigma\)</span>. The 0-dimensional simplices may be omitted
from <code class="docutils literal notranslate"><span class="pre">data</span></code> if they (or their degeneracies) are faces of other
simplices; otherwise they must be included with value <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>See <a class="reference internal" href="#module-sage.homology.simplicial_set" title="sage.homology.simplicial_set"><code class="xref py py-mod docutils literal notranslate"><span class="pre">simplicial_set</span></code></a> and the methods for simplicial sets for
more information and examples.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">u</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In the following simplicial set, <code class="docutils literal notranslate"><span class="pre">u</span></code> is an isolated vertex:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">),</span> <span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">),</span> <span class="n">u</span><span class="p">:</span> <span class="bp">None</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">X</span>
<span class="go">Simplicial set with 5 non-degenerate simplices</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span>
<span class="go">X</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">w</span><span class="p">),</span> <span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">w</span><span class="p">),</span> <span class="n">u</span><span class="p">:</span> <span class="bp">None</span><span class="p">},</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span>
<span class="go">Y</span>
</pre></div>
</div>
<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_finite.algebraic_topological_model">
<code class="descname">algebraic_topological_model</code><span class="sig-paren">(</span><em>base_ring=None</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_finite.algebraic_topological_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the algebraic topological model for this simplicial set
with coefficients in <code class="docutils literal notranslate"><span class="pre">base_ring</span></code>.</p>
<p>The term “algebraic topological model” is defined by Pilarczyk
and Réal <a class="reference internal" href="../../../references/index.html#pr2015" id="id2">[PR2015]</a>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> - coefficient ring (optional, default
<code class="docutils literal notranslate"><span class="pre">QQ</span></code>). Must be a field.</li>
</ul>
<p>Denote by <span class="math notranslate nohighlight">\(C\)</span> the chain complex associated to this simplicial
set. The algebraic topological model is a chain complex <span class="math notranslate nohighlight">\(M\)</span>
with zero differential, with the same homology as <span class="math notranslate nohighlight">\(C\)</span>, along
with chain maps <span class="math notranslate nohighlight">\(\pi: C \to M\)</span> and <span class="math notranslate nohighlight">\(\iota: M \to C\)</span> satisfying
<span class="math notranslate nohighlight">\(\iota \pi = 1_M\)</span> and <span class="math notranslate nohighlight">\(\pi \iota\)</span> chain homotopic to
<span class="math notranslate nohighlight">\(1_C\)</span>. The chain homotopy <span class="math notranslate nohighlight">\(\phi\)</span> must satisfy</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\(\phi \phi = 0\)</span>,</li>
<li><span class="math notranslate nohighlight">\(\pi \phi = 0\)</span>,</li>
<li><span class="math notranslate nohighlight">\(\phi \iota = 0\)</span>.</li>
</ul>
<p>Such a chain homotopy is called a <em>chain contraction</em>.</p>
<p>OUTPUT: a pair consisting of</p>
<ul class="simple">
<li>chain contraction <code class="docutils literal notranslate"><span class="pre">phi</span></code> associated to <span class="math notranslate nohighlight">\(C\)</span>, <span class="math notranslate nohighlight">\(M\)</span>, <span class="math notranslate nohighlight">\(\pi\)</span>, and
<span class="math notranslate nohighlight">\(\iota\)</span></li>
<li>the chain complex <span class="math notranslate nohighlight">\(M\)</span></li>
</ul>
<p>Note that from the chain contraction <code class="docutils literal notranslate"><span class="pre">phi</span></code>, one can recover the
chain maps <span class="math notranslate nohighlight">\(\pi\)</span> and <span class="math notranslate nohighlight">\(\iota\)</span> via <code class="docutils literal notranslate"><span class="pre">phi.pi()</span></code> and
<code class="docutils literal notranslate"><span class="pre">phi.iota()</span></code>. Then one can recover <span class="math notranslate nohighlight">\(C\)</span> and <span class="math notranslate nohighlight">\(M\)</span> from, for
example, <code class="docutils literal notranslate"><span class="pre">phi.pi().domain()</span></code> and <code class="docutils literal notranslate"><span class="pre">phi.pi().codomain()</span></code>,
respectively.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">RP2</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">RP2</span><span class="o">.</span><span class="n">algebraic_topological_model</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 1: Vector space of dimension 1 over Finite Field of size 2,</span>
<span class="go"> 2: Vector space of dimension 1 over Finite Field of size 2}</span>
<span class="gp">sage: </span><span class="n">T</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Torus</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">phi</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">algebraic_topological_model</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: Vector space of dimension 1 over Rational Field,</span>
<span class="go"> 1: Vector space of dimension 2 over Rational Field,</span>
<span class="go"> 2: Vector space of dimension 1 over Rational Field}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_finite.chain_complex">
<code class="descname">chain_complex</code><span class="sig-paren">(</span><em>dimensions=None</em>, <em>base_ring=Integer Ring</em>, <em>augmented=False</em>, <em>cochain=False</em>, <em>verbose=False</em>, <em>subcomplex=None</em>, <em>check=False</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_finite.chain_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normalized chain complex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">dimensions</span></code> – if <code class="docutils literal notranslate"><span class="pre">None</span></code>, compute the chain complex in all
dimensions.  If a list or tuple of integers, compute the
chain complex in those dimensions, setting the chain groups
in all other dimensions to zero.</li>
<li><code class="docutils literal notranslate"><span class="pre">base_ring</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">ZZ</span></code>) – commutative ring</li>
<li><code class="docutils literal notranslate"><span class="pre">augmented</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>,
return the augmented chain complex (that is, include a class
in dimension <span class="math notranslate nohighlight">\(-1\)</span> corresponding to the empty cell).</li>
<li><code class="docutils literal notranslate"><span class="pre">cochain</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>,
return the cochain complex (that is, the dual of the chain
complex).</li>
<li><code class="docutils literal notranslate"><span class="pre">verbose</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – ignored.</li>
<li><code class="docutils literal notranslate"><span class="pre">subcomplex</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">None</span></code>) – if present,
compute the chain complex relative to this subcomplex.</li>
<li><code class="docutils literal notranslate"><span class="pre">check</span></code> (optional, default <code class="docutils literal notranslate"><span class="pre">False</span></code>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, make
sure that the chain complex is actually a chain complex:
the differentials are composable and their product is zero.</li>
</ul>
<p>The normalized chain complex of a simplicial set is isomorphic
to the chain complex obtained by modding out by degenerate
simplices, and the latter is what is actually constructed
here.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">degen</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># s_1 s_0 applied to v</span>
<span class="gp">sage: </span><span class="n">sigma</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S3</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">sigma</span><span class="p">:</span> <span class="p">(</span><span class="n">degen</span><span class="p">,</span> <span class="n">degen</span><span class="p">,</span> <span class="n">degen</span><span class="p">,</span> <span class="n">degen</span><span class="p">)})</span> <span class="c1"># the 3-sphere</span>
<span class="gp">sage: </span><span class="n">S3</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">()</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: Z, 3: Z}</span>
<span class="gp">sage: </span><span class="n">S3</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">(</span><span class="n">augmented</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{-1: 0, 0: 0, 3: Z}</span>
<span class="gp">sage: </span><span class="n">S3</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">base_ring</span><span class="o">=</span><span class="n">QQ</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: Vector space of dimension 1 over Rational Field}</span>

<span class="gp">sage: </span><span class="n">RP5</span> <span class="o">=</span> <span class="n">simplicial_sets</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RP2</span> <span class="o">=</span> <span class="n">RP5</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">RP5</span><span class="o">.</span><span class="n">chain_complex</span><span class="p">(</span><span class="n">subcomplex</span><span class="o">=</span><span class="n">RP2</span><span class="p">)</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: Z, 3: C2, 4: 0, 5: Z}</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_finite.euler_characteristic">
<code class="descname">euler_characteristic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_finite.euler_characteristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Euler characteristic of this simplicial set: the
alternating sum over <span class="math notranslate nohighlight">\(n \geq 0\)</span> of the number of
nondegenerate <span class="math notranslate nohighlight">\(n\)</span>-simplices.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">RealProjectiveSpace</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">euler_characteristic</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">euler_characteristic</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">euler_characteristic</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_finite.f_vector">
<code class="descname">f_vector</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_finite.f_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of the number of non-degenerate simplices in each
dimension.</p>
<p>Unlike for some other cell complexes in Sage, this does not
include the empty simplex in dimension <span class="math notranslate nohighlight">\(-1\)</span>; thus its <span class="math notranslate nohighlight">\(i\)</span>-th
entry is the number of <span class="math notranslate nohighlight">\(i\)</span>-dimensional simplices.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S0</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="bp">None</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">S0</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[2]</span>

<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S1</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">S1</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 1]</span>
<span class="gp">sage: </span><span class="n">simplicial_sets</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 0, 0, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_finite.face_data">
<code class="descname">face_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_finite.face_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the face-map data – a dictionary – defining this simplicial set.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">e</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">)})</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">face_data</span><span class="p">()[</span><span class="n">e</span><span class="p">]</span>
<span class="go">(v, w)</span>

<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">v</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="bp">None</span><span class="p">})</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="ow">in</span> <span class="n">Y</span><span class="o">.</span><span class="n">face_data</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">face_data</span><span class="p">()[</span><span class="n">v</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="sage.homology.simplicial_set.SimplicialSet_finite.n_skeleton">
<code class="descname">n_skeleton</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.SimplicialSet_finite.n_skeleton" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the <span class="math notranslate nohighlight">\(n\)</span>-skeleton of this simplicial set.</p>
<p>That is, the subsimplicial set generated by all nondegenerate
simplices of dimension at most <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code> – the dimension</li>
</ul>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">AbstractSimplex</span><span class="p">,</span> <span class="n">SimplicialSet</span>
<span class="gp">sage: </span><span class="n">v</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">w</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">degen</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">apply_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">tau</span> <span class="o">=</span> <span class="n">AbstractSimplex</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;tau&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">SimplicialSet</span><span class="p">({</span><span class="n">tau</span><span class="p">:</span> <span class="p">(</span><span class="n">degen</span><span class="p">,</span> <span class="n">degen</span><span class="p">,</span> <span class="n">degen</span><span class="p">),</span> <span class="n">w</span><span class="p">:</span> <span class="bp">None</span><span class="p">})</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Y</span></code> is the disjoint union of a 2-sphere, with vertex <code class="docutils literal notranslate"><span class="pre">v</span></code>
and non-degenerate 2-simplex <code class="docutils literal notranslate"><span class="pre">tau</span></code>, and a point <code class="docutils literal notranslate"><span class="pre">w</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[v, w, tau]</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[v, w]</span>
<span class="gp">sage: </span><span class="n">Y</span><span class="o">.</span><span class="n">n_skeleton</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">nondegenerate_simplices</span><span class="p">()</span>
<span class="go">[v, w, tau]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="sage.homology.simplicial_set.all_degeneracies">
<code class="descclassname">sage.homology.simplicial_set.</code><code class="descname">all_degeneracies</code><span class="sig-paren">(</span><em>n</em>, <em>l=1</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.all_degeneracies" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of all composites of degeneracies (written in
“admissible” form, i.e., as a strictly decreasing sequence) of
length <span class="math notranslate nohighlight">\(l\)</span> on an <span class="math notranslate nohighlight">\(n\)</span>-simplex.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">l</span></code> – integers</li>
</ul>
<p>On an <span class="math notranslate nohighlight">\(n\)</span>-simplex, one may apply the degeneracies <span class="math notranslate nohighlight">\(s_i\)</span> for <span class="math notranslate nohighlight">\(0
\leq i \leq n\)</span>. Then on the resulting <span class="math notranslate nohighlight">\(n+1\)</span>-simplex, one may apply
<span class="math notranslate nohighlight">\(s_i\)</span> for <span class="math notranslate nohighlight">\(0 \leq i \leq n+1\)</span>, and so on. But one also has to take
into account the simplicial identity</p>
<div class="math notranslate nohighlight">
\[s_i s_j = s_{j+1} s_i \ \   \text{if }   i \leq j.\]</div>
<p>There are <span class="math notranslate nohighlight">\(\binom{l+n}{n}\)</span> such composites: each non-degenerate
<span class="math notranslate nohighlight">\(n\)</span>-simplex leads to <span class="math notranslate nohighlight">\(\binom{l+n}{n}\)</span> degenerate <span class="math notranslate nohighlight">\(l+n\)</span> simplices.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">all_degeneracies</span>
<span class="gp">sage: </span><span class="n">all_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">{(2, 1, 0)}</span>
<span class="gp">sage: </span><span class="n">all_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">{(0,), (1,)}</span>
<span class="gp">sage: </span><span class="n">all_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">{(2, 1, 0), (3, 1, 0), (3, 2, 0), (3, 2, 1)}</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.homology.simplicial_set.face_degeneracies">
<code class="descclassname">sage.homology.simplicial_set.</code><code class="descname">face_degeneracies</code><span class="sig-paren">(</span><em>m</em>, <em>I</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.face_degeneracies" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the result of applying the face map <span class="math notranslate nohighlight">\(d_m\)</span> to the iterated
degeneracy <span class="math notranslate nohighlight">\(s_I = s_{i_1} s_{i_2} ... s_{i_n}\)</span>.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">m</span></code> – integer</li>
<li><code class="docutils literal notranslate"><span class="pre">I</span></code> – tuple <code class="docutils literal notranslate"><span class="pre">(i_1,</span> <span class="pre">i_2,</span> <span class="pre">...,</span> <span class="pre">i_n)</span></code> of integers. We assume
that this sequence is strictly decreasing.</li>
</ul>
<p>Using the simplicial identities (see <a class="reference internal" href="#module-sage.homology.simplicial_set" title="sage.homology.simplicial_set"><code class="xref py py-mod docutils literal notranslate"><span class="pre">simplicial_set</span></code></a>), we
can rewrite</p>
<div class="math notranslate nohighlight">
\[d_m s_{i_1} s_{i_2} ... s_{i_n}\]</div>
<p>in one of the forms</p>
<div class="math notranslate nohighlight">
\[s_{j_1} s_{j_2} ... s_{j_n} d_t, \quad
s_{j_1} s_{j_2} ... s_{j_{n-1}}.\]</div>
<p>OUTPUT: the pair <code class="docutils literal notranslate"><span class="pre">(J,</span> <span class="pre">t)</span></code> or <code class="docutils literal notranslate"><span class="pre">(J,</span> <span class="pre">None)</span></code>. <code class="docutils literal notranslate"><span class="pre">J</span></code> is returned as
a list.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">face_degeneracies</span>
<span class="gp">sage: </span><span class="n">face_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">([0], None)</span>
<span class="gp">sage: </span><span class="n">face_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">([0], None)</span>
<span class="gp">sage: </span><span class="n">face_degeneracies</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">([0], None)</span>
<span class="gp">sage: </span><span class="n">face_degeneracies</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">([1, 0], 1)</span>
<span class="gp">sage: </span><span class="n">face_degeneracies</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">())</span>
<span class="go">([], 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.homology.simplicial_set.shrink_simplicial_complex">
<code class="descclassname">sage.homology.simplicial_set.</code><code class="descname">shrink_simplicial_complex</code><span class="sig-paren">(</span><em>K</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.shrink_simplicial_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the simplicial complex <code class="docutils literal notranslate"><span class="pre">K</span></code> to a “small” simplicial set.</p>
<p>First convert <code class="docutils literal notranslate"><span class="pre">K</span></code> naively, then mod out by a large contractible
subcomplex, as found by
<code class="xref py py-meth docutils literal notranslate"><span class="pre">simplicial_complex.SimplicialComplex._contractible_subcomplex()</span></code>.
This will produce a simplicial set no larger than, and sometimes
much smaller than, the initial simplicial complex.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">shrink_simplicial_complex</span>
<span class="gp">sage: </span><span class="n">K</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Simplex</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">shrink_simplicial_complex</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1]</span>

<span class="gp">sage: </span><span class="n">Y</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span> <span class="o">=</span> <span class="n">shrink_simplicial_complex</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">S2</span>
<span class="go">Quotient: (Simplicial set with 14 non-degenerate simplices/Simplicial set with 13 non-degenerate simplices)</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 0, 1]</span>
<span class="gp">sage: </span><span class="n">S2</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: 0, 2: Z}</span>

<span class="gp">sage: </span><span class="n">Z</span> <span class="o">=</span> <span class="n">simplicial_complexes</span><span class="o">.</span><span class="n">SurfaceOfGenus</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 15, 57, 38]</span>
<span class="gp">sage: </span><span class="n">Z</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: Z^6, 2: Z}</span>
<span class="gp">sage: </span><span class="n">M</span> <span class="o">=</span> <span class="n">shrink_simplicial_complex</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">f_vector</span><span class="p">()</span>
<span class="go">[1, 30, 25]</span>
<span class="gp">sage: </span><span class="n">M</span><span class="o">.</span><span class="n">homology</span><span class="p">()</span>
<span class="go">{0: 0, 1: Z^6, 2: Z}</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.homology.simplicial_set.standardize_degeneracies">
<code class="descclassname">sage.homology.simplicial_set.</code><code class="descname">standardize_degeneracies</code><span class="sig-paren">(</span><em>*L</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.standardize_degeneracies" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of indices of degeneracy maps in standard (decreasing)
order.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">L</span></code> – list of integers, representing a composition of
degeneracies in a simplicial set.</li>
</ul>
<p>OUTPUT: an equivalent list of degeneracies, standardized to be
written in decreasing order, using the simplicial identity</p>
<div class="math notranslate nohighlight">
\[s_i s_j = s_{j+1} s_i \ \   \text{if }   i \leq j.\]</div>
<p>For example, <span class="math notranslate nohighlight">\(s_0 s_2 = s_3 s_0\)</span> and <span class="math notranslate nohighlight">\(s_0 s_0 = s_1 s_0\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">standardize_degeneracies</span>
<span class="gp">sage: </span><span class="n">standardize_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">(1, 0)</span>
<span class="gp">sage: </span><span class="n">standardize_degeneracies</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">(3, 2, 1, 0)</span>
<span class="gp">sage: </span><span class="n">standardize_degeneracies</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">(3, 1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sage.homology.simplicial_set.standardize_face_maps">
<code class="descclassname">sage.homology.simplicial_set.</code><code class="descname">standardize_face_maps</code><span class="sig-paren">(</span><em>*L</em><span class="sig-paren">)</span><a class="headerlink" href="#sage.homology.simplicial_set.standardize_face_maps" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of indices of face maps in standard (non-increasing)
order.</p>
<p>INPUT:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">L</span></code> – list of integers, representing a composition of
face maps in a simplicial set.</li>
</ul>
<p>OUTPUT: an equivalent list of face maps, standardized to be
written in non-increasing order, using the simplicial identity</p>
<div class="math notranslate nohighlight">
\[d_i d_j = d_{j-1} d_i \ \   \text{if }   i&lt;j.\]</div>
<p>For example, <span class="math notranslate nohighlight">\(d_0 d_2 = d_1 d_0\)</span> and <span class="math notranslate nohighlight">\(d_0 d_1 = d_0 d_0\)</span>.</p>
<p>EXAMPLES:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="kn">from</span> <span class="nn">sage.homology.simplicial_set</span> <span class="kn">import</span> <span class="n">standardize_face_maps</span>
<span class="gp">sage: </span><span class="n">standardize_face_maps</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(0, 0)</span>
<span class="gp">sage: </span><span class="n">standardize_face_maps</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">(1, 0)</span>
<span class="gp">sage: </span><span class="n">standardize_face_maps</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">(3, 2, 1)</span>
</pre></div>
</div>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="cubical_complex.html"
                        title="previous chapter">Finite cubical complexes</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="simplicial_set_constructions.html"
                        title="next chapter">Methods of constructing simplicial sets</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/sage/homology/simplicial_set.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="simplicial_set_constructions.html" title="Methods of constructing simplicial sets"
             >next</a> |</li>
        <li class="right" >
          <a href="cubical_complex.html" title="Finite cubical complexes"
             >previous</a> |</li>
  
    
      <a href="../../../../index.html"><img src="../../../_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="../../index.html">Cell complexes and their homology</a> &#187;</li>
 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2019, The Sage Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.6.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, resize, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* Delayed resize helper.  Not perfect but good enough. */
    resize = function () {
        setTimeout(function () {
            tog.height(bod.height());
        }, 100);
    };
    jq(window).resize(function () {
        resize();
    });

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);
    resize();

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
        resize();
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>