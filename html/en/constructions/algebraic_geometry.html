
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="viewport" content="width=600, initial-scale=1">
    <title>Algebraic Geometry &#8212; Sage Constructions v9.3</title>
    <link rel="stylesheet" href="_static/sage.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="_static/MathJax.js?config=TeX-AMS_HTML-full,../mathjax_sage.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Interface Issues" href="interface_issues.html" />
    <link rel="prev" title="Number fields" href="number_fields.html" />
    <link rel="icon" href="_static/sageicon.png" type="image/x-icon" />
    <script src="_static/thebe.js" type="text/javascript"></script>
    <script src="_static/thebe-sage.js" type="text/javascript"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="interface_issues.html" title="Interface Issues"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="number_fields.html" title="Number fields"
             accesskey="P">previous</a> |</li>
  
    
      <a href="../index.html"><img src="_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="index.html">Sage Constructions v9.3</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Algebraic Geometry</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="algebraic-geometry">
<h1>Algebraic Geometry<a class="headerlink" href="#algebraic-geometry" title="Permalink to this headline">¶</a></h1>
<div class="section" id="point-counting-on-curves">
<span id="index-0"></span><h2>Point counting on curves<a class="headerlink" href="#point-counting-on-curves" title="Permalink to this headline">¶</a></h2>
<p>How do you count points on an elliptic curve over a finite field in
Sage?</p>
<p>Over prime finite fields, includes both the baby step giant step
method and the SEA (Schoof-Elkies-Atkin) algorithm (implemented in PARI
by Christophe Doche and Sylvain Duquesne). An example taken form the
Reference manual:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">10007</span><span class="p">),[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="gp">sage: </span><span class="n">E</span><span class="o">.</span><span class="n">cardinality</span><span class="p">()</span>
<span class="go">10076</span>
</pre></div>
</div>
<p>The command <code class="docutils literal notranslate"><span class="pre">E.points()</span></code> will return the actual list of rational
points.</p>
<p>How do you count points on a plane curve over a finite field? The
<code class="docutils literal notranslate"><span class="pre">rational_points</span></code> command produces points by a simple enumeration
algorithm. Here is an example of the syntax:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;xyz&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Curve</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">*</span><span class="n">z</span><span class="o">^</span><span class="mi">7</span> <span class="o">-</span> <span class="n">x</span><span class="o">^</span><span class="mi">9</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">z</span><span class="o">^</span><span class="mi">8</span><span class="p">);</span> <span class="n">C</span>
<span class="go">Projective Plane Curve over Finite Field of size 5 defined by -x^9 + y^2*z^7 - x*z^8</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">rational_points</span><span class="p">()</span>
<span class="go">[(0 : 0 : 1), (0 : 1 : 0), (2 : 2 : 1), (2 : 3 : 1), (3 : 1 : 1), (3 : 4 : 1)]</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">rational_points</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;bn&quot;</span><span class="p">)</span>
<span class="go">[(0 : 0 : 1), (0 : 1 : 0), (2 : 2 : 1), (2 : 3 : 1), (3 : 1 : 1), (3 : 4 : 1)]</span>
</pre></div>
</div>
<p>The option <code class="docutils literal notranslate"><span class="pre">algorithm=&quot;bn</span></code> uses Sage’s Singular interface and
calls the <code class="docutils literal notranslate"><span class="pre">brnoeth</span></code> package.</p>
<p>Here is another example using Sage’s <code class="docutils literal notranslate"><span class="pre">rational_points</span></code> applied to
Klein’s quartic over <span class="math notranslate nohighlight">\(GF(8)\)</span>.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;xyz&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">y</span><span class="o">^</span><span class="mi">3</span><span class="o">*</span><span class="n">z</span><span class="o">+</span><span class="n">x</span><span class="o">*</span><span class="n">z</span><span class="o">^</span><span class="mi">3</span>
<span class="gp">sage: </span><span class="n">C</span> <span class="o">=</span> <span class="n">Curve</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="n">C</span>
<span class="go">Projective Plane Curve over Finite Field in a of size 2^3 defined by x^3*y + y^3*z + x*z^3</span>
<span class="gp">sage: </span><span class="n">C</span><span class="o">.</span><span class="n">rational_points</span><span class="p">()</span>
<span class="go">[(0 : 0 : 1),</span>
<span class="go"> (0 : 1 : 0),</span>
<span class="go"> (1 : 0 : 0),</span>
<span class="go"> (1 : a : 1),</span>
<span class="go"> (1 : a^2 : 1),</span>
<span class="go"> (1 : a^2 + a : 1),</span>
<span class="go"> (a : 1 : 1),</span>
<span class="go"> (a : a^2 : 1),</span>
<span class="go"> (a : a^2 + 1 : 1),</span>
<span class="go"> (a + 1 : a + 1 : 1),</span>
<span class="go"> (a + 1 : a^2 : 1),</span>
<span class="go"> (a + 1 : a^2 + a + 1 : 1),</span>
<span class="go"> (a^2 : 1 : 1),</span>
<span class="go"> (a^2 : a^2 + a : 1),</span>
<span class="go"> (a^2 : a^2 + a + 1 : 1),</span>
<span class="go"> (a^2 + 1 : a + 1 : 1),</span>
<span class="go"> (a^2 + 1 : a^2 + 1 : 1),</span>
<span class="go"> (a^2 + 1 : a^2 + a : 1),</span>
<span class="go"> (a^2 + a : 1 : 1),</span>
<span class="go"> (a^2 + a : a : 1),</span>
<span class="go"> (a^2 + a : a + 1 : 1),</span>
<span class="go"> (a^2 + a + 1 : a : 1),</span>
<span class="go"> (a^2 + a + 1 : a^2 + 1 : 1),</span>
<span class="go"> (a^2 + a + 1 : a^2 + a + 1 : 1)]</span>
</pre></div>
</div>
<div class="section" id="other-methods">
<h3>Other methods<a class="headerlink" href="#other-methods" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>For a plane curve, you can use Singular’s <code class="docutils literal notranslate"><span class="pre">closed_points</span></code>
command. The input is the vanishing ideal <span class="math notranslate nohighlight">\(I\)</span> of the curve
<span class="math notranslate nohighlight">\(X\)</span> in a ring of <span class="math notranslate nohighlight">\(2\)</span> variables <span class="math notranslate nohighlight">\(F[x,y]\)</span>.
The <code class="docutils literal notranslate"><span class="pre">closed_points</span></code> command returns a list of prime ideals (each a
Gröbner basis), corresponding to the (distinct affine closed)
points of <span class="math notranslate nohighlight">\(V(I)\)</span>. Here’s an example:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">singular_console</span><span class="p">()</span>
<span class="go">                     SINGULAR                             /  Development</span>
<span class="go"> A Computer Algebra System for Polynomial Computations   /   version 3-0-1</span>
<span class="go">                                                       0&lt;</span>
<span class="go">     by: G.-M. Greuel, G. Pfister, H. Schoenemann        \   October 2005</span>
<span class="go">FB Mathematik der Universitaet, D-67653 Kaiserslautern    \</span>
<span class="go">// ** executing /home/wdj/sagefiles/sage-0.9.4/local/LIB/.singularrc</span>
<span class="go">&gt; LIB &quot;brnoeth.lib&quot;;</span>
<span class="go">&gt; ring s = 2,(x,y),lp;</span>
<span class="go">&gt; ideal I = x4+x,y4+y;</span>
<span class="go">&gt; list L = closed_points(I);</span>
<span class="go">&gt; L;</span>
<span class="go">[1]:</span>
<span class="go">   _[1] = y</span>
<span class="go">   _[2] = x</span>
<span class="go">[2]:</span>
<span class="go">   _[1] = y</span>
<span class="go">   _[2] = x+1</span>
<span class="go">[3]:</span>
<span class="go">   _[1] = y</span>
<span class="go">   _[2] = x2+x+1</span>
<span class="go">[4]:</span>
<span class="go">   _[1] = y+1</span>
<span class="go">   _[2] = x</span>
<span class="go">[5]:</span>
<span class="go">   _[1] = y+1</span>
<span class="go">   _[2] = x+1</span>
<span class="go">[6]:</span>
<span class="go">   _[1] = y+1</span>
<span class="go">   _[2] = x2+x+1</span>
<span class="go">[7]:</span>
<span class="go">   _[1] = y2+y+1</span>
<span class="go">   _[2] = x+1</span>
<span class="go">[8]:</span>
<span class="go">   _[1] = y2+y+1</span>
<span class="go">   _[2] = x</span>
<span class="go">[9]:</span>
<span class="go">   _[1] = y2+y+1</span>
<span class="go">   _[2] = x+y</span>
<span class="go">[10]:</span>
<span class="go">   _[1] = y2+y+1</span>
<span class="go">   _[2] = x+y+1</span>
<span class="go">&gt; Auf Wiedersehen.</span>
</pre></div>
</div>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">singular</span><span class="o">.</span><span class="n">lib</span><span class="p">(</span><span class="s2">&quot;brnoeth.lib&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">singular</span><span class="o">.</span><span class="n">ring</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;(x,y)&#39;</span><span class="p">,</span><span class="s1">&#39;lp&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">I</span> <span class="o">=</span> <span class="n">singular</span><span class="o">.</span><span class="n">ideal</span><span class="p">(</span><span class="s1">&#39;x^4+x&#39;</span><span class="p">,</span> <span class="s1">&#39;y^4+y&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">L</span> <span class="o">=</span> <span class="n">singular</span><span class="o">.</span><span class="n">closed_points</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="gp">sage: </span><span class="c1"># Here you have all the points :</span>
<span class="gp">sage: </span><span class="n">L</span>       <span class="c1"># random</span>
<span class="go">[1]:</span>
<span class="go">   _[1]=y+1</span>
<span class="go">   _[2]=x+1</span>
<span class="go">...</span>
<span class="gp">sage: </span><span class="n">l</span><span class="o">=</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">sage</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">1.</span><span class="o">.</span><span class="mi">10</span><span class="p">]];</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="c1"># there are 10 points</span>
<span class="go">10</span>
<span class="gp">sage: </span><span class="n">r</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ring</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">());</span> <span class="n">r</span>
<span class="go">[y, x]</span>
<span class="gp">sage: </span><span class="n">r</span> <span class="ow">in</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">l</span><span class="p">]</span> <span class="c1">#  one of them is given by [y,x]</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p>Another way to compute rational points is to use Singular’s
<code class="docutils literal notranslate"><span class="pre">NSplaces</span></code> command. Here’s the Klein quartic over <span class="math notranslate nohighlight">\(GF(8)\)</span>
done this way:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">singular</span><span class="o">.</span><span class="n">LIB</span><span class="p">(</span><span class="s2">&quot;brnoeth.lib&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">s</span> <span class="o">=</span> <span class="n">singular</span><span class="o">.</span><span class="n">ring</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;(x,y)&#39;</span><span class="p">,</span><span class="s1">&#39;lp&#39;</span><span class="p">)</span>
<span class="go">...</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">singular</span><span class="o">.</span><span class="n">poly</span><span class="p">(</span><span class="s1">&#39;x3y+y3+x&#39;</span><span class="p">)</span>
<span class="go">...</span>
<span class="gp">sage: </span><span class="n">klein1</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">Adj_div</span><span class="p">();</span> <span class="k">print</span><span class="p">(</span><span class="n">klein1</span><span class="p">)</span>
<span class="go">[1]:</span>
<span class="go">   [1]:</span>
<span class="go">      //   coefficients: ZZ/2</span>
<span class="go">//   number of vars : 2</span>
<span class="go">//        block   1 : ordering lp</span>
<span class="go">//                  : names    x y</span>
<span class="go">//        block   2 : ordering C</span>
<span class="go">...</span>
<span class="gp">sage: </span><span class="c1"># define a curve X = {f = 0} over GF(2)</span>
<span class="gp">sage: </span><span class="n">klein2</span> <span class="o">=</span> <span class="n">singular</span><span class="o">.</span><span class="n">NSplaces</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">klein1</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s1">&#39;extcurve(3,</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="k">klein2</span>.name()))
<span class="go">Total number of rational places : NrRatPl = 23</span>
<span class="go">...</span>
<span class="gp">sage: </span><span class="n">klein3</span> <span class="o">=</span> <span class="n">singular</span><span class="o">.</span><span class="n">extcurve</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">klein2</span><span class="p">)</span>
</pre></div>
</div>
<p>Above we defined a curve <span class="math notranslate nohighlight">\(X = \{f = 0\}\)</span> over
<span class="math notranslate nohighlight">\(GF(8)\)</span> in Singular.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">klein1</span><span class="p">)</span>
<span class="go">[1]:</span>
<span class="go">   [1]:</span>
<span class="go">      //   coefficients: ZZ/2</span>
<span class="go">//   number of vars : 2</span>
<span class="go">//        block   1 : ordering lp</span>
<span class="go">//                  : names    x y</span>
<span class="go">//        block   2 : ordering C</span>
<span class="go">   [2]:</span>
<span class="go">      //   coefficients: ZZ/2</span>
<span class="go">//   number of vars : 3</span>
<span class="go">//        block   1 : ordering lp</span>
<span class="go">//                  : names    x y z</span>
<span class="go">//        block   2 : ordering C</span>
<span class="go">[2]:</span>
<span class="go">   4,3</span>
<span class="go">[3]:</span>
<span class="go">   [1]:</span>
<span class="go">      1,1</span>
<span class="go">   [2]:</span>
<span class="go">      1,2</span>
<span class="go">[4]:</span>
<span class="go">   0</span>
<span class="go">[5]:</span>
<span class="go">   [1]:</span>
<span class="go">      [1]:</span>
<span class="go">         //   coefficients: ZZ/2</span>
<span class="go">//   number of vars : 3</span>
<span class="go">//        block   1 : ordering ls</span>
<span class="go">//                  : names    x y t</span>
<span class="go">//        block   2 : ordering C</span>
<span class="go">      [2]:</span>
<span class="go">         1,1</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">klein1</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">[1]:</span>
<span class="go">   1,1</span>
<span class="go">[2]:</span>
<span class="go">   1,2</span>
</pre></div>
</div>
<p>For the places of degree <span class="math notranslate nohighlight">\(3\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">klein2</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">[1]:</span>
<span class="go">   1,1</span>
<span class="go">[2]:</span>
<span class="go">   1,2</span>
<span class="go">[3]:</span>
<span class="go">   3,1</span>
<span class="go">[4]:</span>
<span class="go">   3,2</span>
<span class="go">[5]:</span>
<span class="go">   3,3</span>
<span class="go">[6]:</span>
<span class="go">   3,4</span>
<span class="go">[7]:</span>
<span class="go">   3,5</span>
<span class="go">[8]:</span>
<span class="go">   3,6</span>
<span class="go">[9]:</span>
<span class="go">   3,7</span>
</pre></div>
</div>
<p>Each point below is a pair: (degree, point index number).</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">klein3</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">[1]:</span>
<span class="go">   1,1</span>
<span class="go">[2]:</span>
<span class="go">   1,2</span>
<span class="go">[3]:</span>
<span class="go">   3,1</span>
<span class="go">[4]:</span>
<span class="go">   3,2</span>
<span class="go">[5]:</span>
<span class="go">   3,3</span>
<span class="go">[6]:</span>
<span class="go">   3,4</span>
<span class="go">[7]:</span>
<span class="go">   3,5</span>
<span class="go">[8]:</span>
<span class="go">   3,6</span>
<span class="go">[9]:</span>
<span class="go">   3,7</span>
</pre></div>
</div>
<p>To actually get the points of <span class="math notranslate nohighlight">\(X(GF(8))\)</span>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">R</span> <span class="o">=</span> <span class="n">klein3</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">sage: </span><span class="n">R</span><span class="o">.</span><span class="n">set_ring</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">singular</span><span class="p">(</span><span class="s2">&quot;POINTS;&quot;</span><span class="p">)</span>
<span class="go">[1]:</span>
<span class="go">   [1]:</span>
<span class="go">      0</span>
<span class="go">   [2]:</span>
<span class="go">      1</span>
<span class="go">   [3]:</span>
<span class="go">      0</span>
<span class="go">[2]:</span>
<span class="go">   [1]:</span>
<span class="go">      1</span>
<span class="go">   [2]:</span>
<span class="go">      0</span>
<span class="go">   [3]:</span>
<span class="go">      0</span>
<span class="go">...</span>
</pre></div>
</div>
<p>plus 21 others (omitted). There are a total of <span class="math notranslate nohighlight">\(23\)</span>
rational points.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="riemann-roch-spaces-using-singular">
<span id="index-1"></span><h2>Riemann-Roch spaces using Singular<a class="headerlink" href="#riemann-roch-spaces-using-singular" title="Permalink to this headline">¶</a></h2>
<p>To compute a basis of the Riemann-Roch space of a divisor <span class="math notranslate nohighlight">\(D\)</span>
on a curve over a field <span class="math notranslate nohighlight">\(F\)</span>, one can use Sage’s wrapper
<code class="docutils literal notranslate"><span class="pre">riemann_roch_basis</span></code> of Singular’s implementation of the Brill
Noether algorithm. Note that this wrapper currently only works when
<span class="math notranslate nohighlight">\(F\)</span> is prime and the divisor <span class="math notranslate nohighlight">\(D\)</span> is supported on rational points.
Below are examples of how to use <code class="docutils literal notranslate"><span class="pre">riemann_roch_basis</span></code> and how to use
Singular itself to help an understanding of how the wrapper works.</p>
<ul>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">riemann_roch_basis</span></code>:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;xyz&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">gens</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">f</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">7</span> <span class="o">+</span> <span class="n">y</span><span class="o">^</span><span class="mi">7</span> <span class="o">+</span> <span class="n">z</span><span class="o">^</span><span class="mi">7</span>
<span class="gp">sage: </span><span class="n">X</span> <span class="o">=</span> <span class="n">Curve</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="n">pts</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">rational_points</span><span class="p">()</span>
<span class="gp">sage: </span><span class="n">D</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">divisor</span><span class="p">([</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">pts</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="p">])</span>
<span class="gp">sage: </span><span class="n">X</span><span class="o">.</span><span class="n">riemann_roch_basis</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="go">[(-2*x + y)/(x + y), (-x + z)/(x + y)]</span>
</pre></div>
</div>
</li>
<li><p>Using Singular’s <code class="docutils literal notranslate"><span class="pre">BrillNoether</span></code> command (for details see the section
Brill-Noether in the Singular online documentation
(<a class="reference external" href="http://www.singular.uni-kl.de/Manual/html/sing_960.htm">http://www.singular.uni-kl.de/Manual/html/sing_960.htm</a> and the
paper {CF}):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">singular</span><span class="o">.</span><span class="n">LIB</span><span class="p">(</span><span class="s1">&#39;brnoeth.lib&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">_</span> <span class="o">=</span> <span class="n">singular</span><span class="o">.</span><span class="n">ring</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="s1">&#39;(x,y)&#39;</span><span class="p">,</span><span class="s1">&#39;lp&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;list X = Adj_div(-x5+y2+x);&quot;</span><span class="p">))</span>
<span class="go">Computing affine singular points ...</span>
<span class="go">Computing all points at infinity ...</span>
<span class="go">Computing affine singular places ...</span>
<span class="go">Computing singular places at infinity ...</span>
<span class="go">Computing non-singular places at infinity ...</span>
<span class="go">Adjunction divisor computed successfully</span>

<span class="go">The genus of the curve is 2</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;X = NSplaces(1,X);&quot;</span><span class="p">))</span>
<span class="go">Computing non-singular affine places of degree 1 ...</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">singular</span><span class="p">(</span><span class="s2">&quot;X[3];&quot;</span><span class="p">))</span>
<span class="go">[1]:</span>
<span class="go">   1,1</span>
<span class="go">[2]:</span>
<span class="go">   1,2</span>
<span class="go">[3]:</span>
<span class="go">   1,3</span>
<span class="go">[4]:</span>
<span class="go">   1,4</span>
<span class="go">[5]:</span>
<span class="go">   1,5</span>
<span class="go">[6]:</span>
<span class="go">   1,6</span>
</pre></div>
</div>
<p>The first integer of each pair in the above list is the degree
<span class="math notranslate nohighlight">\(d\)</span> of a point. The second integer is the index of this point
in the list POINTS of the ring X[5][<span class="math notranslate nohighlight">\(d\)</span>][1]. Note that the
order of this latter list is different every time the algorithm
is run, e.g. <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(1\)</span> in the above list refers to a different
rational point each time. A divisor is given by defining a list
<span class="math notranslate nohighlight">\(G\)</span> of integers of the same length as X[3] such that if the
<span class="math notranslate nohighlight">\(k\)</span>-th entry of X[3] is <span class="math notranslate nohighlight">\(d\)</span>, <span class="math notranslate nohighlight">\(i\)</span>, then the <span class="math notranslate nohighlight">\(k\)</span>-th entry of <span class="math notranslate nohighlight">\(G\)</span> is
the multiplicity of the divisor at the <span class="math notranslate nohighlight">\(i\)</span>-th point in the list
POINTS of the ring X[5][<span class="math notranslate nohighlight">\(d\)</span>][1]. Let us proceed by defining a
“random” divisor of degree 12 and computing a basis of its
Riemann-Roch space:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;intvec G = 4,4,4,0,0,0;&quot;</span><span class="p">)</span>
<span class="go">&#39;&#39;</span>
<span class="gp">sage: </span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;def R = X[1][2];&quot;</span><span class="p">)</span>
<span class="go">&#39;&#39;</span>
<span class="gp">sage: </span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;setring R;&quot;</span><span class="p">)</span>
<span class="go">&#39;&#39;</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;list LG = BrillNoether(G,X);&quot;</span><span class="p">))</span>
<span class="go">Forms of degree 6 :</span>
<span class="go">28</span>

<span class="go">Vector basis successfully computed</span>
</pre></div>
</div>
</li>
</ul>
<div class="section" id="ag-codes">
<span id="index-2"></span><h3>AG codes<a class="headerlink" href="#ag-codes" title="Permalink to this headline">¶</a></h3>
<p>Sage can compute an AG code <span class="math notranslate nohighlight">\(C=C_X(D,E)\)</span> by calling
Singular’s BrillNoether to compute a basis of the Riemann Roch
space <span class="math notranslate nohighlight">\(L(D)=L_X(D)\)</span>. In addition to the curve <span class="math notranslate nohighlight">\(X\)</span>
and the divisor <span class="math notranslate nohighlight">\(D\)</span>, you must also specify the evaluation
divisor <span class="math notranslate nohighlight">\(E\)</span>.</p>
<p>Note that this section has not been updated since the wrapper
<code class="docutils literal notranslate"><span class="pre">riemann_roch_basis</span></code> has been fixed. See above for how to
properly define a divisor for Singular’s <code class="docutils literal notranslate"><span class="pre">BrillNoether</span></code>
command.</p>
<p>Here’s an example, one which computes a generator matrix of an
associated AG code. This time we use Singular’s <code class="docutils literal notranslate"><span class="pre">AGCode_L</span></code>
command.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">singular</span><span class="o">.</span><span class="n">LIB</span><span class="p">(</span><span class="s1">&#39;brnoeth.lib&#39;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;ring s = 2,(x,y),lp;&quot;</span><span class="p">)</span>
<span class="go">&#39;&#39;</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;list HC = Adj_div(x3+y2+y);&quot;</span><span class="p">))</span>
<span class="go">Computing affine singular points ...</span>
<span class="go">Computing all points at infinity ...</span>
<span class="go">Computing affine singular places ...</span>
<span class="go">Computing singular places at infinity ...</span>
<span class="go">Computing non-singular places at infinity ...</span>
<span class="go">Adjunction divisor computed successfully</span>

<span class="go">The genus of the curve is 1</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;list HC1 = NSplaces(1..2,HC);&quot;</span><span class="p">))</span>
<span class="go">Computing non-singular affine places of degree 1 ...</span>
<span class="go">Computing non-singular affine places of degree 2 ...</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;HC = extcurve(2,HC1);&quot;</span><span class="p">))</span>
<span class="go">Total number of rational places : NrRatPl = 9</span>
</pre></div>
</div>
<p>We set the following to <code class="docutils literal notranslate"><span class="pre">junk</span></code> to discard the output:</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">junk</span> <span class="o">=</span> <span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;intvec G = 5;&quot;</span><span class="p">)</span>      <span class="c1"># the rational divisor G = 5*HC[3][1]</span>
<span class="gp">sage: </span><span class="n">junk</span> <span class="o">=</span> <span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;def R = HC[1][2];&quot;</span><span class="p">)</span>
<span class="gp">sage: </span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;setring R;&quot;</span><span class="p">)</span>
<span class="go">&#39;&#39;</span>
</pre></div>
</div>
<p>The vector <span class="math notranslate nohighlight">\(G\)</span> represents the divisor
“5 times the point at infinity”.</p>
<p id="index-3">Next, we compute the Riemann-Roch space.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;BrillNoether(G,HC);&quot;</span><span class="p">))</span>
<span class="go">Forms of degree 3 :</span>
<span class="go">10</span>

<span class="go">Vector basis successfully computed</span>

<span class="go">[1]:</span>
<span class="go">   _[1]=x</span>
<span class="go">   _[2]=z</span>
<span class="go">[2]:</span>
<span class="go">   _[1]=y</span>
<span class="go">   _[2]=z</span>
<span class="go">[3]:</span>
<span class="go">   _[1]=1</span>
<span class="go">   _[2]=1</span>
<span class="go">[4]:</span>
<span class="go">   _[1]=y2+yz</span>
<span class="go">   _[2]=xz</span>
<span class="go">[5]:</span>
<span class="go">   _[1]=y3+y2z</span>
<span class="go">   _[2]=x2z</span>
</pre></div>
</div>
<p>That was the basis of the Riemann-Roch space, where each pair of
functions represents the quotient (first function divided by second
function). Each of these basis elements get evaluated at certain
points to construct the generator matrix of the code. We next
construct the points.</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;def R = HC[1][5];&quot;</span><span class="p">)</span>
<span class="go">&#39;// ** redefining R **&#39;</span>
<span class="gp">sage: </span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;setring R;&quot;</span><span class="p">)</span>
<span class="go">&#39;&#39;</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;POINTS;&quot;</span><span class="p">))</span>
<span class="go">[1]:</span>
<span class="go">   [1]:</span>
<span class="go">      0</span>
<span class="go">   [2]:</span>
<span class="go">      1</span>
<span class="go">   [3]:</span>
<span class="go">      0</span>
<span class="go">[2]:</span>
<span class="go">   [1]:</span>
<span class="go">      0</span>
<span class="go">   [2]:</span>
<span class="go">      1</span>
<span class="go">   [3]:</span>
<span class="go">      1</span>
<span class="go">[3]:</span>
<span class="go">   [1]:</span>
<span class="go">      0</span>
<span class="go">   [2]:</span>
<span class="go">      0</span>
<span class="go">   [3]:</span>
<span class="go">      1</span>
<span class="go">[4]:</span>
<span class="go">   [1]:</span>
<span class="go">      (a+1)</span>
<span class="go">   [2]:</span>
<span class="go">      (a)</span>
<span class="go">   [3]:</span>
<span class="go">      1</span>
<span class="go">...</span>
</pre></div>
</div>
<p>plus <span class="math notranslate nohighlight">\(5\)</span> more, for a total of <span class="math notranslate nohighlight">\(9\)</span> rational points
on the curve. We define our “evaluation divisor” <span class="math notranslate nohighlight">\(D\)</span> using
a subset of these points (all but the first):</p>
<div class="highlight-ipycon notranslate"><div class="highlight"><pre><span></span><span class="gp">sage: </span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;def ER = HC[1][4];&quot;</span><span class="p">)</span>
<span class="go">&#39;&#39;</span>
<span class="gp">sage: </span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;setring ER;&quot;</span><span class="p">)</span>
<span class="go">&#39;&#39;</span>
<span class="gp">sage: </span><span class="c1"># D = sum of the rational places no. 2..9 over F_4</span>
<span class="gp">sage: </span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;intvec D = 2..9;&quot;</span><span class="p">)</span>
<span class="go">&#39;&#39;</span>
<span class="gp">sage: </span><span class="c1"># let us construct the corresponding evaluation AG code :</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;matrix C = AGcode_L(G,D,HC);&quot;</span><span class="p">))</span>
<span class="go">Forms of degree 3 :</span>
<span class="go">10</span>

<span class="go">Vector basis successfully computed</span>

<span class="gp">sage: </span><span class="c1"># here is a linear code of type [8,5,&gt; = 3] over F_4</span>
<span class="gp">sage: </span><span class="k">print</span><span class="p">(</span><span class="n">singular</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="s2">&quot;print(C);&quot;</span><span class="p">))</span>
<span class="go">0,0,(a+1),(a),  1,  1,    (a),  (a+1),</span>
<span class="go">1,0,(a),  (a+1),(a),(a+1),(a),  (a+1),</span>
<span class="go">1,1,1,    1,    1,  1,    1,    1,</span>
<span class="go">0,0,(a),  (a+1),1,  1,    (a+1),(a),</span>
<span class="go">0,0,1,    1,    (a),(a+1),(a+1),(a)</span>
</pre></div>
</div>
<p>This is, finally, our desired generator matrix, where <code class="docutils literal notranslate"><span class="pre">a</span></code>
represents a generator of the field extension of degree <span class="math notranslate nohighlight">\(2\)</span>
over the base field <span class="math notranslate nohighlight">\(GF(2)\)</span>.</p>
<p>Can this be “wrapped”?</p>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Algebraic Geometry</a><ul>
<li><a class="reference internal" href="#point-counting-on-curves">Point counting on curves</a><ul>
<li><a class="reference internal" href="#other-methods">Other methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#riemann-roch-spaces-using-singular">Riemann-Roch spaces using Singular</a><ul>
<li><a class="reference internal" href="#ag-codes">AG codes</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="number_fields.html"
                        title="previous chapter">Number fields</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="interface_issues.html"
                        title="next chapter">Interface Issues</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/algebraic_geometry.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="interface_issues.html" title="Interface Issues"
             >next</a> |</li>
        <li class="right" >
          <a href="number_fields.html" title="Number fields"
             >previous</a> |</li>
  
    
      <a href="../index.html"><img src="_static/logo_sagemath_black.svg" height="28" style="vertical-align: middle" title="Sage Logo"></a>
    
  
  
        <li class="nav-item nav-item-0"><a href="index.html">Sage Constructions v9.3</a> &#187;</li>

        <li class="nav-item nav-item-this"><a href="">Algebraic Geometry</a></li> 
      </ul>
    </div>
    
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005--2021, The Sage Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
    <script type="text/javascript">
/*global jQuery, window */
/* Sphinx sidebar toggle.  Putting this code at the end of the body
 * enables the toggle for the live, static, and offline docs.  Note:
 * sage.misc.html.math_parse() eats jQuery's dollar-sign shortcut. */
var jq = jQuery;
jq(document).ready(function () {
    var bar, bod, bg, fg, key, tog, wid_old, wid_new, get_state, set_state;
    bod = jq('div.bodywrapper');
    bar = jq('div.sphinxsidebar');
    tog = jq('<div class="sphinxsidebartoggle"></div>');

    /* The sidebar toggle adapts its height to the bodywrapper height. */
    const resizeObserver = new ResizeObserver(entries => {
        tog.height(bod.height());
    });
    resizeObserver.observe(bod[0]);

    /* Setup and add the toggle. See Sphinx v0.5.1 default.css. */
    fg = jq('div.sphinxsidebar p a').css('color') || 'rgb(152, 219, 204)';
    bg = jq('div.document').css('background-color') || 'rgb(28, 78, 99)';
    wid_old = '230px';
    wid_new = '5px';
    tog.css('background-color', bg)
        .css('border-width', '0px')
        .css('border-right', wid_new + ' ridge ' + bg)
        .css('cursor', 'pointer')
        .css('position', 'absolute')
        .css('left', '-' + wid_new)
        .css('top', '0px')
        .css('width', wid_new);
    bod.css('position', 'relative');
    bod.prepend(tog);

    /* Cookie helpers. */
    key = 'sphinxsidebar=';
    set_state = function (s) {
        var date = new Date();
        /* Expiry in 7 days. */
        date.setTime(date.getTime() + (7 * 24 * 3600 * 1000));
        document.cookie = key + encodeURIComponent(s) + '; expires=' +
            date.toUTCString() + '; path=/';
    };
    get_state = function () {
        var i, c, crumbs = document.cookie.split(';');
        for (i = 0; i < crumbs.length; i += 1) {
            c = crumbs[i].replace(/^\s+/, '');
            if (c.indexOf(key) === 0) {
                return decodeURIComponent(c.substring(key.length, c.length));
            }
        }
        return null;
    };

    /* Event handlers. */
    tog.mouseover(function (ev) {
        tog.css('border-right-color', fg);
    }).mouseout(function (ev) {
        tog.css('border-right-color', bg);
    }).click(function (ev) {
        if (bod.hasClass('wide')) {
            bod.removeClass('wide');
            bod.css('margin-left', wid_old);
            bar.css('width', wid_old);
            bar.show();
            set_state('visible');
        } else {
            set_state('hidden');
            bar.hide();
            bar.css('width', '0px');
            bod.css('margin-left', wid_new);
            bod.addClass('wide');
        }
    });

    /* Hide the normally visible sidebar? */
    if (get_state() === 'hidden') {
        tog.trigger('click');
    } else {
        set_state('visible');
    }
});
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-66100-14', 'auto');
  ga('send', 'pageview');
</script>
  </body>
</html>